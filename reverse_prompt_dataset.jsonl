{"prompt": "Create a NetLogo model that simulates clustering of agents (people) and cells (vegetation) based on their distances, using hierarchical clustering and simple_clustering_by_distance operators.", "gaml_code": "/**\n* Name:  Clustering of agents by their distance \n* Author:  Patrick Taillandier et JD Zucker ;-) \n* Description: A model to show how to use clustering operators with simple_clustering_by_distance to take into account the distances \n*        between agents or between cells to create the clusters,  and showing the relations between the people from the same cluster. \n* Tags: clustering, statistic, grid\n*/\n\nmodel clustering\n\nglobal {\n\t//define the maximal distance between people in the continuous environement (in meters): if the distance between 2 people is lower than this value, they will be in the same group\n\tfloat max_dist_people <- 20.0;\n\t\n\t//define the maximal distance between cells (in number of cells): if the distance between 2 cells is lower than this value, they will be in the same group\n\tint max_dist_cell <- 1;\n\t\n\t//probability for a cell to have vegetation\n\tfloat proba_vegetation <- 0.2;\n\t\n\t//create the people agents\n\tinit {\n\t\tcreate people number:20; \n    }\n    \n    //reflex that builds the people clusters\n    reflex people_clustering {\n    \t//clustering by using the simple clustering operator: two people agents are in the same groups if their distance is lower than max_dist_people (in meters)\n    \t//returns a list of lists (i.e. a list of groups, a group is a list of people agents)\n    \tlist<list<people>> clusters <- list<list<people>>(simple_clustering_by_distance(people, max_dist_people));\n        \n        //We give a random color to each group (i.e. to each people agents of the group)\n        loop cluster over: clusters {\n        \trgb rnd_color <- rnd_color(255);\n        \task cluster {\n        \t\tcolor_cluster <- rnd_color;\n        \t}\n        }\n        \n        //build the hierchical clustering (https://en.wikipedia.org/wiki/Hierarchical_clustering)\n        list clustering_tree <- hierarchical_clustering (people, max_dist_people);\n        \n        //create groups from the results of the hierarchical clustering\n        do create_groups(clustering_tree, nil);\n    }\n    \n    //recursive action that create group_people agents from the list of group.\n    action create_groups (list group, group_people parent_gp) {\n    \tbool compute_shape <- false;\n    \tloop el over: group {\n    \t\tif (el is people) {\n    \t\t\tparent_gp.shape <- people(el).shape;\n    \t\t}\n    \t\telse {\n    \t\t\tcreate group_people returns: created_g{\n    \t\t\t\tif (parent_gp != nil) {\n    \t\t\t\t\tadd self to: parent_gp.sub_groups;\n    \t\t\t\t}\n    \t\t\t\tparent <- parent_gp;\n    \t\t\t}\n    \t\t\tdo create_groups(el, first(created_g));\n    \t\t\tcompute_shape <- true;\n    \t\t}\n    \t}\n    \tif (compute_shape and parent_gp != nil) {\n    \t\task parent_gp {\n    \t\t\tshape <- polyline (sub_groups collect each.location);\n    \t\t}\n    \t\t\n    \t}\n    }\n    //reflex that builds the cell clusters\n    reflex forest_clustering {\n    \tlist<list<vegetation_cell>> clusters <- list<list<vegetation_cell>>(simple_clustering_by_distance(vegetation_cell where (each.color = #green), max_dist_cell));\n        loop cluster over: clusters {\n        \tcreate forest {\n        \t\tcells <- cluster;\n        \t\tshape <- union (cells);\n        \t}\n        }\n        list clustering_tree <- hierarchical_clustering (people, max_dist_people);\n    }\n    \n}\ngrid vegetation_cell width: 25 height: 25 neighbors: 4{\n\trgb color <- flip (proba_vegetation) ? #green : #white;\n}\n\nspecies forest {\n\tlist<vegetation_cell> cells;\n\taspect default {\n\t\tdraw shape.contour + 0.5 color: #red;\n\t}\n}\n\nspecies people {\n\trgb color_cluster <- #black;\n\trgb color_tree <- #black;\n\taspect cluster {\n\t\tdraw circle(2) color: color_cluster;\n\t}\n\taspect tree {\n\t\tdraw circle(2) color: color_tree;\n\t}\n}\n\nspecies group_people {\n\tlist<group_people> sub_groups;\n\tgroup_people parent;\n\taspect default {\n\t\tdraw shape + 0.2 color: #red;\n\t\tif (parent != nil) {\n\t\t\tdraw line ([location, parent.location]) end_arrow: 2 color: #red;\n\t\t}\n\t}\n}\n\nexperiment clustering type: gui {\n\tparameter \"Maximal distance for people clustering\" var: max_dist_people min: 0.0 max: 100.0 category: \"People\";\n\tparameter \"Maximal distance for vegetation cell clustering\" var: max_dist_cell min: 0 max: 5 category: \"Forest\";\n\tparameter \"Probability for vegetation cells\" var: proba_vegetation min: 0.1 max: 1.0 category: \"Forest\";\n\t\n\t//permanent layout: horizontal([vertical([0::5000,1::5000])::5000,2::5000]) tabs:true;\n\toutput {\n\t\tlayout horizontal([vertical([0::5000,1::5000])::5000,2::5000]) tabs:true editors: false;\n\t\tdisplay map_people_clusters {\n\t\t\tspecies people aspect: cluster;\n\t\t}\n\t\tdisplay map_people_tree {\n\t\t\tspecies people aspect: tree;\n\t\t\tspecies group_people;\n\t\t}\n\t\tdisplay map_forest_clusters type:2d antialias:false{\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies forest;\n\t\t}\n\t}\n}"}
{"prompt": "Develop a model that demonstrates clustering techniques using K-Means and DBSCAN algorithms to group agents into clusters. Include visualizations of the clusters and centroids for both methods.", "gaml_code": "/**\n* Name:  Clustering of agents by K Means and DBScan\n* Author:  Patrick Taillandier et J.-D. Zucker\n* Description: A model to show how to use clustering operators and two methods of clustering (K Means and DBScan) \n*              with the goal of grouping agents into clusters\n* Tags: clustering, statistic, spatial\n*/\n\nmodel clustering\n\nglobal {\n\t//the number of groups to create (kmeans)\n\tint k <- 4;\n\t\n\t//the maximum radius of the neighborhood (DBscan)\n\tfloat eps <- 17.0; \n\t\n\t//the minimum number of elements needed for a cluster (DBscan)\n\tint minPoints <- 3;\n\t\n\tinit {\n\t\t//create dummy agents\n\t\t\tcreate dummy number: 50;\n\t     }\t\n\t     \n\treflex cluster_building {\n\t\t//create a list of list containing for each dummy agent a list composed of its x and y values\n\t\tlist<list> instances <- dummy collect ([each.location.x, each.location.y]);\n\t\t\n\t\t//from the previous list, create groups with the eps and minPoints parameters and the DBSCAN algorithm (https://en.wikipedia.org/wiki/DBSCAN)\n\t\tlist<list<int>> clusters_dbscan <- list<list<int>>(dbscan(instances, eps, minPoints));\n\t\t\n\t\t// We give a random color to each group (i.e. to each dummy agents of the group)\n//       loop cluster over: clusters_dbscan {\n//\t\t\trgb col <- rnd_color(255);\n//\t\t\tloop i over: cluster {\n//\t\t\t\task dummy[i] {color_dbscan <- col;}\n//\t\t\t}\n//\t   }\n\t \n\n\t\tint K <- length(clusters_dbscan);\n\t\tloop i from:0 to: K-1 {\n\t\t\tloop j over: clusters_dbscan[i] {\n\t\t\t\task dummy[j] {color_dbscan <- hsb(i/max(1,K),1,1);}\n\t\t}\n\t\t\n\t\t}\n\t\task centroids {\n\t\t\tdo die;\n\t\t}\n\t\t//create dummy centroids\n\t\tcreate centroids number:k;//create dummy centroids\n\t\t\t\n\t\t//from the previous list, create k groups  with the Kmeans algorithm (https://en.wikipedia.org/wiki/K-means_clustering)\n\t\tlist<list<int>> clusters_kmeans <- list<list<int>>(kmeans(instances, k));\n\t\t\n\t\t\n\t\t//We give a fixed color to each group in function of the cluwter's number (i.e. to each dummy agents of the group)\n\t\tK <- length(clusters_kmeans);\n\t\t\n\t\t//list<centroids> the_centroids <- list(centroids) ;\n\t\t\n\t\tloop i from:0 to: K-1 {\n\t\t\task centroids[i] {mypoints <- [];}\n\t\t\tloop j over: clusters_kmeans[i] {\n\t\t\t\task dummy[j] {color_kmeans <- hsb(i/K,1,1);}\n\t\t\t\task centroids[i] {add dummy[j] to:mypoints;}\n\t\t\t   }\n\t\t    ask centroids[i] {\n\t\t  \t\t\tcolor_centroids <- hsb(i/K,1,1);\n\t\t  \t        location <- (mypoints mean_of each.location );\n\t\t                     }\t          \n        }\t      \n     }\n }  \n   \n   species centroids\n\t{\n\trgb color_centroids;\n\tlist<dummy> mypoints;\n\taspect centroids_aspect\n\t{\n\t\tdraw cross(3, 0.5) color: color_centroids border: # black;\n\t\tloop pt over: mypoints\n\t\t{\n\t\t\tdraw line([location, pt]) + 0.1 color: color_centroids;\n\t\t}\n\t}\n}\n\n\n\t\nspecies dummy skills:[moving] {\n\trgb color_dbscan <- #grey;\n\trgb color_kmeans <- #grey;\n\taspect dbscan_aspect {\n\t\tdraw square(2) color: color_dbscan;\n\t}\n\taspect kmeans_aspect {\n\t\tdraw circle(2) color: color_kmeans;\n\t}\n\treflex move\n\t{\n\t\tdo wander;\t\t\n\t}\n}\n\nexperiment clustering type: gui {\n\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\n\tparameter \"Maximum radius of the neighborhood to be considered\" var: eps category: \"DBSCAN\";\n\tparameter \"Minimum number of points needed for a cluster \" var: minPoints category: \"DBSCAN\";\n\toutput {\n\t\tlayout horizontal([1::5000,0::5000]) tabs:true editors: false;\n\t\tdisplay map_dbscan type:2d{\n            //define a new overlay layer positioned at the coordinate half-space/0\n            overlay position: { world.shape.width/2, 0 } size: { 180 #px, 50 #px } background: #black transparency: 0.2 border: #black rounded: true\n            {\n\t\t\t\t\t//draw square(5#px) at: { 0, 0 } color: #red border: #white;\n                    draw string(\"DbScan\") at: { world.shape.width/2 - 40, 20 } color: #blue font: font(\"SansSerif\", 36, #bold); \n                }\t\t\n\n\t\t\tspecies dummy aspect: dbscan_aspect;\n\t\t}\n\t\tdisplay map_kmeans type:2d{\n\t\t\toverlay position: { world.shape.width/2, 0 } size: { 180 #px, 50 #px } background: #black transparency: 0.2 border: #black rounded: true\n            {\n\t\t\t\t\t//draw square(5#px) at: { 0, 0 } color: #red border: #white;\n                    draw string(\"K-means\") at: { world.shape.width/2-45, 20 } color: #orange font: font(\"SansSerif\", 36, #bold); \n                }\t\n\t\t\tspecies dummy aspect: kmeans_aspect;\n\t\t\tspecies centroids aspect:centroids_aspect;\n\t\t}\n\t}\n}"}
{"prompt": "Show me an example of how to use various statistical operators in GAMA, including univariate and dynamic time warping.", "gaml_code": "/**\n* Name: Operators\n* Author: Patrick Taillandier\n* Description: A model which illustrates the use of univariate statistical operators of GAMA \n* Tags: statistic\n*/\n\nmodel statistic_operators\n\nglobal {\n\tinit tet {\n\t\tlist<int> data <- [1,2,3,4,5,6,7,10,20,100];\n\t\twrite \"data: \" + data;\n\t\twrite \"min: \" + min(data);\n\t\twrite \"max: \" + max(data);\n\t\twrite \"sum: \" + sum(data);\n\t\twrite \"mean: \" + mean(data);\n\t\twrite \"median: \" + median(data);\n\t\twrite \"standard_deviation: \" + standard_deviation(data);\n\t\twrite \"geometric_mean: \" + geometric_mean(data);\n\t\twrite \"harmonic_mean: \" + harmonic_mean(data);\n\t\twrite \"variance: \" + harmonic_mean(data);\n\t\twrite \"mean_deviation: \" + mean_deviation(data);\n\t\twrite \"kurtosis: \" + kurtosis(data);\n\t\twrite \"skewness: \" + skewness(data);\n\t\twrite \"gamma_rnd: \" + gamma_rnd(0.1,1); \n\t\twrite \"gini index: \" + gini([10.0, 1.0, 2.0, 0.0]);\n\t\t\n\t\tlist<float> l1 <- [10.0,5.0,1.0, 3.0, 4.0, 7.5, 1.0,10.0,5.0,1.0];\n\t\tlist<float> l2 <- [1.0,1.0,15.0,1.0,1.0, 3.0, 4.0, 7.5];\n\t\twrite \"Dynamic Time Warping: \" + dtw(l1,l2);\n\t\twrite \"Dynamic Time Warping with a radius of 2: \" + dtw(l1,l2,2);\t\n\t}\n}\n\nexperiment test_operators type: gui;"}
{"prompt": "Train a 3D regression model to predict z-values from x and y values using a dataset of randomly generated points.", "gaml_code": "/**\n* Name: Regression\n* Author: Patrick Taillandier\n* Description: A model which shows how to use the regression \n* Tags: regression, 3d, statistic\n*/\n\nmodel example_regression\n\nglobal {\n\t//Regression variable that will store the function\n\tregression location_fct;\n\tfloat x_val <- 50.0;\n\tfloat y_val <- 50.0;\n\t\n\tfloat val <- -1.0;\n\tinit {\n\t\tloop i from: 0 to: 18{\n\t\t\tif (i != 10) {\n\t\t\t\tcreate dummy with:[location::{i * 5 + 2 - rnd(4), i*5 + 2 - rnd(4), i*5 + 2 - rnd(4)}];\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Reflex to compute the regression\n\treflex do_regression {\n\t\tmatrix<float> instances <- 0.0 as_matrix {3,length(dummy)};\n\t\tloop i from: 0 to: length(dummy) -1 {\n\t\t\tdummy ag <- dummy[i];\n\t\t\tinstances[0,i] <- ag.location.x;\n\t\t\tinstances[1,i] <- ag.location.y;\n\t\t\tinstances[2,i] <- ag.location.z;\n\t\t}\n\t\t//Compute the function of regression\n\t\tlocation_fct  <- build(instances);\n\t\twrite \"learnt function: \" + location_fct;\n\t\t\n\t\t//Predict the value using the function resulting before\n\t\tval <-  predict(location_fct, [x_val, y_val]);\n\t\twrite \"value : \" + val;\n\t\t\n\t\t//T test\n\t\tlist<float> actuals <- dummy collect (each.location.z);\n\t\tlist<float> predictions;\n\t\task dummy { predictions <+ predict(location_fct, [location.x,location.y]); }\n\t\tfloat p_value <- t_test(actuals,predictions);\n\t\twrite \"p value : \" + p_value;\n\t}\n}\n\nspecies dummy {\n\taspect default {\n\t\tdraw sphere(2) color: #blue;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Point to test, x value\" var: x_val ;\n\tparameter \"Point to test, y value\" var: y_val ;\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tcamera 'default' location: {-123.6464,147.7097,94.8008} target: {123.9258,66.7844,0.0};\n\t\t\tspecies dummy;\n\t\t\tgraphics \"new Point \" {\n\t\t\t\tif (location_fct != nil) {\n\t\t\t\t\tdraw sphere(2) color: #red at: {x_val,y_val,val};\n\t\t\t\t\t\n\t\t\t\t\t//Draw the function as a line\n\t\t\t\t\tdraw line([{100,100,predict(location_fct, [100,100])},{-10,-10,predict(location_fct, [-10,-10])}]) color: #black;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Compare the accuracy of a prediction model using different comparators (kappa, fuzzy kappa) on a raster map, and visualize the results.", "gaml_code": "/**\n* Name: Raster Map Comparison\n* Author: Patrick Taillandier\n* Description: This model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used :\n* \n* - kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation;\n* \n* - fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic;\n* \n* - fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logic\n* Tags: grid, comparison, raster, statistic\n*/\n\nmodel mapcomparison\n\nglobal {\n\tlist<string> categories <- [\"type 1\", \"type 2\", \"type 3\", \"type 4\"];\n\tmap<string,rgb> color_cat <- [\"type 1\"::#blue, \"type 2\"::#green, \"type 3\"::#yellow, \"type 4\"::#red];\n\tmatrix<float> fuzzy_categories;\n\tmatrix<float> fuzzy_transitions;\n\tlist<float> nb_per_cat_obs;\n\tlist<float> nb_per_cat_sim;\n\t \n\tinit {\n\t\t//Initialize randomly the category of each cell\n\t\task shuffle(cell) {\n\t\t\tstring neigh_cat <-one_of(neighbours).cat_observed;\n\t\t\tcat_init <- neigh_cat in categories ? neigh_cat : one_of(categories);\n\t\t\tcolor_init <- color_cat[cat_init];\n\t\t}\n\t\t\n\t\t//Initialize the category observed and the cat attributes of the cells according to probability : \n\t\t// 60% of cases, the category observed will be the same than the category initialized\n\t\t//60% of cases, the category will be the same than the category observed\n\t\task cell {\n\t\t\tcat_observed <- flip(0.6) ?  cat_init : one_of(categories);\n\t\t\tcat <- flip(0.6) ?  cat_observed : one_of(categories);\n\t\t\tcolor <- color_cat[cat];\n\t\t\tcolor_obs <- color_cat[cat_observed];\n\t\t}\n\t\tfuzzy_categories <- 0.0 as_matrix {length(categories),length(categories)};\n\t\tloop i from: 0 to: length(categories) - 1 {\n\t\t\tfuzzy_categories[i,i] <- 1.0;\n\t\t}\n\t\tfuzzy_transitions <- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};\n\t\tloop i from: 0 to: (length(categories) * length(categories)) - 1 {\n\t\t\tfuzzy_transitions[i,i] <- 1.0;\t\n\t\t}\n\t\tlist<float> similarity_per_agents ;\n\t\twrite \"kappa(map observed, map simulation, categories): \" + kappa( cell collect (each.cat_observed),cell collect (each.cat),categories);\n\t\twrite \"kappa simulation(map init, map observed, map simulation,categories): \" + kappa_sim( cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat),categories);\n\t\tusing topology(cell) {\n\t\t\twrite \"fuzzy kappa(map observed, map simulation,categories): \" + fuzzy_kappa(list(cell), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_categories, 10);\n\t\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories): \" + fuzzy_kappa_sim(list(cell), cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_transitions, 10);\n\t\t}\n\t\tloop i from: 0 to: length(cell) - 1 {\n\t\t\tint val <- int(255 * similarity_per_agents[i]);\n\t\t\task cell[i] {color_fuzzy <- rgb(val, val, val);}\n\t\t\t\n\t\t}\n\t\tloop c over: categories {\n\t\t\tnb_per_cat_obs << cell count (each.cat_observed = c);\n\t\t\tnb_per_cat_sim << cell count (each.cat = c); \n\t\t}\n\t\twrite \"percent_absolute_deviation : \" + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + \"%\";\n\t\t\n\t}\n\t\n}\n\ngrid cell width: 50 height: 50 {\n\tstring cat_init;\n\tstring cat_observed;\n\tstring cat ;\n\trgb color;\n\trgb color_init;\n\trgb color_obs;\n\trgb color_fuzzy <- #white;\n\tlist<cell> neighbours <- self neighbors_at 1;\n\t\n\taspect fuzzy_sim {\n\t\tdraw shape color:color_fuzzy border: color_fuzzy;\n\t}\n\taspect init {\n\t\tdraw shape color:color_init border: color_init;\n\t}\n\taspect observed {\n\t\tdraw shape color:color_obs border: color_obs;\n\t}\n}\n\nexperiment mapcomparison type: gui {\n\toutput {\n\t\tlayout #split;\n\t\tdisplay map_sim type: 2d antialias:false{\n\t\t\tgrid cell;\n\t\t}\n\t\tdisplay map_observed type: 2d{\n\t\t\tspecies cell aspect: observed refresh: false;\n\t\t}\n\t\tdisplay map_init type: 2d{\n\t\t\tspecies cell aspect: init refresh: false;\n\t\t}\n\t\tdisplay map_fuzzy type: 2d{\n\t\t\tspecies cell aspect: fuzzy_sim ;\n\t\t}\n\t}\n}"}
{"prompt": "Compare the accuracy of a prediction model using different comparators (kappa and fuzzy kappa) on a vector map dataset, considering both weighted and unweighted areas.", "gaml_code": "/**\n* Name: Vector Map Comparison\n* Author: Patrick Taillandier\n* Description: This model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used :\n* \n* - kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation;\n* \n* - fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic;\n* \n* - fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logic\n* \n* For each comparator, two comparisons are made : one without taking into account the weights of an area, just computing with each area having the same \n* importance, and an other using weights related to the area of the region\n* Tags: shapefile, comparison, statistic\n*/\n\nmodel mapcomparison\n\nglobal {\n\tlist<string> categories ;\n\tmap<string,rgb> color_cat ;\n\tmatrix<float> fuzzy_categories;\n\tmatrix<float> fuzzy_transitions;\n\tlist<float> nb_per_cat_obs;\n\tlist<float> nb_per_cat_sim;\n\tfile data <- file(\"../includes/CLC00_06.shp\");\n\t\n\tgeometry shape <- envelope(data);\n\t \n\tinit {\n\t\tcreate areaclc from: data with: [init_cover::string(read(\"CODE_00\")),obs_cover::string(read(\"CODE_06\"))] ;\n\t\task areaclc {\n\t\t\tif (not (init_cover in categories)) {categories << init_cover; }\n\t\t\tif (not (obs_cover in categories)) {categories << obs_cover;}\n\t\t\t\n\t\t}\n\t\tloop cat over: categories {\n\t\t\tcolor_cat[cat] <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t}\n\t\task areaclc {\n\t\t\tsim_cover <- flip(0.7) ? obs_cover : one_of (categories);\n\t\t}\n\t\t\n\t\tfuzzy_categories <- 0.0 as_matrix {length(categories),length(categories)};\n\t\tloop i from: 0 to: length(categories) - 1 {\n\t\t\tfuzzy_categories[i,i] <- 1.0;\n\t\t}\n\t\tfuzzy_transitions <- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};\n\t\tloop i from: 0 to: (length(categories) * length(categories)) - 1 {\n\t\t\tfuzzy_transitions[i,i] <- 1.0;\t\n\t\t}\n\t\tlist<float> similarity_per_agents ;\n\t\twrite \"kappa(map observed, map simulation, categories): \" + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);\n\t\twrite \"kappa(map observed, map simulation,categories, weights): \" + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));\n\t\t\n\t\twrite \"kappa simulation(map init, map observed, map simulation, categories): \" + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);\n\t\twrite \"kappa simulation(map init, map observed, map simulation, categories, weights): \" + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));\n\t\t\n\t\twrite \"fuzzy kappa(map observed, map simulation,categories): \" + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000);\n\t\twrite \"fuzzy kappa(map observed, map simulation,categories,weights): \" + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000,areaclc collect (each.shape.area));\n\t\t\n\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories): \" + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000);\n\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories,weights): \" + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000,areaclc collect (each.shape.area));\n\t\t\n\t\tloop i from: 0 to: length(areaclc) - 1 {\n\t\t\tint val <- int(255 * similarity_per_agents[i]);\n\t\t\task areaclc[i] {color_fuzzy <- rgb(val, val, val);}\n\t\t\t\n\t\t}\n\t\tloop c over: categories {\n\t\t\tlist<areaclc> area_c <- areaclc where (each.obs_cover = c);\n\t\t\tlist<float> area_shape_c <- area_c collect (each.shape.area);\n\t\t\tnb_per_cat_obs << sum(area_shape_c );\n\t\t\tnb_per_cat_sim << sum((areaclc where (each.sim_cover = c)) collect (each.shape.area)); \n\t\t}\n\t\twrite \"percent_absolute_deviation : \" + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + \"%\";\n\t\t\n\t}\n\t\n}\n \nspecies areaclc {\n\tstring init_cover;\n\tstring obs_cover;\n\tstring sim_cover;\n\trgb color_fuzzy;\n\t\n\taspect init {\n\t\tdraw shape color: color_cat[init_cover];\n\t}\n\taspect simulation {\n\t\tdraw shape color: color_cat[sim_cover];\n\t}\n\taspect observed {\n\t\tdraw shape color: color_cat[obs_cover];\n\t}\n\taspect fuzzy_sim {\n\t\tdraw shape color: color_fuzzy;\n\t}\n}\n\n\nexperiment \"Compare\" type: gui {\n\toutput {\n\t\tlayout #split consoles: false editors: false navigator: false parameters: false tabs: true toolbars: false tray: false ;\n\t\tdisplay \"Simulated Map\" type: 3d{\n\t\t\tspecies areaclc aspect: simulation;\n\t\t}\n\t\tdisplay \"Observed Map\" type: 3d{\n\t\t\tspecies areaclc aspect: observed refresh: false;\n\t\t}\n\t\tdisplay \"Initial Map\" type: 3d{\n\t\t\tspecies areaclc aspect: init refresh: false;\n\t\t}\n\t\tdisplay \"Fuzzy Comparison Map\" type: 3d background: #black{\n\t\t\tspecies areaclc aspect: fuzzy_sim ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that demonstrates image manipulation and visualization using popular formats.", "gaml_code": "/**\n* Name: CastingImages\n* Shows how to cast Images from and to popular formats \n* Author: Alexis Drogoul\n* Tags: \n*/\n\n\nmodel CastingImages\n\n/* Insert your model definition here */\n\n\nglobal {\n\timage im <- #gama_logo;\n\tmatrix<int> mat <- matrix(im);\n\tfield f <- field(im);\n}\n\nexperiment Show {\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay im type: 3d {\n\t\t\timage im;\n\t\t}\n\t\t\n\t\tdisplay mat {\n\t\t\timage mat;\n\t\t}\n\t\t\n\t\tdisplay field type: 3d {\n\t\t\tmesh f scale: 0.05 triangulation: true;\n\t\t}\n\t}\n\t\n}"}
{"prompt": "Create a NetLogo model that simulates a 3D environment with moving bugs and allows users to take snapshots of the display, save them as images, and copy them to the clipboard.", "gaml_code": "/**\n* Name: ManualSnapshot\n* Shows how to make (and use) snapshots of displays using images \n* Author: A. Drogoul, 2023\n* Tags: image, clipboard, snapshot\n*/\nmodel ManualSnapshot\n\nglobal {\n\t\n\timage background <- image(100,100, #white) ;\n\n\tinit {\n\t\tcreate bug number: 100;\n\t}\n\n}\n\nspecies bug skills:[moving]{\n\t\n\trgb color <- rnd_color(255);\n\t\n\treflex {\n\t\tdo wander amplitude: 20.0 speed: 0.1;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(1) color: color;\n\t}\n}\n\nexperiment \"Snapshot Depth\" type: gui {\n\t\n\treflex when: (cycle > 1) and every(100 #cycle) {\n\t\task simulation {\n\t\t\t// We choose a neutral background\n\t\t\tbackground <- grayscale(brighter(snapshot(\"My Display\")));\n\t\t}\n\t}\n\t\n\t\n\toutput synchronized: true {\n\t\tdisplay \"My Display\" type:3d axes: false{\n\t\t\timage background refresh: true;\n\t\t\tspecies bug;\n\t\t}\n\t}\n\n}\n\nexperiment \"Save Snapshots\" type: gui {\n\t\n\tint i <- 0;\n\t\n\treflex when: (cycle > 1) and every(100 #cycle) {\n\t\task simulation {\n\t\t\t// We choose a neutral background\n\t\t\tsave (snapshot(\"My Display\")) to: \"snapshots/snapshot\" + myself.i + \".png\";\n\t\t}\n\t\ti <- i + 1;\n\t}\n\t\n\t\n\toutput synchronized: true {\n\t\tdisplay \"My Display\" type:3d axes: false{\n\t\t\tspecies bug;\n\t\t}\n\t}\n\n}\n\nexperiment \"Copy Snapshot to Clipboard\" type: gui {\n\t\n\tint i <- 0;\n\t\n\tinit {\n\t\twrite \"press 'c' to copy the snapshot to your clipboard\";\n\t}\n\t\n\toutput synchronized: true {\n\t\tdisplay \"My Display\" type:3d axes: false{\n\t\t\tspecies bug;\n\t\t\tevent \"c\" {if (copy_to_clipboard(snapshot(simulation, \"My Display\"))) {write \"Snapshot copied to the clipboard !\" ;}}\n\t\t}\n\t}\n\n}"}
{"prompt": "Generate a NetLogo model that loads an SVG file, extracts its geometries, and displays them as 3D shapes and wireframes, while also generating random images of these shapes.", "gaml_code": "/**\n* Name: SVGManipulation\n* Shows how to manipulate the geometries produced by SVG files, and also how to translate them to images \n* Author: drogoul\n* Tags: \n*/\n\nmodel SVGManipulation\n\nglobal {\n\t\n\t\n\tsvg_file geometries <- svg_file(\"../includes/geometries.svg\"); // try different files, like city.svg, europe.svg, ant.svg... \n\tgeometry shape <- envelope(geometries);\n\t\n\tinit {\n\t\tcreate shapes from: geometries;\n\t\tcreate images number: 30;\n\t}\n\t\n\tspecies shapes skills: [moving] {\n\t\trgb color <- rnd_color(256);\n\t\t\n\t\treflex {\n\t\t\tdo wander speed: 0.01 amplitude: 10.0;\n\t\t}\n\t\t\n\t\t\n\t\taspect default {\n\t\t\tdraw shape color: color;\n\t\t}\n\t}\n\t\n\t\n\tspecies images {\n\t\timage im <- image(geometries, rnd(world.shape.width / 2)+1, rnd(world.shape.height / 2)+1);\t\t\n\t\taspect default {\n\t\t\tdraw im size: {im.width, im.height};\n\t\t}\n\t}\n\n}\n\nexperiment \"Open me\" type: gui {\n\t\n\t\n\t\n\toutput {\n\t\n\t\tdisplay \"Loop on geometries\" type: 3d {\n\t\t\tgraphics g {\n\t\t\t\tloop gg over: geometries {\n\t\t\t\t\tdraw gg border: #black width: 0.3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay \"Wireframe geometry\" type: 3d {\n\t\t\tgraphics g {\n\t\t\t\tdraw geometry(geometries) wireframe: true border: #black width: 0.3;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay \"Geometries as agents\" type: 3d {\n\t\t\tspecies shapes;\n\t\t}\n\t\t\n\t\tdisplay \"Image Full\" type: 3d {\n\t\t\timage image(geometries);\n\t\t}\n\t\t\n\t\tdisplay \"Images Small\" type: 3d {\n\t\t\tspecies images;\n\t\t}\n\t\n\t\n\t}\n}"}
{"prompt": "Show examples of how to declare and manipulate images in a 2D graphical interface using GAML.", "gaml_code": "/**\n* Name: DeclaringImages\n* Shows how to declare images \n* Author: A. Drogoul\n* Tags: image\n*/\nmodel DeclaringImages\n\nglobal {\n\n\t// a blank image\n\timage blank <- image(100, 100);\n\t// or with a point...\n\tpoint size <- {100,100};\n\timage blank2 <- image(size);\n\n\t// a blank image with transparency\n\timage blank_transparent <- image(100, 100, true);\n\n\t// a blank image with transparency, filled with a color\n\timage colored <- image(100, 100, #red);\n\n\t// an image read from the clipboard (nil if none is present)\n\timage clip <- copy_from_clipboard(image);\n\n\n\t// an image read from a file on disk\n\timage on_disk <- image(\"../includes/Kandinsky.jpeg\");\n\t// a shortcut equivalent to:\n\timage on_disk2 <- image(file(\"../includes/Kandinsky.jpeg\"));\n\t// and of course, any image can be sent to the clipboard as well\n\tbool copied <- copy_to_clipboard(on_disk);\n\t\n\t// an image built from a field\n\tfield terrain <- generate_terrain(10,100,100,0.5,0.5,0.5);\n\timage from_terrain <- image(terrain);\n\t\n\t//an image built from a matrix<int>\n\tmatrix<int> mat <- {100,100} matrix_with int(rnd_color(255));\n\timage from_matrix <- image(mat);\n\t\n\t//an image built out of a grid\n\tgrid cells width: 100 height: 100 {\n\t\trgb color <- rnd_color(255);\n\t}\n\timage from_grid <- image(cells);\n}\n\n\n\n\nexperiment name type: gui {\n\n\toutput {\n\t\tdisplay Images type:2d{\n\t\t\timage from_terrain;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that displays a grid of SVG emojis with their names and icons, with two display options for 3D views.", "gaml_code": "/**\n* Name: Emoji\n* Shows how to use SVG versions of Emojis \n* Author: drogoul\n* Tags: image, svg\n*/\n\n\nmodel Emojis\n\nglobal {\n\tint shape_width <- 200;\n\tgeometry shape <- square(shape_width);\n\tfont text_font <- font(\"Arial\", 10, #bold);\n\tdirectory emoji_folder <- folder(\"../includes/emoji/\"); \n\t// Filter the file names that end up with \"svg\"\n\tlist<svg_file> file_list <- emoji_folder select (each contains (\".svg\")) collect (the_file: svg_file(emoji_folder.path + \"/\" + the_file));\n\tint cell_dimension <- 10;\n\tint size_max <- cell_dimension - 2;\n\tinit {\n\t\tint number <- int((shape_width / cell_dimension) ^2  / 2);\n\t\tloop the_file over: number among(file_list) {\n\t\t\tgeometry ss <- geometry(the_file);\n\t\t\tcreate emoji with: [ratio::ss.width / ss.height,shape::(geometry(the_file)),name::replace(replace(the_file.name,\"emoji_\",\"\"),\".svg\",\"\"), icon:: image(the_file)];\n\t\t}\n\t}\n\t\n\t\n\t\n}\n\nspecies emoji {\n\tfloat ratio;\n\timage icon;\n\trgb color <- rnd_color(255);\n\tthe_grid my_place <- the_grid(index);\n\tpoint location <- my_place.location;\n\t\n\taspect icon_aspect {\n\t\tdraw icon size: size_max;\n\t\tdraw replace(name,'_',\"\\n\") font: text_font at: location + {0,cell_dimension/2} anchor: #top_center color: #black;\n\t}\n\t\n\taspect shape_aspect {\n\t\tdraw shape border: #black color: color size: (ratio > 1) ? {size_max, size_max/ratio}: {size_max*ratio, size_max};\n\t\tdraw replace(name,'_',\"\\n\") font: text_font at: location + {0,cell_dimension/2} anchor: #top_center color: #black;\n\t}\n}\n\ngrid the_grid cell_width: cell_dimension cell_height: cell_dimension*2;\n\nexperiment Emojis {\n\t\n\toutput {\n\t\tlayout #split consoles: false toolbars: false tabs: false background: #black controls: true;\n\t\tdisplay \"Show vector emojis\" type: 3d axes: false{\n\t\t\tspecies emoji aspect: shape_aspect;\n\t\t}\n\t\tdisplay \"Show icon emojis\" type: 3d axes: false {\n\t\t\tspecies emoji aspect: icon_aspect;\n\t\t}\n\t}\n\t\n}"}
{"prompt": "Create a GAML model that demonstrates various image manipulation techniques on an input image, allowing users to visualize and compare different transformations.", "gaml_code": "/**\n* Name: ImageManipulation\n* A model to demonstrate some tools to produce, use and save images \n* Author: A. Drogoul\n* Tags: image\n*/\nmodel ImageManipulation\n\nglobal {\n\timage im1;\n\tint x <- 0;\n\tint y <- 0;\n\tint row <- 5 * im1.width;\n\tint cols <- 5 * (im1.height + 50);\n\tgeometry shape <- rectangle(row, cols);\n\n\tinit {\n\t\tdo create_agent(im1, \"Original\");\n\t\tdo create_agent(horizontal_flip(im1), \"Horizontal flip\");\n\t\tdo create_agent(vertical_flip(im1), \"Vertical flip\");\n\t\tdo create_agent((im1 rotated_by 180), \"Rotation 180\u00b0\");\n\t\tdo create_agent(blend(im1, horizontal_flip(im1), 0.5), \"Blend with flip\");\n\t\tdo create_agent((im1 * 0.5), \"Size / 2\");\n\t\tdo create_agent((im1 * 0.2), \"Size / 5\");\n\t\tdo create_agent(((im1 * 0.1) * 10), \"(Size / 10) * 10\");\n\t\tdo create_agent((im1 rotated_by 90) * 0.5, \"Rotation 90\u00b0 / 2\");\n\t\tdo create_agent((im1 rotated_by -33) * 0.7, \"Rotation -33\u00b0 * 0.7\");\n\t\tdo create_agent(darker(im1,0.5), \"50% darker\");\n\t\tdo create_agent(brighter(im1, 0.5), \"50% brighter\");\n\t\tdo create_agent((im1 * #lightgreen), \"Light green tint\");\n\t\tdo create_agent((im1 * #lightskyblue), \"Light blue tint\");\n\t\tdo create_agent(im1 tinted_with (#red, 0.15), \"15% red tint\");\n\t\tdo create_agent(grayscale(im1), \"Grayscale\");\n\t\tdo create_agent(grayscale(im1 * rgb(100, 100, 100)), \"Dark Grayscale\");\n\t\tdo create_agent(brighter(brighter(brighter(grayscale(im1)))), \"Bright Grayscale\");\n\t\tdo create_agent((sharpened(im1, 5)), \"5 x Sharpened\");\n\t\tdo create_agent(blurred(im1,2), \"2 x Blurred\");\n\t\tdo create_agent(antialiased(im1, 10), \"10 x Antialiased\");\n\t\tdo create_agent(im1 with_width 200, \"With width 200\"); \n\t\tdo create_agent(im1 with_height 400, \"With height 400\");\n\t\tdo create_agent(im1 with_size (im1.width, im1.height / 2), \"Distorted height / 2\");\n\t\tdo create_agent(im1 with_size (im1.width / 3, im1.height), \"Distorted width / 3\");\n\t\tdo create_agent(im1 cropped_to (200, 200, im1.width - 200, im1.height - 200), \"Cropped \");\n\t}\n\n\tfont title <- font(\"Arial\", 20 #px, #bold);\n\n\taction create_agent (image im, string n) {\n\t\tcreate support {\n\t\t\tself.img <- im;\n\t\t\tself.name <- n;\n\t\t\tself.shape <- envelope(img) at_location {x + im1.width / 2, y + im1.height / 2};\n\t\t\tif (x < row - im1.width) {\n\t\t\t\tx <- x + im1.width;\n\t\t\t} else {\n\t\t\t\tx <- 0;\n\t\t\t\ty <- y + im1.height;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies support {\n\timage img;\n\n\t\n\taspect default {\n\t\tdraw img at: location size: {shape.width, shape.height};\n\t\tdraw name font: title at: location + {0, 0, 10} anchor: #center color: #white border: #black;\n\t}\n\n}\n\nexperiment ImageManipulation type: gui {\n\n\taction _init_ {\n\t\timage im <- copy_from_clipboard(image);\n\t\tif im = nil {\n\t\t\tim <- image(\"../includes/Kandinsky.jpeg\");\n\t\t}\n\t\tcreate simulation with: [im1::im];\n\t\t\n\t}\n \n\toutput {\n\t\tdisplay Agents type: 3d axes: false fullscreen: true background: #black {\n\t\t\tcamera 'default' location: {shape.width/2, shape.height/2, max(shape.width, shape.height)*1.5} target: {shape.width/2, shape.height/2, 0};\n\t\t\tspecies support aspect: default;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Develop a traffic simulation model using GAML, incorporating a road network and various agents (roads, intersections, vehicles) with specific skills and behaviors.", "gaml_code": "/**\n* Name: Traffic\n* Description: define species for traffic simulation\n* Author: Patrick Taillandier & Duc Pham\n* Tags: driving skill, graph, agent_movement, skill, transport\n*/\n\nmodel simple_traffic_model\n\nglobal {\n\tshape_file nodes_shape_file <- shape_file(\"../../includes/rouen/nodes.shp\");\n\tshape_file roads_shape_file <- shape_file(\"../../includes/rouen/roads.shp\");\n\t\n\tgeometry shape <- envelope(roads_shape_file);\n\tgraph road_network;\n\tinit {\n\t\tcreate intersection from: nodes_shape_file;\n\t\t\n\t\tcreate road from: roads_shape_file {\n\t\t\t// Create another road in the opposite direction\n\t\t\tcreate road {\n\t\t\t\tnum_lanes <- myself.num_lanes;\n\t\t\t\tshape <- polyline(reverse(myself.shape.points));\n\t\t\t\tmaxspeed <- myself.maxspeed;\n\t\t\t\tlinked_road <- myself;\n\t\t\t\tmyself.linked_road <- self;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\troad_network <- as_driving_graph(road, intersection);\n\t\t\n\t\tcreate vehicle number: 1000 with: (location: one_of(intersection).location);\n\t}\n\n}\n\nspecies road skills: [road_skill] {\n\trgb color <- #white;\n\t\n\taspect base {\n\t\tdraw shape color: color end_arrow: 1;\n\t}\n}\n\nspecies intersection skills: [intersection_skill] ;\n\nspecies vehicle skills: [driving] {\n\trgb color <- rnd_color(255);\n\tinit {\n\t\tvehicle_length <- 1.9 #m;\n\t\tmax_speed <- 100 #km / #h;\n\t\tmax_acceleration <- 3.5;\n\t}\n\n\treflex select_next_path when: current_path = nil {\n\t\t// A path that forms a cycle\n\t\tdo compute_path graph: road_network target: one_of(intersection);\n\t}\n\t\n\treflex commute when: current_path != nil {\n\t\tdo drive;\n\t}\n\taspect base {\n\t\tdraw triangle(5.0) color: color rotate: heading + 90 border: #black;\n\t}\n}\n\nexperiment city type: gui {\n\toutput synchronized: true {\n\t\tdisplay map type: 2d background: #gray {\n\t\t\tspecies road aspect: base;\n\t\t\tspecies vehicle aspect: base;\t\t}\n\t}\n}"}
{"prompt": "Create a model that loads OSM files, extracts road network data, and saves it to shapefiles for use in driving skill models.", "gaml_code": "/**\n* Name: OSM Loading Driving\n* Author: Patrick Taillandier\n* Description: Model to show how to import OSM Files, using them to create agents for a road network, and saving the different agents in shapefiles. \n* The first goal of this model is to prepare data for the driving skill models.\n* Tags:  load_file, gis, shapefile, save_file, osm\n*/\n\n\nmodel OSMdata_to_shapefile \n \nglobal{\n\t//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\tmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"]]);\n\t\n\t//OSM file to load\n\tfile<geometry> osmfile <-  file<geometry>(osm_file(\"../../includes/rouen.gz\", filtering))  ;\n\t\n\tgeometry shape <- envelope(osmfile);\n\tgraph the_graph; \n\tmap<point, intersection> nodes_map;\n\t\n\t\n\n\tinit {\n\t\twrite \"OSM file loaded: \" + length(osmfile) + \" geometries\";\n\t\t\n\t\t//from the OSM file, creation of the selected agents\n\t\tloop geom over: osmfile {\n\t\t\tif (shape covers geom) {\n\t\t\t\tstring highway_str <- string(geom get (\"highway\"));\n\t\t\t\tif (length(geom.points) = 1 ) {\n\t\t\t\t\tif ( highway_str != nil ) {\n\t\t\t\t\t\tstring crossing <- string(geom get (\"crossing\"));\n\t\t\t\t\t\tcreate intersection with: [shape ::geom, type:: highway_str, crossing::crossing] {\n\t\t\t\t\t\t\tnodes_map[location] <- self;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstring oneway <- string(geom get (\"oneway\"));\n\t\t\t\t\tfloat maxspeed_val <- float(geom get (\"maxspeed\"));\n\t\t\t\t\tstring lanes_str <- string(geom get (\"lanes\"));\n\t\t\t\t\tint lanes_val <- empty(lanes_str) ? 1 : ((length(lanes_str) > 1) ? int(first(lanes_str)) : int(lanes_str));\n\t\t\t\t\tcreate road with: [shape ::geom, type:: highway_str, oneway::oneway, maxspeed::maxspeed_val, lanes::lanes_val] {\n\t\t\t\t\t\tif lanes < 1 {lanes <- 1;} //default value for the lanes attribute\n\t\t\t\t\t\tif maxspeed = 0 {maxspeed <- 50.0;} //default value for the maxspeed attribute\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\twrite \"Road and node agents created\";\n\t\t\n\t\task road {\n\t\t\tpoint ptF <- first(shape.points);\n\t\t\tif (not(ptF in nodes_map.keys)) {\n\t\t\t\tcreate intersection with:[location::ptF] {\n\t\t\t\t\tnodes_map[location] <- self;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tpoint ptL <- last(shape.points);\n\t\t\tif (not(ptL in nodes_map.keys)) {\n\t\t\t\tcreate intersection with:[location::ptL] {\n\t\t\t\t\tnodes_map[location] <- self;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\twrite \"Supplementary node agents created\";\n\t\task intersection {\n\t\t\tif (empty (road overlapping (self))) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t}\n\t\t\n\t\twrite \"node agents filtered\";\n\t\t\n\t\t//Save all the road agents inside the file with the path written, using the with: facet to make a link between attributes and columns of the resulting shapefiles. \n\t\tsave road to:\"../includes/roads.shp\" attributes:[\"lanes\"::self.lanes, \"maxspeed\"::maxspeed, \"oneway\"::oneway] ;\n\t\tsave intersection to:\"../includes/nodes.shp\" attributes:[\"type\"::type, \"crossing\"::crossing] ;\n\t\twrite \"road and node shapefile saved\";\n\t}\n}\n\t\n\nspecies road{\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\tstring type;\n\tstring oneway;\n\tfloat maxspeed;\n\tint lanes;\n\taspect base_ligne {\n\t\tdraw shape color: color; \n\t}\n\t\n} \n\t\nspecies intersection {\n\tstring type;\n\tstring crossing;\n\taspect base { \n\t\tdraw square(3) color: #red ;\n\t}\n} \n\t\n\nexperiment fromOSMtoShapefiles type: gui {\n\toutput {\n\t\tdisplay map type: 2d {\n\t\t\tgraphics \"world\" {\n\t\t\t\tdraw world.shape.contour color:#black;\n\t\t\t}\n\t\t\tspecies road aspect: base_ligne  refresh: false  ;\n\t\t\tspecies intersection aspect: base   refresh: false ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of traffic flow on a map of Rouen, France, where vehicles follow paths and interact with each other and traffic signals.", "gaml_code": "/**\n* Name: Following Paths\n* Description: Vehicles moving between two intersection using the same path.\n\t\t\t   Note that all vehicles slow down when reaching the end of the path, because at that point they don't know which road to choose next,\n\t\t\t   and thus cannot determine their leading vehicle.\n* Author: Duc Pham\n* Tags: driving skill, graph, agent_movement, skill, transport\n*/\n\nmodel FollowingPaths\n\nimport \"Traffic.gaml\"\n\nglobal {\n\tfloat step <- 0.1 #s;\n\t\n\tstring map_name <- \"rouen\";\n\tfile shp_roads <- file(\"../../includes/\" + map_name + \"/roads.shp\");\n\tfile shp_nodes <- file(\"../../includes/\" + map_name + \"/nodes.shp\");\n\n\tgeometry shape <- envelope(shp_roads) + 50; \n\t\n\tgraph road_network;\n\t\n\tinit {\n\t\tcreate road from: shp_roads with: [num_lanes::int(read(\"lanes\"))] {\n\t\t\t// Create another road in the opposite direction\n\t\t\tcreate road {\n\t\t\t\tnum_lanes <- myself.num_lanes;\n\t\t\t\tshape <- polyline(reverse(myself.shape.points));\n\t\t\t\tmaxspeed <- myself.maxspeed;\n\t\t\t\tlinked_road <- myself;\n\t\t\t\tmyself.linked_road <- self;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcreate intersection from: shp_nodes\n\t\t\t\twith: [is_traffic_signal::(read(\"type\") = \"traffic_signals\")] {\n\t\t\ttime_to_change <- 30#s;\n\t\t}\n\t\t\n\t\t// Create a graph representing the road network, with road lengths as weights\n\t\tmap edge_weights <- road as_map (each::each.shape.perimeter);\n\t\troad_network <- as_driving_graph(road, intersection) with_weights edge_weights;\n\t\t\n\t\t// Initialize the traffic lights\n\t\task intersection {\n\t\t\tdo initialize;\n\t\t}\n\t\tcreate vehicle_following_path number: 100;\n\t}\n}\n\nspecies vehicle_following_path parent: base_vehicle {\n\tinit {\n\t\tvehicle_length <- 1.9 #m;\n\t\tmax_speed <- 100 #km / #h;\n\t\tmax_acceleration <- 3.5;\n\t}\n\n\treflex select_next_path when: current_path = nil {\n\t\t// A path that forms a cycle\n\t\tlist<intersection> dst_nodes <- [intersection[98], intersection[100], intersection[137], intersection[98]];\n\t\tdo compute_path graph: road_network nodes: dst_nodes;\n\t}\n\t\n\treflex commute when: current_path != nil {\n\t\tdo drive;\n\t}\n}\n\nexperiment city type: gui {\n\toutput synchronized: true {\n\t\tdisplay map type: 2d background: #gray {\n\t\t\tspecies road aspect: base;\n\t\t\tspecies vehicle_following_path aspect: base;\n\t\t\tspecies intersection aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Simulate a 3D cityscape with traffic lights and cars driving on roads, using a graph-based model to compute shortest paths.", "gaml_code": "/**\n* Name: Mix Drive City\n* Description: Vehicles driving in a road graph\n* Author: Duc Pham and Patrick Taillandier\n* Tags: gis, shapefile, graph, agent_movement, skill, transport\n*/\n\nmodel simple_intersection\n\n\nglobal {\n\tfloat size_environment <- 1#km;\n\t\n\tgeometry shape <- envelope(size_environment);\n\t\n\t//the typical step for the advanced driving skill\n\tfloat step <- 0.5 #s;\n\t\n\t//use only for display purpose\n\tfloat lane_width <- 2.0;\n\t\n\t//number of cars\n\tint num_cars <- 300;\n\t\n\tfloat proba_block_node_car <- 1.0; \n\t\n\t//graph used for the shortest path computation\n\tgraph road_network;\n\t\n\tinit {\n\t\tcreate intersection with: (location: {10,size_environment/2});\n\t\tcreate intersection with: (location: {size_environment/2,size_environment/2});\n\t\tcreate intersection with: (location: {size_environment / 2 + 30,size_environment/2}, is_traffic_signal: true);\n\t\tcreate intersection with: (location: {size_environment - 10,size_environment/2});\n\t\n\t\tcreate intersection with: (location: {size_environment/2, 10});\n\t\tcreate intersection with: (location: {size_environment/2,size_environment - 10});\n\t\t\n\t\tcreate road with:(num_lanes:1, maxspeed: 50#km/#h, shape:line([intersection[0],intersection[1]]));\n\t\tcreate road with:(num_lanes:1, maxspeed: 50#km/#h, shape:line([intersection[1],intersection[2]]));\n\t\tcreate road with:(num_lanes:1, maxspeed: 50#km/#h, shape:line([intersection[2],intersection[3]]));\n\t\tcreate road with:(num_lanes:1, maxspeed: 50#km/#h, shape:line([intersection[4],intersection[1]]));\n\t\tcreate road with:(num_lanes:1, maxspeed: 50#km/#h, shape:line([intersection[1],intersection[5]]));\n\t\t\n\t\n\t\t//build the graph from the roads and intersections\n\t\troad_network <- as_driving_graph(road,intersection);\n\t\t\n\t\t//for traffic light, initialize their counter value (synchronization of traffic lights)\n\t\task intersection where each.is_traffic_signal {\n\t\t\tdo initialize;\n\t\t}\n\t\t\n\t}\n\t\n\treflex add_car {\n\t\tcreate car with: (location: intersection[0].location, target: intersection[3]);\n\t\tcreate car with: (location: intersection[4].location, target: intersection[5]);\n\t}\n}\n\n\n//road species\nspecies road skills: [road_skill]{\n\tstring type;\n\tstring oneway;\n\t\n\taspect base_ligne {\n\t\tdraw shape color: #white end_arrow:5; \n\t}\n\t\n} \n\n//intersection species\nspecies intersection skills: [intersection_skill] {\n\tbool is_traffic_signal;\n\tfloat time_to_change <- 60#s ;\n\tfloat counter <- rnd(time_to_change);\n\t\n\t//take into consideration the roads coming from both direction (for traffic light)\n\tlist<road> ways1;\n\tlist<road> ways2;\n\t\n\t//if the traffic light is green\n\tbool is_green;\n\trgb color <- #yellow;\n\n\t//initialize the traffic light\n\taction initialize {\n\t\tdo compute_crossing;\n\t\tstop << [];\n\t\tif (flip(0.5)) {\n\t\t\tdo to_green;\n\t\t} else {\n\t\t\tdo to_red;\n\t\t}\n\t}\n\n\taction compute_crossing {\n\t\tif (length(roads_in) >= 2) {\n\t\t\troad rd0 <- road(roads_in[0]);\n\t\t\tlist<point> pts <- rd0.shape.points;\n\t\t\tfloat ref_angle <- last(pts) direction_to rd0.location;\n\t\t\tloop rd over: roads_in {\n\t\t\t\tlist<point> pts2 <- road(rd).shape.points;\n\t\t\t\tfloat angle_dest <- last(pts2) direction_to rd.location;\n\t\t\t\tfloat ang <- abs(angle_dest - ref_angle);\n\t\t\t\tif (ang > 45 and ang < 135) or (ang > 225 and ang < 315) {\n\t\t\t\t\tways2 << road(rd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tloop rd over: roads_in {\n\t\t\tif not (rd in ways2) {\n\t\t\t\tways1 << road(rd);\n\t\t\t}\n\t\t}\n\t}\n\n\t//shift the traffic light to green\n\taction to_green {\n\t\tstop[0] <- ways2;\n\t\tcolor <- #green;\n\t\tis_green <- true;\n\t}\n\n\t//shift the traffic light to red\n\taction to_red {\n\t\tstop[0] <- ways1;\n\t\tcolor <- #red;\n\t\tis_green <- false;\n\t}\n\n\t//update the state of the traffic light\n\treflex dynamic_node when: is_traffic_signal {\n\t\tcounter <- counter + step;\n\t\tif (counter >= time_to_change) {\n\t\t\tcounter <- 0.0;\n\t\t\tif is_green {\n\t\t\t\tdo to_red;\n\t\t\t} else {\n\t\t\t\tdo to_green;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect base {\n\t\tif color != #yellow {\n\t\t\tdraw circle(10) color: color at:{location.x, location.y+20};\t\t\t\n\t\t}\n\t}\n}\n\n\nspecies car skills: [driving] {\n\trgb color <- rnd_color(255);\n\tintersection target;\n\t\n\tinit {\n\t\tvehicle_length <- 3.8 #m;\n\t\t//car occupies 2 lanes\n\t\tnum_lanes_occupied <-1;\n\t\tmax_speed <-150 #km / #h;\n\t\t\t\t\n\t\tproba_block_node <- proba_block_node_car;\n\t\tproba_respect_priorities <- 1.0;\n\t\tproba_respect_stops <- [1.0];\n\t\tproba_use_linked_road <- 0.0;\n\n\t\tlane_change_limit <- 2;\n\t\tlinked_lane_limit <- 0;\n\t\t\n\t}\n\t//choose a random target and compute the path to it\n\treflex choose_path when: final_target = nil {\n\t\tdo compute_path graph: road_network target: target; \n\t}\n\treflex move when: final_target != nil {\n\t\tdo drive;\n\t\t//if arrived at target, kill it and create a new car\n\t\tif (final_target = nil) {\n\t\t\tdo unregister;\n\t\t\tdo die;\n\t\t}\n\t}\n\t\n\t// Just use for display purpose\n\t// Shifts the position of the vehicle perpendicularly to the road,\n\t// in order to visualize different lanes\n\tpoint compute_position {\n\t\tif (current_road != nil) {\n\t\t\tfloat dist <- (road(current_road).num_lanes - lowest_lane -\n\t\t\t\tmean(range(num_lanes_occupied - 1)) - 0.5) * lane_width;\n\t\t\tif violating_oneway {\n\t\t\t\tdist <- -dist;\n\t\t\t}\n\t\t \tpoint shift_pt <- {cos(heading + 90) * dist, sin(heading + 90) * dist};\t\n\t\t\n\t\t\treturn location + shift_pt;\n\t\t} else {\n\t\t\treturn {0, 0};\n\t\t}\n\t}\n\t\n\t\n\taspect default {\n\t\tif (current_road != nil) {\n\t\t\tpoint pos <- compute_position();\n\t\t\t\tdraw rectangle(vehicle_length*4, lane_width * num_lanes_occupied*4) \n\t\t\t\tat: pos color: color rotate: heading border: #black;\n\t\t\tdraw triangle(lane_width * num_lanes_occupied) \n\t\t\t\tat: pos color: #white rotate: heading + 90 ;\n\t\t}\n\t}\n\n}\n\n\nexperiment simple_intersection  type: gui {\n\n\toutput synchronized: true {\n\t\tdisplay city type: 3d background: #black axes: false{\n\t\t\tspecies road aspect: base_ligne;\n\t\t\tspecies intersection aspect: base;\n\t\t\tspecies car ;\n\t\t}\n\t}\n}"}
{"prompt": "Simulate a traffic scenario with vehicles driving randomly on a road graph, including cars and motorbikes, with realistic traffic light intervals and movement patterns.", "gaml_code": "/**\n* Name: Drive Random\n* Description: Vehicles driving randomly in a road graph\n* Author: Duc Pham\n* Tags: gis, shapefile, graph, agent_movement, skill, transport\n*/\n\nmodel DriveRandom\n\nimport \"Traffic.gaml\"\n\nglobal {\n\tfloat seed <- 42.0;\n\tfloat traffic_light_interval init: 60#s;\n\tfloat step <- 0.2#s;\n\n\tstring map_name;\n\tfile shp_roads <- file(\"../../includes/\" + map_name + \"/roads.shp\");\n\tfile shp_nodes <- file(\"../../includes/\" + map_name + \"/nodes.shp\");\n\n\tgeometry shape <- envelope(shp_roads) + 50;\n\t\n\tint num_cars;\n\tint num_motorbikes;\n\n\tgraph road_network;\n\tlist<intersection> non_deadend_nodes;\n\n\tinit {\n\t\tcreate road from: shp_roads {\n\t\t\tnum_lanes <- rnd(4, 6);\n\t\t\t// Create another road in the opposite direction\n\t\t\tcreate road {\n\t\t\t\tnum_lanes <- myself.num_lanes;\n\t\t\t\tshape <- polyline(reverse(myself.shape.points));\n\t\t\t\tmaxspeed <- myself.maxspeed;\n\t\t\t\tlinked_road <- myself;\n\t\t\t\tmyself.linked_road <- self;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcreate intersection from: shp_nodes\n\t\t\t\twith: [is_traffic_signal::(read(\"type\") = \"traffic_signals\")] {\n\t\t\ttime_to_change <- traffic_light_interval;\n\t\t}\n\t\t\n\t\t// Create a graph representing the road network, with road lengths as weights\n\t\tmap edge_weights <- road as_map (each::each.shape.perimeter);\n\t\troad_network <- as_driving_graph(road, intersection) with_weights edge_weights;\n\t\t\n\t\tnon_deadend_nodes <- intersection where !empty(each.roads_out);\n\t\t// Initialize the traffic lights\n\t\task intersection {\n\t\t\tdo initialize;\n\t\t}\n\t\t\n\t\tcreate motorbike_random number: num_motorbikes;\n\t\tcreate car_random number: num_cars;\n\t}\n}\n\nspecies vehicle_random parent: base_vehicle {\n\tinit {\n\t\troad_graph <- road_network;\n\t\tlocation <- one_of(non_deadend_nodes).location;\n\t\tright_side_driving <- true;\n\t}\n\n\t// Move the vehicle to a random node when it reaches a deadend\n\treflex relocate when: next_road = nil and distance_to_current_target = 0.0 {\n\t\tdo unregister;\n\t\tlocation <- one_of(non_deadend_nodes).location;\n\t}\n\t\n\treflex commute {\n\t\tdo drive_random graph: road_graph;\n\t}\n}\n\nspecies motorbike_random parent: vehicle_random {\n\tinit {\n\t\tvehicle_length <- 1.9 #m;\n\t\tnum_lanes_occupied <- 1;\n\t\tmax_speed <- (50 + rnd(20)) #km / #h;\n\n\t\tproba_block_node <- 0.0;\n\t\tproba_respect_priorities <- 1.0;\n\t\tproba_respect_stops <- [1.0];\n\t\tproba_use_linked_road <- 0.5;\n\n\t\tlane_change_limit <- 2;\t\t\n\t\tlinked_lane_limit <- 1;\n\t}\n}\n\nspecies car_random parent: vehicle_random {\n\tinit {\n\t\tvehicle_length <- 3.8 #m;\n\t\tnum_lanes_occupied <- 2;\n\t\tmax_speed <- (60 + rnd(10)) #km / #h;\n\t\t\t\t\n\t\tproba_block_node <- 0.0;\n\t\tproba_respect_priorities <- 1.0;\n\t\tproba_respect_stops <- [1.0];\n\t\tproba_use_linked_road <- 0.0;\n\n\t\tlane_change_limit <- 2;\t\t\t\n\t\tlinked_lane_limit <- 0;\n\t}\n}\n\n\n\n\nexperiment ring type: gui {\n\n\tparameter 'Traffic light interval' var:traffic_light_interval;\n\t\n\taction _init_{ \n\t\tcreate simulation with:[\n\t\t\tmap_name::\"ring\",\n\t\t\tnum_cars::50,\n\t\t\tnum_motorbikes::100\n\t\t];\n\t}\n\n\toutput synchronized: true {\n\t\tdisplay map type: 2d background: #gray {\n\t\t\tspecies road aspect: base;\n\t\t\tspecies car_random aspect: base;\n\t\t\tspecies motorbike_random aspect: base;\n\t\t\tspecies intersection aspect: base;\n\t\t}\n\t}\n}\n\n\nexperiment city type: gui {\n\taction _init_{\n\t\tcreate simulation with:[\n\t\t\tmap_name::\"rouen\",\n\t\t\tnum_cars::100,\n\t\t\tnum_motorbikes::200\n\t\t];\n\t}\n\n\toutput synchronized: true {\n\t\tdisplay map type: 2d background: #gray {\n\t\t\tspecies road aspect: base;\n\t\t\tspecies car_random aspect: base;\n\t\t\tspecies motorbike_random aspect: base;\n\t\t\tspecies intersection aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model for simulating traffic flow and behavior, including road networks, intersections, vehicles, and traffic signals.", "gaml_code": "/**\n* Name: Traffic\n* Description: define species for traffic simulation\n* Author: Patrick Taillandier & Duc Pham\n* Tags: driving skill, graph, agent_movement, skill, transport\n*/\n\nmodel traffic\n\nglobal {\n\t// This is for visualization purposes only, \n\t// the width of a vehicle is specified using num_lanes_occupied\n\tfloat lane_width <- 0.7;  \n}\n\nspecies road skills: [road_skill] {\n\trgb color <- #white;\n\tstring oneway;\n\n\taspect base {\n\t\tdraw shape color: color end_arrow: 1;\n\t}\n}\n\nspecies intersection skills: [intersection_skill] {\n\trgb color;\n\tbool is_traffic_signal;\n\tfloat time_to_change <- 30#s;\n\tfloat counter <- rnd(time_to_change);\n\tlist<road> ways1;\n\tlist<road> ways2;\n\tbool is_green;\n\trgb color_fire;\n\n\taction initialize {\n\t\tif (is_traffic_signal) {\n\t\t\tdo compute_crossing;\n\t\t\tstop << [];\n\t\t\tif (flip(0.5)) {\n\t\t\t\tdo to_green;\n\t\t\t} else {\n\t\t\t\tdo to_red;\n\t\t\t}\n\t\t}\n\t}\n\n\taction compute_crossing {\n\t\tif (length(roads_in) >= 2) {\n\t\t\troad rd0 <- road(roads_in[0]);\n\t\t\tlist<point> pts <- rd0.shape.points;\n\t\t\tfloat ref_angle <- last(pts) direction_to rd0.location;\n\t\t\tloop rd over: roads_in {\n\t\t\t\tlist<point> pts2 <- road(rd).shape.points;\n\t\t\t\tfloat angle_dest <- last(pts2) direction_to rd.location;\n\t\t\t\tfloat ang <- abs(angle_dest - ref_angle);\n\t\t\t\tif (ang > 45 and ang < 135) or (ang > 225 and ang < 315) {\n\t\t\t\t\tways2 << road(rd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tloop rd over: roads_in {\n\t\t\tif not (rd in ways2) {\n\t\t\t\tways1 << road(rd);\n\t\t\t}\n\t\t}\n\t}\n\n\taction to_green {\n\t\tstop[0] <- ways2;\n\t\tcolor_fire <- #green;\n\t\tis_green <- true;\n\t}\n\n\taction to_red {\n\t\tstop[0] <- ways1;\n\t\tcolor_fire <- #red;\n\t\tis_green <- false;\n\t}\n\n\treflex dynamic_node when: is_traffic_signal {\n\t\tcounter <- counter + step;\n\t\tif (counter >= time_to_change) {\n\t\t\tcounter <- 0.0;\n\t\t\tif is_green {\n\t\t\t\tdo to_red;\n\t\t\t} else {\n\t\t\t\tdo to_green;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect base {\n\t\tif (is_traffic_signal) {\n\t\t\tdraw circle(1) color: color_fire;\n\t\t} else {\n\t\t\tdraw circle(1) color: color;\n\t\t}\n\t}\n}\n\nspecies base_vehicle skills: [driving] {\n\trgb color <- rnd_color(255);\n\tgraph road_graph;\n\t\n\tpoint compute_position {\n\t\t// Shifts the position of the vehicle perpendicularly to the road,\n\t\t// in order to visualize different lanes\n\t\tif (current_road != nil) {\n\t\t\tfloat dist <- (road(current_road).num_lanes - lowest_lane -\n\t\t\t\tmean(range(num_lanes_occupied - 1)) - 0.5) * lane_width;\n\t\t\tif violating_oneway {\n\t\t\t\tdist <- -dist;\n\t\t\t}\n\t\t \tpoint shift_pt <- {cos(heading + 90) * dist, sin(heading + 90) * dist};\t\n\t\t\n\t\t\treturn location + shift_pt;\n\t\t} else {\n\t\t\treturn {0, 0};\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tif (current_road != nil) {\n\t\t\tpoint pos <- compute_position();\n\t\t\t\t\n\t\t\tdraw rectangle(vehicle_length, lane_width * num_lanes_occupied) \n\t\t\t\tat: pos color: color rotate: heading border: #black;\n\t\t\tdraw triangle(lane_width * num_lanes_occupied) \n\t\t\t\tat: pos color: #white rotate: heading + 90 border: #black;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates a repeated simulation with serialization and visualization of agent movement.", "gaml_code": "/**\n* Name: Model1\n* Author: Benoit Gaudou\n* Description: Loads a simulation from a file\n* Tags: serialization, load_file\n*/\n\nmodel Serialization\n\nglobal {\n\tint toot <- 0;\n\tstring s <- \"test\";\n\t\n\tinit {\n\t\tcreate people number: 1;\n\t\tcreate other number: 2;\n\t\twrite \"Run the model.\";\n\t\twrite \"Every 4 steps, the simulation is restored to its initial step.\";\n\t\twrite \"You will thus observe the red agent going to the right side of the display and, every 4 steps, moving back to its initial location.\";\n\t}\n\t\n\treflex t {\n\t\twrite toot;\n\t\ttoot <- toot +10;\n\t}\n}\n\nspecies people {\n\tint t;\n\tlist<int> lo <- [1,2,3];\n\t\n\treflex move {\n\t\tfloat r <- rnd(5.0);\n\t\twrite \"\" + cycle + \" - \"  + r  ;\n\t\tlocation <- {location.x + r, location.y};\n\t}\n\t\n\taspect default {\n\t\tdraw circle(1) color: #red;\n\t}\n}\n\nspecies other {\n\taspect default {\n\t\tdraw circle(1) color: #blue;\n\t}\n}\n\nexperiment \"Repeated Simulations\" type: gui {\n\n\tstring saved_step <- \"\";\n\n\tinit {\n\t\tsaved_step <- serialize(self.simulation);\n\t}\n\t\n\treflex restore when: (cycle mod 4) = 0 {\n\t\twrite \"================ begin restore \" + self + \" - \" + cycle;\n\t\trestore simulation from: saved_step;\n\t\twrite \"================ end restore \" + self + \" - \" + cycle;\t\t\t\n\t}\n\n\toutput {\n\t\tlayout #split;\n\t\tdisplay d {\n\t\t\tspecies people aspect: default;\n\t\t\tspecies other aspect: default;\n\t\t}\t\n\t\t\n\t\tdisplay c  type: 2d {\n\t\t\tchart \"t\" {\n\t\t\t\tdata \"location\" value: first(people).location.x;\n\t\t\t}\n\t\t}\t\n\t}\n}"}
{"prompt": "Create a NetLogo model that saves and serializes a simulation to a file every 2 cycles, displaying the serialization of each agent.", "gaml_code": "/**\n* Name: ModelSaveAndSerialize\n* Author: Benoit Gaudou\n* Description: Save a simulation to a file and display the serialization of the simulation\n* Tags: serialization, save_file\n*/\n\nmodel SavingSimulation\n\nglobal {\n\tstring s <- \"test\";\n\t\n\tinit {\n\t\tcreate people number: 1;\n\t}\n}\n\nspecies people {\n\tint t;\n\tlist<int> lo <- [1,2,3];\n}\n\nexperiment SaveSimulation type: gui {\n\t\n\treflex save_simulation when: cycle mod 2 = 0 {\n\t\twrite \"================ START SAVE + self \" + \" - \" + cycle ;\t\t\n\t\tsave simulation to: '../result/file.simulation'  ;\n\t\twrite \"================ END SAVE + self \" + \" - \" + cycle ;\t\t\t\t\t\n\t}\n\t\n\treflex serialize_agent when: cycle mod 2 = 1 {\n\t\twrite \"================ Serialize simulation \" + self + \" - \" + cycle;\n\t\twrite serialize(self.simulation);\n\t\twrite \"================ END Serialize simulation \" + self + \" - \" + cycle;\t\t\t\t\n\t}\n\t\n}"}
{"prompt": "Create a GAMA model that demonstrates how to serialize and restore agents using various methods, including saving to disk and memory, exchanging attributes between agents, and creating new clones from saved data.", "gaml_code": "/**\n* Name: SerializeAndRestoreAgents\n* Shows how to save / read agents using the statements and operators defined in GAMA \n* Author: A. Drogoul\n* Tags: serialize, create, restore\n*/\n\n\nmodel SerializeAndRestoreAgents\n\n\n\nglobal {\n\t\n\tlist<string> serialized_people <- [];\n\t\n\tint number_of_people <- 100;\n\t\n\tinit {\n\t\tcreate people number: number_of_people;\n\t\task people {do create_family;}\n\t}\n\t\n\t/**\n\t * This action saves all the people on disk, each in its own file, using the uncompressed json format\n\t */\n\taction save_people_on_disk {\n\t\task people {\n\t\t\tsave self to: '../people/save'+int(self)+'.agent' format: 'json';\n\t\t}\n\t}\n\t\n\t/**\n\t * This action saves all the people in memory, each in its own string, using the binary format\n\t */\n\taction save_people_in_memory {\n\t\tserialized_people <- [];\n\t\task people {\n\t\t\tserialized_people << serialize(self);\n\t\t}\n\t\twrite serialized_people;\n\t}\n\t\n\t/**\n\t * This action asks people to \"restore\" themselves using a random file, effectively replacing their attributes by the one of the agent saved\n\t */\n\taction exchange_people_from_disk {\n\t\tif folder_exists(\"../people/\") and !empty(folder(\"../people\")) {\n\t\t\task people {\n\t\t\t\trestore self from: string(folder(\"../people\"))+'/save'+rnd(number_of_people - 1)+'.agent';\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * This action asks people to \"restore\" themselves using a random string, effectively replacing their attributes by the one of the agent saved\n\t */\n\taction exchange_people_from_memory {\n\t\task people {\n\t\t\trestore self from: any(serialized_people);\n\t\t}\n\t\tserialized_people <- [];\n\t}\n\t\n\t/**\n\t * This action creates new people using the previously saved strings\n\t */\n\taction create_clones_from_memory {\n\t\tloop saved over: serialized_people {\n\t\t\tcreate people from: saved;\n\t\t}\n\t}\n\t\n\taction create_clones_from_disk {\n\t\tloop saved over: folder(\"../people\") {\n\t\t\tcreate people from: file(string(folder(\"../people\"))+\"/\"+saved);\n\t\t}\n\t}\n\n\t\n}\n\nspecies people {\n\tlist<people> family;\n\t\n\taction create_family {\n\t\tfamily <- rnd(5) among people;\n\t}\n\t\n}\n\n\nexperiment \"Save, Restore, Create and Clone\" {\n\tcategory \"Saving\" color: #green;\n\ttext \"These actions save all the people on disk or in memory, each in its own file/string, using the uncompressed json format\" color: #green category: \"Saving\";\n\tuser_command \"Save on disk\" color: #green category: \"Saving\" { ask simulation { do save_people_on_disk;}}\n\tuser_command \"Save in memory\" color: #green category: \"Saving\" { ask simulation { do save_people_in_memory;}}\n\tcategory \"Restoring existing agents\" color: #orange;\n\ttext \"These actions ask people to 'restore' themselves using a random file/string, effectively replacing their attributes by the ones of the agent saved\" color: #orange category: \"Restoring existing agents\";\n\tuser_command \"Exchange from disk\" color: #orange category: \"Restoring existing agents\" { ask simulation { do exchange_people_from_disk;}}\n\tuser_command \"Exchange in memory\" color: #orange category: \"Restoring existing agents\" { ask simulation { do exchange_people_from_memory;}}\n\tcategory \"Creating new agents\" color: #red;\n\ttext \"These actions create new people from the files/strings of the previously saved agents\" color: #red category: \"Creating new agents\";\n\tuser_command \"Create clones from disk\" color: #red category: \"Creating new agents\" { ask simulation { do create_clones_from_disk;}}\t\n\tuser_command \"Create clones from memory\" color: #red category: \"Creating new agents\" { ask simulation { do create_clones_from_memory;}}\n\n\t\n\toutput {\n\t\tbrowse people;\n\t}\n}"}
{"prompt": "Design a GAML model that demonstrates serialization and deserialization of simulations, including saving and loading from file, using three experiments: Save Simulation, Reload Simulation, and Restore Simulation.", "gaml_code": "/***\n* Name: CreateSimuGraph2\n* Author: Benoit Gaudou\n* Description: Loads a simulation from a file\n* Tags: serialization, load_file\n***/\n\nmodel CreateSimuGraph2\n\nimport \"Base Model.gaml\"\n\n\nexperiment \"1. Save Simulation\" type: gui parent: Base {\n\t\n\t\n\tstring file_path <- \"../includes/saved_simulation.simulation\";\n\t\n\ttext \"Run the simulation until cycle 5, when it will be saved in a file and quit\" font: font(\"Helvetica\", 14, #bold);\n\tparameter \"File path\" var: file_path ;\n\t\n\treflex store when: cycle = 5 {\t\t\n\t\tsave simulation to: file_path ;\n\t\tdo die;\t\n\t}\t\n\n}\n\nexperiment \"2. Reload Simulation\" type: gui parent: Base{\n\t\n\tsimulation_file input <- file(\"../includes/saved_simulation.simulation\");\n\t\n\ttext \"This experiment has created its initial simulation from the serialized version of the previous simulation saved in the file\" font: font(\"Helvetica\", 14, #bold);\n\tparameter \"File to read\" var: input <- file(\"../includes/saved_simulation.simulation\");\n\t\n\t// We create the initial simulation from the file\n\taction _init_ {\n\t\tcreate simulation from: input;\t\n\t}\n\n}\n\nexperiment \"3. Restore Simulation\" type: gui parent: Base{\n\t\n\tsimulation_file input <- file(\"../includes/saved_simulation.simulation\");\n\t\n\ttext \"This experiment has created its initial simulation normally, and uses `restore` at step 10 to initialise it from the serialized version of the previous simulation. This creates an endless loop !\" font: font(\"Helvetica\", 14, #bold);\n\tparameter \"File to read\" var: input <- file(\"../includes/saved_simulation.simulation\");\n\t\n\t// We \"restore\" the simulation from the file. As it happens each time the simulation reaches 10 cycles, it loops forever between 5 and 10 cycles. \n\treflex when: simulation.cycle=10 {\n\t\trestore simulation from: input;\t\n\t}\n\n}"}
{"prompt": "Create a GAML model that demonstrates the functionality of recording and stepping forward/backward experiments on a Follow Weighted Network model.", "gaml_code": "/**\n* Name:  Demonstration of back and forth experiments on the Follow Weighted Network model\n* Author:  Patrick Taillandier (modified by Benoit Gaudou & Alexis Drogoul)\n* Description: Model illustrating the experiments typed `record` and the possibility to step them forward and backward. \n* Tags: record, graph, save\n*/\n\nmodel BackwardExperiments\n\nimport \"Base Model.gaml\"\n\n/**\n * This is the fastest and smallest format for recording simulations. Compression can be enabled to lower the memory usage.\n */\nexperiment \"Binary back and forth\" record: true parent: Base;"}
{"prompt": "Show how GAML values can be transformed into JSON objects and vice versa, including various data structures such as lists, maps, and agents.", "gaml_code": "/**\n* Name: Json\n* Shows how to transform GAML values into JSON objects\n* Author: A. Drogoul\n* Tags: Serialization, JSON\n*/\n\n\nmodel Json\n\nglobal {\n\tinit {\n\t\twrite \"-------------\";\t\t\t\n\t\twrite \"Simple values\";\n\t\twrite \"------------- TO JSON\";\n\t\twrite sample(to_json(1));\n\t\twrite sample(to_json(1.24));\n\t\twrite sample(to_json(\"a string\"));\n\t\twrite sample(to_json(date(0)));\n\t\twrite sample(to_json(#blue));\n\t\twrite sample(to_json(font(\"Helvetica\")));\n\t\twrite sample(to_json({20,10}));\n\t\twrite \"------------- From JSON\";\n\t\twrite (from_json(to_json(1,true)));\n\t\twrite (from_json(to_json(1.24,true)));\n\t\twrite (from_json(to_json(\"a string\",true)));\n\t\twrite (from_json(to_json(date(0),true)));\n\t\twrite (from_json(to_json(#blue,true)));\n\t\twrite (from_json(to_json(font(\"Helvetica\"),true)));\n\t\twrite (from_json(to_json({20,10},true)));\n\t\twrite \"-------------\";\t\t\t\n\t\twrite \"Lists\";\n\t\twrite \"------------- TO JSON\";\n\t\twrite(to_json([1,2,3,4,5],true));\n\t\twrite(to_json([\"a\",2,\"aa\",4,5.2],true));\n\t\twrite \"------------- FROM JSON\";\n\t\twrite(from_json(to_json([1,2,3,4,5],true)));\n\t\twrite(from_json(to_json([\"a\",2,\"aa\",4,5.2],true)));\n\t\t\n\t\twrite \"-------------\";\t\t\t\t\t\n\t\twrite \"Maps\";\n\t\twrite \"------------- TO JSON\";\n\t\twrite(to_json([\"a\"::2,\"b\"::4],true));\n\t\twrite(to_json([123::43,234::#green],true));\n\t\twrite \"------------- FROM JSON\";\n\t\twrite(from_json(to_json([\"a\"::2,\"b\"::4],true)));\n\t\twrite(from_json(to_json([123::43,234::#green],true)));\n\t\t\n\t\twrite \"-------------\";\t\t\t\n\t\twrite \"Other data structures\";\n\t\twrite \"------------- TO JSON\";\n\t\twrite(to_json(23::34,true));\n\t\twrite(to_json({2,2} matrix_with 10,true));\n\t\twrite \"------------- FROM JSON\";\n\t\twrite(from_json(to_json(23::34,true)));\n\t\twrite(from_json(to_json({2,2} matrix_with 10,true)));\n\t\twrite \"-------------\";\t\n\t\twrite \"Agents\";\n\t\twrite \"-------------\";\t\n\t\t// We create 2 sp's\t...\n\t\tcreate sp number: 2 ;\n\t\t// ... make them friends ...\n\t\tsp[0].friend <- sp[1];\n\t\tsp[1].friend <- sp[0];\n\t\t// ... serialise them ...\n\t\tstring s <- (to_json(sp[0]));\n\t\t// ... then kill them ...\n\t\task sp {\n\t\t\tdo die;\n\t\t}\n\t\t// ... and finally recreate them while asking to recreate an unknown value. \n\t\tunknown t <- from_json(s);\n\t\t// We verify that t contains the former agent\n\t\twrite t = sp(0);\n\t\t// ... and that all sp's have been recreated (as they were friends)\n\t\twrite sp.population;\n\t\twrite(to_json(sp.population,true));\n//\t\tsave sp.population to: \"../pop.json\" rewrite: true;\n\t}\n}\n\nspecies sp \n{\n\tsp friend;\n}\n\nexperiment \"Run me\";"}
{"prompt": "Create a GAML model to simulate predator-prey dynamics on a 10x10 grid, where prey agents move randomly and their locations are recorded and displayed.", "gaml_code": "/**\n* Name: Dynamic of the vegetation (grid)\n* Author:\n* Description: Second part of the tutorial : Predator Prey\n* Tags: grid\n*/\n\nmodel prey_predator\n\nglobal {\n\tinit {\n\t\tcreate prey number: 1;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 5.0 ;\n\trgb color <- #blue;\n\t\t\n\tvegetation_cell my_cell <- one_of (vegetation_cell) ; \n\t\t\n\tinit { \n\t\tlocation <- my_cell.location;\n\t}\n\t\t\n\treflex basic_move { \n\t\tmy_cell <- one_of (my_cell.neighbors) ;\n\t\tlocation <- my_cell.location ;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 10 height: 10 neighbors: 4 {\n\tfloat max_food <- 1.0 ;\n\trgb color <- rnd_color(255) ;\n}\n\nexperiment \"Record and keep same seed\" record: true keep_seed: true {\n\tfloat seed <- 0.0;\n\t\n\toutput {\n\t\tdisplay main_display antialias:false{\n\t\t\tgrid vegetation_cell border: #black ;\n\t\t\tspecies prey aspect: base;\n\t\t}\n\t\tdisplay location_x type: 2d antialias:false{\n\t\t\tchart \"grid_x of the prey\" {\n\t\t\t\tdata \"grid_x\" value: first(prey).my_cell.grid_x;\n\t\t\t}\n\t\t}\t\n\t\t\n\t}\n}\n\nexperiment \"Record without keeping seed\" record: true keep_seed: false {\n\toutput {\n\t\tdisplay main_display antialias:false{\n\t\t\tgrid vegetation_cell border: #black ;\n\t\t\tspecies prey aspect: base;\n\t\t}\n\t\tdisplay location_x type: 2d antialias:false{\n\t\t\tchart \"grid_x of the prey\" {\n\t\t\t\tdata \"grid_x\" value: first(prey).my_cell.grid_x;\n\t\t\t}\n\t\t}\t\n\t\t\n\t}\n}"}
{"prompt": "Create a simple traffic simulation model where agents can navigate through a grid of roads with varying weights and speeds. The model should include two types of agents: informed agents that know the road weights and uninformed agents that do not. The simulation should display the road network and agent movements.", "gaml_code": "/**\n* Name: BaseModel\n* Based on the internal empty template. \n* Author: A. Drogoul\n* Tags: \n*/\n\n\nmodel BaseModel\n\nglobal {\n\tmap<road, float> roads_weight;\n\tgraph road_network;\n\tfloat slow_coeff <- 3.0;\n\t\n\tinit {\n\t\t//This road will be slow\n\t\tcreate road {\n\t\t\tshape <- line ([{10,50},{90,50}]);\n\t\t\tslow <- true;\n\t\t}\n\t\t//The others will be faster\n\t\tcreate road {\n\t\t\tshape <- line ([{10,50},{10,10}]);\n\t\t\tslow <- false;\n\t\t}\n\t\tcreate road {\n\t\t\tshape <- line ([{10,10},{90,10}]);\n\t\t\tslow <- false;\n\t\t}\n\t\tcreate road {\n\t\t\tshape <- line ([{90,10},{90,50}]);\n\t\t\tslow <- false;\n\t\t}\n\t\t\n\t\t//Weights map of the graph for those who will know the shortest road by taking into account the weight of the edges\n\t\troads_weight <- road as_map (each:: each.shape.perimeter * (each.slow ? slow_coeff : 1.0));\n\t\troad_network <- as_edge_graph(road);\n\t\t\n\t\t//people with information about the traffic\n\t\tcreate people {\n\t\t\tcolor <- #blue;\n\t\t\tsize <- 2.0;\n\t\t\troads_knowledge <- roads_weight;\n\t\t}\n\t\t\n\t\t//people without information about the traffic\n\t\tcreate people {\n\t\t\tcolor <- #yellow;\n\t\t\tsize <- 1.0;\n\t\t\troads_knowledge <- road as_map (each:: each.shape.perimeter);\n\t\t}\n\t\t\n\t\tpeople(0).other <- people(1);\n\t\tpeople(1).other <- people(0);\n\t\t\n\t}\n}\n\nspecies road {\n\tbool slow;\n\taspect geom {\n\t\tdraw shape color: slow ? #red : #green;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tmap<road, float> roads_knowledge;\n\tpoint the_target;\n\trgb color;\n\tfloat size;\n\tpath path_to_follow;\n\tpeople other;\n\t\n\tinit {\n\t\tthe_target <- {90,50};\n\t\tlocation <- {10,50};\n\t}\n\t\t\n\treflex movement when: location != the_target{\n\t\tif (path_to_follow = nil) {\n\t\t\t\n\t\t\t//Find the shortest path using the agent's own weights to compute the shortest path\n\t\t\tpath_to_follow <- path_between(road_network with_weights roads_knowledge, location,the_target);\n\t\t}\n\t\t//the agent follows the path it computed but with the real weights of the graph\n\t\tdo follow path:path_to_follow speed: 5.0 move_weights: roads_weight;\n\t}\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t\tdraw line(self,other) color: #black;\n\t}\n}\n\nexperiment Base virtual: true {\n\tfloat minimum_cycle_duration <- 0.1;\n\toutput {\n\t\tlayout #split;\n\t\tdisplay map {\n\t\t\tspecies road aspect: geom;\n\t\t\tspecies people aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Show how to serialize and deserialize arbitrary objects in binary format using GAML.", "gaml_code": "/**\n* Name: SerializeandDeserializeObjects\n* Shows how to serialize and deserialize arbitrary objects in binary format\n* Author: A. Drogoul\n* Tags: serialization\n*/\n\n\nmodel SerializeandDeserializeObjects\n\nglobal {\n\tinit {\n\t\t\n\t\tlist objects <- [[1,2,3,4], \"fff\",rgb(100,100,100)];\n\t\twrite \"Base object list: \" + objects;\n\t\t\n\t\twrite \"\\nIndividually serialized and deserialized:\";\n\t\tloop o over: objects {\n\t\t\tstring s <- serialize(o);\n\t\t\twrite \"\\nserializing \" + o + \" => \" + s;\n\t\t\twrite \"deserialized: \" + deserialize(s);\n\t\t}\n\t\n\t\tassert objects = deserialize(serialize(objects));\n\t\twrite \"\\nserializing and deserializing a list containing all the objects returns a list strictly identical to the initial one\";\n\t}  \n}\n\nexperiment \"Run\";"}
{"prompt": "Create a 3D visualization of anisotropic diffusion on a grid using NetLogo, including multiple displays and visualizations of the diffusion process.", "gaml_code": "/**\n* Name: Anisotropic diffusion (Simple)\n* Author: Benoit Gaudou\n* Description: This model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread \n*     through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion.\n* Tags: diffusion, matrix, math, elevation\n*/\nmodel anisotropic_diffusion\n\nglobal {\n\tgeometry shape <- rectangle(100,100);\n\tint size <- 100; // better to have a pow of 2 for the size of the grid\n\tfield cells <- field(size, size, 0.0);\n\tint rnd_component -> rnd(8) - 4;\n\t\n\t\n\tinit {\n\t\tloop i from: 0 to: size - 1 {\n\t\t\tloop j from: 0 to: size - 1 {\n\t\t\t\tcells[i,j] <- j*size+i;\n\t\t\t}\n\t\t} \n\t}\n\n\t// Declare the anisotropic matrix (diffuse to the left-upper direction)\n\tmatrix<float> mat_diff <- matrix([\n\t\t[4 / 9, 2.5 / 9, 0 / 9], \n\t\t[2.5 / 9, 0 / 9, 0 / 9], \n\t\t[0 / 9, 0 / 9, 0.1 / 9]\n\t]);\n\n\treflex diff {\n\t\tdiffuse \"phero\" on: cells matrix: mat_diff;\n\t}\n\n\treflex new_Value {\n\t\tloop i from: -10 to: 10 step: 5 {\n\t\t\tcells[size / 2 - i + rnd_component, size / 2 + i + rnd_component] <- 15;\n\t\t}\n\t\t\n\t}\n}\n\nexperiment diffusion type: gui autorun: true {\n\toutput synchronized: true {\n\t\tlayout #split;\n\t\tdisplay \"Brewer\" type: 3d  background: #black antialias:true  {\n\t\t\tcamera 'default' location: {-36.7763,-33.4928,81.1831} target: {30.905,35.6694,0.0};\n\t\t\tlight #default intensity: 60;\n\t\t\tmesh cells scale: 5 grayscale: true color:(brewer_colors(\"Set3\")) triangulation: true;\n\t\t}\n\n\t\tdisplay \"HSB Smoothed 2\" type: 3d background: #black {\n\t\t\tcamera 'default' location: {50.7757,142.7832,27.2522} target: {50.3509,7.5626,0.0};\n\t\t\tmesh cells scale: 5 color: cells collect hsb(float(each)/5,1,1) triangulation: true smooth: true;\n\t\t}\n\t\tdisplay \"One Color Smoothed 4 with Lines\" type: 3d background: #black {\n\t\t\tcamera 'default' location: {50.7757,142.7832,27.2522} target: {50.3509,7.5626,0.0};\n\t\t\tmesh cells scale: 5 color:  palette([#lightblue, #blue, #blue, #darkblue]) triangulation: true border: #white smooth: 4;\n\t\t}\n\t\t\n\n\t\tdisplay \"Scale\" type: 3d background: #black {\n\t\t\tcamera 'default' location: {48.6197,99.6662,110.4741} target: {50.6666,17.0904,0.0};\n\t\t\tmesh cells scale:5 color: scale([#red::1, #yellow::2, #green::3, #blue::6])  ;\n\t\t}\n\t\t\n\t\tdisplay \"Simple gradient\" type: 3d background: #white antialias:true { \n\t\t\tcamera 'default' location: {50.7757,142.7832,27.2522} target: {50.3509,7.5626,0.0};\n\t\t\tmesh cells scale:0 color: palette([#lightblue, #blue, #blue, #darkblue]) ;\n\t\t\t\n\t\t}\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates and visualizes the diffusion of a signal over a grid using a 4-parameter variation, proportion, radius, and min-value. The model should display the diffusion process in real-time and allow users to manipulate these parameters.", "gaml_code": "/**\n* Name: Generate diffusion matrix with parameters\n* Author: Julien Mazars\n* Description: This model shows how to create a diffusion matrix by using the 4 parameters variation, proportion, radius and min-value. \n*     Manipulate the parameters to see in real time the result. The number displayed in each cells are the ratio of the initial signal \n*     diffused at the end of a step.\n* Tags: diffusion, math, matrix\n*/\n\nmodel kernelmatrixgeneration\n\nglobal {\n\t// parameters\n\tfloat variation <- 0.0;\n\tfloat proportion <- 1.0;\n\tint radius <- 1;\n\tfloat min_value <- 0.0;\n\tint cycle_length <- 1;\n\t\n\t// global variables\n\tint cell_max_size <- 51;\n\tint x_min <- cell_max_size;\n\tint x_max <- 0;\n\tint y_min <- cell_max_size;\n\tint y_max <- 0;\n\t\n\tfloat world_size <- 100.0;\n\tgeometry shape <- cube(world_size);\n\t\n\tbuffer_cells selected_cells;\n\t\n\t// init the emiter cell as the one in the center of the world.\n\tinit {\n\t\tselected_cells <- location as buffer_cells;\n\t}\n\t\n\treflex update {\n\t\tx_min <- cell_max_size;\n\t\tx_max <- 0;\n\t\ty_min <- cell_max_size;\n\t\ty_max <- 0;\n\t\t// copy the values of the buffer_cells (of the previous step) to the grid which will be displayed.\n\t\task cells {\n\t\t\tvalue <- (location as buffer_cells).value;\n\t\t}\n\t\task buffer_cells {\n\t\t\t// find the boundaries of the diffusion\n\t\t\tif (value != 0.0) {\n\t\t\t\tif (grid_x > x_max) {\n\t\t\t\t\tx_max <- grid_x;\n\t\t\t\t}\n\t\t\t\tif (grid_x < x_min) {\n\t\t\t\t\tx_min <- grid_x;\n\t\t\t\t}\n\t\t\t\tif (grid_y > y_max) {\n\t\t\t\t\ty_max <- grid_y;\n\t\t\t\t}\n\t\t\t\tif (grid_y < y_min) {\n\t\t\t\t\ty_min <- grid_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// re-initialize the value of the buffer grid to 0, and the value of the central cell to 1.\n\t\task buffer_cells {\n\t\t\tvalue <- 0.0;\n\t\t\tif (self = selected_cells) {\n\t\t\t\tvalue <- 1.0;\n\t\t\t}\n\t\t}\n\t\t// diffuse the value over the buffer grid, according to the parameters choosen.\n\t\tdiffuse var:value on:buffer_cells variation:variation proportion:proportion radius:radius cycle_length:cycle_length min:min_value;\n\t}\n}\n\n// the buffer grid will be used to compute the diffusion at each step.\ngrid buffer_cells height:cell_max_size width:cell_max_size {\n\t// the diffused variable\n\tfloat value <- 0.0;\n}\n\n// this grid is the copy of the buffer grid at the end of each step. Indeed, we have to display the grid once the diffusion has been done.\ngrid cells height:cell_max_size width:cell_max_size {\n\t// the diffused variable\n\tfloat value <- 0.0;\n\t\n\taspect base {\n\t\t// we only display the cells wich contains a non null value\n\t\tif (grid_x <= x_max and grid_x >= x_min and grid_y <= y_max and grid_y >= y_min)\n\t\t{\n\t\t\t// compute dynamically the size of the current cell.\n\t\t\tfloat size_cell <- world_size/(x_max-x_min+1);\n\t\t\t// compute dynamically the position of the current cell.\n\t\t\tpoint pos <- {(grid_x-x_min+1)*size_cell-0.5*size_cell,(grid_y-y_min+1)*size_cell-0.5*size_cell};\n\t\t\t// display each cell as a square. The color is linked to the value of the diffused variable.\n\t\t\tdraw square(size_cell) color:hsb(value,1.0,1.0) border:#black at:pos;\n\t\t\t// display the ratio in each square.\n\t\t\tdraw string(value) at: pos + {-size_cell/3,0,2} color: #black font: font(\"Helvetica\", size_cell * #zoom * 2/3, #bold) perspective:true;\n\t\t}\n\t}\n}\n\nexperiment my_experiment type:gui {\n\tparameter \"proportion\" var:proportion;\n\tparameter \"variation\" var:variation;\n\tparameter \"min_value\" var:min_value;\n\tparameter \"radius\" var:radius;\n\tparameter \"cycle_length\" var:cycle_length;\n\t\n\tinit {\n\t\t// no need to have a faster display. Let's cool down your computer a bit ;)\n\t\tminimum_cycle_duration <- 200#ms;\n\t}\n\toutput {\n\t\tdisplay my_display type: 3d {\n\t\t\tspecies cells aspect:base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates uniform diffusion on a 64x64 grid with a mask, where cells outside the mask do not diffuse and cells inside the mask diffuse uniformly. The model should display two 3D visualizations of the grid: one showing diffusion avoiding the masked cells and another showing diffusion without avoidance.", "gaml_code": "/**\n* Name: Uniform diffusion with mask (Avoid mask)\n* Author: Julien Mazars\n* Description: This model is used to show how a uniform diffusion can be used with a mask. The cell at the center of the grid emit a pheromon at each step, which is spread \n*     through the grid thanks to the diffusion mechanism. A mask is used to restrict the diffusion to a \"corridor\" (the white part of the bmp image). The first display shows a \n*     diffusion avoiding the masked cells (the value is redistributed to the neighboring cells, to have a constant number of pheromon), the second display shows a diffusion \n*     without avoiding the masked cells (the value is diffused in the masked cell, and never rediffused again).\n* Tags: diffusion, matrix, math, obstacle, elevation\n*/\n\nmodel diffusion_with_mask\n\nglobal {\n\tint grid_size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(grid_size) * 10);\n  \tcells_avoid_mask selected_cells1;\n  \tcells_diffuse_on_mask selected_cells2;\n  \t// Load the image mask as a matrix. The white part of the image is the part where diffusion will work, and the black part is where diffusion will be blocked.\n  \tmatrix<int> mymask <- image_file(\"../includes/complex_mask.bmp\") as_matrix({grid_size,grid_size});\n  \t// Declare a uniform diffusion matrix\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells1 <- location as cells_avoid_mask;\n\t\tselected_cells2 <- location as cells_diffuse_on_mask;\n\t}\n\treflex new_Value {\n\t\task selected_cells1 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task selected_cells2 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\". The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells_avoid_mask matrix: mat_diff mask: mymask avoid_mask: true;\n\t\tdiffuse var: phero on: cells_diffuse_on_mask matrix: mat_diff mask: mymask;\t\n\t}\n}\n\n\ngrid cells_avoid_mask height: grid_size width: grid_size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\ngrid cells_diffuse_on_mask height: grid_size width: grid_size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tlayout #split;\n\t\tdisplay diffusion_avoiding_mask type: 3d antialias:false{\n\t\t\tcamera 'default' location: {-237.5703,1046.6397,370.0514} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_avoid_mask elevation: true triangulation: true;\n\t\t}\n\t\tdisplay diffusion_on_mask type: 3d antialias:false{\n\t\t\tcamera 'default' location: {-237.5703,1046.6397,370.0514} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_diffuse_on_mask elevation: true triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of anisotropic diffusion on a toroidal grid using NetLogo's GAML language, with a focus on visualizing the pheromone spread and cell values.", "gaml_code": "/**\n* Name: Anisotropic diffusion (Toroidal)\n* Author: Benoit Gaudou\n* Description: This model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread \n*     through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion, in a toroidal world.\n* Tags: diffusion, matrix, math, elevation\n*/\n\nmodel anisotropic_diffusion_torus\n\nglobal torus: true {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells selected_cells;\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[4/9,2/9,0/9],\n\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\n\t\t\t\t\t\t\t\t\t[0/9,0.0,0.0]]);\n\tinit {\n\t\tselected_cells <- location as cells;\n\t}\n\treflex new_Value {\n\t\task selected_cells{\n\t\t\tphero <- 1.0;\n\t\t}  \n\t}\n\n\treflex diff {\n\t\tdiffuse var: phero on: cells matrix: mat_diff method:dot_product;\t\n\t}\n}\n\n\ngrid cells height: size width: size  {\n\tfloat phero  <- 0.0;\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: 3d antialias:false{\n\t\t\tcamera 'default' location: {277.7744,923.8543,660.6005} target: {320.0,320.0,0.0};\n\t\t\tgrid cells elevation: true triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates the diffusion of three colors in a grid, blending them together using a uniform matrix and accelerating the process by incorporating a cycle length feature.", "gaml_code": "/**\n* Name: Blend color in a cuve\n* Author: Julien Mazars\n* Description: This model is used to show how we can diffuse several variables in the same grid. At the cycle 0, 3 different pheromons are emited in 3 of the 4 corners of the cuve \n*     (each one associated to a color). Thanks to the diffusion mechanism, all the 3 colors will blend each other. The process is accelerated by using the facet \"cycle_length\". \n*     The \"avoid_mask\" facet is used in order to have a constant sum of pheromon. \n* Tags: diffusion, matrix, math, color, elevation\n*/\n\nmodel cycle_length\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n\tint cycle_length <- 5;\n  \tgeometry shape <- envelope(square(size));\n  \tlist<cells> top_left_cells;\n  \tlist<cells> top_right_cells;\n  \tlist<cells> bot_left_cells;\n  \t// Declare the uniform matrix\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\n\n\t// Initialize the emiter cells\n\tinit {\n\t\ttop_left_cells <- list<cells>(cells where (each.grid_x < location.x\n\t\t\tand each.grid_x > cycle_length\n\t\t\tand each.grid_y < location.y\n\t\t\tand each.grid_y > cycle_length\n\t\t));\n\t\ttop_right_cells <- list<cells>(cells where (each.grid_x < size-cycle_length\n\t\t\tand each.grid_x > location.x\n\t\t\tand each.grid_y < location.y\n\t\t\tand each.grid_y > cycle_length\n\t\t));\n\t\tbot_left_cells <- list<cells>(cells where (each.grid_x < location.x\n\t\t\tand each.grid_x > cycle_length\n\t\t\tand each.grid_y < size-cycle_length\n\t\t\tand each.grid_y > location.y\n\t\t));\n\t}\n\treflex init_value when:cycle=0 {\n\t\task(top_left_cells){\n\t\t\tphero1 <- 1.0;\n\t\t}\n\t\task(top_right_cells){\n\t\t\tphero2 <- 1.0;\n\t\t}\n\t\task(bot_left_cells){\n\t\t\tphero3 <- 1.0;\n\t\t}\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\" for each one of the pheromons. \n\t\t// In order to not loosing phero value, we apply a hand made mask (with the operator \"where\") and we turn the \"avoid_mask\" facet to true.\n\t\tlist cells_where_diffuse <- cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);\n\t\tdiffuse var: phero1 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\n\t\tdiffuse var: phero2 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\n\t\tdiffuse var: phero3 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\n\t}\n}\n\n\ngrid cells height: size width: size {\n\t// \"phero1\", \"phero2\", \"phero3\" are the variables storing the value of the diffusion\n\tfloat phero1  <- 0.0;\n\tfloat phero2  <- 0.0;\n\tfloat phero3  <- 0.0;\n\t// The color of the cell is construct using the 3 pheromons.\n\trgb color <- rgb(phero1*256,phero2*256,phero3*256) update: rgb(phero1*256,phero2*256,phero3*256);\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: 3d antialias:false{\n\t\t\tcamera 'default' location: {54.9788,112.1365,32.8371} target: {32.0,32.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: (phero1+phero2+phero3)*10 triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates uniform diffusion on a grid, with a central emitter cell and a 3D visualization of the diffusion process.", "gaml_code": "/**\n* Name: Uniform diffusion\n* Author: Benoit Gaudou\n* Description: This model is used to show how a diffusion works with a uniform matrix of diffusion in a grid. The cell at the center of the grid emit a pheromon at each step, which is spread \n*     through the grid thanks to the diffusion mechanism. Without passing a diffusion matrix, the default diffusion matrix is a uniform matrix 3x3, with value 1/nb_neighbors.\n* Tags: diffusion, matrix, math, elevation\n*/\n\nmodel uniform_diffusion\n\nglobal {\n\tint size <- 128; // better to have a pow of 2 for the size of the grid\n  \tfield cells <- field(size, size, 0.0);\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\treflex new_Value {\n\t\t\n\t\tcells[any_point_in(circle(25))] <- (100);\n\t}\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\", with a uniform matrix of diffusion. \n\t\tdiffuse \"trial\" on: cells ;\n\t}\n}\n\nexperiment diffusion type: gui autorun:true {\n\toutput  synchronized: true {\n\t\tdisplay uniform_diffusion_in_8_neighbors_grid type: 3d camera:#from_up_front axes: false {\n\t\t\tmesh cells color: #green triangulation: true scale: 1 smooth: true ;\n\t\t}\n\t}\n}"}
{"prompt": "Anisotropic diffusion simulation with two computation methods (dot product and convolution) on a 3D grid, using NetLogo or GAML language.", "gaml_code": "/**\n* Name: Anisotropic diffusion with several computation method\n* Author: Benoit Gaudou\n* Description: This model is used to show two different computation methods to use diffusion : with the dot product method and with the convolution method. \n*     The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. \n* Tags: diffusion, matrix, math, elevation\n*/\n\nmodel diffusion_computation_method\n\nglobal{\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells_dot selected_cells_dot;\n  \tcells_convol selected_cells_convol;\n  \t// Declare the anisotropic matrix (diffuse to the left-upper direction)\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[2/9,2/9,1/9],\n\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\n\t\t\t\t\t\t\t\t\t[1/9,0.0,0.0]]);\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells_dot <- location as cells_dot;\n  \t\tselected_cells_convol <- location as cells_convol;\n\t}\n\treflex new_Value {\n\t\task(selected_cells_dot){\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task(selected_cells_convol){\n\t\t\tphero <- 1.0;\n\t\t}\t\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells_dot\" (with a dot product computation) and on \"cells_convol\" (with a convol computation). \n\t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells_dot matrix: mat_diff method: \"dot_product\";\t\n\t\tdiffuse var: phero on: cells_convol matrix: mat_diff method: \"convolution\";\t\t\t\n\t}\n}\n\n\ngrid cells_dot height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\ngrid cells_convol height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay dot type: 3d antialias:false{\n\t\t\tcamera 'default' location: {-241.1855,1167.8588,390.2962} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_dot elevation: true triangulation: true;\n\t\t}\n\t\tdisplay convol type: 3d antialias:false{\n\t\t\tcamera 'default' location: {-241.1855,1167.8588,390.2962} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_convol elevation: true triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of anisotropic diffusion using NetLogo's GAML language, where a central cell emits pheromones that diffuse through a grid according to a custom matrix.", "gaml_code": "/**\n* Name: Anisotropic diffusion (Simple)\n* Author: Benoit Gaudou\n* Description: This model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread \n*     through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion.\n* Tags: diffusion, matrix, math, elevation\n*/\n\nmodel anisotropic_diffusion\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells selected_cells;\n  \t\n  \t// Declare the anisotropic matrix (diffuse to the left-upper direction)\n\tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[5/9,1.5/9,0/9],\n\t\t\t\t\t\t\t\t\t[1.5/9,1/9,0.0],\n\t\t\t\t\t\t\t\t\t[0/9,0.0,0.2/9]]);\n\t\n\treflex diff { \n\t\tdiffuse var: phero on: cells matrix:mat_diff;\n\t}\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells <- location as cells;\n\t}\n\treflex new_Value {\n\t\task selected_cells {\n\t\t\tphero <- rnd(2.0);\n\t\t}\n\t}\n}\n\n\ngrid cells height: size width: size neighbors: 8 {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: 3d antialias:false{\n\t\t\tcamera 'default' location: {311.2555,820.9735,742.8089} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: true triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates uniform diffusion on a 3D grid with two different neighbor configurations (8 and 4 neighbors) and visualizes the diffusion process using elevation.", "gaml_code": "/**\n* Name: Uniform diffusion\n* Author: Benoit Gaudou\n* Description: This model is used to show how a diffusion works with a uniform matrix of diffusion in a grid. The cell at the center of the grid emit a pheromon at each step, which is spread \n*     through the grid thanks to the diffusion mechanism. Without passing a diffusion matrix, the default diffusion matrix is a uniform matrix 3x3, with value 1/nb_neighbors.\n* Tags: diffusion, matrix, math, elevation\n*/\n\nmodel uniform_diffusion\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells_eight_nb selected_cells_8;\n  \tcells_four_nb selected_cells_4;\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells_8 <- location as cells_eight_nb;\n\t\tselected_cells_4 <- location as cells_four_nb;\n\t}\n\treflex new_Value {\n\t\task selected_cells_4 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task selected_cells_8 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t}\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\", with a uniform matrix of diffusion. The value of the diffusion\n\t\t// will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells_eight_nb ;\n\t\tdiffuse var: phero on: cells_four_nb ;\n\t}\n}\n\n\ngrid cells_eight_nb height: size width: size neighbors: 8 {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(min([0.6,phero]),1.0,1.0) update: hsb(min([0.6,phero]),1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\ngrid cells_four_nb height: size width: size neighbors: 4 {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(min([0.6,phero]),1.0,1.0) update: hsb(min([0.6,phero]),1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput synchronized: true {\n\t\tlayout #split;\n\t\tdisplay uniform_diffusion_in_8_neighbors_grid type: 3d antialias:false {\n\t\t\tcamera 'default' location: {-185.5731,1098.5143,337.845} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_eight_nb elevation: true triangulation: true;\n\t\t}\n\t\tdisplay uniform_diffusion_in_4_neighbors_grid type: 3d antialias:false{\n\t\t\tcamera 'default' location: {-185.5731,1098.5143,337.845} target: {320.0,320.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_four_nb elevation: true triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates diffusion on a grid, using a matrix of diffusion and accelerating the process by computing several times the diffusion at each step. The model should include two types of cells: regular cells and quick cells, which diffuse at a faster rate.", "gaml_code": "/**\n* Name: Diffusion in a cuve (Cycle length)\n* Author: Julien Mazars\n* Description: This model is used to show how to use diffusion on a grid, and how to accelerate the process by computing several times the diffusion at each step. \n*     The cells at the center of the grid emit a pheromon at the cycle 0, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. \n*     The \"avoid_mask\" facet is used in order to have a constant sum of pheromon. \n* Tags: diffusion, matrix, math, elevation\n*/\n\nmodel cycle_length\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n\tint cycle_length <- 5;\n  \tgeometry shape <- envelope(square(size));\n  \tlist<cells> selected_cells;\n  \tlist<quick_cells> selected_quick_cells;\n  \t// Declare an uniform diffusion matrix\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\n\t\t\t\t\t\t\t\t\t\n\tint impulse_area_size <- 6;\n\n\t// Initialize the emiter cells as the cells at the center of the word\n\tinit {\n\t\tselected_cells <- list<cells>(cells where (each.grid_x < location.x+impulse_area_size\n\t\t\tand each.grid_x > location.x-impulse_area_size\n\t\t\tand each.grid_y < location.y+impulse_area_size\n\t\t\tand each.grid_y > location.y-impulse_area_size\n\t\t));\n\t\tselected_quick_cells <- list<quick_cells>(quick_cells where (each.grid_x < location.x+impulse_area_size\n\t\t\tand each.grid_x > location.x-impulse_area_size\n\t\t\tand each.grid_y < location.y+impulse_area_size\n\t\t\tand each.grid_y > location.y-impulse_area_size\n\t\t));\n\t}\n\treflex init_value when:cycle=0 {\n\t\task(selected_cells){\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task(selected_quick_cells){\n\t\t\tphero <- 1.0;\n\t\t}\t\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\" and on \"quick_cells\". The diffusion declared on \"quick_cells\" will make 5 computations at each step to accelerate the process. \n\t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\t// In order to not loosing phero value, we apply a hand made mask (with the operator \"where\") and we turn the \"avoid_mask\" facet to true.\n\t\tlist cells_where_diffuse <- cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);\n\t\tdiffuse var: phero on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product;\t\n\t\tlist quick_cells_where_diffuse <- quick_cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);\n\t\tdiffuse var: phero on: quick_cells_where_diffuse matrix: mat_diff avoid_mask: true cycle_length: 10 method:dot_product;\n\t}\n}\n\n\ngrid cells height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0);\n} \n\ngrid quick_cells height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0);\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tlayout #horizontal;\n\t\tdisplay a type: 3d antialias:false{\n\t\t\tcamera 'default' location: {54.9788,112.1365,32.8371} target: {32.0,32.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: phero*10 triangulation: true;\n\t\t}\n\t\tdisplay quick type: 3d antialias:false{\n\t\t\tcamera 'default' location: {54.9788,112.1365,32.8371} target: {32.0,32.0,0.0};\n\t\t\t// Display the grid with elevation\n\t\t\tgrid quick_cells elevation: phero*10 triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "**This is a NetLogo simulation model for studying population dynamics and interactions between species. The model includes features such as adding animal species, changing interaction types, and displaying population evolution charts and interaction graphs.**", "gaml_code": "/**\n *  Author: Tri Nguyen-Huu\n *  Description: A generalized Lotka-Volterra model. \n * The left column and upper row allow to add or remove animal species. \n * Each animal species has a population that evolves by default independantly from others, according to a logistic law (with a carrying capacity).\n * The buttons in the matrix can be pressed in order to add interactions, \"+\" denoting a positive action from the upper species towards the left species, \n * and a \"-\" denotes a negative interaction. A positive interaction of species \"A\" towards \"B\" means that a high density of species high increases the\n * density of species B (for example A is predated by B). A negative interaction of species \"A\" towards \"B\" means that a high density of species high \n * decreases the density of species B (for example B is predated by A).\n * \n * Common Lotka-Volterra interactions between two spices A and B ares:\n * mutalism: A -> B: +, B -> A: +\n * A predating B: A -> B: -, B -> A: +\n * competition: A -> B: -, B -> A: -\n */\n\nmodel GeneralizedLotkaVolterra\n\nglobal {\n\t// behaviour parameters\n\tbool saturation <- true;\n\tbool externalFoodForPredators <- false;\n\t\n\t// number of species\n\tint maxSpecies <- 8;\n\t\n\t// vizualisation parameters\n\tint fontSize <- 9;\n\tfloat edgeSpacing <- 10.0;\n\tbool graphType <- true;\n\tint xRange <- 200;\n\tbool showCumulatedGraph <- true;\n\t\n\t// names generator parameters\n\tstring language <- \"english\" among: [\"french\",\"english\"];\n\n\tmap<string,list<list<string>>> animal_names <- map(\n\t\t\t\t\t\t\t\t\t\t\"french\"::[[\"Go\u00e9\",\"land\"],[\"Ga\",\"zelle\"],[\"Tama\",\"noir\"],[\"La\",\"pin\"],[\"Cou\",\"cou\"],[\"Ca\",\"nard\"],[\"Cha\",\"mois\"],[\"Ecu\",\"reuil\"],[\"El\u00e9\",\"phant\"],\n\t\t\t\t\t\t\t\t\t\t[\"Droma\",\"daire\"],[\"P\u00e9\",\"lican\"],[\"Sou\",\"ris\"],[\"Pou\",\"let\"],[\"Perro\",\"quet\"],[\"Rossi\",\"gnol\"],[\"Gre\",\"nouille\"],[\"Phaco\",\"ch\u00e8re\"],[\"Maque\",\"reau\"],\n\t\t\t\t\t\t\t\t\t\t[\"Sar\",\"dine\"],[\"Mou\",\"ton\"],[\"Ser\",\"pent\"],[\"Tor\",\"tue\"],[\"Pu\",\"tois\"]],\n\t\t\t\t\t\t\t\t\t\t\"english\"::[[\"Chee\",\"tah\"],[\"Gi\",\"raffe\"],[\"Ele\",\"phant\"],[\"Ra\",\"bbit\"],[\"Squi\",\"rrel\"],\n\t\t\t\t\t\t\t\t\t\t[\"Chame\",\"leon\"],[\"Bumble\",\"bee\"],[\"Bu\",\"ffalo\"],[\"Ze\",\"bra\"],\n\t\t\t\t\t\t\t\t\t\t[\"Rattle\",\"snake\"],[\"Bea\",\"ver\"],[\"Sala\",\"mander\"],[\"Hippo\",\"potamus\"],[\"Pa\",\"rrot\"],\n\t\t\t\t\t\t\t\t\t\t[\"Rhino\",\"ceros\"],[\"Kanga\",\"roo\"],[\"Leo\",\"pard\"],[\"Alli\",\"gator\"],\n\t\t\t\t\t\t\t\t\t\t[\"Go\",\"rilla\"],[\"Croco\",\"dile\"],[\"Platy\",\"pus\"],[\"Octo\",\"pus\"],[\"Porcu\",\"pine\"]]\n\t\t\t\t\t\t\t\t\t\t);\n\n\t// color palette\n\tlist<rgb> color_list <- shuffle([\n\t\t\trgb(255,222,0),\n\t\t\trgb(255,108,44),\n\t\t\trgb(255,80,87),\n\t\t\trgb(295,85,180),\n\t\t\trgb(27,63,148),\n\t\t\trgb(0,167,143),\n\t\t\trgb(0,174,239),\n\t\t\trgb(30,181,58)\n\t]);\n\t\n\t// interaction types and corresponding colors\n\tlist<string> possible_type <-[\"neutral\",\"positive\",\"negative\"];\n\tmap<string,rgb> typeColor <- [\"neutral\"::rgb(200,200,200),\"negative\"::rgb(250,65,65),\"positive\"::rgb(150,217,100)];\n\t\n\timage_file arrow <- image_file(\"../../includes/arrow.png\");\n\t\n\t// model variables\n\tlist<animal> speciesList <- list_with(maxSpecies, nil);\n\tgraph the_graph <- [] ;\n\tmap<pair<animal,animal>,string> edge_type <- [];\n\t\n\tgeometry shape <- square(1000);\n\t\n\t// numerical scheme parameter\n\tfloat hKR4 <- 0.01;\n\t\n\tinit{\n\t\t// create the colors for the different animal species\n\t\tif (maxSpecies > 8){\n\t\t\tcolor_list <- list_with(maxSpecies, rgb(0,0,0));\n\t\t\tloop i from: 0 to: maxSpecies-1{\n\t\t\t\tcolor_list[i] <- rgb(int(240/maxSpecies*i),int(240/maxSpecies*i),255);\n\t\t\t}\n\t\t}\n\n\t\t// initialize the scheduler\n\t\tcreate solver_and_scheduler;\n\t}\n\t\n//\treflex test {\n//\t\task animal where (!dead(each) and length(each.interactionMap)>0){\n//\t\t\twrite self.name + ' '+self.interactionMap;\n//\t\t}\n//\t}\n\t\n\t// update the interaction graph\n\treflex layout_graph {\n\t\tthe_graph <- directed(layout_circle(the_graph,rectangle(world.shape.width * 0.7, world.shape.height*0.7),false));\n\t}\n\t\n\t// apply actions for the buttons that have been pressed since the last time step\n\taction buttonPressed {\n\t\t// identify which button has been pressed\n\t\t// **********************************************************************//\n\t\t// previously this part of the code was in the solve statement           //\n\t\t// button pressed where flagged has pressed, and the flag was removed    //\n\t\t// after updating.                                                       //\n\t\t// can changes by pushing button make the solver crash ?                 //\n\t\t// **********************************************************************//\n\t\tbutton selectedButton <- first(button overlapping (circle(1) at_location #user_location));\n\t\tif selectedButton != nil {\n\t\t\t// perform action depending on the button type \n\t\t\tif (selectedButton.buttonType = 'species'){\n\t\t\t\t// action for species buttons \n\t\t\t\t// if the buttion is in the row, switch to the button in the corresponding column\n\t\t\t\tif (selectedButton.grid_x > 0) {\n\t\t\t\t\task selectedButton.oppositeButton {do speciesButtonAction;}\n\t\t\t\t}else{\n\t\t\t\t\task selectedButton {do speciesButtonAction;}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// action for buttons in the main matrix\n\t\t\t\tif (selectedButton.active) and (selectedButton.grid_x != selectedButton.grid_y){\n\t\t\t\t\task selectedButton {do interactionButtonAction;}\n\t\t\t\t}\t\n\t\t\t}\t\t\t\t\n\t\t}\n\t}\n}\n\n// definition of species\n\nspecies animal{\n\tfloat t;\n\tfloat pop;\n\tfloat r;\n\tfloat k;\n\trgb color;\n\tmap<animal,string> interactionMap;\n\t\n\tbool isPredator;\n\t\n\t// list of interactions with this animal species, sorted by type\n\tlist<animal> positive_species <-[];\n\tlist<animal> negative_species <-[];\n\tmap<animal,float> interaction_coef <- [];\n\t\n\taction change_type(animal ani, string type){\n\t\tremove ani from: positive_species;\n\t\tremove ani from: negative_species;\n\t\tremove key: ani from: interaction_coef;\n\t\tif type = \"positive\" { positive_species <+ ani;}\n\t\tif type = \"negative\" { negative_species <+ ani;}\n\t\tif type != \"neutral\" {interaction_coef <+ ani::(rnd(100)/100);}\n\t}\n\t\n\t// find a predation relationship exists\n\taction updateInteractionsTypes{\n\t\tinteractionMap <- [];\n\t\tloop ani over: positive_species{\n\t\t\tif (self in ani.positive_species){\n\t\t\t\tinteractionMap << ani::\"mutualism\";\n\t\t\t}else if (self in ani.negative_species){\n\t\t\t\tinteractionMap << ani::\"predator\";\n\t\t\t}else {\n\t\t\t\tinteractionMap << ani::\"positive\";\n\t\t\t}\n\t\t}\n\t\tloop ani over: negative_species{\n\t\t\tif (self in ani.positive_species){\n\t\t\t\tinteractionMap << ani::\"prey\";\n\t\t\t}else if (self in ani.negative_species){\n\t\t\t\tinteractionMap << ani::\"competition\";\n\t\t\t}else {\n\t\t\t\tinteractionMap << ani::\"negative\";\n\t\t\t}\n\t\t}\n\t\tisPredator <- \"predator\" in interactionMap.values;\n//\t\twrite \"updated \"+name+\": \"+interactionMap;\n\t}\n\t\n\t// part of the ODE system\n\tequation dynamics simultaneously: [animal]{\n\t\tdiff(pop,t) = r*pop * (1 - pop/k \n\t\t\t+ int(saturation) * (\n\t\t\tsum((positive_species where (!dead(each))) collect(interaction_coef[each]*each.pop/k)) \n\t\t\t- sum((negative_species where (!dead(each))) collect(interaction_coef[each]*each.pop/k)))\n\t\t);\t\n    }\n        \n \t// aspect for the interaction graph\n\taspect interactionGraphAspect{\n\t\tdraw circle(30) color: color;\n\t\tdraw name anchor: #left_center at: location+{38,-25,0} color: #black font:font(\"SansSerif\", 10, #bold);\n\t}\n\t\n\t\n\t\taspect interactionGraphAspect{\n\t\tdraw circle(30) color: color;\n\t\tdraw name anchor: #left_center at: location+{38,-25,0} color: #black font:font(\"SansSerif\", 10, #bold);\t\t\n\t}\n}\n\n\nspecies solver_and_scheduler{\n\tfloat t;\n\tfloat dummy;\n\tlist<float> pop <- list_with(maxSpecies,0.0);\n\tlist<float> cumulatedPop <- list_with(maxSpecies,0.0);\n\tlist<int> lastValues <- list_with(xRange,0);\n\tlist<int> lastCumValues <- list_with(xRange,0);\n\t\n\t\n\t// Master equation. \n\t// Do nothing, but needed in order to make the scheduler able to solve the\n\t// equation system.\n\tequation dynamics simultaneously: [animal]{ \n\t\tdiff(dummy,t) = 0;\t\t\n    }\n    \n\t// solve the ODE system assembled from all equations from animal species\n\treflex solveEquation {\n\t    solve dynamics method: \"rk4\" step_size:0.01;\n    }\n\n\t// compute statistics\n\treflex updateCount{\n\t\tloop i from: 0 to: maxSpecies-1{\n\t\t\tpop[i] <- (speciesList[i] != nil)?speciesList[i].pop:0;\n\t\t\tcumulatedPop[i] <- i=0?pop[0]:cumulatedPop[i-1]+pop[i];\n\t\t}\n\t\tremove from: lastCumValues index: 0;\n\t\tlastCumValues << cumulatedPop[maxSpecies-1];\n\t\tremove from: lastValues index: 0;\n\t\tlastValues << max(pop);\n\t}\n\t\n\t\n}\n\n\n// buttons grid for the interaction matrix\ngrid button width:maxSpecies+1 height:maxSpecies+1 \n{\n\tstring type <- \"neutral\";\n\tbool active <- false;\n\tbutton oppositeButton <- button[self.grid_y,self.grid_x];\n\tstring buttonType <- 'arrow';\n\tpoint buttonDimensions <- {shape.width * 0.8,shape.height * 0.8};\n\tpoint locationShift <-  (grid_x = 0)?{-0.1*shape.width,0}:{0,-0.1*shape.height};\n\tpoint cornerShift <- {2 #px, -3 #px};\n\t\n\t\n\tinit{\n\t\t// sets the type of button action\n\t\tif (grid_x*grid_y > 0){\n\t\t\tbuttonType <- (grid_x = grid_y)?'none':'interaction';\n\t\t}else if (grid_x > 0 or grid_y > 0){\n\t\t\tbuttonType <- 'species';\n\t\t}\n\t\t// sets the dimensions of the button\n\t\tif (grid_x = 0 and grid_y > 0){\n\t\t\tbuttonDimensions <- {shape.width, shape.height * 0.8};\n\t\t\tcolor <- color_list[grid_y - 1];\n\t\t}\n\t\tif (grid_y = 0 and grid_x > 0){\n\t\t\tbuttonDimensions <- {shape.width * 0.8, shape.height};\n\t\t\tcolor <- color_list[grid_x - 1];\n\t\t}\n\t\t\n\t}\n\t\n\t// action for species modification button\n\taction speciesButtonAction{\n\t\tif (active) {\n\t\t// remove animal species and reset interactions\n\t\t\tanimal species_to_be_removed <- speciesList[grid_y - 1];\n\t\t\tthe_graph <- species_to_be_removed remove_node_from the_graph;\n\t\t\task button where ((each.grid_x = self.grid_y) or (each.grid_y = self.grid_y)) {\n\t\t\t\tself.type <- \"neutral\";\n\t\t\t}\n\n\t\t\task animal {\n\t\t\t\tremove species_to_be_removed from: self.positive_species;\n\t\t\t\tremove key: species_to_be_removed from: self.interaction_coef;\n\t\t\t\tdo updateInteractionsTypes;\n\t\t\t}\n\n\t\t\task species_to_be_removed {\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\tspeciesList[self.grid_y - 1] <- nil;\n\t\t} else {\n\t\t// add a new animal species\n\t\t\tcreate animal {\n\t\t\t\tname <- animal_names[language][rnd(length(animal_names[language]) - 1)][0] + animal_names[language][rnd(length(animal_names[language]) - 1)][1];\n\t\t\t\tspeciesList[myself.grid_y - 1] <- self;\n\t\t\t\tr <- rnd(100) / 1000;\n\t\t\t\tk <- 30.0 + rnd(50);\n\t\t\t\tpop <- 1.0;\n\t\t\t\tself.color <- myself.color;\n\t\t\t\tthe_graph <- the_graph add_node speciesList[myself.grid_y - 1];\n\t\t\t}\n\n\t\t}\n\n\t\t// change active level for the button and the corresponding interaction buttons\n\t\tactive <- !active;\n\t\toppositeButton.active <- !oppositeButton.active;\n\t\task button where (each.grid_x > 0 and each.grid_y > 0 and each.grid_x > 0) {\n\t\t\tself.active <- (speciesList[self.grid_x - 1] != nil) and (speciesList[self.grid_y - 1] != nil);\n\t\t}\n\t}\n\t\n\t// action for type of interaction modification button\n\taction interactionButtonAction{\n\t\tstring new_type <- possible_type[mod(possible_type index_of(type)+1,length(possible_type))];\n\t\t// change the button to the new type\n\t\ttype <- new_type;\n\t\t// add the interaction type to the concerned animal species (x->y)\n\t\task speciesList[grid_y - 1] {\n\t\t\tdo change_type(speciesList[myself.grid_x - 1], new_type);\n\t\t\tdo updateInteractionsTypes;\n\t\t}\n\t\tif (new_type != 'neutral'){\n\t\t\tadd edge(speciesList[grid_x - 1], speciesList[grid_y - 1]) to: the_graph;\n\t\t\tadd (speciesList[grid_x - 1]::speciesList[grid_y - 1])::new_type to: edge_type;\t\n\t\t}else{\n\t\t\twrite \"before \"+the_graph.edges;\n\t\t\tremove edge(speciesList[grid_x - 1], speciesList[grid_y - 1]) from: the_graph;\n\t\t\twrite \"after \"+the_graph.edges;\n\t\t}\n\t\task speciesList[grid_x - 1]{\n\t\t\tdo updateInteractionsTypes;\n\t\t}\n\t}\n\t\n\t\n\taspect modern {\n\t\tif (buttonType = 'species'){\n\t\t\t// rectangle\n\t\t\tdraw rectangle(buttonDimensions) at: location + locationShift  color: active?color:rgb(230,230,230);\n\t\t\t\n\t\t\tif !active {\n\t\t\t\t//question mark for inactive species\n\t\t\t\tpoint textShift <- (grid_x = 0)?{-0.15*shape.width,0,0.1}:{-0.05*shape.width, -0.1 * shape.height,0.1};\n\t\t\t\tdraw \"?\" font:font(\"Arial\", 40, #bold)  at: location + textShift anchor: #center color: #white;\n\t\t\t}\n\t\t\t// column\n\t\t\tif (grid_x = 0 and speciesList[grid_y - 1] != nil)  {\n\t\t\t\tdraw speciesList[grid_y -1].name font:font(\"SansSerif\", fontSize, #bold) anchor: #bottom_left at: location + locationShift + {-buttonDimensions.x/2,buttonDimensions.y/2,0.1} + cornerShift color: #white;\n\t\t\t} \n\t\t\t// row\n\t\t\tif (grid_y = 0 and speciesList[grid_x - 1] != nil)  {\n\t\t\t\tdraw speciesList[grid_x -1].name font:font(\"SansSerif\", fontSize, #bold) rotate: -90 anchor: #bottom_left at: location + locationShift + {buttonDimensions.x/2,buttonDimensions.y/2,0.1} + {cornerShift.y,-cornerShift.x}  color: #white;\n\t\t\t}\n\t\t\t\n\t\t} else if (buttonType = 'arrow'){\n\t\t\tdraw arrow size: shape.width *0.7;\n\t\t}else if (buttonType = 'interaction' and active){\n\t\t\tif (type = \"neutral\"){\n\t\t\t\tdraw rectangle(shape.width * 0.8,shape.height * 0.8) color: rgb(230,230,230);// border: rgb(210,210,210);\n\t\t\t}else{\n\t\t\t\tdraw rectangle(shape.width * 0.8,shape.height * 0.8) color: typeColor[type];\n\t\t\t}\n\t\t\t\t\n\t\t\t// draw a \"+\" or \"-\"\n\t\t\tif type != \"neutral\" {draw rectangle(shape.width * 0.55,shape.height * 0.15) color: #white at: location + {0,0,0.1};}\n\t\t\tif type = \"positive\" {draw rectangle(shape.width * 0.15,shape.height * 0.55) color: #white at: location + {0,0,0.1};}\n\t\t}else{\n\t\t\tdraw rectangle(buttonDimensions) color: rgb(245,245,245) ;\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\nexperiment Simulation type: gui autorun: true  {\n\t// limit the speed of the simulation\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\t// Help section.\n \ttext \"Click on '?'s to add animal species, then click on grey squares to change among 3 types of interactions:\n'+' means that the upper species has a positive impact on the left species (e.g. the left one eats the top one). \n'-' is for negative impact.\ngrey is neutral.\" category: \"Help\";\n\ttext \"https://en.wikipedia.org/wiki/Generalized_Lotka-Volterra_equation\" category: \"Help\" color: rgb(241, 196, 15);\n \tcategory \"Help\" expanded: true color: rgb(46, 204, 113);\n \t\n \t// Language section\n \tparameter \"Language for animal names\" var: language category: \"Language\";\n \t\n \t// Display options\n \tparameter \"Font size\" var: fontSize category: \"Display\" min: 1 max: 15;\n \tparameter \"Graph edges spacing\" var: edgeSpacing category: \"Display\" min: 0.0 max: 20.0;\n \t\n \t// output definition\n \t\t\t\n\toutput { \n\t\t// set the window layout\n\t\tlayout value: horizontal([0::50,vertical([1::50,2::50])::50]) tabs:false;\n\t\t\n\t\t// left display: interaction matrix\n\t\tdisplay action_button name:\"Species interactions\" toolbar: false type:3d axes: false{\n\t\t\tcamera 'default' location: {500.0,500.0231,1273.0} target: {500.0,500.0,0.0} locked: true;\n//\t\t\tcamera name: 'myCamera' locked: true;\n\t\t\tlight #default intensity: 120;\n\t\t\tspecies button aspect: modern;\n\t\t\t\n\t\t\t// event listener for mouse clicks\n\t\t\tevent #mouse_down {ask simulation {do buttonPressed;}} \n\t\t\t\n\t\t\t// window title\n\t\t\toverlay position: {0, 0} size: { 0 #px, 0 #px } background: #white transparency: 0.0{\n\t\t\t\tdraw string(\"Interaction matrix\") at: {10 #px,10 #px}  anchor: #top_left color: #black font: font(\"SansSerif\", 15, #bold) ; \n            }\n\t\t}\n\t\t\n\t\t// top-right display: charts\n\t\tdisplay \"Graphs\" name: \"Charts\" refresh: every(1#cycle) type: 3d toolbar: false axes: false{\n\t\t\tcamera name: \"myCamera\" locked: true;\n\t\t\t\n\t\t\t// chart definition: cumulated population\n\t\t\tchart \"Cumulated population size\" type: series style: area background: #white \n\t\t\tx_range: xRange x_tick_line_visible: false y_range: {0,30 + max(100,max(first(solver_and_scheduler).lastCumValues))} \n\t\t\ty_label: \"Population (cumulated)\"\n\t\t\tvisible: showCumulatedGraph series_label_position: none title_visible: false label_font: font(\"SansSerif\", 16) {\n\t\t\t\tloop i from: 0 to: maxSpecies-1{\n\t\t\t\t\tdata \"species\"+i value: first(solver_and_scheduler).cumulatedPop[i] color: color_list[i] marker: false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// chart definition: time series\n\t\t\tchart \"Time series\" type: series style: line background: #white \n\t\t\tx_range: xRange x_tick_line_visible: false y_range: {0,30 + max(30,max(first(solver_and_scheduler).lastValues))} \n\t\t\ty_label: \"Population\"\n\t\t\tvisible: !showCumulatedGraph series_label_position: none title_visible: false label_font: font(\"SansSerif\", 16) {\n\t\t\t\tloop i from: 0 to: maxSpecies-1{\n\t\t\t\t\tdata \"species\"+i value: first(solver_and_scheduler).pop[i] color: color_list[i] marker: false thickness: 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// mouse event listener\n\t\t\tevent #mouse_down {showCumulatedGraph <- !showCumulatedGraph;} \n\t\t\t\n\t\t\t// window title\n\t\t\toverlay position: {0, 0} size: {2000, 32#px} background: #white transparency: 0 rounded: false{\n\t\t\t\tdraw string(\"Population evolution\") at: {10 #px,10 #px}  anchor: #top_left color: #black font:font(\"SansSerif\", 15, #bold) ; \n            }\n           \n\t\t}\n\t\t\n\t\t// bottom-right display: interaction graph\n\t\tdisplay \"Interaction graph\" toolbar: false type:3d axes: false {\n\t\t\tcamera #default locked: true;\n\t\t\tgraphics \"edges\" {\n\t\t\t\tlist<pair> myEdges <- the_graph.edges;\n\t\t\t\t// draw the edges\n\t\t\t\tloop while: !empty(myEdges){\n\t\t\t\t\tpair<animal,animal> myEdge <- first(myEdges);\n\t\t\t\t\tremove myEdge from: myEdges;\n\t\t\t\t\tanimal ani1 <- first(myEdge);\n\t\t\t\t\tanimal ani2 <- last(myEdge);\n\t\t\t\t\tif ((ani2::ani1) in myEdges){\n\t\t\t\t\t\t// reciprocal interaction\n\t\t\t\t\t\tremove (ani2::ani1) from: myEdges;\n\t\t\t\t\t\tfloat angle <- ani1 towards ani2;\n\t\t\t\t\t\tpoint centre <- centroid(polyline([ani1.location,ani2.location]));\n\t\t\t\t\t\tif (ani1.interactionMap[ani2] = 'predator'){\n\t\t\t\t\t\t\tdraw geometry(myEdge) + 8  color: #red;\n\t\t\t\t\t\t\tdraw triangle(40) rotate: angle + 90 at: centre + {cos(angle),sin(angle),0}*12 color: #red;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ani1.interactionMap[ani2] = 'mutualism'){\n\t\t\t\t\t\t\tif (angle >= 90 and angle < 270){angle <- angle + 180;}\n\t\t\t\t\t\t\tdraw geometry(myEdge) + 3  color: rgb(53,174,36);\n\t\t\t\t\t\t\tdraw \"Mutualism\" rotate: angle at: centre + {sin(angle),-cos(angle),0}*edgeSpacing*3 \n\t\t\t\t\t\t\t\tanchor: #center color: #black font:font(\"SansSerif\", 10, #bold);\n\t\t\t\t\t\t\tint textLength <- 110;\n\t\t\t\t\t\t\tdraw triangle(40) rotate: angle + 90 at: centre +{cos(angle),sin(angle),0} * textLength +  {sin(angle),-cos(angle),0}*edgeSpacing*3 color: rgb(53,174,36);\n\t\t\t\t\t\t\tdraw triangle(40) rotate: angle + 270 at: centre - {cos(angle),sin(angle),0} * textLength +  {sin(angle),-cos(angle),0}*edgeSpacing*3 color: rgb(53,174,36);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// one way interaction\n\t\t\t\t\t\tfloat angle <- first(myEdge) towards last(myEdge);\n\t\t\t\t\t\tpoint centre <- centroid(polyline([first(myEdge).location,last(myEdge).location]));\n\t\t\t\t\t\trgb myColor <- edge_type[myEdge] = \"negative\"?#red:rgb(53,174,36);\n\t\t\t\t\t\tdraw geometry(myEdge) + 3  color: myColor;\n\t\t\t\t\t\tdraw triangle(20) rotate: angle + 90 at: centre + {cos(angle),sin(angle),0}*12 color: myColor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tloop edge over: the_graph.edges {\n//\t\t\t\t\t// mandatory cast\n//\t\t\t\t\tpair<animal,animal> myEdge <- edge;\n//\t\t\t\t\tfloat angle <- first(myEdge) towards last(myEdge);\n//\t\t\t\t\tpoint centre <- centroid(polyline([first(myEdge).location,last(myEdge).location]));\n//\t\t\t\t\trgb myColor <- edge_type[myEdge] = \"negative\"?#red:rgb(53,174,36);\n//\t\t\t\t\tdraw geometry(edge) + 3 at: centre + {sin(angle),-cos(angle),0}*edgeSpacing color: myColor;\n//\t\t\t\t\tdraw triangle(20) rotate: angle + 90 at: centre + {cos(angle),sin(angle),0}*12 + {sin(angle),-cos(angle),0}*edgeSpacing color: myColor;\n//\t\t\t\t}\n \t\t\t}\n \t\t\tspecies animal aspect: interactionGraphAspect;\n \t\t\t\n \t\t\t// window title\n \t\t\toverlay position: { 0, 0} size: { 0 #px, 0 #px } background: #white transparency: 0.0{\n\t\t\t\tdraw string(\"Interaction graph\") at: {10 #px,10 #px} anchor: #top_left color: #black font:font(\"SansSerif\", 15, #bold) ; \n            }\n\t\t}\n\t\n\t}\n}"}
{"prompt": "Simulate a geometric brownian motion for four cryptocurrencies (BTC, SOL, ETH, XRP) using an Euler-Maruyama method and visualize their prices over different time windows.", "gaml_code": "/**\n* Name: stochastic_differential_equations\n* Author: Jean-Claude R\u00e9gnault \n* Description: A simple example of an SDE simulation solved with an Euler-Maruyama Method for a \n* \t\t\t\tgeometric brownian motion, which is based on a classical Euler forward method for ODEs.\n* \n* \t\t\t\tThis toy model simulates the evolution of some cryptocurrencies. Use at your own risk.\n*\n* Tags: math, equation\n*/\n \nmodel stochastic_differential_equations\n\nglobal {\t\n\tstring view <- \"Month\" among: [\"Day\",\"Week\",\"Month\",\"3 Months\",\"Year\",\"Lifetime\"];\n\tint time_window_size <- 1;\n\tint elapsed_steps <- 1;\n\tfloat step <- 1.2;\n\t// step for integration\t\n\tfloat dt <- 0.01;\n\tint nb_steps <- int(floor(1/dt));\n\t\n\t//parameters of the geometric brownian motion\n  \tfloat mu <- 0.03;\n   \tfloat sigma <- 0.25; \n   \t\n   \t//initial condition\n   \tfloat X0 <- 1.0;\n   \t  \t\n\tinit {\n\t\tcreate SDE_agent number: 4{\n\t\t\tX <- X0;\n\t\t}\n\t}\n\t\n\t\n\treflex update_time_window{\n\t\tswitch view{\n\t\t\tmatch \"Day\"{\n\t\t\t\ttime_window_size <-1;\n\t\t\t}\n\t\t\tmatch \"Week\"{\n\t\t\t\ttime_window_size <-30;\n\t\t\t}\n\t\t\tmatch \"Month\"{\n\t\t\t\ttime_window_size <-30;\n\t\t\t}\n\t\t\tmatch \"3 Months\"{\n\t\t\t\ttime_window_size <-90;\n\t\t\t}\n\t\t\tmatch \"Year\"{\n\t\t\t\ttime_window_size <-365;\n\t\t\t}\n\t\t\tmatch \"Lifetime\"{\n\t\t\t\ttime_window_size <-length(first(SDE_agent).t[]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Species which represents the SDE System \nspecies SDE_agent {\n\t//Variable to represent the discrete time for integration\n\tfloat t;\n \t//Main variable \n   \tfloat X; \t\n\n\tequation SDE simultaneously: [SDE_agent]{\n\t\tdiff(X,t) = mu * X + sigma * X * sqrt(dt) * gauss(0,1)/dt;\n\t}\n\t\n\treflex solving when: int(self)=0{\n\t\tsolve SDE method: \"Euler\" step_size: dt;\n\t\telapsed_steps <- length(t[]);\n\t}\n}\n\n\nexperiment mysimulation type: gui {\n\tfloat minimum_cycle_duration <- 0.2#s;\n\t//parameter \"Window\" var: time_window_size category: 'Choix';\n\tparameter \"Window\" var: view category: 'Choix';\n\toutput {\n\t\tlayout \t#split tabs: true;\n\t\tdisplay display_charts  type: 2d  {\n\t\t\tchart 'BTC price' type: series  \n\t\t\t\tx_range: min(elapsed_steps,time_window_size*nb_steps) background: #white \n\t\t\t\tx_tick_line_visible: false{\n\t\t\t\tdata \"BTC\" value: first(SDE_agent).X[] color: rgb(239,142,25) marker: false;\n\t\t\t}\n\t\t}\n\t\tdisplay display_charts2  type: 2d  {\n\t\t\tchart 'SOL price' type: series \n\t\t\t\tx_range: min(elapsed_steps,time_window_size*nb_steps)  background: #white \n\t\t\t\tx_tick_line_visible: false{\n\t\t\t\tdata \"SOL\" value: SDE_agent[1].X[] color: rgb(0,0,0) marker: false;\n\t\t\t}\n\t\t}\n\t\tdisplay display_charts3  type: 2d  {\n\t\t\tchart 'ETH price' type: series \n\t\t\t\tx_range: min(elapsed_steps,time_window_size*nb_steps) background: #white \n\t\t\t\tx_tick_line_visible: false{\n\t\t\t\tdata \"ETH\" value: SDE_agent[2].X[] color: rgb(33, 92,175) marker: false;\n\t\t\t}\n\t\t}\n\t\tdisplay display_charts4  type: 2d {\n\t\t\tchart 'XRP price' type: series \n\t\t\t\tx_range: min(elapsed_steps,time_window_size*nb_steps) background: #white \n\t\t\t\tx_tick_line_visible: false{\n\t\t\t\tdata \"XRP\" value: SDE_agent[3].X[] color: rgb(31,135,178) marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple SIR model using ODEs to simulate the spread of a disease, including visualization of time series and phase portrait plots.", "gaml_code": "/**\n* Name: SIR (Simple)\n* Author: hqnghi\n* Description: A simple example of ODE use into agents with the example of the SIR equation system.\n* Tags: equation, math\n*/\n\nmodel simple_ODE_SIR\n\nglobal {\n\tinit {\n\t\tcreate agent_with_SIR_dynamic number:1;\n\t}\n}\n\n\nspecies agent_with_SIR_dynamic {\n\tint N <- 1500 ;\n\tint iInit <- 1;\t\t\n\n    float t;  \n\tfloat S <- N - float(iInit); \t      \n\tfloat I <- float(iInit); \n\tfloat R <- 0.0; \n\t\n\tfloat alpha <- 0.2 min: 0.0 max: 1.0;\n\tfloat beta <- 0.8 min: 0.0 max: 1.0;\n\n\tfloat h <- 0.01;\n   \n\tequation SIR{ \n\t\tdiff(S,t) = (- beta * S * I / N);\n\t\tdiff(I,t) = (beta * S * I / N) - (alpha * I);\n\t\tdiff(R,t) = (alpha * I);\n\t}\n                \n    reflex solving {\n    \tsolve SIR method: \"rk4\"  ;\n    }    \n}\n\n\nexperiment Simulation type: gui {\n\tfloat minimum_cycle_duration <- 0.1#s;\n\toutput { \n\t\tlayout #vertical tabs: true;\n\t\tdisplay display_charts toolbar: false  type: 2d {\n\t\t\tchart \"Time series\" type: series background: rgb(47,47,47) color: #white {\n\t\t\t\tdata 'S' value: first(agent_with_SIR_dynamic).S color: rgb(46,204,113) ;\t\t\t\t\n\t\t\t\tdata 'I' value: first(agent_with_SIR_dynamic).I color: rgb(231,76,60) ;\n\t\t\t\tdata 'R' value: first(agent_with_SIR_dynamic).R color: rgb(52,152,219) ;\n\t\t\t}\n\t\t}\n\t\tdisplay display_phase_portrait toolbar: false  type: 2d {\n\t\t\tchart \"Phase portrait\" type: xy background: rgb(47,47,47) color: #white x_label:\"S\" y_label:\"Y\" x_range: {0,1600} y_range: {0,700}{\n\t\t\t\tdata 'I vs S' value: [first(agent_with_SIR_dynamic).S,first(agent_with_SIR_dynamic).I] color: rgb(243,156,18)  ;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Investigate how different integration step sizes (h) affect the accuracy of numerical solutions for the Lotka-Volterra equations. Compare and visualize the results for h=0.01 and h=1.", "gaml_code": "/***\n* Name: Influence of the integration step\n* Author: Tri, Nghi, Benoit\n* Description:  The aim is to show the influence of the integration step on the result precision.\n* \t\t\t\tThe solutions of the Lotka-Volterra are periodic. When the integration step is not\n* \t\t\t\tsmall enough, this periodicity is lost, as illustrated with h=1.\n* \n* Tags: equation, math\n***/\n\nmodel LVInfluenceoftheIntegrationstep\n\nglobal {\n\tinit {\n\t\tcreate userLV with: [h::0.01,x::2.0,y::2.0];\t\n\t\tcreate userLV with: [h::1.0,x::2.0,y::2.0];\t\t\t\t\t\t\t\t\t\n\t}\n}\n\nspecies userLV {\n\tfloat t;\n\tfloat x ; \n\tfloat y ; \n\tfloat h;\n\tfloat alpha <- 0.8 ;\n\tfloat beta  <- 0.3 ;\n\tfloat gamma <- 0.2 ;\n\tfloat delta <- 0.85;\n\t\n\tequation eqLV { \n\t\tdiff(x,t) =   x * (alpha - beta * y);\n\t\tdiff(y,t) = - y * (delta - gamma * x);\n    }\t\t\n    \n\treflex solving {\n\t\tsolve eqLV method: #rk4 step_size: h;\n\t}\n}\n\nexperiment examples type: gui {\n\tfloat minimum_cycle_duration <- 0.05#s;\n\toutput {\t\n\t\tlayout horizontal([vertical([0::100,1::100])::100,2::100]) tabs: true;\t\n\t\tdisplay \"h=0.01\"  toolbar: false  type: 2d {\n\t\t\tchart 'Lotka-Voltera dynamics (time series)' type: series \n\t\t\t\tbackground: rgb(47,47,47) color: #white\n\t\t\t\ty_label: \"pop\" x_tick_line_visible: false{\n\t\t\t\tdata \"x (h=0.01)\" value: first(userLV).x[] color: rgb(52,152,219) marker: false thickness: 2;\n\t\t\t\tdata \"y (h=0.01)\" value: first(userLV).y[] color: rgb(41,128,185) marker: false thickness: 2;\n//\t\t\t\tdata \"x (h=1)\" value: last(userLV).x color: rgb(243,156,18) marker: false thickness: 2;\n//\t\t\t\tdata \"y (h=1)\" value: last(userLV).y color: rgb(230,126,34) marker: false thickness: 2;\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\tdisplay \"h=1\"   toolbar: false  type: 2d {\n\t\t\tchart 'Lotka-Voltera dynamics (time series)' type: series \n\t\t\tbackground: rgb(47,47,47) color: #white\n\t\t\ty_label: \"pop\" x_tick_line_visible: false{\n//\t\t\t\tdata \"x (h=0.01)\" value: first(userLV).x color: rgb(52,152,219) marker: false thickness: 2;\n//\t\t\t\tdata \"y (h=0.01)\" value: first(userLV).y color: rgb(41,128,185) marker: false thickness: 2;\n\t\t\t\tdata \"x (h=1)\" value: last(userLV).x[] color: rgb(243,156,18) marker: false thickness: 2;\n\t\t\t\tdata \"y (h=1)\" value: last(userLV).y[] color: rgb(230,126,34) marker: false thickness: 2;\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t\tdisplay \"Phase Portrait\"  toolbar: false  type: 2d  {\n\t\tchart 'Lotka-Voltera dynamics (phase portrait)' type: xy \n\t\t\tbackground: rgb(47,47,47) color: #white y_label: \"y\" x_label: \"x\"\n\t\t\tx_range: {0,8} y_range: {0,5.3}{\n\t\t\t\tdata \"h=0.01\" value: [first(userLV).x,first(userLV).y] color: rgb(52,152,219) marker: false;\t\t\t\n\t\t\t\tdata \"h=1\" value: [last(userLV).x,last(userLV).y] color: rgb(243,156,18) marker: false;\t\t\t\n\t\t\t}\t\t\n\t\t}\t\t\t\t\t\t\n\t}\n}"}
{"prompt": "Compare and visualize the numerical solutions of the Lotka-Volterra model using Runge-Kutta 4 (RK4) and Euler methods with a step size of 0.1, highlighting their differences in accuracy.", "gaml_code": "/***\n* Name: Influence of the integration step\n* Author: Tri, Nghi, Benoit\n* Description: The aim is to show the influence of the integration method on the result precision.\n* \t\t\t\tNote: an integration step of 0.1 is considered as not accurate enough. It is used here \n* \t\t\t\tto highlight the impact of the integration method.\n* \n* \t\t\t\tAbout the expected dynamics: Lotka-Volterra model solutions are known to be periodic. With\n* \t\t\t\ta step of 0.1, the numerical solution provided by the Runge-Kutta 4 method for Lotka-Volterra \n* \t\t\t\tmodel looks periodic (see the phase portrait), while for the Euler the solution is unbounded (which\n* \t\t\t\tis wrong). See as time increases how errors accumulate, leading to negative and unbounded values.\n* \n* Tags: equation, math\n***/\n\nmodel LVInfluenceoftheIntegrationMethod\n\nglobal {\n\tinit {\n\t\tcreate LVRK4 with: [x::2.0, y::2.0];\n\t\tcreate LVEuler with: [x::2.0, y::2.0];\n\t}\n\n}\n\nspecies LVRK4 {\n\tfloat t;\n\tfloat x;\n\tfloat y;\n\tfloat h <- 0.1;\n\tfloat alpha <- 0.8;\n\tfloat beta <- 0.3;\n\tfloat gamma <- 0.2;\n\tfloat delta <- 0.85;\n\t\n\tequation eqLV {\n\t\tdiff(x, t) = x * (alpha - beta * y);\n\t\tdiff(y, t) = -y * (delta - gamma * x);\n\t}\n\n\treflex solving {\n\t\tsolve eqLV method: #rk4 step_size: h;\n\t}\n}\n\n\nspecies LVEuler {\n\tfloat t;\n\tfloat x;\n\tfloat y;\n\tfloat h <- 0.1;\n\tfloat alpha <- 0.8;\n\tfloat beta <- 0.3;\n\tfloat gamma <- 0.2;\n\tfloat delta <- 0.85;\n\n\tequation eqLV {\n\t\tdiff(x, t) = x * (alpha - beta * y);\n\t\tdiff(y, t) = -y * (delta - gamma * x);\n\t}\n\n\treflex solving {\t\n\t\tsolve eqLV method: #Euler step_size: h;    \n\t}\n\t\n\t\n\t\n\treflex end_simulation when: cycle > 126{\n\t\task world{do pause;}\n\t}\n\n}\n\nexperiment examples type: gui {\n\tfloat minimum_cycle_duration <- 0.1#s;\n\toutput {\n\t\tlayout #split tabs: true;\n\t\tdisplay LV_series name: \"Time series\" toolbar: false  type: 2d {\n\t\t\tchart 'Comparison Euler - RK4 (RK4 is more accurate)' type: series \n\t\t\tx_serie: first(LVRK4).t[] y_label: \"pop\" background: rgb(47,47,47) color: #white x_tick_line_visible: false {\n\t\t\t\tdata \"x (rk4)\" value: first(LVRK4).x[] color: rgb(52,152,219) marker: false thickness: 2;\n\t\t\t\tdata \"y (rk4)\" value: first(LVRK4).y[] color: rgb(41,128,185) marker: false thickness: 2;\n\t\t\t\tdata \"x (Euler)\" value: first(LVEuler).x[] color: rgb(243,156,18) marker: false thickness: 2;\n\t\t\t\tdata \"y (Euler)\" value: first(LVEuler).y[] color: rgb(230,126,34) marker: false thickness: 2;\n\t\t\t}\n\n\t\t}\n\t\tdisplay LV_phase_portrait name: \"Phase portrait\" toolbar: false  type: 2d {\n\t\t\tchart 'Comparison Euler - RK4 (RK4 is more accurate)' type: xy \n\t\t\tbackground: rgb(47,47,47) color: #white x_label: \"x\" y_label: \"y\" x_tick_line_visible: false y_tick_line_visible: false{\n\t\t\t\tdata \"y(x(t)) rk4\" value: rows_list(matrix(first(LVRK4).x[],first(LVRK4).y[])) color: rgb(52,152,219) marker: false thickness: 2;\n\t\t\t\tdata \"y(x(t)) Euler\" value: rows_list(matrix(first(LVEuler).x[],first(LVEuler).y[])) color: rgb(243,156,18) marker: false thickness: 2;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates the SIR model with varying simulation steps and displays the results as charts, including a phase portrait of I vs S.", "gaml_code": "/***\n* Name: SIRInfluenceofSimulationStep\n* Author: Tri, Nghi and Benoit \n* Description: This model illustrates the impact of the simulation step on the integration speed.\n* Tags: equation, math, step\n***/\n\n\nmodel SIRInfluenceofSimulationStep\n\nglobal {\n\tstring step_string;\n\tinit {\n\t\twrite name + \"\" + step;\n\t\tstep_string <- string(step)+\"s\";\n\t\tcreate userSIR with: [h::0.1,N::500,I::1.0];\n\t}\n\t\n\treflex w {\n\t\twrite name + \" - c = \" + cycle + \" - s = \" + step + \" - t = \" + time;\t\t\n\t}\n}\n\nspecies userSIR {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \t\t\t\t\n\t\n\tequation eqSIR {\n\t\tdiff(S,t) = (- beta * S * I / N);\n\t\tdiff(I,t) = (beta * S * I / N) - (gamma * I);\n\t\tdiff(R,t) = (gamma * I);\n\t}\t\t\n\t\n\treflex solving {\t\t\n\t\tsolve eqSIR method: #rk4 step_size: h ;\n\t}\n\n}\n\n\nexperiment examples type: gui {\n\tfloat minimum_cycle_duration <- 0.1#s;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [step::2#s,name::\"s2s\"]   ;\n\t\tcreate simulation with: [step::10#s,name::\"s10s\"] ;\t\t\n\t}\n\t\n\toutput {\n\t\tlayout #split tabs: true;\t\n\t\tdisplay SIR toolbar: false  type: 2d {\n\t\t\tchart 'Time Teries ('+step_string+' per cycle)' type: series \n\t\t\tbackground: rgb(47,47,47) color: #white y_label: \"pop\" x_tick_line_visible: false{\n\t\t\t\tdata \"S\" value: first(userSIR).S[] color: rgb(46,204,113) marker: false thickness: 2;\n\t\t\t\tdata \"I\" value: first(userSIR).I[] color: rgb(231,76,60) marker: false thickness: 2;\n\t\t\t\tdata \"R\" value: first(userSIR).R[] color: rgb(52,152,219) marker: false thickness: 2;\n\t\t\t}\t\t\t\n\t\t}\n\t\tdisplay \"Phase Portrait\" toolbar: false  type: 2d  {\n\t\tchart 'Phase Portrait ('+step_string+' per cycle)' type: xy \n\t\tbackground: rgb(47,47,47) color: #white y_label: \"y\" x_label: \"x\"\n\t\t\tx_range: {0,500} y_range: {0,450}{\n\t\t\t\tdata \"I vs S\" value: rows_list(matrix(first(userSIR).S[],first(userSIR).I[])) color: rgb(52,152,219) marker: false;\t\t\t\n\t\t\t}\t\t\n\t\t}\t\t\t\t\t\n\t}\n}"}
{"prompt": "Create a NetLogo model that displays different visualization types for a Lotka-Volterra system, including phase portraits and time series plots with both discrete and continuous data.", "gaml_code": "/**\n *  continuous curves\n *  Author: Tri and Nghi\n *  Description: \n * \n * This model illustrates different displays for a Lotka-Volterra model. ABMs usually only require a discrete \n * visualization of the results (one value per cycle). EBMs compute a continuous solution, and thus require\n * a continuous display. The syntax is shown below.\n * \n * Phase portraits are very common in mathematics, and can be displayed with the 'type: xy' facet.\n */\n \n \nmodel Displays\n\n\nglobal {\t\n\tinit {\n\t\tcreate LV_model with: [x::2.0, y::2.0];\n\t}\n}\n\nspecies LV_model { \n\tfloat t;\n\tfloat x;\n\tfloat y;\n\tfloat h <- 0.1;\n\tfloat alpha <- 0.8;\n\tfloat beta <- 0.3;\n\tfloat gamma <- 0.2;\n\tfloat delta <- 0.85;\n\t\n\tequation eqLV {\n\t\tdiff(x, t) = x * (alpha - beta * y);\n\t\tdiff(y, t) = -y * (delta - gamma * x);\n\t}\n\n\treflex solving {\n\t\tsolve eqLV method: #rk4 step_size: h;\n\t}\n}\n\nexperiment Displays type: gui {\n\tfloat minimum_cycle_duration <- 0.1#s;\n\toutput {\n\t\tlayout #split tabs: true;\n\t\tdisplay D1 toolbar: false type: 2d {\n\t\t\tchart 'Time series' type: series background: rgb(47,47,47) color: #white y_label:\"pop\" x_tick_line_visible: false{\n\t\t\t\tdata \"x\" value: first(LV_model).x color: rgb(52,152,219);\n\t\t\t\tdata \"y\" value: first(LV_model).y color: rgb(41,128,185);\n\t\t\t}\n\t\t}\n\t\tdisplay D2 toolbar: false type: 2d {\n\t\t\tchart 'Time series - continuous display' type: series background:  rgb(47,47,47) color: #white y_label:\"pop\" x_tick_line_visible: false{\n\t\t//\tchart 'Time series - continuous display' type: series x_serie: first(LV_model).t[] background: #white y_label:\"pop\"{\n\t\t\t\tdata \"x\" value: first(LV_model).x[] color: rgb(52,152,219) marker: false;\n\t\t\t\tdata \"y\" value: first(LV_model).y[] color: rgb(41,128,185) marker: false;\n\t\t\t}\n\t\t}\n\t\tdisplay D3 name: \"Phase Portrait \" toolbar: false  type: 2d {\n\t\t\tchart 'Phase Portrait' type: xy background:  rgb(47,47,47) color: #white x_label: \"x\" y_label:\"y\"{\n\t\t\t\t// Continuous display requires to pass a list of two values x and y\n\t\t\t\tdata \"y(x(t))\" value: [first(LV_model).x,first(LV_model).y] color: rgb(243,156,18);\n\t\t\t}\n\t\t}\n\t\tdisplay D4 name: \"Phase Portrait - continuous display\" toolbar: false type: 2d {\n\t\t\tchart 'Phase Portrait - continuous display' type: xy background:  rgb(47,47,47) color: #white x_label: \"x\" y_label:\"y\"{\n\t\t\t\t// Continuous display requires to pass a list of two values x and y\n\t\t\t\tdata \"y(x(t))\" value: rows_list(matrix(first(LV_model).x[],first(LV_model).y[])) color: rgb(243,156,18) marker: false;\n\t\t\t}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates an SIR (Susceptible-Infected-Recovered) epidemiological model with multiple strains of infection, allowing for visualization of the spread of disease and recovery rates.", "gaml_code": "/**\n* Name: SIR (Split in Agents, Multiple Strains)\n* Author: tri and nghi\n* Description: This model is an extension of the model SIR_split_in_agents.gaml. \n* It creates several agents of one compartment type (here typically several I_agt).\n* Tags: equation, math\n*/\nmodel SIR_split_in_agents_multiple_strains\n\nglobal {\n\t// Parameters\n\tint number_S <- 495 ; // The number of susceptible\n\tint number_I <- 5 ; // The number of infected\n\tint number_R <- 0 ; // The number of removed \n\n\tfloat _beta <- 0.8 ; // The parameter Beta\n\tfloat _delta <- 0.2 ; // The parameter Delta\n\t\n\t// Global variables\n\tint strain_number <- 2;\n\tint N <- number_S + number_I * strain_number + number_R;\t\n\tfloat hKR4 <- 0.01;\n\t\n\tinit {\n\t\tcreate S_agt {\n\t\t\tSsize <- float(number_S);\n\t\t}\n\n\t\tcreate I_agt number: strain_number {\n\t\t\tIsize <- float(number_I);\n\t\t\tself.beta <- _beta*(0.8+rnd(0.4)); \n\t\t\twrite self.beta;\n\t\t\tself.delta <- _delta; \n\t\t}\n\n\t\tcreate R_agt {\n\t\t\tRsize <- float(number_R);\n\t\t}\n\n\t\tcreate my_SIR_maths {\n\t\t\tself.Sm <- float(number_S);\n\t\t\tself.Im <- float(number_I) * strain_number;\n\t\t\tself.Rm <- float(number_R);\n\t\t}\n\n\t\twrite 'Basic Reproduction Number (R0): ' + string(_beta * number_S / (_delta));\n\t}\n\n}\n\n\nspecies S_agt {\n\tfloat t;\t\t\n\tfloat Ssize;\n\t\n\tequation evol simultaneously: [I_agt, R_agt] {\n\t\tdiff(self.Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N);\n\t}\n\n\treflex solving {\n\t\tsolve evol method: #rk4 step_size: hKR4 ;\n\t}\n}\n\nspecies I_agt {\n\tfloat t;\t\t\n\tfloat Isize;\n\t \n\tfloat beta;\n\tfloat delta;\n\t\n\tequation evol simultaneously: [S_agt, R_agt] {\n\t\tdiff(self.Isize, t) = (beta * first(S_agt).Ssize * self.Isize / N) - (delta * self.Isize);\n\t}\n}\n\nspecies R_agt {\n\tfloat t;\t\t\n\tfloat Rsize;\n\n\tequation evol simultaneously: [I_agt] {\n\t\tdiff(self.Rsize, t) = (sum(I_agt collect (each.delta * each.Isize)));\n\t}\n}\n\nspecies my_SIR_maths {\n\tfloat t;\n\tfloat Im;\n\tfloat Sm;\n\tfloat Rm;\n\t\n\tequation SIR {\n\t\tdiff(self.Sm, t) = (-_beta * Sm * Im / N);\n\t\tdiff(self.Im, t) = (_beta * Sm * Im / N) - (_delta * Im);\n\t\tdiff(self.Rm, t) = (_delta * Im);\n\t}\n\n\treflex solving {\n\t\tsolve SIR method: #rk4 step_size: hKR4;\n\t}\n}\n\n\n\nexperiment Simulation type: gui {\n\tfloat minimum_cycle_duration <- 0.1#s;\n\tparameter 'Number of Susceptible' type: int var: number_S <- 495 category: \"Initial population\"; \n\tparameter 'Number of Infected'    type: int var: number_I <- 5   category: \"Initial population\";\n\tparameter 'Number of Removed'     type: int var: number_R <- 0   category: \"Initial population\";\n\n\tparameter 'Beta (S->I)'  type: float var: _beta <- 0.8   category: \"Parameters\";\n\tparameter 'Delta (I->R)' type: float var: _delta <- 0.2 category: \"Parameters\";\t\n\t\n\toutput {\n\t\tlayout #split tabs: true;\n\t\tdisplay chart_3system_eq name: \"Split system\" toolbar: false  type: 2d {\n\t\t\tchart 'Split system' type: series background: rgb(47,47,47) color: #white x_tick_line_visible: false{\n\t\t\t\tdata 'susceptible' value: first(S_agt).Ssize color: rgb(46,204,113) marker_shape: marker_circle;\n\t\t\t\tdata 'infected 1' value: first(I_agt).beta * first(I_agt).Isize color: rgb(231,76,60)+120 marker_shape: marker_diamond;\n\t\t\t\tdata 'infected 2' value: last(I_agt).beta * last(I_agt).Isize color: rgb(231,76,60)+100 marker_shape: marker_diamond;\n\t\t\t\tdata 'infected 1+2' value: sum(I_agt accumulate (each.beta * each. Isize)) color: rgb(231,76,60) marker_shape: marker_circle;\t\t\t\t\n\t\t\t\tdata 'recovered' value: first(R_agt).Rsize color: rgb(52,152,219) marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay chart_1system_eq name: \"Unified system\" toolbar: false  type: 2d  {\n\t\t\tchart 'Unified system' type: series background: rgb(47,47,47) color: #white x_tick_line_visible: false{\n\t\t\t\tdata 'susceptible (maths)' value: first(my_SIR_maths).Sm color: rgb(46,204,113) marker_shape: marker_circle;\n\t\t\t\tdata 'infected (maths)' value: first(my_SIR_maths).Im color: rgb(231,76,60) marker_shape: marker_circle;\n\t\t\t\tdata 'recovered (maths)' value: first(my_SIR_maths).Rm color: rgb(52,152,219) marker_shape: marker_circle;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of pedestrian movement in a urban environment using a graph-based model, incorporating GIS data and visualizing free space and pedestrian paths.", "gaml_code": "/***\n* Name: generate_pedestrian_path\n* Author: Patrick Taillandier\n* Description: Show how to create pedestrian path and associated free space\n* Tags: * Tags: pedestrian, gis, shapefile, graph, agent_movement, skill, transport\n***/\n\nmodel generate_pedestrian_path\n\nglobal {\n\t\n\tfile wall_shapefile <- file(\"../includes/walls.shp\");\n\t\n\t\n\tgeometry shape <- envelope(wall_shapefile);\n\tbool display_free_space <- false;\n\tfloat P_shoulder_length <- 0.45;\n\t\n\tfloat simplification_dist <- 0.5; //simplification distance for the final geometries\n\t\n\tbool add_points_open_area <- true;//add points to open areas\n \tbool random_densification <- false;//random densification (if true, use random points to fill open areas; if false, use uniform points), \n \tfloat min_dist_open_area <- 0.1;//min distance to considered an area as open area, \n \tfloat density_open_area <- 0.01; //density of points in the open areas (float)\n \tbool clean_network <-  true; \n\tfloat tol_cliping <- 1.0; //tolerance for the cliping in triangulation (float; distance), \n\tfloat tol_triangulation <- 0.1; //tolerance for the triangulation \n\tfloat min_dist_obstacles_filtering <- 0.0;// minimal distance to obstacles to keep a path (float; if 0.0, no filtering), \n\t\n\t\n\tgeometry open_area ;\n\t\n\tinit {\n\t\topen_area <- copy(shape);\n\t\tcreate wall from:wall_shapefile {\n\t\t\topen_area <- open_area -(shape buffer (P_shoulder_length/2.0));\n\t\t}\n\t\tlist<geometry> generated_lines <- generate_pedestrian_network([],[open_area],add_points_open_area,random_densification,min_dist_open_area,density_open_area,clean_network,tol_cliping,tol_triangulation,min_dist_obstacles_filtering,simplification_dist);\n\t\t\n\t\tcreate pedestrian_path from: generated_lines  {\n\t\t\tdo initialize bounds:[open_area] distance: min(10.0,(wall closest_to self) distance_to self) masked_by: [wall] distance_extremity: 1.0;\n\t\t}\n\t\tsave pedestrian_path to: \"../includes/pedestrian paths.shp\" format:\"shp\";\n\t\tsave open_area to: \"../includes/open area.shp\" format:\"shp\";\n\t\tsave pedestrian_path collect each.free_space to: \"../includes/free spaces.shp\" format:\"shp\";\n\t}\n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n\trgb color <- rnd_color(255);\n\taspect default {\n\t\tdraw shape  color: color;\n\t}\n\taspect free_area_aspect {\n\t\tif(display_free_space and free_space != nil) {\n\t\t\tdraw free_space color: #cyan border: #black;\n\t\t}\n\t}\n}\n\nspecies wall {\n\taspect default {\n\t\tdraw shape + (P_shoulder_length/2.0) color: #gray border: #black;\n\t}\n}\n\nexperiment normal_sim type: gui {\n\t\n\tparameter var:display_free_space;\n\tparameter var:P_shoulder_length;\n\t\n\toutput {\n\t\tdisplay map type: 3d axes:false{\n\t\t\tspecies wall refresh: false;\n\t\t\tgraphics \"open_area\" {\n\t\t\t\tdraw open_area color: #lightpink;\n\t\t\t}\n\t\t\tspecies pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n\t\t\tspecies pedestrian_path refresh: true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple pedestrian simulation environment with 100 pedestrians crossing the road in a frontal or perpendicular manner, with obstacles and various parameters to adjust.", "gaml_code": "/***\n* Name: pedestrian_simple_environment\n* Author: Patrick Taillandier\n* Description: \n* Tags: pedestrian, agent_movement, skill, transport\n***/\n\nmodel pedestrian_simple_environment\n\nglobal {\n\t\n\tfloat environment_size <- 50.0;\n\tfloat margin <- 2.0;\n\tint nb_obstacles <- 0 ;\n\tint nb_people <- 100;\n\tstring scenario <- \"frontal crossing\" among: [\"big crowd\", \"frontal crossing\", \"perpendicular crossing\"] ;\n\t\t\n\tbool display_force <- false;\n\tbool display_circle_min_dist <- true ;\n\t\n\tfloat P_shoulder_length <- 0.45 ;\n\tfloat P_proba_detour <- 1.0 ;\n\tbool P_avoid_other <- true;\n\tfloat P_obstacle_consideration_distance <- 5.0;\n\tfloat P_pedestrian_consideration_distance <- 5.0;\n\tfloat P_tolerance_waypoint <- 0.1;\n\tbool P_use_geometry_waypoint <- true;\n\t\n\tstring P_model_type <- \"simple\" among: [\"simple\", \"advanced\"]; \n\t\n\tfloat P_A_pedestrian_SFM_advanced <- 25.0 ;\n\tfloat P_A_obstacles_SFM_advanced <- 25.0 ;\n\tfloat P_B_pedestrian_SFM_advanced <- 0.5;\n\tfloat P_B_obstacles_SFM_advanced <- 0.1 ;\n\tfloat P_relaxion_SFM_advanced <- 0.1 ;\n\tfloat P_gama_SFM_advanced <- 0.35;\n\tfloat P_lambda_SFM_advanced <- 0.1 ;\n\tfloat P_minimal_distance_advanced <- 0.5;\n\t\n\t\n\tfloat P_n_prime_SFM_simple <- 3.0;\n\tfloat P_n_SFM_simple <- 2.0;\n\tfloat P_lambda_SFM_simple <- 2.0 ;\n\tfloat P_gama_SFM_simple <- 0.35;\n\tfloat P_relaxion_SFM_simple <- 0.54;\n\tfloat P_A_pedestrian_SFM_simple <- 4.5;\n\t\n\tgeometry shape <- square(environment_size);\n\tgeometry free_space <- copy(shape);\n\tgeometry left_space;\n\tgeometry right_space;\n\tgeometry bottom_space; \n\tgeometry top_space;\n\t\n\tfloat step <- 0.1;\n\t\n\tinit {\n\t\tleft_space <- polygon([{0,0}, {0, environment_size}, {environment_size/10, environment_size}, {environment_size/10,0}]);\n\t\tright_space <- polygon([{environment_size,0}, {environment_size, environment_size}, {9 * environment_size/10, environment_size}, {9 * environment_size/10,0}]);\n\t\tbottom_space <- polygon([{0, environment_size}, {0, 9 * environment_size/10}, {environment_size,9*  environment_size/10}, {environment_size, environment_size}]);\t\n\t\ttop_space <- polygon([{0, 0}, {0, environment_size/10}, {environment_size, environment_size/10}, {environment_size, 0.0}]);\t\n\t\t\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tlocation <- any_location_in(square(8*environment_size/10) at_location {environment_size/2, environment_size/2} scaled_by 0.8);\n\t\t\tshape <- sphere(1+rnd(environment_size/50.0));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people number: nb_people {\n\t\t\tobstacle_consideration_distance <- P_obstacle_consideration_distance;\n\t\t\tobstacle_consideration_distance <- P_obstacle_consideration_distance;\n\t\t\tpedestrian_consideration_distance <- P_pedestrian_consideration_distance;\n\t\t\tshoulder_length <- P_shoulder_length;\n\t\t\tavoid_other <- P_avoid_other;\n\t\t\tproba_detour <- P_proba_detour;\n\t\t\tuse_geometry_waypoint <- P_use_geometry_waypoint;\n\t\t\ttolerance_waypoint <- P_tolerance_waypoint;\n\t\t\t\n\t\t\tpedestrian_model <- P_model_type;\n\t\t\tif (pedestrian_model = \"simple\") {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_simple;\n\t\t\t\tgama_SFM <- P_gama_SFM_simple;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_simple;\n\t\t\t\tn_prime_SFM <- P_n_prime_SFM_simple;\n\t\t\t\tn_SFM <- P_n_SFM_simple;\n\t\t\t} else {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n\t\t\t\tA_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n\t\t\t\tB_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n\t\t\t\tB_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_advanced;\n\t\t\t\tgama_SFM <- P_gama_SFM_advanced;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_advanced;\n\t\t\t\tminimal_distance <- P_minimal_distance_advanced;\n\t\t\t}\n\t\t\t\n\t\t\tpedestrian_species <- [people];\n\t\t\tobstacle_species<-[obstacle];\n\t\t\tswitch scenario {\n\t\t\t\tmatch \"frontal crossing\" {\n\t\t\t\t\tint id <- int(self);\n\t\t\t\t\tlocation <- any_location_in(even(id) ? left_space : right_space);\n\t\t\t\t\tcurrent_target <- closest_points_with(location, even(id) ? right_space : left_space)[1];\n\t\t\t\t} match \"perpendicular crossing\" {\n\t\t\t\t\tint id <- int(self);\n\t\t\t\t\tlocation <- any_location_in(even(id) ? left_space : bottom_space);\n\t\t\t\t\tcurrent_target <- closest_points_with(location, (even(id) ? right_space : top_space))[1];\n\t\t\t\t} match \"big crowd\" {\n\t\t\t\t\tlocation <- any_location_in(free_space);\n\t\t\t\t\tcurrent_target <- any_location_in(world.shape.contour);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex end_simulation when: empty(people) {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [pedestrian] schedules: shuffle(people) {\n\trgb color <- rnd_color(255);\n\tfloat speed <- 3 #km/#h;\n\tbool avoid_other <- true;\n\tpoint current_target ;\n\treflex move when: current_target != nil{\n\t\tif (nb_obstacles > 0) {\n\t\t\tdo walk_to target: current_target bounds: free_space;\n\t\t} else {\n\t\t\tdo walk_to target: current_target;\n\t\t}\n\t\tif (self distance_to current_target < 0.5) {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tif (display_circle_min_dist and minimal_distance > 0) {\n\t\t\t\tif not empty(people at_distance minimal_distance) {\n\t\t\t\t\tdraw circle(minimal_distance) color: #red;\n\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tdraw triangle(shoulder_length) color: color rotate: heading + 90.0;\n\t\t\n\t\tif  display_force {\n\t\t\n\t\t\tloop op over: forces.keys {\n\t\t\t\tif (species(agent(op)) = obstacle ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t\telse if ((agent(op)) = self ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nexperiment big_crowd type: gui {\n\t\n\tparameter var:display_force;\n\tparameter var:display_circle_min_dist;\n\tparameter var:P_shoulder_length;\n\tparameter var:P_proba_detour;\n\tparameter var:P_avoid_other;\n\tparameter var:P_obstacle_consideration_distance;\n\tparameter var:P_pedestrian_consideration_distance;\n\tparameter var:P_tolerance_waypoint;\n\tparameter var:P_use_geometry_waypoint;\n\tparameter var:P_model_type;\n\tparameter var:P_A_pedestrian_SFM_advanced category: \"SFM advanced\" ;\n\tparameter var:P_A_obstacles_SFM_advanced category: \"SFM advanced\" ;\n\tparameter var:P_B_pedestrian_SFM_advanced category: \"SFM advanced\" ;\n\tparameter var:P_B_obstacles_SFM_advanced category: \"SFM advanced\" ;\n\tparameter var:P_relaxion_SFM_advanced  category: \"SFM advanced\" ;\n\tparameter var:P_gama_SFM_advanced category: \"SFM advanced\" ;\n\tparameter var:P_lambda_SFM_advanced category: \"SFM advanced\" ;\n\tparameter var:P_minimal_distance_advanced category: \"SFM advanced\" ;\n\tparameter var:P_n_prime_SFM_simple category: \"SFM simple\" ;\n\tparameter var:P_n_SFM_simple category: \"SFM simple\" ;\n\tparameter var:P_lambda_SFM_simple category: \"SFM simple\" ;\n\tparameter var:P_gama_SFM_simple category: \"SFM simple\" ;\n\tparameter var:P_relaxion_SFM_simple category: \"SFM simple\" ;\n\tparameter var:P_A_pedestrian_SFM_simple category: \"SFM simple\" ;\n\t\n\t\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"big crowd\", nb_people::500];\n\t}\n\toutput {\n\t\tdisplay map  {\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n\nexperiment frontal_crossing type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"frontal crossing\", nb_people::100];\n\t}\n\toutput {\n\t\tdisplay map  {\n\t\t\tgraphics \"areas\" transparency: 0.5{\n\t\t\t\tdraw right_space color: #green border: #black;\n\t\t\t\tdraw left_space color: #red border: #black;\n\t\t\t}\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\nexperiment perpendicular_crossing type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"perpendicular crossing\", nb_people::100];\n\t}\n\t\n\toutput {\n\t\tdisplay map  {\n\t\t\tgraphics \"areas\" transparency: 0.7{\n\t\t\t\tdraw right_space color: #green border: #black;\n\t\t\t\tdraw left_space color: #red border: #black;\n\t\t\t\tdraw bottom_space color: #yellow border: #black;\n\t\t\t\tdraw top_space color: #magenta border: #black;\n\t\t\t}\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}"}
{"prompt": "Simulate a complex urban environment with pedestrians navigating through walls and open areas, using different pedestrian movement models and displaying various simulation parameters.", "gaml_code": "/***\n* Name: pedestrian_complex_environment\n* Author: Patrick Taillandier\n* Description: show how to use the pedestrian skill for complex envorinment - require to generate pedestrian paths before - see model \"Generate Pedestrian path.gaml\" \n* Tags: pedestrian, gis, shapefile, graph, agent_movement, skill, transport\n***/\n\nmodel pedestrian_complex_environment\n\nglobal {\n\t\n\tfile wall_shapefile <- file(\"../includes/walls.shp\");\n\t\n\tshape_file free_spaces_shape_file <- shape_file(\"../includes/free spaces.shp\");\n\tshape_file open_area_shape_file <- shape_file(\"../includes/open area.shp\");\n\tshape_file pedestrian_paths_shape_file <- shape_file(\"../includes/pedestrian paths.shp\");\n\n\t\n\tgraph network;\n\t\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tbool display_free_space <- false;\n\tbool display_force <- false;\n\tbool display_target <- false;\n\tbool display_circle_min_dist <- true;\n\tfloat P_shoulder_length <- 0.45;\n\tfloat P_proba_detour <- 0.5;\n\tbool P_avoid_other <- true;\n\tfloat P_obstacle_consideration_distance <- 3.0;\n\tfloat P_pedestrian_consideration_distance <- 3.0;\n\tfloat P_tolerance_target <- 0.1;\n\tbool P_use_geometry_target <- true;\n\t\n\t\n\tstring P_model_type <- \"simple\" among: [\"simple\", \"advanced\"];\t\n\tfloat P_A_pedestrian_SFM_advanced <- 0.16 ;\n\tfloat P_A_obstacles_SFM_advanced <- 1.9 ;\n\tfloat P_B_pedestrian_SFM_advanced <- 0.1 ;\n\tfloat P_B_obstacles_SFM_advanced <- 1.0 ;\n\tfloat P_relaxion_SFM_advanced  <- 0.5 ;\n\tfloat P_gama_SFM_advanced <- 0.35 ;\n\tfloat P_lambda_SFM_advanced <- 0.1 ;\n\tfloat P_minimal_distance_advanced <- 0.25;\t\n\tfloat P_n_prime_SFM_simple <- 3.0 ;\n\tfloat P_n_SFM_simple <- 2.0 ;\n\tfloat P_lambda_SFM_simple <- 2.0 ;\n\tfloat P_gama_SFM_simple <- 0.35 ;\n\tfloat P_relaxion_SFM_simple <- 0.54 ;\n\tfloat P_A_pedestrian_SFM_simple <-4.5;\n\t\n\tfloat step <- 0.1;\n\tint nb_people <- 250;\n\n\tgeometry open_area ;\n\t\n\tinit {\n\t\topen_area <- first(open_area_shape_file.contents);\n\t\tcreate wall from:wall_shapefile;\n\t\tcreate pedestrian_path from: pedestrian_paths_shape_file {\n\t\t\tlist<geometry> fs <- free_spaces_shape_file overlapping self;\n\t\t\tfree_space <- fs first_with (each covers shape); \n\t\t}\n\t\t\n\n\t\tnetwork <- as_edge_graph(pedestrian_path);\n\t\t\n\t\task pedestrian_path {\n\t\t\tdo build_intersection_areas pedestrian_graph: network;\n\t\t}\n\t\n\t\tcreate people number:nb_people{\n\t\t\tlocation <- any_location_in(one_of(open_area));\n\t\t\tobstacle_consideration_distance <-P_obstacle_consideration_distance;\n\t\t\tpedestrian_consideration_distance <-P_pedestrian_consideration_distance;\n\t\t\tshoulder_length <- P_shoulder_length;\n\t\t\tavoid_other <- P_avoid_other;\n\t\t\tproba_detour <- P_proba_detour;\n\t\t\t\n\t\t\tuse_geometry_waypoint <- P_use_geometry_target;\n\t\t\ttolerance_waypoint<- P_tolerance_target;\n\t\t\tpedestrian_species <- [people];\n\t\t\tobstacle_species<-[wall];\n\t\t\t\n\t\t\tpedestrian_model <- P_model_type;\n\t\t\t\n\t\t\n\t\t\tif (pedestrian_model = \"simple\") {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_simple;\n\t\t\t\tgama_SFM <- P_gama_SFM_simple;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_simple;\n\t\t\t\tn_prime_SFM <- P_n_prime_SFM_simple;\n\t\t\t\tn_SFM <- P_n_SFM_simple;\n\t\t\t} else {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n\t\t\t\tA_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n\t\t\t\tB_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n\t\t\t\tB_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_advanced;\n\t\t\t\tgama_SFM <- P_gama_SFM_advanced;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_advanced;\n\t\t\t\tminimal_distance <- P_minimal_distance_advanced;\n\t\t\t\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\treflex stop when: empty(people) {\n\t\tdo pause;\n\t}\n\t\n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n\taspect default { \n\t\tdraw shape  color: #gray;\n\t}\n\taspect free_area_aspect {\n\t\tif(display_free_space and free_space != nil) {\n\t\t\tdraw free_space color: #lightpink border: #black;\n\t\t}\n\t\t\n\t}\n}\n\nspecies wall {\n\tgeometry free_space;\n\tfloat high <- rnd(10.0, 20.0);\n\t\n\taspect demo {\n\t\tdraw shape border: #black depth: high texture: [\"../includes/top.png\",\"../includes/texture5.jpg\"];\n\t}\n\t\n\taspect default {\n\t\tdraw shape + (P_shoulder_length/2.0) color: #gray border: #black;\n\t}\n}\n\nspecies people skills: [pedestrian]{\n\trgb color <- rnd_color(255);\n\tfloat speed <- gauss(5,1.5) #km/#h min: 2 #km/#h;\n\n\treflex move  {\n\t\tif (final_waypoint = nil) {\n\t\t\tdo compute_virtual_path pedestrian_graph:network target: any_location_in(open_area) ;\n\t\t}\n\t\tdo walk ;\n\t}\t\n\t\n\taspect default {\n\t\t\n\t\tif display_circle_min_dist and minimal_distance > 0 {\n\t\t\tdraw circle(minimal_distance).contour color: color;\n\t\t}\n\t\t\n\t\tdraw triangle(shoulder_length) color: color rotate: heading + 90.0;\n\t\t\n\t\tif display_target and current_waypoint != nil {\n\t\t\tdraw line([location,current_waypoint]) color: color;\n\t\t}\n\t\tif  display_force {\n\t\t\tloop op over: forces.keys {\n\t\t\t\tif (species(agent(op)) = wall ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t\telse if ((agent(op)) = self ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\n\nexperiment normal_sim type: gui {\n\t\n\t\n\tparameter \"display free space\" var:display_free_space;\n\tparameter \"display force\" var:display_force;\n\tparameter \"display target\" var:display_target; \n\tparameter \"display circle_min_dist\" var:display_circle_min_dist;\n\tparameter \"P shoulder_length\" var:P_shoulder_length;\n\tparameter \"P proba_detour\" var:P_proba_detour;\n\tparameter \"P avoid_other\" var:P_avoid_other;\n\tparameter \"P obstacle_consideration_distance\" var:P_obstacle_consideration_distance;\n\tparameter \"P pedestrian_consideration_distance\" var:P_pedestrian_consideration_distance;\n\tparameter \"P tolerance_target\" var:P_tolerance_target;\n\tparameter \"P use_geometry_target\" var:P_use_geometry_target;\n\n\n\tparameter \"P model_type\" var:P_model_type among: [\"simple\", \"advanced\"]; \n\n\tparameter \"P A_pedestrian_SFM_advanced\" var:P_A_pedestrian_SFM_advanced   category: \"SFM advanced\";\n\tparameter \"P A_obstacles_SFM_advanced\" var:P_A_obstacles_SFM_advanced   category: \"SFM advanced\";\n\tparameter \"P B_pedestrian_SFM_advanced\" var:P_B_pedestrian_SFM_advanced   category: \"SFM advanced\";\n\tparameter \"P B_obstacles_SFM_advanced\" var:P_B_obstacles_SFM_advanced   category: \"SFM advanced\";\n\tparameter \"P relaxion_SFM_advanced\" var:P_relaxion_SFM_advanced    category: \"SFM advanced\";\n\tparameter \"P gama_SFM_advanced\" var:P_gama_SFM_advanced category: \"SFM advanced\";\n\tparameter \"P lambda_SFM_advanced\" var:P_lambda_SFM_advanced   category: \"SFM advanced\";\n\tparameter \"P minimal_distance_advanced\" var:P_minimal_distance_advanced   category: \"SFM advanced\";\n\n\tparameter \"P n_prime_SFM_simple\" var:P_n_prime_SFM_simple   category: \"SFM simple\";\n\tparameter \"P n_SFM_simple\" var:P_n_SFM_simple   category: \"SFM simple\";\n\tparameter \"P lambda_SFM_simple\" var:P_lambda_SFM_simple   category: \"SFM simple\";\n\tparameter \"P gama_SFM_simple\" var:P_gama_SFM_simple   category: \"SFM simple\";\n\tparameter \"P relaxion_SFM_simple\" var:P_relaxion_SFM_simple   category: \"SFM simple\";\n\tparameter \"P A_pedestrian_SFM_simple\" var:P_A_pedestrian_SFM_simple   category:\"SFM simple\";\n\t\n\t\n\tfloat minimum_cycle_duration <- 0.02;\n\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n\t\t\tspecies pedestrian_path refresh: false;\n\t\t\tspecies people;\n\t\t}\n\t}\n}"}
{"prompt": "How to display a small field using GAML and OpenGL in a GUI experiment.", "gaml_code": "/**\n* Name: Issue3776\n* Demonstrates how very small fields can be displayed \n* See https://github.com/gama-platform/gama.old/issues/3776\n* Author: drogoul\n* Tags: \n*/\n\n\nmodel Issue3776\n\nglobal {\n\tfield f <- field(matrix([1],[5]));\n}\n\nexperiment Issue3776 type: gui {\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tmesh f grayscale: true ;\n\t\t}\n\t\tdisplay map_image  {\n\t\t\tgraphics \"image\" {\n\t\t\t\tdraw image(f);\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Verify that GAML files load and gather attributes correctly, specifically for Issue 3579 on the Gama Platform.", "gaml_code": "/**\n* Name: Issue3579\n* Verifies that the fields are correctly loaded and gathered for GAML files \n* See https://github.com/gama-platform/gama.old/issues/3579\n* Author: A. Drogoul\n* Tags: files,attributes,metadata\n*/\n\n\nmodel Issue3579\n\nimport \"Issue 3570.gaml\"\n\nglobal {\n\tinit {\n\t\tgaml_file ff <- gaml_file(\"Issue 3579.gaml\");\n\t\twrite ff.experiments; // Only the experiments defined in this file are listed, not the ones imported\n\t\twrite ff.tags; // try adding new tags and run the model again\n\t\twrite ff.uses; // if no file is used (resp. imported) these fields return an empty list\n\t\twrite ff.imports; \n\t\twrite ff.valid; // whether the file is syntactically valid or not\n\t}\n}\n\nexperiment \"Test it\";"}
{"prompt": "Create a GAML model that demonstrates and tests the assertion of an error condition with a custom label.", "gaml_code": "/**\n* Name: Issue3624\n* A simple model to verify that issue #3624 has been addressed  \n* See https://github.com/gama-platform/gama.old/issues/3624\n* Author: A. Drogoul\n* Tags: assert, test\n*/\n\n\nmodel Issue3624\n\nglobal {\n\tinit {\n\t\tint i <- 100;\n\t\t// The custom label should be added to the error raised by assert\n\t\tassert i < 100 label: \"Var i should be greater than 100 !\";\n\t}\n}\n\nexperiment \"Verify me\";"}
{"prompt": "Test a GAML model that generates charts for every combination of OS and hardware, using Issue #3570 fixes.", "gaml_code": "/**\n* Name: Issue3570\n* Tests whether the two fixes provided in Issue #3570 are working on every combination of OS and hardware. \n* See https://github.com/gama-platform/gama.old/issues/3570\n* Author: A. Drogoul\n* Tags: chart, display, snapshot\n*/\nmodel Issue3570\n\nglobal {}\n\nexperiment 'Verify me' {\n\toutput synchronized: true { // should be synchronized by default\n\t\tdisplay \"One chart\" autosave: {1000, 1000} every 100 #cycle type: 2d {\n\t\t\t// 1000x1000 images should be saved in the 'snapshot' folder every 100 cycles\n\t\t\tchart \"One series\"  {\n\t\t\t\tdata \"Data one\" value: rnd(100);\n\t\t\t\tdata \"Data two\" value: rnd(100);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Verify that a GAML model can save simple text files without specifying a file format.", "gaml_code": "/**\n* Name: Issue3660\n* Verifies that the absence of a format for a file to save does not prevent from saving simple text files\n* See https://github.com/gama-platform/gama.old/issues/3660 \n* Author: Alexis Drogoul\n* Tags: save, data, file\n*/\n\n\nmodel Issue3660\n\nglobal {\n    init {\n        string info <- \"\"  + 3 +\"\\n0.0\\n0.0\\n\"+4+\"\\n\"+\"\\n\"+42;\n//      save info to: \"res/satellite.pgw\"; // A warning should be emitted when uncommenting this line\n        save info to: \"res/satellite.pgw\" format: \"text\"; // An info should be emitted\n        save info to: \"res/satellite.txt\" format: \"txt\"; // Nothing should be emitted\n    }\n}\nexperiment name type: gui { }"}
{"prompt": "Create a GAML model that demonstrates the ability to save shape files multiple times without issues.", "gaml_code": "/**\n* Name: Issue3685\n* Demonstrates that the issue reported in #3685 does not exist anymore (shape files could not be saved twice in a row). \n* See https://github.com/gama-platform/gama.old/issues/3685\n* Author: Alexis Drogoul\n* Tags: \n*/\n\n\nmodel Issue3685\n\n/* Insert your model definition here */\n\n\nglobal {\n\t\n\tinit {\n\t\tsave self to:\"test.shp\" format:\"shp\" rewrite:true;\n\t}\n}\n\nexperiment a;"}
{"prompt": "Create a GAML model to test issue #3649 related to abort functionality in both GUI and Batch modes.", "gaml_code": "/**\n* Name: Issue3649\n* Model created to test Issue #3649\n* See https://github.com/gama-platform/gama.old/issues/3649\n* Author: A. Drogoul\n* Tags: batch, abort\n*/\n\n\nmodel Issue3649\n\nglobal {\n\t\n\tabort {\n\t\t// This sentence should be written whatever the type of experiment used (GUI or Batch)\n\t\twrite \"The simulation is aborted\";\n\t}\n}\n\n\nexperiment 'Verify me in GUI' {\n\tinit {\n\t\task simulations {\n\t\t\tdo die;\n\t\t}\n\t}\n}\n\nexperiment 'Verify me in Batch' type: batch until: cycle > 1 autorun: true keep_simulations: false;"}
{"prompt": "Test and demonstrate various loop constructs in a programming language, including for loops over lists, ranges, and species, as well as while loops with different conditions.", "gaml_code": "/**\n* Name: Loops\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n@no_warning\nmodel Loops\n\nspecies dummy {\n\tint value;\n}\n\nexperiment loop_over type:test{\n\t\n\ttest loop_over_list_int {\n\t\tlet l <- [1,2,3,4];\n\t\tint sum <- 0;\n\t\tloop v over:l{\n\t\t\tsum <- sum + v;\n\t\t}\n\t\tassert sum = 10;\n\t\t\n\t}\n\t\n\ttest loop_over_empty_list{\n\t\tloop v over:[] {\n\t\t\tassert false; // this should never happen as the list is empty\n\t\t}\n\t\tassert true;\n\t}\n\t\n\ttest loop_over_species {\n\t\tint i <- 1;\n\t\tcreate dummy number:4{\n\t\t\tvalue <- i;\n\t\t\ti <- i + 1;\n\t\t}\n\t\t\n\t\tint sum <- 0;\n\t\tloop d over:dummy{\n\t\t\tsum <- sum + d.value;\n\t\t}\n\t\tassert sum = 10;\n\t\task dummy {\n\t\t\tdo die;\n\t\t}\n\t}\n\t\n\ttest loop_over_empty_species {\n\t\tint sum <- 0;\n\t\tloop d over: dummy{\n\t\t\tsum <- sum + d.value;\n\t\t}\n\t\tassert sum = 0;\n\t}\n\t\n\t\t\n\t// when we iterate over nil, nothing in the loop is executed and no exception is raised\n\ttest loop_over_nil {\n\t\tbool exception_thrown <- false;\n\t\tbool code_executed <- true;\n\t\ttry {\n\t\t\tloop i over:nil {\n\t\t\t\tassert false; // this code is not executed\n\t\t\t}\t\n\t\t\t// if there's any code here, it should be executed\n\t\t\tcode_executed <- true;\t\n\t\t}\n\t\tcatch {\n\t\t\texception_thrown <- true;\n\t\t}\n\t\tassert not exception_thrown and code_executed;\n\t}\n\t\n\ttest loop_over_list_int_break {\n\t\tlet l <- [1,2,3,4];\n\t\tint sum <- 0;\n\t\tloop v over:l{\n\t\t\tsum <- sum + v;\n\t\t\tbreak;\n\t\t}\n\t\tassert sum = 1;\n\t\t\n\t}\n\t\n}\n\nexperiment loop_times type:test{\n\t\n\ttest loop_times {\n\t\tint i <- 1;\n\t\tint sum <- 0;\n\t\tloop times:4 {\n\t\t\tsum <- sum + i;\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert sum = 10;\n\t}\n\t\n\t\n\ttest loop_zero_times {\n\t\tint i <- 1;\n\t\tint sum <- 0;\n\t\tloop times:0 {\n\t\t\tsum <- sum + i;\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert sum = 0;\n\t}\n\t\n\ttest loop_negative_times {\n\t\tint i <- 1;\n\t\tint sum <- 0;\n\t\tloop times:-4 {\n\t\t\tsum <- sum + i;\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert sum = 0;\n\t}\t\n\n\t\n\t// here the float is going to be truncated and not rounded\n\ttest loop_float_times {\n\t\tint i <- 1;\n\t\tint sum <- 0;\n\t\tloop times:3.7 {\n\t\t\tsum <- sum + i;\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert sum = 6;\n\t}\n\t\n\t// when times is nil nothing in the loop is executed and no exception is risen\n\ttest loop_nil_times {\n\t\tbool exception_thrown <- false;\n\t\tbool code_executed <- true;\n\t\ttry {\n\t\t\tloop times:nil {\n\t\t\t\tassert false; // this code is not executed\n\t\t\t}\t\t\n\t\t\t// if there's any code here, it should be executed\n\t\t\tcode_executed <- true;\t\n\t\t}\n\t\tcatch {\n\t\t\texception_thrown <- true;\n\t\t}\n\t\tassert not exception_thrown and code_executed;\n\t}\n\t\n\ttest loop_string_times{\n\t\tbool exception_thrown <- false;\n\t\tbool code_executed <- true;\n\t\ttry{\n\t\t\tloop times:\"two\"{\n\t\t\t\tassert false; // should never be executed\n\t\t\t}\t\n\t\t\t// if there's any code here, it should be executed\n\t\t\tcode_executed <- true;\t\n\t\t}\n\t\tcatch {\n\t\t\texception_thrown <- true;\n\t\t}\n\t\tassert not exception_thrown and code_executed;\n\t}\n\t\n\t\n\ttest loop_times_break {\n\t\tint i <- 1;\n\t\tint sum <- 0;\n\t\tloop times:4 {\n\t\t\tsum <- sum + i;\n\t\t\ti <- i + 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert sum = 1;\n\t}\n\t\n}\n\nexperiment loop_from_to type:test{\n\t\t\n\n\ttest loop_from_to {\n\t\tint sum <- 0;\n\t\tloop i from:1 to: 4 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 10;\n\t}\n\t\n\ttest loop_from_negative_to_positive {\n\t\tint sum <- 0;\n\t\tloop i from:-1 to: 4 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 9;\n\t}\n\n\t\n\ttest loop_from_negative_to_negative {\n\t\tint sum <- 0;\n\t\tloop i from:-1 to: -4 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = -10;\n\t}\n\t\n\t\n\ttest loop_to_from{\n\t\tint sum <-0;\n\t\tloop i from:4 to: 1 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 10;\t\t\n\t}\n\n\ttest loop_from_to_step {\n\t\tint sum <- 0;\n\t\tloop i from:1 to: 4 step:1 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 10;\n\t}\n\t\n\t\n\ttest loop_from_to_step_2 {\n\t\tint sum <- 0;\n\t\tloop i from:1 to: 5 step:2 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = (1 + 3 + 5);\n\t}\n\t\n\t// In that case it should loop forever\n\ttest loop_infinite_loop_negative_step_ints {\n\t\tbool success <- false;\n\t\tloop i from:1 to: 5 step:-1 {\n\t\t\tif i < -10 {// arbitrary number just to make sure we have made a few iterations already\n\t\t\t\tsuccess <- true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert success; // as it's infinite loop we should never reach this\n\t}\n\t\n\t// same as the previous one but looping in the other direction\n\ttest loop_infinite_loop_positive_step_ints {\n\t\tbool success <- false;\n\t\tloop i from:5 to: 1 step:1 {\n\t\t\tif i > 10 {// arbitrary number just to make sure we have made a few iterations already\n\t\t\t\tsuccess <- true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert success; // as it's infinite loop we should never reach this\n\t}\n\t\n\t// same as the previous one but with floats\n\ttest loop_infinite_loop_positive_step_floats {\n\t\tbool success <- false;\n\t\tloop i from:5.0 to: 1.0 step:1.0 {\n\t\t\tif i > 10 {// arbitrary number just to make sure we have made a few iterations already\n\t\t\t\tsuccess <- true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert success; // as it's infinite loop we should never reach this\t\n\t}\n\t\n\t\n\t// same as the previous one but looping in the other direction\n\ttest loop_infinite_loop_negative_step_floats {\n\t\tbool success <- false;\n\t\tloop i from:1.0 to: 5.0 step:-1.0 {\n\t\t\tif i < -10 {// arbitrary number just to make sure we have made a few iterations already\n\t\t\t\tsuccess <- true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert success; // as it's infinite loop we should never reach this\t\n\t}\n\t\n\t\n\t// In the case of a floating step, the value of the loop will automatically \n\t// become a float, even if from and to are integers\n\ttest loop_integer_from_to_and_floating_step {\n\t\tfloat sum <- 0.0;\n\t\tloop i from:1 to: 5 step:1.6 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 1.0 + 2.6 + 4.2;\n\t}\n\t\n\ttest loop_floating_from_to{\n\t\tfloat sum <- 0.0;\n\t\tloop i from:1.0 to: 4.0 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 10.0;\t\t\n\t}\n\t\n\ttest loop_floating_from_to_step{\n\t\tfloat sum <- 0.0;\n\t\tloop i from:0.0 to: 4.0 step:0.8 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 0.8 + 1.6 + 2.4 + 3.2 + 4.0;\t\t\n\t}\n\t\n\ttest loop_floating_to_from {\n\t\tfloat sum <- 0.0;\n\t\tloop i from:4.0 to: 1.0 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 10.0;\t\t\n\t}\n\t\n\t\t\n\ttest loop_floating_to_from_step {\n\t\tfloat sum <- 0.0;\n\t\tloop i from:4.0 to: 1.0 step:-2.0 {\n\t\t\tsum <- sum + i;\n\t\t}\n\t\tassert sum = 6.0;\t\t\n\t}\n\t\n\t\n\t\t\n\t//break statements are able to get out of this loop\n\ttest loop_from_to_break{\n\t\tfloat sum <- 0.0;\n\t\tloop i from:4.0 to: 1.0 step:-2.0 {\n\t\t\tsum <- sum + i;\n\t\t\tbreak;\n\t\t}\n\t\tassert sum = 4.0;\t\n\t}\n\t\n\ttest loop_from_to_equal_int {\n\t\tint iterations <- 0;\n\t\tloop i from: 1 to: 1 {\n\t\t\titerations <- iterations+1;\n\t\t}\n\t\tassert iterations = 1;\n\t}\n\t\n\t\ttest loop_from_to_equal_float{\n\t\tint iterations <- 0;\n\t\tloop i from: 1.0 to: 1.0 {\n\t\t\titerations <- iterations+1;\n\t\t}\n\t\tassert iterations = 1;\n\t}\n\t\n\t\n}\n\n\nexperiment loop_while type:test{\n\t\n\ttest loop_while {\n\t\tint i <- 0;\n\t\t\n\t\tloop while:i < 10 {\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert i = 10;\n\t}\n\t\n\t// unlike do/while loops in some other programming languages, here if the condition is not met\n\t// since the beginning, we don't iterate even once.\n\ttest loop_while_initially_wrong {\n\t\tint i <- 0;\n\t\t\n\t\tloop while:i = 10 {\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert i = 0;\n\t}\n\t\n\t// in case the condition is nil we don't iterate at all\n\ttest loop_while_nil_condition {\n\t\tint i <- 0;\n\t\t\n\t\tloop while:nil {\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert i = 0;\n\t}\n\t\n\t// In case of a string condition too we do not iterate\n\ttest loop_while_string_condition {\n\t\tint i <- 0;\n\t\t\n\t\tloop while:\"rocambolesque\" {\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert i = 0;\n\t}\n\t\n\t// In case of a list we iterate until it's empty\n\ttest loop_while_empty_list {\n\t\tint i <- 0;\n\t\t\n\t\tloop while:[] {\n\t\t\ti <- i + 1;\n\t\t}\n\t\tassert i = 0;\n\t}\n\t\n\t// In case the list contains something we iterate \n\ttest loop_while_list {\n\t\tint i <- 0;\n\t\tlist l <- [4,\"banana\",5, false, [], true];\n\t\tloop while:l {\n\t\t\ti <- i + 1;\n\t\t\tremove from:l index:0;\n\t\t}\n\t\tassert i = 6;\n\t}\n\t\n\t// a list containing only an empty list is still not empty itself so we should also iterate in that case\n\ttest loop_while_list_of_empty_list {\n\t\tint i <- 0;\n\t\tlist l <- [[]];\n\t\tloop while:l {\n\t\t\ti <- i + 1;\n\t\t\tremove from:l index:0;\n\t\t}\n\t\tassert i = 1;\n\t}\n\t\n\t//break statements are able to get out of this loop\n\ttest loop_while_break{\n\t\tint i <- 0;\n\t\t\n\t\tloop while:i < 10 {\n\t\t\ti <- i + 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert i = 1;\n\t}\n\t\n}"}
{"prompt": "Create a model that demonstrates a 'no-protocol' interaction protocol using FIPA standards, where two agents (Initiator and Participant) engage in a conversation with flexible message exchange and termination.", "gaml_code": "/**\n* Name: FIPA no protocol\n* Author:\n* Description: This model demonstrates a usecase of 'no-protocol' interaction protocol.\n* \n* 'no-protocol' is a freestyle interaction protocol in which the modeler\n* \n* \t\t(1) can send whatever type of message (i.e., message performative) in the corresponding conversation\n* \n* \t\t(2) is responsible for marking the end of the conversation by sending a message with 'end_conversation' performative. \n* Tags: fipa\n*/\nmodel no_protocol_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; mailbox: ' + string(mailbox);\n\t}\n\n\treflex say_hello when: (time = 1) {\n\t\tdo start_conversation to: [p] protocol: 'no-protocol' performative: 'inform' contents: [ ('Hello from ' + name)] ;\n\t}\n\t\n\treflex read_hello_from_participant when: (time = 3) {\n\t\tloop i over: informs {\n\t\t\twrite name + ' receives message with content: ' + string(i.contents);\n\t\t\tdo inform message: i contents: [ ('Goodbye from ' + name)] ;\n\t\t}\n\t}\n\t\n\treflex read_rebound_goodbye when: (time = 5) {\n\t\tloop i over: mailbox {\n\t\t\twrite name + ' receives message with content: ' + string(i.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; mailbox: ' + string(mailbox);\n\t}\n\n\treflex reply_hello when: (time = 2) {\n\t\tloop m over: informs {\n\t\t\twrite name + ' receives message with content: ' + (string(m.contents));\n\t\t\tdo inform message: m contents: [ ('Rebound hello from ' + name) ] ;\n\t\t}\n\t}\n\t\n\treflex read_goodbye when: (time = 4) {\n\t\tloop i over: informs {\n\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\n\t\t\tdo end_conversation message: i contents: [ ('Rebound goodbye from' + name) ] ;\n\t\t}\n\t}\n}\n\nexperiment test_no_protocol type: gui {}"}
{"prompt": "Implement a model demonstrating the FIPA Request interaction protocol using GAML, including Initiator and Participant agents exchanging messages.", "gaml_code": "/**\n* Name: FIPA Request\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Request interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n* \n* \n* The Initiator agent begins the 'fipa-request' conversation/interaction protocol by sending a 'request' \n* message to the Participant agent with 'go sleeping' as content.\n* \n* On receiving the 'request' message, the Participant agent replies with a 'refuse' message.\n* \n* After the Initiator reads the 'refuse' message, the 'fipa-request' conversation ends.\n* Tags: fipa\n*/\nmodel fipa_request_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-request' performative: 'request' contents: ['go sleeping'] ;\n\t}\n\t\n\treflex read_refuse_message when: !(empty(refuses)) {\n\t\twrite 'read refuse messages';\n\t\tloop r over: refuses {\n\t\t\twrite 'refuse message with content: ' + string(r.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\n\treflex reply_messages when: (!empty(requests)) {\n\t\twrite name + ' sends a refuse message';\n\t\tdo refuse message: (requests at 0) contents: ['I don\\'t want'] ;\n\t}\n}\n\n\n\nexperiment test_request_interaction_protocol type: gui {}"}
{"prompt": "Implement the FIPA Contract Net interaction protocol for 5 participants, including an initiator and 4 proposers, with specific message exchanges and outcomes.", "gaml_code": "/**\n* Name: FIPA Contract Net (2)\n* Author:\n* Description: This model demonstrates a use-case of the FIPA Contract Net interaction protocol. \n* \n* \n* One initiator sends a 'cfp' message to 5 participants.\n* \n* The first participant (participant0) replies with a refuse message.\n* \n* Four participants (participant1, participant2, participant3, participant4) reply with four propose messages.\n* \n* \n* When the initiator receives the propose messages, it proceeds as follows:\n* \n* The initiator replies to participant1 with a reject_proposal message.\n* \n* The initiator replies to participant2, participant3, participant4 with three accept_proposal messages respectively.\n* \n* \n* When participant2, participant3 and participant4 receive the accept_proposal messages from the initiator, they proceed as follows:\n* \n* Participant2 replies with a failure message.\n* \n* Participant3 replies with an inform_done message.\n* \n* Participant4 replies with an inform_result message.\n* Tags: fipa\n*/\n\nmodel cfp_cfp_2\n\nglobal {\n\tint nbOfParticipants <- 5;\n\tparticipant refuser;\n\tlist<participant> proposers;\n\tparticipant reject_proposal_participant;\n\tlist<participant> accept_proposal_participants ;\n\tparticipant failure_participant;\n\tparticipant inform_done_participant;\n\tparticipant inform_result_participant;\n\t\n\t\n\tinit {\n\t\tcreate initiator;\n\t\tcreate participant number: nbOfParticipants returns: ps;\n\t\t\n\t\trefuser <- ps[0];\n\t\t\n\t\tadd ps all: true to: proposers;\n\t\tremove refuser from: proposers;\n\t\t\n\t\treject_proposal_participant <- proposers[0];\n\t\t\n\t\tadd proposers all: true to: accept_proposal_participants;\n\t\tremove reject_proposal_participant from: accept_proposal_participants;\n\t\t\n\t\tfailure_participant <- accept_proposal_participants[0];\n\t\tinform_done_participant <- accept_proposal_participants[1];\n\t\tinform_result_participant <- accept_proposal_participants[2];\n\t\t\n\t\twrite 'Please step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies initiator skills: [fipa] {\n\t\n\treflex send_cfp_to_participants when: (time = 1) {\n\t\t\n\t\twrite '(Time ' + time + '): ' + name + ' sends a cfp message to all participants';\n\t\tdo start_conversation to: list(participant) protocol: 'fipa-contract-net' performative: 'cfp' contents: ['Go swimming'] ;\n\t}\n\t\n\treflex receive_refuse_messages when: !empty(refuses) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives refuse messages';\n\t\t\n\t\tloop r over: refuses {\n\t\t\twrite '\\t' + name + ' receives a refuse message from ' + agent(r.sender).name + ' with content ' + r.contents ;\n\t\t}\n\t}\n\t\n\treflex receive_propose_messages when: !empty(proposes) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives propose messages';\n\t\t\n\t\tloop p over: proposes {\n\t\t\twrite '\\t' + name + ' receives a propose message from ' + agent(p.sender).name + ' with content ' + p.contents ;\n\t\t\t\n\t\t\tif (p.sender = reject_proposal_participant) {\n\t\t\t\twrite '\\t' + name + ' sends a reject_proposal message to ' + p.sender;\n\t\t\t\tdo reject_proposal message: p contents: ['Not interested in your proposal'] ;\n\t\t\t} else {\n\t\t\t\twrite '\\t' + name + ' sends a accept_proposal message to ' + p.sender;\n\t\t\t\tdo accept_proposal message: p contents: ['Interesting proposal. Go do it'] ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex receive_failure_messages when: !empty(failures) {\n\t\tmessage f <- failures[0];\n\t\twrite '\\t' + name + ' receives a failure message from ' + agent(f.sender).name + ' with content ' + f.contents ;\n\t}\n\t\n\treflex receive_inform_messages when: !empty(informs) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives inform messages';\n\t\t\n\t\tloop i over: informs {\n\t\t\twrite '\\t' + name + ' receives a inform message from ' + agent(i.sender).name + ' with content ' + i.contents ;\n\t\t}\n\t}\n}\n\nspecies participant skills: [fipa] {\n\t\n\treflex receive_cfp_from_initiator when: !empty(cfps) {\n\t\t\n\t\tmessage proposalFromInitiator <- cfps[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a cfp message from ' + agent(proposalFromInitiator.sender).name + ' with content ' + proposalFromInitiator.contents;\n\t\t\n\t\tif (self = refuser) {\n\t\t\twrite '\\t' + name + ' sends a refuse message to ' + agent(proposalFromInitiator.sender).name;\n\t\t\tdo refuse message: proposalFromInitiator contents: ['I am busy today'] ;\n\t\t}\n\t\t\n\t\tif (self in proposers) {\n\t\t\twrite '\\t' + name + ' sends a propose message to ' + agent(proposalFromInitiator.sender).name;\n\t\t\tdo propose message: proposalFromInitiator contents: ['Ok. That sound interesting'] ;\n\t\t}\n\t}\n\t\n\treflex receive_reject_proposals when: !empty(reject_proposals) {\n\t\tmessage r <- reject_proposals[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a reject_proposal message from ' + agent(r.sender).name + ' with content ' + r.contents;\n\t}\n\t\n\treflex receive_accept_proposals when: !empty(accept_proposals) {\n\t\tmessage a <- accept_proposals[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a accept_proposal message from ' + agent(a.sender).name + ' with content ' + a.contents;\n\t\t\n\t\tif (self = failure_participant) {\n\t\t\twrite '\\t' + name + ' sends a failure message to ' + agent(a.sender).name;\n\t\t\tdo failure message: a contents: ['Failure'] ;\n\t\t}\n\t\t\n\t\tif (self = inform_done_participant) {\n\t\t\twrite '\\t' + name + ' sends an inform_done message to ' + agent(a.sender).name;\n\t\t\tdo inform message: a contents: ['Inform done'] ;\n\t\t}\n\t\t\n\t\tif (self = inform_result_participant) {\n\t\t\twrite '\\t' + name + ' sends an inform_result message to ' + agent(a.sender).name;\n\t\t\tdo inform message: a contents: ['Inform result'] ;\n\t\t}\n\t}\n}\n\nexperiment test type: gui { }"}
{"prompt": "Design a model that demonstrates the FIPA Request interaction protocol, including an Initiator agent and a Participant agent exchanging messages to request and respond to a task.", "gaml_code": "/**\n* Name: FIPA Request (2)\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Request interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n* \n* \n* The Initiator agent begins the 'fipa-request' conversation/interaction protocol by sending a 'request' \n* message to the Participant agent with 'go sleeping' as content.\n* \n* On receiving the 'request' message, the Participant agent replies with two consecutive messages : \n* \n* (1) an 'agree' message indicating that the Participant agent accepts to execute the request of the Initiator agent, \n* \n* (2) a 'failure' message indicating that the Participant agent fails to (can not) execute the requestion of the Initiator agent \n* (in this case, the Participant agent says that it can not go sleeping because the bed is broken!).\n* \n* After the Initiator reads the 'failure' message from the Participant, the corresponding conversation ends.\n* Tags: fipa\n*/\nmodel fipa_request_2\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-request' performative: 'request' contents: ['go sleeping'] ;\n\t}\n\t\n\treflex read_agree_message when: !(empty(agrees)) {\n\t\twrite 'read agree messages';\n\t\tloop a over: agrees {\n\t\t\twrite 'agree message with content: ' + string(a.contents);\n\t\t}\n\t}\n\t\n\treflex read_failure_message when: !(empty(failures)) {\n\t\twrite 'read failure messages';\n\t\tloop f over: failures {\n\t\t\twrite 'failure message with content: ' + (string(f.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\n\treflex reply_messages when: (!empty(requests)) {\n\t\tmessage requestFromInitiator <- (requests at 0);\n\t\twrite 'agree message';\n\t\tdo agree message: requestFromInitiator contents: ['I will'];\n\t\t\n\t\twrite 'inform the initiator of the failure';\n\t\tdo failure message: requestFromInitiator contents: ['The bed is broken'];\n\t}\n}\n\n\n\nexperiment test_request_interaction_protocol type: gui {}"}
{"prompt": "Implement a simulation of the FIPA Propose interaction protocol using NetLogo or similar agent-based modeling framework.", "gaml_code": "/**\n* Name: FIPA Propose\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Propose interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).\n* \n* \n* The Initiator agent begins the conversation/interaction protocol by sending a 'propose' \n* message to the Participant agent with 'Go swimming?' as content.\n* \n* On receiving the 'propose' message, the participant agent replies with an 'accept_proposal' message \n* indicating that it agrees to go swimming.\n* \n* After the Initiator agent reads the 'accept_proposal' message, the conversation ends.\n* Tags: fipa\n*/\nmodel fipa_propose_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_propose_message when: (time = 1) {\n\t\twrite name + ' sends a propose message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-propose' performative: 'propose' contents: ['Go swimming?'] ;\n\t}\n\t\n\treflex read_accept_proposals when: !(empty(accept_proposals)) {\n\t\twrite name + ' receives accept_proposal messages';\n\t\tloop i over: accept_proposals {\n\t\t\twrite 'accept_proposal message with content: ' + string(i.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex accept_proposal when: !(empty(proposes)) {\n\t\tmessage proposalFromInitiator <- proposes at 0;\n\t\t\n\t\tdo accept_proposal message: proposalFromInitiator contents: ['OK! It \\'s hot today!'] ;\n\t}\n}\n\nexperiment test_propose_interaction_protocol type: gui {}"}
{"prompt": "Design a model demonstrating the FIPA Request interaction protocol using GAMA, highlighting potential issues and exceptions.", "gaml_code": "/**\n * Name: FIPA Request (4)\n * Author:\n * Description: This model demonstrates a usecase of the FIPA Request interaction protocol. \n * (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n * \n * \n * The Initiator agent begins the 'fipa-request' conversation/intaction protocol by sending a 'request' \n * message to the Participant agent with 'go sleeping' as content.\n * \n * On receiving a 'request' message, the Participant agent replies with an 'inform' message. \n * According to the specification of the FIPA Requestion interaction protocol, the next possible messages \n * after receiving a 'request' message are either 'refuse' message or 'agree' message. \n * Hence replying with an 'inform' message upon receiving a 'request' message violates the protocol specification. \n * GAMA will hence raise a GamaRuntimeException. \n * A conversation is automatically ended in case of GamaRuntimeException raised. Hence this conversation ends.\n * Tags: fipa\n */\nmodel fipa_request_4\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-request' performative: 'request' contents: ['go sleeping'] ;\n\t}\n\t\n\treflex read_refuse_message when: !(empty(refuses)) {\n\t\twrite 'read refuse messages';\n\t\tloop r over: refuses {\n\t\t\twrite 'refuse message with content: ' + string(r.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\n\treflex reply_messages when: (!empty(requests)) {\n\t\twrite name + ' sends an inform message';\n\t\t\n\t\t\n\t\twrite 'A GamaRuntimeException is raised to inform that the message\\'s performative doesn\\'t respect the \\'request\\' interaction protocol\\' specification';\n\t\tdo inform message: (requests at 0) contents: ['I don\\'t want'] ; // Attention: note that GAMA will raise an exception because an 'inform' message is not appropriate here.\n\t}\n}\n\n\nexperiment test_request_interaction_protocol type: gui {}"}
{"prompt": "Implement a simulation of the FIPA Request interaction protocol using GAML, including an Initiator and Participant agent exchanging messages.", "gaml_code": "/**\n* Name: FIPA Request (3)\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Request interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n* \n* \n* The Initiator agent begins the 'fipa-request' conversation/interaction protocol by sending a 'request'  \n* message to the Participant agent with 'go sleeping' as content.\n* \n* On receiving the 'request' message, the Participant replies with two consecutive messages :\n* \n* (1) an 'agree' message indicating that the Participant agent accepts to execute the request of the Initiator agent,\n* \n* (2) an 'inform' message indicating that the Participant agent has already executed the request of the Initiator agent \n* (in this case, the 'inform' message informs the Initiator that the Participant agent has already gone to bed!).\n* \n* After the Initiator agent reads the 'inform' message, the conversation ends.\n* Tags: fipa\n*/\nmodel fipa_request_3\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-request' performative: 'request' contents: ['go sleeping'] ;\n\t}\n\n\treflex read_agree_message when: !(empty(agrees)) {\n\t\twrite 'read agree messages';\n\t\tloop a over: agrees {\n\t\t\twrite 'agree message with content: ' + string(a.contents);\n\t\t}\n\t}\n\t\n\treflex read_inform_message when: !(empty(informs)) {\n\t\twrite 'read inform messages';\n\t\tloop i over: informs {\n\t\t\twrite 'inform message with content: ' + string(i.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + string(conversations) + '; messages: ' + string(mailbox);\n\t}\n\n\treflex reply_messages when: (!empty(requests)) {\n\t\tmessage requestFromInitiator <- (requests at 0);\n\t\twrite 'agree message';\n\t\tdo agree message: requestFromInitiator contents: ['I will'] ;\n\t\t\n\t\twrite 'inform the initiator';\n\t\tdo inform message: requestFromInitiator contents: ['I\\'m in bed already'] ;\n\t}\n}\n\n\n\nexperiment test_request_interaction_protocol type: gui {}"}
{"prompt": "Implement a simulation of the FIPA Contract Net interaction protocol using GAML, where one initiator sends a 'cfp' message to multiple participants and all participants reply with a 'refuse' message.", "gaml_code": "/**\n* Name: FIPA Contract Net\n* Author:\n* Description: This model demonstrates a use-case of the FIPA Contract Net interaction protocol. \n* One initiator sends a 'cfp' message to other participants. \n* All participants reply with a 'refuse' messages which end the interaction protocol.\n* Tags: fipa\n*/\n\nmodel cfp_cfp_1\n\nglobal {\n\tint nbOfParticipants <- 5;\n\t\n\tinit {\n\t\tcreate initiator;\n\t\tcreate participant number: nbOfParticipants;\n\n\t\twrite 'Please step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies initiator skills: [fipa] { \n\t\n\treflex send_cfp_to_participants when: (time = 1) {\n\t\t\n\t\twrite '(Time ' + time + '): ' + name + ' sends a cfp message to all participants';\n\t\tdo start_conversation to: list(participant) protocol: 'fipa-contract-net' performative: 'cfp' contents: ['Go swimming'];\n\t}\n\t\n\treflex receive_refuse_messages when: !empty(refuses) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives refuse messages';\n\t\t\n\t\tloop r over: refuses {\n\t\t\twrite '\\t' + name + ' receives a refuse message from ' + r.sender + ' with content ' + r.contents ;\n\t\t}\n\t}\n}\n\nspecies participant skills: [fipa] {\n\t\n\treflex receive_cfp_from_initiator when: !empty(cfps) {\n\t\t\n\t\tmessage proposalFromInitiator <- cfps[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a cfp message from ' + agent(proposalFromInitiator.sender).name + ' and replies with a refuse message';\n\t\tdo refuse message: proposalFromInitiator contents: ['I am busy today'] ;\n\t\t\n\t}\n}\n\nexperiment test type: gui { }"}
{"prompt": "Design a model demonstrating the FIPA Query interaction protocol using NetLogo-like syntax, including Initiator and Participant agents exchanging query and inform messages.", "gaml_code": "/**\n* Name: FIPA Query\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Query interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).\n* \n* \n* The Initiator agent begins the 'fipa-query' conversation/interaction protocol by sending a 'query' \n* message to the Participant agent with 'your name?' as content.\n* \n* On receiving the 'query' message, the Participant agent replies with two consecutive messages :\n* \n*  (1) an 'agree' message indicating that the Participant agent accepts to execute the query of the Initiator agent,\n* \n*  (2) an 'inform' message informing the Initiation agent of Participant agent's name.\n* \n* \n* After the Initiator agent read the 'inform' message from the Participant agent, the conversation ends.\n* Tags: fipa\n*/\nmodel fipa_query_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_query_message when: (time = 1) {\n\t\twrite name + ' sends query message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-query' performative: 'query' contents: ['your name?'] ;\n\t}\n\t\n\treflex read_inform_message when: !(empty(informs)) {\n\t\twrite name + ' reads inform messages';\n\t\tloop i over: informs {\n\t\t\twrite 'inform message with content: ' + string(i.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\n\treflex reply_query_messages when: !(empty(queries)) {\n\t\tmessage queryFromInitiator <- queries at 0;\n\t\t\n\t\twrite name + ' reads a query message with content : ' + string(queryFromInitiator.contents);\n\t\t\n\t\tdo agree message: queryFromInitiator contents: ['OK, I will answer you'] ;\t\t\n\t\tdo inform message: queryFromInitiator contents: [ 'My name is ' + name ] ;\n\t}\n}\n\nexperiment test_query_interaction_protocol type: gui {}"}
{"prompt": "Implement a FIPA Propose interaction protocol between an Initiator and Participant agent, where the Initiator proposes to go swimming and the Participant rejects the proposal.", "gaml_code": "/**\n* Name: FIPA Propose (2)\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Propose interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).\n* \n* \n* The Initiator agent begins the conversation/interaction protocol by sending a 'propose' \n* message to the Participant agent with 'Go swimming?' as content.\n* \n* On receiving the 'propose' message, the participant agent replies with an 'reject_proposal' message \n* indicating that it refuses to go swimming.\n* \n* After the Initiator agent reads the 'reject_proposal' message, the conversation ends.\n* Tags: fipa\n*/\nmodel fipa_propose_2\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_propose_message when: (time = 1) {\n\t\twrite name + ' sends a propose message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-propose' performative: 'propose' contents: ['Go swimming?'] ;\n\t}\n\n\treflex read_accept_proposals when: !(empty(reject_proposals)) {\n\t\twrite name + ' receives reject_proposal messages';\n\t\tloop i over: reject_proposals {\n\t\t\twrite 'reject_proposal message with content: ' + string(i.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex accept_proposal when: !(empty(proposes)) {\n\t\tmessage proposalFromInitiator <- proposes at 0;\n\t\t\n\t\tdo reject_proposal message: proposalFromInitiator contents: ['No! It \\'s too cold today!'] ;\n\t}\n}\n\nexperiment test_propose_interaction_protocol type: gui {}"}
{"prompt": "Design a model demonstrating the FIPA Query interaction protocol between an Initiator and Participant agent, where the Initiator sends a query message and the Participant responds with a refuse message.", "gaml_code": "/**\n* Name: FIPA Query (2)\n* Author:\n* Description: This model demonstrates a usecase of the FIPA Query interaction protocol. \n* (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).\n* \n* \n* The Intiator agent begins the 'fipa-query' conversation/interaction protocol by sending a 'query' \n* message to the Participant agent with 'your name?' as content.\n* \n* On receiving the 'query' message, the Participant agent replies with a 'refuse' message indicating that its name is a secret!\n* \n* After the Initiator agent reads the 'refuse' message, the conversation ends.\n* Tags: fipa\n*/\nmodel fipa_query_2\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_query_message when: (time = 1) {\n\t\twrite name + ' sends a query message';\n\t\tdo start_conversation to: [p] protocol: 'fipa-query' performative: 'query' contents: ['your name?'];\n\t}\n\t\n\treflex read_refuse_messages when: !(empty(refuses)) {\n\t\twrite name + ' receives refuse messages';\n\t\tloop i over: refuses {\n\t\t\twrite 'refuse message with content: ' + string(i.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex reply_query_messages when: !(empty(queries)) {\n\t\tmessage queryFromInitiator  <- queries at 0;\n\t\t\n\t\twrite name + ' reads a query message with content : ' + string(queryFromInitiator.contents);\n\t\t\n\t\tdo refuse message: queryFromInitiator contents: ['No! That is a secret!'] ;\t\t\n\t}\n}\n\nexperiment test_query_interaction_protocol type: gui {}"}
{"prompt": "Create a GAML model that opens and runs an HTML page in the default web browser to control a server.", "gaml_code": "model ExternalController\n\nglobal {\n}\n\nexperiment start {\n\n\tinit {\n\t\t// we just open the html page to control gama-server in the default web browser\n\t\ttry {\n\t\t\tstring cmd <- \"open \" + project_path + \"scripts/connector/connector.html\";\n\t\t\twrite cmd;\n\t\t\twrite command(cmd);\n\t\t}\n\n\t\tcatch {\n\t\t\tstring cmd <- \"start \\\"\\\" \" + project_path + \"scripts/connector/connector.html\";\n\t\t\twrite cmd;\n\t\t\twrite command(cmd);\n\t\t}\n\n\t\tdo die;\n\t}\n\n}"}
{"prompt": "Design a multi-simulation model of the game Pong using NetLogo-like language, where agents can teleport between simulations when entering buffer zones.", "gaml_code": "/**\n* Name: Pong Teleportation\n* Author: Nicolas Marilleau\n* Description: This model show how to send complex data (as an agent) by using list or map. In this multi-simulation, the space is distributed \n* on 3 (nb_simul) simulation running in parallel. Each simulation manage local space and agent moving in this local space. When an agent go inside a \n* buffer zone, it is teleported to the next simulation (remove from the first and created inside the next one).\n* Tags: Network, MQTT, multi-simulation\n*/\n\n/**\n * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n * It is a free and unsecure server.\n * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n */\n\n\nmodel PongTeleportation\n\nglobal {\n\tint numberOfSimulation <- 3;\n\tint simulation_id <- 0;\n\tstring prefixName <- \"SIMULATION_\";\n\tgeometry shape <- rectangle(200,100);\n\t\n\tinit\n\t{\n\t\tname <- prefixName+simulation_id;\n\t\tcreate Pong number:10{\n\t\t\tmyColor <- rnd_color(255);\t\t\n\t\t}\n\t\tcreate Buffer with:[zone::0];\n\t\tcreate Buffer with:[zone::1];\n\t}\n}\n\n\nspecies Buffer skills:[network]\n{\n\tint zone;\n\tstring next_agent;\n\tinit{\n\t\tname <- \"buffer_\"+world.name+string(zone);\n\t\tnext_agent <- \"buffer_\"+(world.prefixName+((1+simulation_id) mod numberOfSimulation)) +string((zone+1)mod 2);\n\t\tshape <- rectangle(10,100);\n\t\tif(zone = 0){\n\t\t\tlocation <- point(5,50);\n\t\t} else {\n\t\t\tlocation <- point(195,50);\n\t\t}\n\t\tdo connect with_name:name;\n\t\tdo join_group with_name:\"buffer\";\n\t\twrite \"my name \"+ name +\" \" + next_agent;\n\t}\n\t\n\treflex teleport{\n\t\tlist<Pong> to_move <- Pong where(each.last_zone = -1 and each overlaps shape);\n\t\tloop ping over:to_move\n\t\t{\n\t\t\twrite \"send agent\";\n\t\t\tmap<string,unknown> msg <- map([\"name\"::ping.name,\"mcolor\"::ping.myColor, \"location\"::(ping.location - {self.location.x,0})]);\n\t\t\tstring smsg <- serialize(msg);\n\t\t\tdo send to:next_agent contents:msg;\n\t\t\task ping { do die;}\n\t\t}\n\t}\n\treflex enable_teleport{\n\t\tlist<Pong> internal <- Pong where(each.last_zone = self.zone and !( self.shape overlaps each.location));\n\t\t\t\n\t\task internal {\n\t\t\tlast_zone <- -1;\n\t\t}\n\t}\n\t\n\treflex retrieve_agent when: has_more_message() {\n\t\tloop while:has_more_message()\n\t\t{\n\t\t\tmessage msg <- fetch_message();\n\t\t\tmap<string, unknown> details <- map(msg.contents);\n\t\t\tcreate Pong with:[name::details[\"name\"],myColor::details[\"mcolor\"],location::details[\"location\"]]\n\t\t\t{\n\t\t\t\tlocation <- {myself.location.x,location.y};\n\t\t\t\tlast_zone <- myself.zone;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect default{\n\t\tdraw shape color:#pink;\n\t}\n}\n\nspecies Pong \n{\n\trgb myColor;\n\tint last_zone <- -1;\n\t\n\treflex pongMove\n\t{\n\t\tlocation <- location + {1,0};\n\t}\n\t\n\taspect default\n\t{\n\t\tdraw circle(2) color:myColor;\n\t}\n}\n\n\nexperiment start\n{\n\t//definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\t// number of simulations running in parallel.\n\tint nb_simul <- 3;\n\t\n\tinit {\t\n\t\tsimulation_id <- 0;\n\t\tseed <- 1.0;\n\t\tloop i from:1 to: nb_simul -1\n\t\t{\n\t\t\tcreate simulation with: [simulation_id::i, seed::1+i, numberOfSimulation::nb_simul];\n\t\t\t\t\t\t\n\t\t}\n\t}\n\toutput{\n\t\tlayout horizontal([0::5000, 1::5000, 2::5000]) tabs: true editors: false;\n\t\t\n\t\tdisplay map{\n\t\t\tspecies Pong;\n\t\t\tspecies Buffer transparency:0.5;\n\t\t}\n\t}\n}"}
{"prompt": "Design a simple agent-based model demonstrating a teacher broadcasting a message to students using MQTT protocol.", "gaml_code": "/**\n* Name: broadcast to a group of agents\n* Author: Nicolas Marilleau\n* Description: It is a simple model showing an agent (a teacher called Victoria) that broadcast a message to students.\n* Tags: Network, MQTT\n*/\n\n/**\n * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n * It is a free and unsecure server.\n * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n */\nmodel broadcast_to_a_group_of_agents\n\nglobal {\n\tint nb_student <- 10;\n\n\tinit {\n\t\twrite \"The default connect accesses a default free remote server (broker.mqtt.cool, with port 1883). An internet connection is thus required.\" color: #red;\n\t\twrite \"The default broket is for test only, limit the number of connections otherwise connection will be refused.\" color: #red;\n\t\twrite \"To connect to your local/remote server, change the parameters of the connect statement\" color: #blue;\t\t\n\t\t\n\t\tcreate Teacher with: [name:: \"Victoria\"] {\n\t\t\tdo connect with_name: name;\n\t\t\t//default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t\t//do connect to:\"localhost\" with_name:name login:\"admin\" password:\"admin\" port: 1883;\n\t\t}\n\n\t\tcreate Student number: nb_student {\n\t\t// The name attribute of each agent being unique, we use it as an id in the connection to the server\t\n\t\t\tdo connect with_name: name;\n\n\t\t\t// Define here the groups of agents. An agent could join or leave several group.\n\t\t\tdo join_group with_name: \"students\";\n\t\t\t//default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t\t//do connect to:\"localhost\" with_name:name login:\"admin\" password:\"admin\" port: 1883;\n\t\t}\n\n\t}\n\n}\n\nspecies Student skills: [network] {\n\n\treflex fetch when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t//read a message\n\t\t\tmessage mess <- fetch_message();\n\t\t\t//display the message \n\t\t\twrite name + \" fecth this lesson: \" + mess.contents;\n\t\t}\n\t}\n\t\n}\n\nspecies Teacher skills: [network] {\n\n\treflex send {\n\t//send a message\n\t\tdo send to: \"students\" contents: \"chapter \" + cycle;\n\t}\n\n}\n\nexperiment start type: gui {\n\tfloat minimum_cycle_duration <- 1 #s;\n\t\n\toutput {\n\t}\n}"}
{"prompt": "Design a simple MQTT-based network model that simulates a ping-pong game between two agents, demonstrating basic communication and message exchange using the MQTT protocol.", "gaml_code": "/**\n* Name: MQTT_PING_PONG\n* Author: Nicolas Marilleau and Arnaud Grignard\n* Description: The simple PING PONG model based on MQTT protocol.\n* Tags: Network, MQTT\n*/\n\n/**\n * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n * It is a free and unsecure server.\n * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n */\nmodel PING_PONG_model\n\nglobal {\n\tlist<string> clients <- [\"ping\", \"pong\"];\n\n\tinit {\n\t\twrite \"The default connect accesses a default free remote server (broker.mqtt.cool, with port 1883). An internet connection is thus required.\" color: #red;\n\t\twrite \"The default broket is for test only, limit the number of connections otherwise connection will be refused.\" color: #red;\n\t\twrite \"To connect to your local/remote server, change the parameters of the connect statement\" color: #blue;\n\t\t//create Ping agent\n\t\tcreate PING_PONG with: [name:: \"ping\", dest::\"pong\"] {\n\t\t\tdo connect with_name: name;\n\t\t}\n\t\t//create Pong agent\n\t\tcreate PING_PONG with: [name:: \"pong\", dest::\"ping\"] {\n\t\t\tdo connect with_name: name;\n\t\t\tdo send to: dest contents: \"This message is sent by \" + name + \" to \" + dest;\n\t\t}\n\t\t//default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t//do connect to:\"localhost\" with_name:name login:\"admin\" password:\"admin\" port: 1883;\n\t}\n\n}\n\nspecies PING_PONG skills: [network] {\n\tstring dest;\n\n\treflex fetch when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t//read a message\n\t\t\tmessage mess <- fetch_message();\n\t\t\t//display the message \n\t\t\twrite name + \" fecth this message: \" + mess.contents;\n\t\t\t//send a message\n\t\t\tdo send to: dest contents: \"This message is sent by \" + name + \" to \" + dest;\n\t\t}\n\t}\n\n}\n\nexperiment start type: gui {\n\tfloat minimum_cycle_duration <- 0.5 #s;\n\t\n\toutput {\n\t}\n}"}
{"prompt": "Create a simple model demonstrating network communication between multiple agents using MQTT protocol, with a focus on broadcasting messages to all agents.", "gaml_code": "/**\n* Name: broad cast to all agents\n* Author: Nicolas Marilleau\n* Description: It is a simple model showing few agents that broadcast a message to others.\n* Tags: Network, MQTT\n*/\n\n/**\n * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n * It is a free and unsecure server.\n * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n */\nmodel broad_cast_to_all_agent\n\nglobal {\n\tint nb_agents <- 10;\n\n\tinit {\n\t\twrite \"The default connect accesses a default free remote server (broker.mqtt.cool, with port 1883). An internet connection is thus required.\" color: #red;\n\t\twrite \"The default broket is for test only, limit the number of connections otherwise connection will be refused.\" color: #red;\n\t\twrite \"To connect to your local/remote server, change the parameters of the connect statement\" color: #blue;\t\t\n\t\t\n\t//create Ping agent\n\t\tcreate People number: nb_agents {\n\t\t// The name attribute of each agent being unique, we use it as an id in the connection to the server\t\n\t\t\tdo connect with_name: name;\n\t\t\t//default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t\t// do connect to:\"localhost\" with_name:name login:\"admin\" password:\"admin\" port: 1883;\n\t\t}\n\n\t\task one_of(People) {\n\t\t\tis_sender <- true;\n\t\t}\n\t}\n}\n\nspecies People skills: [network] {\n\tbool is_sender <- false;\n\n\treflex fetch when: has_more_message() {\n\t//read a message\n\t\tmessage mess <- fetch_message();\n\t\t//display the message \n\t\twrite name + \" fecth a message from: \" + mess.sender + \" -- \" + mess.contents;\n\t}\n\n\treflex send when: is_sender {\n\t//send a message to all agents (even him). \"ALL\" is the built in group \n\t//for which each agent participates. \n\t\tdo send to: \"ALL\" contents: \"This message is sent by \" + name + \" to All\";\n\t}\n\n}\n\nexperiment start type: gui {\n\tfloat minimum_cycle_duration <- 1 #s;\n\t\n\toutput {\n\t}\n}"}
{"prompt": "Create a model of an Arduino device that can connect to a network and continuously receive and display messages.", "gaml_code": "/**\n* Name: Arduino Listener \n* Author: Huynh Quang Nghi, Benoit Gaudou\n* Description: \n* Tags: Network, Arduino\n*/\n\nmodel Arduino_Listener\n\nglobal {\t\n\n\tinit {\n\t\tcreate NetworkingAgent number: 1 {\n\t\t   do connect protocol: \"arduino\" ;\n\t\t}\t\t\n\t} \n}\n\nspecies NetworkingAgent skills:[network] {\n\n\treflex fetch when:has_more_message() {\t\n\t\tloop while:has_more_message()\n\t\t{\n\t\t\tmessage s <- fetch_message();\n\t\t\twrite s.contents;\n\t\t}\n\t}\n}\n\nexperiment test_Arduino type: gui {\n\toutput {\n\t\tdisplay d {\n\t\t\tspecies NetworkingAgent;\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates two clients communicating through WebSocket protocol over TCP network.", "gaml_code": "/**\n* Name: Socket_TCP_HelloWorld_Server\n* Author: Arnaud Grignard\n* Description: Two clients are communicating throught the Socket WebSocket protocol.\n* Tags: Network, TCP, Socket\n*/\nmodel WebSocket_HelloWorld\n\nglobal{\n\tint id <- 0;\n\tstring type <- \"server\";\n\n\tinit {\n\t\tif (type = \"server\") {\n\t\t\tdo create_server;\n\t\t}\n\n\t\tif (type = \"client\") {\n\t\t\tdo create_client;\n\t\t}\n\n\t}\n\n\taction create_server {\n\t\tcreate Server number: 2 {\n\t\t\tdo connect protocol: \"websocket_server\" port: 3001 with_name:name force_network_use:true;\n\t\t\tdo join_group with_name: \"server_group\";\n\t\t\tid <- id + 1;\n\t\t\tcolor <- rnd_color(255);\n\t\t}\n\n\t\task one_of(Server) {\n\t\t\tisLeader <- true;\n\t\t}\n\n\t}\n\n\taction create_client {\n\t\tcreate Client number: 2 {\n\t\t// replace the \"localhost\" address by the IP address of the other computer \n\t\t\tdo connect to: \"localhost\" protocol: \"websocket_client\" port: 3001 with_name: name  force_network_use:true;\n\t\t\tdo join_group with_name: \"client_group\";\n\t\t\tid <- id + 1;\n\t\t\tcolor <- rgb(rnd(255)); \n\t\t}\n\n\t}\n\treflex space{\n\t\twrite \"\";\n\t\twrite \"\";\n\t\twrite \"\";\n\t\twrite \"\";\n\t}\n}\n\nspecies Server skills: [network]  parallel:true{\n\tstring dest;\n\trgb color;\n\tbool isLeader <- false;\n\n\treflex receive when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage mm <- fetch_message();\n\t\t\twrite name + \" received : \" + mm.contents color: color;\n\t\t}\n\n\t}\n\n\treflex send when: isLeader {\n\t\tdo send to: \"client_group\" contents: (\"I am Server Leader \" + name + \", I give order to client_group at \" + cycle);\n\t\tdo send to: \"server_group\" contents: (\"I am Server Leader \" + name + \", I give order to server_group\");\n\t}\n\n}\n\nspecies Client skills: [network]  parallel:true{\n\trgb color;\n\n\treflex receive when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage mm <- fetch_message();\n\t\t\twrite name + \" received : \" + mm.contents color: color;\n\t\t}\n\n\t}\n\n\treflex send {\n\t\tdo send to: \"server_group\" contents: name + \" at \" + cycle + \" sent to server_group a message\";\n\t}\n\n}\n\nexperiment \"WebSocket Server and Client\" type: gui {\n\tfloat minimum_cycle_duration <- 0.25;\n\n\tinit {\n\t\tcreate simulation with: [type:: \"client\"];\n\t}\n\n\toutput {\n\t}\n\n}"}
{"prompt": "Create a simple WebSocket server using GAML that can interact with an external client script and demonstrate basic network communication capabilities.", "gaml_code": "/**\n* Name: Socket_TCP_HelloWorld_Server\n* Author: HUYNH Quang Nghi\n* Description: Simplest WebSocket server to test with external tools. You can run the python script \"client_ws.py\" to interact with it\n* Tags: Network, TCP, Socket\n*/\nmodel Socket_TCP_HelloWorld_Server\n\nglobal {\n\n\tinit {\n\t\twrite \"HOW TO USE\" color: #red;\n\t\twrite \"1. Launch this model\";\n\t\twrite \"2. Execute the client scripts/client_ws.py\";\n\t\twrite \"3. Step on this server model\";\n\t\t\n\t\t\n\t\tcreate Server {\n\t\t\tdo connect protocol: \"websocket_server\" port: 3001 with_name: name raw: true;\n\t\t}\n\t}\n}\n\nspecies Server skills: [network] parallel: true {\n\tstring dest;\n\trgb color;\n\n\treflex receive when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage mm <- fetch_message();\n\t\t\twrite name + \" received : \" + mm.contents color: color;\n\t\t\tdo send to: mm.sender contents: (\"I am Server Leader \" + name + \", I give order to server_group\");\n\t\t}\n\n\t}\n\n}\n\nexperiment \"WebSocket Server Test\" type: gui {\n\tfloat minimum_cycle_duration <- 0.25;\n\toutput {\n\t}\n\n}"}
{"prompt": "Create a GAMA model that simulates a camera tracking mouse movements from a Processing application using UDP protocol.", "gaml_code": "/**\n* Name: UDP Listener Mouse from Processing For camera.gaml\n* Author: Arnaud Grignard, Benoit Gaudou & Nicolas Marilleau\n* Description: A server is run and waits for messages that transmit coordinates of the camera.\n* \t\t\t   The model library provides an example of such an external application:\n* \t\t\t\tUDPMouseLocationSender / UDPMouseLocationSender.pde\n* Tags: Network, Socket, UDP\n*/\nmodel SocketUDP_Server_Mouse_Listener_For_Camera\n\nglobal skills: [network] {\n\tint port <- 9877;\n\tstring url <- \"localhost\";\n\tpoint cam_loc <- {0, 0};\n\n\tinit {\n\t\twrite \"After having launched this model, run the program UDPMouseLocationSender / UDPMouseLocationSender.pde with Processing 3. \";\n\t\twrite \"Processing 3 can be found here: https://processing.org/\";\n\t\twrite \"Run the GAMA simulation, move on Processing and move the mouse on the gray small screen and observe the camera in GAMA\" color: #red;\n\t\tdo connect to: url protocol: \"udp_server\" port: port size_packet: 1024;\n\t\tcreate observedAgents number: 10;\n\t}\n\n\treflex fetch when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage s <- fetch_message();\n\t\t\tlist coordinates <- string(s.contents) split_with (\";\");\n\t\t\tlocation <- {int(coordinates[0]), int(coordinates[1])};\n\t\t\tcam_loc <- {int(coordinates[0]), int(coordinates[1])};\n\t\t}\n\n\t}\n\n}\n\nspecies observedAgents {\n\tint size <- rnd(10);\n\n\taspect default {\n\t\tdraw cube(size) color: #red border: #black;\n\t}\n\n}\n\nexperiment Server_testdd type: gui {\n\toutput {\n\t\tdisplay d type: 3d {\n\t\t\tcamera #default target: cam_loc dynamic: true;\n\t\t\tspecies observedAgents;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAMA model that simulates an UDP emitter sending agent coordinates to a server, including example code for setting up an UDP server in Processing.", "gaml_code": "/**\n* Name: UDP Emitter Example.gaml\n* Author: Benoit Gaudou & Nicolas Marilleau\n* Description: An UDP emitter that sends the coordinates of an agent toward an UDP server.\n* \t\t\t\tOne server example (in Processing) is provided in the model library in the UDPServer folder.\n* Tags: Network, Socket, UDP\n*/\n\nmodel SocketUDP_Emitter\n\nglobal {\t\n\n\tint port <- 9876;\n\tstring url <- \"localhost\";\n\n\tinit {\n\t\twrite \"Before running this model, run an UDP server (on the same port).\" color: #red;\n\t\twrite \"1 server example is provided using Processing 3.\";\n\t\twrite \"Processing 3 can be downloaded from: https://processing.org/\";\n\t\twrite \"First run one server (e.g. UDPServer.pde), then launch and run the GAMA simulation\" color: #red;\n\t\t\n\t\t\n\t\tcreate NetworkingAgent number:1 {\n\t\t   do connect to: url protocol: \"udp_emitter\" port: port ;\n\t\t}\t\t\n\t} \n}\n\nspecies NetworkingAgent skills:[network] {\n\n\treflex move {\n\t\tlocation <- any_location_in(world);\n\t}\n\n\treflex send {\n\t\twrite \"sending message \";\n\t\tdo send contents: \"\" + location.x + \";\" + location.y;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(1) color: #red border: #blue;\n\t}\n}\n\nexperiment Client_testdd type: gui {\n\n\toutput {\n\t\tdisplay \"My display\" { \n\t\t\tspecies NetworkingAgent;\n\t\t}\n\n\t}\n}"}
{"prompt": "Create a GAMA model that simulates an agent moving based on mouse coordinates received through a UDP connection from a Processing application.", "gaml_code": "/**\n* Name: UDP Listener Mouse from Processing.gaml\n* Author: Arnaud Grignard, Benoit Gaudou  & Nicolas Marilleau\n* Description: A server is run and waits for messages that transmit coordinates of the agent.\n* \t\t\t   The model library provides an example of such an external application:\n* \t\t\t\tUDPMouseLocationSender / UDPMouseLocationSender.pde\n* Tags: Network, Socket, UDP\n*/\n\nmodel SocketUDP_Server_Mouse_Listener\n\nglobal {\t\n\n\tint port <- 9877;\n\tstring url <- \"localhost\";\t\n\t\n\tinit {\n\t\twrite \"After having launched this model, run the program UDPMouseLocationSender / UDPMouseLocationSender.pde with Processing 3. \";\n\t\twrite \"Processing 3 can be found here: https://processing.org/\";\n\t\twrite \"Run the GAMA simulation, move the mouse on the gray small screen of Processing 3 and observe the move of the agent in GAMA\" color: #red;\n\t\t\n\t\tcreate NetworkingAgent number: 1 {\n\t\t   do connect to: url protocol: \"udp_server\" port: port ;\n\t\t}\t\t\n\t} \n}\n\nspecies NetworkingAgent skills:[network] {\n\t\n\treflex fetch when:has_more_message() {\t\n\t\tloop while:has_more_message()\n\t\t{\n\t\t\tmessage s <- fetch_message();\n\t\t\tlist coordinates <- string(s.contents) split_with(\";\");\n\t\t\tlocation <- {int(coordinates[0]),int(coordinates[1])};\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw circle(1) color: #red border: #black; \n\t}\n}\n\nexperiment Server_testdd type: gui {\n\toutput {\n\t\tdisplay d {\n\t\t\tspecies NetworkingAgent;\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple GAMA model that simulates an MQTT receiver using a NetworkingAgent to connect to an MQTT broker and fetch messages.", "gaml_code": "/**\n* Name: MQTT_Receiver\n* Author: Nicolas Marilleau and Arnaud Grignard\n* Description: The simple receiver model based on MQTT protocol.\n* Tags: Network, MQTT\n*/\n\nmodel MQTT_HelloWorld_Receive\n\n\n\nglobal {\t\n\tinit {\n\t\twrite \"A MQTT server should run.\" color: #red;\n\t\twrite \"Another instance of GAMA should run the model Example_MQTT_Send.gaml, so that an agent can send messages.\";\n\t\t\n\t\tcreate NetworkingAgent number:1 {\n\t\t\tname <- \"receiver\";\n\t\t\t/**\n\t\t\t * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n\t\t\t * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n\t\t\t * It is a free and unsecure server.\n\t\t\t * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n\t\t\t */\n\t\t\tdo connect  with_name:\"receiver\";\n\t\t\t\n\t\t\t// default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t\t// do connect to:\"localhost\" with_name:\"receiver\" login:\"admin\" password:\"admin\" port: 1883;\n\t\t}\n\t}\n}\n\nspecies NetworkingAgent skills:[network]{\n\tstring dest;\n\n\treflex fetch when:has_more_message() {\t\n\t\tloop while: has_more_message() {\n\t\t\tmessage mess <- fetch_message();\n\t\t\twrite \"fetch this message: \" + mess;\t\t\t\t\n\t\t}\n\t}\n}\n\nexperiment Network_receiver type: gui {\n\toutput {\n\t}\n}"}
{"prompt": "Create a multi-agent system where two clients communicate through MQTT protocol, one sending messages to another, using GAMA's networking features and displaying the simulation in 3D GUI.", "gaml_code": "/**\n* Name: MQTT__Send\n* Author: Nicolas Marilleau and Arnaud Grignard\n* Description: Two clients are communicated throught the MQTT protocol.\n* Tags: Network, MQTT\n*/\n\nmodel MQTT_SendAgent\n\nglobal skills:[network]{\t\n\tinit\n\t{   \n\t\twrite \"A MQTT server should run.\" color: #red;\n\t\twrite \"Another instance of GAMA should run the model Example_MQTT_Receive_Agent.gaml, to show how agents receive messages.\";\n\t\t/**\n\t\t * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n\t\t * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n\t\t * It is a free and unsecure server.\n\t\t * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n\t\t */\n\t\tdo connect  with_name:\"sender\";\n\t\t\n\t\t// default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t// do connect to:\"localhost\" with_name:\"sender\" login:\"admin\" password:\"admin\" port: 1883;\n\t\t\n\t\tcreate NetworkingAgent number:10{\t\n\t\t\tcolor <- rnd_color(255);\t\n\t\t\tshape <-sphere(5);\t\n\t\t}\n\t}\n\treflex sendAgent{\n\t\twrite \"send agent on the network\";\n\t\tdo send to:\"receiver\" contents:(9 among NetworkingAgent);\t\n\t}\n}\n\nspecies NetworkingAgent skills:[moving]{\n   rgb color;\n   reflex update{\n     do wander;\n   }\t\n   aspect base{\n   \tdraw shape color:color;\n   }\n}\n\nexperiment Network_sender type: gui {\n\toutput {\n\t\tdisplay view type:3d{\n\t\t\tspecies NetworkingAgent aspect:base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple receiver model for MQTT protocol using GAMA, including connection to an MQTT server and message handling.", "gaml_code": "/**\n* Name: MQTT_Receiver\n* Author: Nicolas Marilleau and Arnaud Grignard\n* Description: The simple receiver model based on MQTT protocol.\n* Tags: Network, MQTT\n*/\n\nmodel MQTT_Receiver\n\nglobal skills:[network] {\t\n\tinit {   \n\t\twrite \"A MQTT server should run.\" color: #red;\n\t\twrite \"Another instance of GAMA should run the model Example_MQTT_Send_Agent.gaml, to show how agents can send messages.\";\n\t\t/**\n\t\t * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n\t\t * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n\t\t * It is a free and unsecure server.\n\t\t * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n\t\t */\n\t\tdo connect  with_name:\"receiver\";\n\t\t\n\t\t// default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t// do connect to:\"localhost\" with_name: \"receiver\" login:\"admin\" password:\"admin\" port: 1883;\n\t}\n\treflex receiveAgent when:has_more_message(){\n\t\t// write \"fetch agent on the network\";\n\t\tmessage mess <- fetch_message();\n\t\t\n\t\t// Accessing the content of a message unserialised the received object\n\t\t// In the case of an agent:\n\t\t//  - if it does not exist (same species and id) in the receiving simulation, it is recreated.\n\t\t//  - Otherwise the existing agent is updated (update of the attribute values) \n\t\twrite name + \" fecth this message: \" + mess.contents;\t\n\t\t\n\t}\n}\n\nspecies NetworkingAgent{\n   rgb color;\t\n   aspect base{\n   \tdraw shape color:color;\n   }\n\t\n}\n\nexperiment Network_receiver type: gui {\n\toutput {\n\t\tdisplay view type: opengl {\n\t\t\tspecies NetworkingAgent aspect:base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple MQTT-based communication model between two clients, where one client sends messages to both clients at specific intervals.", "gaml_code": "/**\n* Name: MQTT__Send\n* Author: Nicolas Marilleau and Arnaud Grignard\n* Description: Two clients are communicated through the MQTT protocol.\n* Tags: Network, MQTT\n*/\n\nmodel MQTT_HelloWorld_Send\n\nglobal {\t\n\tlist<string> clients <-[\"sender\",\"receiver\"];\n\tinit {\n\t\twrite \"A MQTT server should run.\" color: #red;\n\t\twrite \"Another instance of GAMA should run the model Example_MQTT_Receive.gaml, to show how agents receive messages.\";\n\t\t\n\t\tcreate NetworkingAgent number:1{\n\t\t\tname <-clients[0];\n\t\t\tdest <- clients[1];\n\t\t\t/**\n\t\t\t * Demo connection based on a default free remote server (broker.mqtt.cool, with port 1883). \n\t\t\t * Using the default MQQT server requires an available internet connection. Depending on your web access, it could be slow down the simulation. \n\t\t\t * It is a free and unsecure server.\n\t\t\t * Using YOUR server is thus adviced. You can download free solution such as ActiveMQ (http://activemq.apache.org) \n\t\t\t */\n\t\t\tdo connect  with_name:\"sender\";\n\t\t\t\n\t\t\t// default ActiveMQ MQTT login is \"admin\", the password is \"admin\" and the port is 1883\n\t\t\t// do connect to:\"localhost\" with_name:\"sender\" login:\"admin\" password:\"admin\" port: 1883;\n\t\t}\n\t}\n}\n\nspecies NetworkingAgent skills:[network]{\n\tstring dest;\n\t\n\treflex send when: cycle mod 10  = 3\n\t{\n\t\twrite \"sending message: \" + \"This message a string from \" + name;\n\t\tdo send to:\"sender\" contents:\"This message a string from \" + name;\n\t\tdo send to:\"receiver\" contents:\"This message a string from \" + name;\n\t}\n\t\n\treflex send2 when: cycle mod 10  = 5\n\t{\n\t\tint a <- 0;\t\t\n\t\twrite \"sending message: \" + a;\n\t\tdo send to:\"sender\" contents:a;\n\t\tdo send to:\"receiver\" contents:a;\t\t\n\t}\t\n\n\treflex send3 when: cycle mod 10  = 8\n\t{\n\t\twrite \"sending message: \" + self;\n\t\tdo send to:\"sender\" contents:self;\t\t\n\t}\n\t\n\treflex receive\n\t{\n\t\twrite \"length mail box \"  + mailbox collect(each.contents);\n\t}\n}\n\nexperiment Network_sender type: gui {\n\toutput {\n\t}\n}"}
{"prompt": "Create a GAML model that simulates two clients communicating through TCP protocol over a network, with one client acting as server and sending messages to another group of clients.", "gaml_code": "/**\n* Name: Socket_TCP_HelloWorld_Server\n* Author: Arnaud Grignard\n* Description: Two clients are communicated throught the Socket TCP protocol.\n* Tags: Network, TCP, Socket\n*/\nmodel Socket_TCP_HelloWorld_Server\n\nglobal{\n\tint id <- 0;\n\tstring type <- \"server\";\n\n\tinit {\n\t\tif (type = \"server\") {\n\t\t\tdo create_server;\n\t\t}\n\n\t\tif (type = \"client\") {\n\t\t\tdo create_client;\n\t\t}\n\n\t}\n\n\taction create_server {\n\t\tcreate Server number: 2 {\n\t\t\tdo connect protocol: \"tcp_server\" port: 3001 with_name:name raw:true;\n\t\t\tdo join_group with_name: \"server_group\";\n\t\t\tid <- id + 1;\n\t\t\tcolor <- rnd_color(255);\n\t\t}\n\n\t\task one_of(Server) {\n\t\t\tisLeader <- true;\n\t\t}\n\n\t}\n\n\taction create_client {\n\t\tcreate Client number: 2 {\n\t\t// replace the \"localhost\" address by the IP address of the other computer \n\t\t\tdo connect to: \"localhost\" protocol: \"tcp_client\" port: 3001 with_name: name raw:true;\n\t\t\tdo join_group with_name: \"client_group\";\n\t\t\tid <- id + 1;\n\t\t\tcolor <- rgb(rnd(255)); \n\t\t}\n\n\t}\n\treflex space{\n\t\twrite \"\";\n\t\twrite \"\";\n\t\twrite \"\";\n\t\twrite \"\";\n\t}\n}\n\nspecies Server skills: [network]  parallel:true{\n\tstring dest;\n\trgb color;\n\tbool isLeader <- false;\n\n\treflex receive when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage mm <- fetch_message();\n\t\t\twrite name + \" received : \" + mm.contents color: color;\n\t\t}\n\n\t}\n\n\treflex send when: isLeader {\n\t\tdo send to: \"client_group\" contents: (\"I am Server Leader \" + name + \", I give order to client_group at \" + cycle);\n\t\tdo send to: \"server_group\" contents: (\"I am Server Leader \" + name + \", I give order to server_group\");\n\t}\n\n}\n\nspecies Client skills: [network]  parallel:true{\n\trgb color;\n\n\treflex receive when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage mm <- fetch_message();\n\t\t\twrite name + \" received : \" + mm.contents color: color;\n\t\t}\n\n\t}\n\n\treflex send {\n\t\tdo send to: \"server_group\" contents: name + \" at \" + cycle + \" sent to server_group a message\";\n\t}\n\n}\n\nexperiment \"TCP Server Test\" type: gui {\n\tfloat minimum_cycle_duration <- 0.25;\n\n\tinit {\n\t\tcreate simulation with: [type:: \"client\"];\n\t}\n\n\toutput {\n\t}\n\n}"}
{"prompt": "Create a simple TCP server model that can connect to an external client script and exchange messages, using a GUI interface.", "gaml_code": "/**\n* Name: Socket_TCP_HelloWorld_Server\n* Author: HUYNH Quang Nghi\n* Description: Simplest TCP server to test with external tools. \n* You can run the python script \"client.py\" to connect to it\n* Tags: Network, TCP, Socket\n*/\nmodel Socket_TCP_HelloWorld_Server\n\nglobal {\n\n\tinit {\n\t\twrite \"HOW TO USE\" color: #red;\n\t\twrite \"1. Launch this model\";\n\t\twrite \"2. Execute the client scripts/client.py\";\n\t\twrite \"3. Step on this server model\";\n\t\t\n\t\tcreate Server {\n\t\t\tdo connect protocol: \"tcp_server\" port: 3001 with_name: name raw: true;\n\t\t}\n\n\t}\n\n}\n\nspecies Server skills: [network] parallel: true {\n\tstring dest;\n\trgb color;\n\n\treflex receive when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage mm <- fetch_message();\n\t\t\twrite name + \" received : \" + mm.contents color: color;\n\t\t\tdo send to: mm.sender contents: (\"I am Server Leader \" + name + \", I give order to server_group\");\n\t\t}\n\n\t}\n\n}\n\nexperiment \"TCP Server Test\" type: gui {\n\tfloat minimum_cycle_duration <- 0.25;\n\toutput {\n\t}\n\n}"}
{"prompt": "Create a multi-simulation model of Pong using NetLogo, where agents can be teleported between simulations when entering a buffer zone.", "gaml_code": "/**\n* Name: Pong Teleportation\n* Author: Nicolas Marilleau\n* Description: This model show how to send complex data (as an agent) by using list or map. In this multi-simulation, the space is distributed \n* on 3 (nb_simul) simulation running in parallel. Each simulation manage local space and agent moving in this local space. When an agent go inside a \n* buffer zone, it is teleported to the next simulation (remove from the first and created inside the next one).\n* Tags: Network, TCP, multi-simulation\n*/\nmodel PongTeleportation\n\nglobal {\n\tint numberOfSimulation <- 3;\n\tint simulation_id <- 0;\n\tstring prefixName <- \"SIMULATION_\";\n\tgeometry shape <- rectangle(200, 100);\n\n\tinit {\n\t\tname <- prefixName + simulation_id;\n\t\tcreate Pong number: 10 {\n\t\t\tmyColor <- rnd_color(255);\n\t\t}\n\n\t\tcreate Buffer with: [zone::0];\n\t\tcreate Buffer with: [zone::1];\n\t}\n\n}\n\nspecies Buffer skills: [network] {\n\tint zone;\n\tstring next_agent;\n\n\tinit {\n\t\tname <- \"buffer_\" + world.name + string(zone);\n\t\tnext_agent <- \"buffer_\" + (world.prefixName + ((1 + simulation_id) mod numberOfSimulation)) + string((zone + 1) mod 2);\n\t\tshape <- rectangle(10, 100);\n\t\tif (zone = 0) {\n\t\t\tlocation <- point(5, 50);\n\t\t} else {\n\t\t\tlocation <- point(195, 50);\n\t\t}\n\n\t\tif (simulation_id = 0) {\n\t\t\tdo connect to: \"localhost\" with_name: name protocol: \"tcp_server\" port: 3001;\n\t\t\tdo join_group with_name: \"server_group\";\n\t\t} else {\n\t\t\tdo connect to: \"localhost\" with_name: name protocol: \"tcp_client\" port: 3001;\n\t\t\tdo join_group with_name: \"buffer\";\n\t\t\twrite \"my name \" + name + \" \" + next_agent;\n\t\t}\n\n\t}\n\n\treflex teleport {\n\t\tlist<Pong> to_move <- Pong where (each.last_zone = -1 and each overlaps shape);\n\t\tloop ping over: to_move {\n\t\t\twrite \"send agent\";\n\t\t\tmap<string, unknown> msg <- map([\"name\"::ping.name, \"mcolor\"::ping.myColor, \"location\"::(ping.location - {self.location.x, 0})]);\n\t\t\tstring smsg <- serialize(msg);\n\t\t\tdo send to: next_agent contents: msg;\n\t\t\task ping {\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treflex enable_teleport {\n\t\tlist<Pong> internal <- Pong where (each.last_zone = self.zone and !(self.shape overlaps each.location));\n\t\task internal {\n\t\t\tlast_zone <- -1;\n\t\t}\n\n\t}\n\n\treflex retrieve_agent when: has_more_message() {\n\t\tloop while: has_more_message() {\n\t\t\tmessage msg <- fetch_message();\n\t\t\tmap<string, unknown> details <- map(msg.contents);\n\t\t\tcreate Pong with: [name:: details[\"name\"], myColor::details[\"mcolor\"], location::details[\"location\"]] {\n\t\t\t\twrite \"received agent\";\n\t\t\t\tlocation <- {myself.location.x, location.y};\n\t\t\t\tlast_zone <- myself.zone;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taspect default {\n\t\tdraw shape color: #pink;\n\t}\n\n}\n\nspecies Pong {\n\trgb myColor;\n\tint last_zone <- -1;\n\n\treflex pongMove {\n\t\tlocation <- location + {1, 0};\n\t}\n\n\taspect default {\n\t\tdraw circle(2) color: myColor;\n\t}\n\n}\n\nexperiment start {\n//definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\n\tfloat minimum_cycle_duration <- 0.05;\n\n\tinit {\n\t\tint nb_simul <- 3;\n\t\tsimulation_id <- 0;\n\t\tseed <- 1.0;\n\t\tloop i from: 1 to: nb_simul - 1 {\n\t\t\tcreate simulation with: [simulation_id::i, seed::1 + i, numberOfSimulation::nb_simul];\n\t\t}\n\n\t}\n\n\toutput {\n\t\tlayout horizontal([0::5000, 1::5000, 2::5000]) tabs: true editors: false;\n\t\tdisplay map {\n\t\t\tspecies Pong;\n\t\t\tspecies Buffer transparency: 0.5;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a simple model that simulates an HTTP GET request to the Open Library API and displays the response headers, body, and code.", "gaml_code": "/**\n* Name: HTTPGET\n* Based on the internal empty template. \n* Author: benoitgaudou\n* Tags: \n*/\n\n\nmodel HTTPGET\n\nglobal {\n\tint port <- 443;       // for HTPP : 80 http, for HTTPS : 443 \n\tstring url <- \"https://openlibrary.org\";\t\n\t\n\tinit {\n\t\tcreate NetworkingAgent number: 1 {\n\t\t   do connect to: url protocol: \"http\" port: port raw: true;\n\t\t}\t\t\n\t} \n\n}\n\nspecies NetworkingAgent skills:[network] {\n\t\n\treflex send when:  cycle = 0 {\n\t\twrite \"sending message \";\t\t\n\t\tdo send to: \"/search/authors.json?q=j%20k%20rowling\" contents: [\"GET\"];\n\t//\tdo send to: \"/search/authors.json?q=j%20k%20rowling\" contents: [\"GET\", [\"Content-Type\"::\"application/json\"]];\t\t\n\t}\n\n\treflex get_message {\n\t\tloop while:has_more_message()\n\t\t{\n\t\t\t//read a message\n\t\t\tmessage mess <- fetch_message();\n\t\t\t//display the message \n\t\t\twrite name + \" fecth this message: \" + mess.contents;\t\n\t\t\twrite sample(map(mess.contents)[\"CODE\"]);\n\t\t\twrite sample(map(mess.contents)[\"BODY\"]);\n\t\t\twrite sample(map(mess.contents)[\"HEADERS\"]);\t\t\t\n\t\t}\n\t\t\n\t}\n\n\t\n\taspect default {\n\t\tdraw circle(1) color: #red border: #black; \n\t}\n}\n\nexperiment Server_testdd type: gui {\n\toutput {\n\t\tdisplay d {\n\t\t\tspecies NetworkingAgent;\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates an HTTP POST request to a Flask server and displays the response message.", "gaml_code": "/**\n* Name: HTTPGET\n* Based on the internal empty template. \n* Author: benoitgaudou\n* Tags: network, web service, HTTP\n*/\n\n/*\n * The code below can be tested with a Flask server (Python Web server).\n * A simple script (with small instructions to launch it) is available on the scripts / HTTP folder.\n */\n\nmodel HTTPPOST\n\nglobal {\n\tint port <- 5000;     // for HTTP : 80 http, for HTTPS : 443 , for Flask server : 5000\n\tstring url <- \"127.0.0.1\";\t\n\t\n\tinit {\n\t\tcreate NetworkingAgent number: 1 {\n\t\t   do connect to: url protocol: \"http\" port: port raw: true;\n\t\t}\t\t\n\t} \n\n}\n\nspecies NetworkingAgent skills:[network] {\n\t\n\treflex send when:  cycle = 0 {\n\t\twrite \"sending message \";\n\t\t\n\t\tdo send to: \"/test\" contents: [\"POST\",to_json([\"toto\"::34,\"titi\"::world]), [\"Content-Type\"::\"application/json\"] ];\n\t\t\n// \t\tdo send to: \"/api/user/\" contents: [\"POST\",\"raw-query-param\", [\"Content-Type\"::\"text/plain\"] ];\t\t\n//\t\tdo send to: \"/api/user/\" contents: [\"DELETE\"];\n\t}\n\n\treflex get_message {\n\t\tloop while:has_more_message()\n\t\t{\n\t\t\t//read a message\n\t\t\tmessage mess <- fetch_message();\n\t\t\t\n\t\t\t//display the message \n\t\t\twrite name + \" fecth this message: \" + mess.contents;\t\n\t\t\twrite sample(map(mess.contents)[\"CODE\"]);\n\t\t\twrite sample(map(mess.contents)[\"BODY\"]);\n\t\t\twrite sample(map(mess.contents)[\"HEADERS\"]);\t\t\t\n\t\t}\n\t\t\n\t}\n\n\t\n\taspect default {\n\t\tdraw circle(1) color: #red border: #black; \n\t}\n}\n\nexperiment Server_testdd type: gui {\n\toutput {\n\t\tdisplay d {\n\t\t\tspecies NetworkingAgent;\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates basic SQL operations (create table, insert data, select data, update data, delete data, drop table) on an SQLite database. The model should include error handling and display the results of each operation.", "gaml_code": "/**\n* Name:  Simple SQL Command in SQLIte\n* Author: Truong Minh Thai\n* Description:  This model does SQl query commands:\n* \n * - Create table \n * \n * - Insert data\n * \n * - Select data\n * \n * - Delete data\n * \n * - Drop table \n * \n * \n *  Note: the file emptyFile.db is only ... an empty file.\n* Tags: database\n  */\nmodel SQLite_selectNUpdate\n\nglobal {\n\tmap<string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../includes/emptyFile.db'];\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed\" color: #red;\n\n\t\tcreate DB_Accessor;\n\n\t\t// Test of the connection to the database\n\t\tif (!first(DB_Accessor).testConnection(PARAMS)) {\n\t\t\twrite \"Connection impossible\";\n\t\t\tdo pause;\n\t\t}\n\n\t\task (DB_Accessor) {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE IF EXISTS registration\";\t\t\t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\n\t\t\twrite \"REGISTRATION table has been created.\";\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\n\t\t\tdo insert params: PARAMS into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\n\t\t\tdo insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\n\t\t\tdo insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\n\t\t\twrite \"Five records have been inserted.\";\n\t\t\twrite \"Click on <<Step>> button to view selected data\";\n\t\t}\n\t}\n}\n\nspecies DB_Accessor skills: [SQLSKILL] {\n\treflex select {\n\t\tlist<list> t <- select(PARAMS, \"SELECT * FROM registration\");\n\t\twrite \"Select before updated \" + t;\n\t\twrite \"    Metadata (column names): \" + t[0];\n\t\twrite \"    Metadata (column types): \" + t[1];\n\t\twrite \"    Data                   : \" + t[2]; \n\t}\n\n\treflex select_parametric {\n\t\tlist<list> t <- self.select(params: PARAMS, \n                            select: \"SELECT * FROM registration WHERE age < ?;\",\n                            values: [26] );\n\t\twrite \"Parametric select before updated \" + t;\n\t\twrite \"    Metadata (column names): \" + t[0];\n\t\twrite \"    Metadata (column types): \" + t[1];\n\t\twrite \"    Data                   : \" + t[2]; \n\t}\n\n\treflex update {\n\t\tdo executeUpdate params: PARAMS updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\n\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM registration where id=103 \";\n\t\tlist<list> t <- select(PARAMS, \"SELECT * FROM registration\");\n\t\twrite \"Select after updated \" + t;\n\t}\n\n\treflex drop {\n\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE registration\";\n\t\twrite \"Registration table has been dropped.\" color: #red;\n\t\twrite \"Another simulation step will throw an exception as the database is not available anymore.\" color: #red;\n\t}\n}\n\nexperiment simple_SQL_exp type: gui {}"}
{"prompt": "Create a GAML model that demonstrates basic SQL operations using the AgentDB species for MySQL database connection and interaction.", "gaml_code": "/**\n* Name:  Simple Species MySql\n* Author: Truong Minh Thai\n* Description:  This model illustrates the use of the AgentDB species (instead of the SQLSKILL), and in particular following actions:\n* \n *    - testConection\n * \n *    - isConnected\n * \n *    - close \n * \n *    - executeUpdate\n * \n *    - insert\n * \n *    - select\n * \n *    - getParameter \n * \n * \n *  This model does SQl query commands:\n * \n * - Create table \n * \n * - Insert data\n * \n * - Select data\n * \n * - Delete data\n * \n * - Drop table \n * \n * \n *  NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (testDB here)\n *        IN ORDER THAT THE MODEL CAN RUN PROPERLY.\n* Tags: database\n */\nmodel simpleSQL_DBSpecies_MySQL\n\nglobal {\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'mysql', 'database'::'testDB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tinit {\n\t\twrite \"This model will work only if MySQL database server is installed and launched,\" color: #red;\n\t\twrite \"and if the database testDB has been created.\" color: #red;\n\n\t\tcreate DB_Accessor number: 1 {\n\t\t\tif (!testConnection (PARAMS)) {\n\t\t\t\twrite \"Impossible connection\";\n\t\t\t} else {\n\t\t\t\twrite \"Connection of \" + self;\n\t\t\t\tdo connect params: PARAMS;\n\t\t\t}\n\n\t\t}\n\n\t\tif (!first(DB_Accessor).isConnected()) {\n\t\t\twrite \"No connection.\";\n\t\t\task (DB_Accessor) {\n\t\t\t\tdo close;\n\t\t\t}\n\n\t\t\tdo pause;\n\t\t} else {\n\t\t\twrite \"  with parameters: \" + first(DB_Accessor).getParameter ();\n\t\t\twrite \"\";\n\t\t}\n\n\t\task (DB_Accessor) {\n\t\t\tdo executeUpdate updateComm: \"DROP TABLE IF EXISTS registration\";\n\t\t\tdo executeUpdate updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\n\t\t\twrite \"REGISTRATION table has been created.\";\n\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\n\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\n\t\t\tdo insert into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\n\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\n\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\n\t\t\twrite \"Five records have been inserted.\";\n\t\t\twrite \"Click on <<Step>> button to view selected data\";\n\t\t}\n\n\t}\n\n}\n\nspecies DB_Accessor parent: AgentDB {\n\treflex select {\n\t\tlist<list> t <- select(\"SELECT * FROM registration\");\n\t\twrite \"Select before updated \" + t;\n\t}\n\n\treflex update {\n\t\tdo executeUpdate updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\n\t\tdo executeUpdate updateComm: \"DELETE FROM registration where id=103 \";\n\t\tlist<list> t <- select(\"SELECT * FROM registration\");\n\t\twrite \"Select after updated \" + t;\n\t}\n\n\treflex drop {\n\t\tdo executeUpdate updateComm: \"DROP TABLE registration\";\n\t\twrite \"Registration table has been dropped.\" color: #red;\n\t\twrite \"Another simulation step will throw an exception as the database is not available anymore.\" color: #red;\t\n\t}\n}\n\nexperiment simple_SQL_exp type: gui {}"}
{"prompt": "Create a GAML model that simulates SQL queries on a MySQL database using the AgentDB species. The model should demonstrate various operations such as creating and dropping tables, inserting and selecting data, updating records, and deleting rows.", "gaml_code": "/**\n* Name:  Simple Species MySql\n* Author: Truong Minh Thai\n* Description:  This model illustrates the use of the AgentDB species (instead of the SQLSKILL), and in particular following actions:\n* \n *    - testConection\n * \n *    - isConnected\n * \n *    - close \n * \n *    - executeUpdate\n * \n *    - insert\n * \n *    - select\n * \n *    - getParameter \n * \n * \n *  This model does SQl query commands:\n * \n * - Create table \n * \n * - Insert data\n * \n * - Select data\n * \n * - Delete data\n * \n * - Drop table \n * \n * \n *  NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (testDB here) AND IMPORTED THE FILE (../includes/meteo_DB_dump.sql)\n *        IN ORDER THAT THE MODEL CAN RUN PROPERLY.\n* Tags: database\n */\nmodel simpleSQL_DBSpecies_MySQL\n\nglobal {\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'mysql', 'database'::'testDB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tinit {\n\t\twrite \"This model will work only if MySQL database server is installed and launched,\" color: #red;\n\t\twrite \"and if the database testDB has been created.\" color: #red;\n\t\t\n\t\tcreate DB_Accessor number: 1 {\n\t\t\tif ( testConnection (params::PARAMS) = false) {\n\t\t\t\twrite \"Impossible connection\";\n\t\t\t} else {\n\t\t\t\twrite \"Connection of \" + self;\n\t\t\t\tdo connect params: PARAMS;\n\t\t\t}\n\n\t\t}\n\n\t\tif (!first(DB_Accessor).isConnected()) {\n\t\t\twrite \"No connection.\";\n\t\t\task (DB_Accessor) {\n\t\t\t\tdo close;\n\t\t\t}\n\n\t\t\tdo pause;\n\t\t} else {\n\t\t\twrite \"  with parameters: \" + first(DB_Accessor).getParameter();\n\t\t\twrite \"\";\t\t\n\t\t}\n\n\t\task (DB_Accessor) {\n\t\t\tdo executeUpdate updateComm: \"DROP TABLE IF EXISTS registration\";\t\t\n\t\t\tdo executeUpdate updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\n\t\t\twrite \"REGISTRATION table has been created.\";\n\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\n\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\n\t\t\tdo insert into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\n\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\n\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\n\t\t\twrite \"Five records have been inserted.\";\n\t\t\twrite \"Click on <<Step>> button to view selected data\";\n\t\t}\n\n\t}\n\n}\n\nspecies DB_Accessor parent: AgentDB {\n\treflex select {\n\t\tlist<list> t <- list<list> (select (select::\"SELECT * FROM registration\"));\n\t\twrite \"Select before updated \" + t;\n\t}\n\n\treflex update {\n\t\tdo executeUpdate updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\n\t\tdo executeUpdate updateComm: \"DELETE FROM registration where id=103 \";\n\t\tlist<list> t <- list<list> (select(\"SELECT * FROM registration\"));\n\t\twrite \"Select after updated \" + t;\n\t}\n\n\treflex drop {\n\t\tdo executeUpdate updateComm: \"DROP TABLE registration\";\n\t\twrite \"Registration table has been dropped.\" color: #red;\n\t\twrite \"Another simulation step will throw an exception as the database is not available anymore.\" color: #red;\n\t}\n}\n\nexperiment simple_SQL_exp type: gui {}"}
{"prompt": "Create a GAMA model that tests connections to various databases (MySQL, SQLite, PostgreSQL) using SQLSKILL and AgentDB.", "gaml_code": "/**\n* Name: SQLConnection\n* Author: thaitruongminh\n* Description: How to create a connection to a database in GAMA\n* Tags: database\n */\nmodel test_connection\n\nglobal {\n\tmap<string, string> MySQL <- ['host'::'localhost', 'dbtype'::'mysql', 'database'::'', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tmap<string, string> SQLITE <- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];\n\n\t// Note that the postgis extension needs to be installed in the postgres database.\n\t// Enable the postGIS extension in the database with: CREATE EXTENSION postgis;\n\t// https://postgis.net/install/\n\tmap<string, string> POSTGRES <- ['host'::'localhost', 'dbtype'::'postgres', 'database'::'postgres', 'port'::'5432', 'user'::'postgres', 'passwd'::''];\n\t\n\tinit {\n\t\t\n\t\twrite \"This model will work only if the corresponding database is installed and the database management server launched.\" color: #red;\n\n\t\twrite \"TESTS CONNECTIONS WITH SQLSKILL\";\n\t\tcreate DB_connection_tester;\n\t\t\n\t\twrite \"\";\n\t\twrite \"TESTS CONNECTIONS WITH AgentDB\";\t\t\t\n\t\tcreate AgentDB_MySQL;\t\n\t\tcreate AgentDB_SQLITE;\n\t\tcreate AgentDB_POSTGRESQL;\t\t\n\t\t\n\t\task AgentDB_MySQL {do die;}\n\t\task AgentDB_SQLITE {do die;}\n\t\task AgentDB_POSTGRESQL {do die;}\n\t}\n\n}\n\nspecies DB_connection_tester skills: [SQLSKILL] {\n\tinit {\n\t\twrite \"Connection to MySQL is \" +  testConnection(MySQL);\n\t\twrite \"Connection to SQLITE is \" +  testConnection(SQLITE);\n\t\twrite \"Connection to POSTGRESQL is \" +  testConnection(POSTGRES);\n\t}\n}\n\nspecies AgentDB_MySQL parent: AgentDB {\n\tinit {\n\t\twrite \"Connection to MySQL with AgenDB is \" +  testConnection(MySQL);\n\t}\n}\n\nspecies AgentDB_SQLITE parent: AgentDB {\n\tinit {\n\t\twrite \"Connection to SQLITE with AgenDB is \" +  testConnection(SQLITE);\n\t}\n}\n\nspecies AgentDB_POSTGRESQL parent: AgentDB {\n\tinit {\n\t\twrite \"Connection to POSTGRESQL with AgenDB is \" +  testConnection(POSTGRES);\n\t}\n}\n\nexperiment default_expr type: gui { }"}
{"prompt": "Create a NetLogo model that integrates with MySQL database to store and retrieve data from a table, using a DB_accessor agent to execute SQL queries.", "gaml_code": "/**\n* Name:  create_agents_Insert_result_MySQL\n* Author: Benoit Gaudou\n* Description: This model illustrates the use of the MySQL DBMS to: \n* \n *     - create agents from a database\n * \n *     - store every cycle some results into a database\n * \n * \n *  Note: this model could be used with any DBMS just by changing the PARAMS variable.\n * \n * \n *  NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../includes/meteo_DB_dump.sql)\n *        IN ORDER THAT THE MODEL CAN RUN PROPERLY.\n* Tags: database\n */\nmodel create_agents_Insert_result_MySQL \n\nglobal {\n\tstring res_DB <- '`result_DB`';\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'mysql', 'database'::'meteo_DB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tstring SQLquery_idPoint <- \"SELECT `idPointgrille`, AVG(`RRmm`) AS RR, AVG(`Tmin`) AS Tmin, AVG(`Tmax`) AS Tmax, AVG(`Rglot`) AS Rglot, AVG(`ETPmm`) AS ETPmm\n    \t\t\tFROM meteo_table GROUP BY `idPointgrille`\";\n\tinit {\n\t\twrite \"This model will work only if the MySQL database server is installed.\" color: #red;\n\t\twrite \"In addition, the database \\\"meteo_db\\\" should have be created and the data imported inside. The SQL queries are available in the file ../includes/meteo_DB_dump.sql.\";\n\t\twrite \"\";\n\t\t\n\t\tcreate DB_accessor;\n\t\task DB_accessor {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE IF EXISTS `result_DB`\";\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE `result_DB` (\n\t\t\t\t\t\t\t\t\t\t  `idPoint` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,\n\t\t\t\t\t\t\t\t\t\t  `valRnd` float NOT NULL DEFAULT '0',\n\t\t\t\t\t\t\t\t\t\t  `cycle` int(16) NOT NULL DEFAULT '0'\n\t\t\t\t\t\t\t\t\t\t) ENGINE=InnoDB DEFAULT CHARSET=utf8;\";\n\t\t}\n\n\t\twrite first(DB_accessor).select (PARAMS, SQLquery_idPoint);\n\n\t\tcreate idPoint from: first(DB_accessor).select(PARAMS, SQLquery_idPoint)\n\t\twith: [name:: \"idPointgrille\", RRmm::\"RR\", Tmin::\"Tmin\", Tmax::\"Tmax\", Rglot::\"Rglot\", ETPmm::\"ETPmm\"];\n\t}\n\n\treflex endSimu when: (cycle = 10) {\n\t\task DB_accessor {\n\t\t\twrite \"Data: \" + (select(PARAMS, \"select * FROM \" + res_DB + \";\"));\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE \" + res_DB + \";\";\n\t\t}\n\n\t\twrite \"DROP the table = \" + res_DB;\n\t\tdo pause; \n\t}\n\n}\n\nspecies idPoint {\n\tfloat RRmm;\n\tfloat Tmin;\n\tfloat Tmax;\n\tfloat Rglot;\n\tfloat ETPmm;\n\tfloat valRnd;\n\t\n\treflex compute_new_random_value {\n\t\tvalRnd <- float(rnd(RRmm + Tmin + Tmax + Rglot + ETPmm));\n\t}\n\n\treflex store_valRnd {\t\t\n\t\task (first(DB_accessor)) {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO \" + res_DB + \" VALUES(?, ?, ?);\" values: [myself.name, myself.valRnd, cycle];\n\t\t}\n\n\t\twrite \" \" + self + \" inserts value \" + valRnd;\n\t}\n}\n\nspecies DB_accessor skills: [SQLSKILL] {\n\tlist listRes <- [];\n\t\n\tinit {\n\t\t// Test of the connection to the database\n\t\tif (!testConnection(PARAMS)) {\n\t\t\twrite \"Connection impossible\";\n\t\t\task (world) {\n\t\t\t\tdo pause;\n\t\t\t}\n\n\t\t} else {\n\t\t\twrite \"Connection Database OK.\";\n\t\t}\n\n\t\twrite \"\" + (select(PARAMS,\"SELECT * FROM meteo_table\"));\n\t\twrite \"\" + (select(PARAMS, SQLquery_idPoint));\n\t}\n\n}\n\nexperiment createInsertMySQL type: gui {\n}"}
{"prompt": "Create a GAML model that connects to a PostGIS database and saves agent data from a shapefile into MySQL tables.", "gaml_code": "/**\n* Name:  Agents to Database in PostGIS\n* Author: Truong Minh Thai\n* Description: \n* init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents\n* \n* savetosql: Save data of agent into MySQL.\n* \n* transform= true because you need to transform geometry data from Absolute(GAMA) to Gis\n* \n* Tags: database\n*/\n\nmodel agent2DB_MySQL \n  \nglobal { \n\tfile buildingsShp <- file('../../includes/building.shp');\n\tfile boundsShp <- file('../../includes/bounds.shp');\n\tgeometry shape <- envelope(boundsShp);\n\t \n\tmap<string,string> PARAMS <-  [//'srid'::'4326', // optional\n\t\t\t\t\t\t\t\t   'host'::'localhost','dbtype'::'postgres','database'::'spatial_db',\n\t\t\t\t\t\t\t\t   'port'::'5432','user'::'postgres','passwd'::''];\n\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed\" color:#red; \n\t\twrite \"The model \\\"Create Spatial Table in PostGIS.gaml\\\" can be run previously to create the database and tables.\";\n\t\t\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\tcreate bounds from: boundsShp;\n\t\t\n\t\tcreate DB_Accessor\n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\n\t\t}\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\t\t \n\t}\n}   \n  \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies bounds {\n\treflex printdata{\n\t\t write \" name : \" + (name) ;\n\t}\n\t\n\treflex savetosql{  // save data into Postgres\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"bounds\"\n\t\t\t\t\t  columns: [\"geom\"]\n\t\t\t\t\t  values: [myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\t\n}\n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\twrite \" name : \" + (name) + \"; type: \" + (type) + \"shape:\" + shape;\n\t}\n\t\n\treflex savetosql{  // save data into Postgres\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"buildings\"\n\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\n\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}   \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that saves data from agents to a PostGIS database using SQL skills, including transforming geometry data from Absolute(GAMA) to GIS and inserting it into a table named 'buildings' with columns 'name' and 'geom', which is in Multipolygon3D format.", "gaml_code": "/**\n* Name:  Agents to Database in PostGIS\n* Author: Truong Minh Thai, Quang Truong, Thu  Tran\n* Description: \n* savetosql: Save data of agent into MySQL.\n* Geometry  column in PostGIS is in Multipolygon3D\n* * transform= true because you need to transform geometry data from Absolute(GAMA) to Gis\n* \n*  NOTE: Geodatabase and tables are created before. Then use the this model to insert data from shapefile\n* Geometry  column in PostGIS is in Multipolygon3D \n* Tags: database\n*/\n\nmodel agent2DB_POSTGIS \n  \nglobal { \n\tfile districtShp <- file('../../includes/district.shp') ;\n\tgeometry shape <- envelope(districtShp);\n\t \n\tmap<string,string> PARAMS <-  ['srid'::'32846', // 32648 represents for the WGS 84 - Zone 48 Northern.\n\t\t\t\t\t\t\t\t   'host'::'localhost','dbtype'::'postgres','database'::'spatial_db3d',\n\t\t\t\t\t\t\t\t   'port'::'5432','user'::'postgres','passwd'::''];\n\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed\" color:#red;\n\t\twrite \"The model \\\"Create Spatial Table in PostGIS.gaml\\\" can be run previously to create the database and tables. The model should be modified to create the database spatial_db3d.\";\n\t\t\n\t\tcreate district from: districtShp with: [ward_name::string(read ('Ward_name'))];\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\n\t\t\n\t\tcreate DB_Accessor\n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t}\n\t}\n}   \n  \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies district {\n\tstring ward_name;\n\t\n\treflex printdata{\n\t\twrite \" name : \" + (name) ;\n\t}\n\treflex savetosql{  // save data into Postgres\n\t\twrite \"begin\"+ name;\n\t    ask (DB_Accessor) {\n\t    \t// Using  ST_Force3D() for converting the geometry data to 3D in the case that the geom in table is in 3D      \n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO buildings(name,geom) VALUES('\"+myself.ward_name+\"',ST_Force3D(ST_Multi(ST_GeomFromText('\" + myself.shape +\"',32648))))\";\n\t\t}\t\n\t}\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}   \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies district aspect: default;\n\t\t}\n\t}\n}"}
{"prompt": "Generate a NetLogo model that connects to a PostGIS database, retrieves building data, and creates agents based on the retrieved geometry. The model should include a GUI display of the created buildings.", "gaml_code": "/**\n* Name:  Agents from Database in PostGIS\n* Author: Benoit Gaudou\n* Description:  This model does SQL query commands and create agents using the results\n* Tags: database\n  */\n\nmodel DB2agentPOSTGIS \n\nglobal {\n\tmap<string,string> BOUNDS <- [\t//'srid'::'32648', // optional\n\t \t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'postgis',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_db',\n\t\t\t\t\t\t\t\t\t'port'::'5432',\n\t\t\t\t\t\t\t\t\t'user'::'postgres',\n\t\t\t\t\t\t\t\t\t'passwd'::'',\n\t\t\t\t\t\t\t\t  \t'select'::'SELECT ST_AsEWKB(geom) as geom FROM bounds;' ];\n\tmap<string,string> PARAMS <- [\t//'srid'::'32648', // optional\n\t\t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'postgis',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_db',\n\t\t\t\t\t\t\t\t\t'port'::'5432',\n\t\t\t\t\t\t\t\t\t'user'::'postgres',\n\t\t\t\t\t\t\t\t\t'passwd'::''];\n\t\n\tstring QUERY <- \"SELECT type, ST_AsEWKB(geom) as geom FROM buildings;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\t\t  \t\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed and initialized.\" color:#red;\n\t\twrite \"To this purpose, the following models can run first: \";\n\t\twrite \"     - \\\"Create Spatial Table in PostGIS.gaml\\\" to create the database,\";\t\t\n\t\twrite \"     - \\\"Agents to Database in PostGIS.gaml\\\" to insert data in the database.\";\n\t\twrite \"\";\t\t\n\t\t\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: select(PARAMS, QUERY)\n\t\t\t\t\t\t\t with:[ nature::\"type\", shape::\"geom\"];\n\t\t }\n\t\t write \"Buildings created: \"+length(buildings) ;\n\t}\n}\n\nspecies DB_accessor skills: [SQLSKILL];\n\nspecies buildings {\n\tstring nature;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentPOSTGIS type: gui {\n\toutput {\n\t\tdisplay fullView type:3d{\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that connects to a PostGIS database and inserts data from a shapefile into a table named 'buildings'.", "gaml_code": "/**\n* Name:  Agents to Database in PostGIS\n* Author: Truong Minh Thai\n* Description: \n* savetosql: Save data of agent into MySQL.\n* \n* transform= true because you need to transform geometry data from Absolute(GAMA) to Gis\n* \n*  NOTE: Create database and tables using Create Spatial Table in PostGIS.gaml. Then use the this model to insert data from shapefile\n* Geometry  column in PostGIS is in Multipolygon \n* Tags: database\n*/\n\nmodel agent2DB_POSTGIS \n  \nglobal { \n\tfile buildingsShp <- file('../../includes/building.shp') ;\n\tgeometry shape <- envelope(buildingsShp);\n\t \n\tmap<string,string> PARAMS <-  ['srid'::'4326', // optinal postgis\n\t\t\t\t\t\t\t\t   'host'::'localhost','dbtype'::'postgres','database'::'spatial_db2d',\n\t\t\t\t\t\t\t\t   'port'::'5432','user'::'postgres','passwd'::''];\n\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed\" color: #red;\n\t\twrite \"The model \\\"Create Spatial Table in PostGIS.gaml\\\" can be run previously to create the database and tables. The model should be modified to create the database spatial_db2d.\";\n\t\t\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\n\t\t\n\t\tcreate DB_Accessor\n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t} \n\t}\n}   \n  \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\twrite \" name : \" + (name) + \"; type: \" + (type) + \"shape:\" + shape;\n\t}\n//\t\n\treflex savetosql{  // save data into Postgres\n\t\twrite \"begin\"+ name;\n\t    ask (DB_Accessor) {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO buildings(type,geom) VALUES('\" + myself.type + \"',ST_Multi(ST_GeomFromText('\" + myself.shape +\"',4326)))\";\n\t\t}\t\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}   \nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that connects to a PostGIS database and creates two tables (bounds and buildings) using SQL queries.", "gaml_code": "/**\n* Name:  CreateBuildingTablePostGIS\n* Author: Truong Minh Thai\n* Description: This model shows how to create a database and a table in PostGIS using GAMA\n * Tags: database\n */\nmodel CreateBuildingTablePostGIS\n\nglobal {\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'postgres', 'database'::'', 'port'::'5432', 'user'::'postgres', 'passwd'::''];\n\tstring database_name <- \"spatial_db\"; // \"spatial_db2d\" or \"spatial_db3d\"\n\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed.\" color: #red;\n\t\twrite \"Note that for postgresql/postgis, a template database with postgis extension should be created previously.\";\n\t\twrite \"With Postgresql 10, with pgAdmin 4: \";\n\t\twrite \"   - create a database named `template_postgis`,\";\n\t\twrite \"   - open the Query tool (by right-clicking on the template_postgis database),\";\n\t\twrite \"   - execute the code:  `CREATE EXTENSION postgis;`\";\n\t\twrite \" pgAdmin 4 should be closed before trying to connect to the database from GAMA.\";\n\t\twrite \"\";\n\t\tcreate dummy;\n\t\task dummy {\n\t\t\tif (testConnection(PARAMS)) {\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP DATABASE IF EXISTS \" + database_name + \" ;\";\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE \"+ database_name +\" with TEMPLATE = template_postgis;\";\n\t\t\t\twrite \"spatial_BD database has been created. \";\n\n\t\t\t\t// remove \"database\" from: PARAMS;\n\t\t\t\tput database_name key: \"database\" in: PARAMS;\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"bounds table has been created.\";\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name character varying(255), \" + \" type character varying(255), \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"buildings table has been created. \";\n\t\t\t} else {\n\t\t\t\twrite \"Connection to MySQL cannot be established \";\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies dummy skills: [SQLSKILL] {\n}\n\nexperiment default_expr type: gui {\n}"}
{"prompt": "Create a GAMA model that connects to a MySQL database, retrieves data from a specific table, and creates agents based on the retrieved information.", "gaml_code": "/**\n* Name:  Agents from Database in MySQL\n* Author: Benoit Gaudou\n* Description:  This model does SQl query commands and create agents using the results\n* Tags: database\n  */\n\nmodel DB2agentMySQL\n\nglobal {\n\tmap<string,string> BOUNDS <- [\t//'srid'::'32648', // optional\n\t\t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'mysql',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_DB_GAMA',\n\t\t\t\t\t\t\t\t\t'port'::'8889',\n\t\t\t\t\t\t\t\t\t'user'::'root',\n\t\t\t\t\t\t\t\t\t'passwd'::'root',\n\t\t\t\t\t\t\t\t  \t\"select\"::\"SELECT geom FROM bounds;\" ];\n\tmap<string,string> PARAMS <- [\t//'srid'::'32648', // optional\n\t\t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'mysql',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_DB_GAMA',\n\t\t\t\t\t\t\t\t\t'port'::'8889',\n\t\t\t\t\t\t\t\t\t'user'::'root',\n\t\t\t\t\t\t\t\t\t'passwd'::'root'];\n\t\n\tstring QUERY <- \"SELECT name, type, geom FROM buildings ;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\t \t\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed and contains proper data.\" color: #red;\n\t\twrite \"To this purpose, the following models can run first: \";\n\t\twrite \"     - \\\"Create Spatial Table in MySQL.gaml\\\" to create the database,\";\n\t\twrite \"     - \\\"Agents to Database in MySQL.gaml\\\" to insert data in the database.\";\n\t\twrite \"\";\n\t\t\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: select(PARAMS,QUERY) \n\t\t\t\t\t\t\t with:[ type::\"type\", shape:: \"geom\"];\n\t\t }\n\t}\n}\n\n\nspecies DB_accessor skills: [SQLSKILL];\n\nspecies buildings {\n\tstring type;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentMySQL type: gui {\n\toutput {\n\t\tdisplay fullView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that demonstrates how to connect to a MySQL database and execute SQL queries to create a new database and two tables.", "gaml_code": "/**\n* Name:  CreateBuildingTableMySQL\n* Author: Truong Minh Thai\n* Description: This model shows how to create a database and a table in MySQL using GAMA\n * Tags: database\n */\nmodel CreateBuildingTableMySQL\n\n\nglobal\n{\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'mysql', 'database'::'', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tinit\n\t{\n\t\twrite \"This model will work only if the corresponding database is installed\" color: #red;\n\n\t\tcreate test_species number: 1;\n\t\task test_species {\n\t\t\tif (testConnection (PARAMS)) {\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP DATABASE IF EXISTS spatial_DB_GAMA\";\t\t\t\t\t\t\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_DB_GAMA\";\n\t\t\t\twrite \"spatial_BD_GAMA database was created \";\n\t\t\t\t\t\n\t\t\t\tPARAMS[\"database\"] <- \"spatial_DB_GAMA\";\n\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"bounds table was created \";\n\t\t\t\t\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name VARCHAR(255), \" + \" type VARCHAR(255), \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"buildings table was created \";\n\t\t\t} else {\n\t\t\t\twrite \"Connection to MySQL can not be established \";\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies test_species skills: [SQLSKILL]  { }\n\nexperiment default_expr type: gui { }"}
{"prompt": "Create a GAML model that connects to a MySQL database and saves agent data from two shapefiles (buildings.shp and bounds.shp) into spatial tables 'buildings' and 'bounds', using the DB_Accessor species with SQL skills.", "gaml_code": "/**\n* Name:  Agents to Database in MySQL\n* Author: Truong Minh Thai\n* Description:   init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents\n* \n* savetosql: Save data of agent into MySQL. \n* \n* transform= true because you need to transform geometry data from Absolute(GAMA) to Gis\n* \n* NOTE: You should have created a database 'spatial_DB_GAMA' into the MySQL server \n*  in order that the model can run properly.\n* Tags: database\n*/\n\nmodel agent2DB_MySQL \n  \nglobal { \n\tfile buildingsShp <- file('../../includes/building.shp');\n\tfile boundsShp <- file('../../includes/bounds.shp');\n\tgeometry shape <- envelope(boundsShp);\n\t\n\tmap<string,string> PARAMS <- ['srid'::'4326',\n\t\t\t\t                  'host'::'localhost','dbtype'::'mysql','database'::'spatial_DB_GAMA',\n\t\t\t\t                  'port'::'8889','user'::'root','passwd'::'root'];\n\n\tinit {\n\t\twrite \"This model will work only if the corresponding database is installed\" color: #red;\n\t\twrite \"The model \\\"Create Spatial Table in MySQL.gaml\\\" can be run previously to create the table.\";\n\t\t\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\tcreate bounds from: boundsShp;\n\t\t\n\t\tcreate DB_Accessor number: 1  \n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\n\t\t}\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\t\t \n\t}\n}   \n \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies bounds {\n\treflex printdata{\n\t\t write ' name : ' + (name) ;\n\t}\n\t\n\treflex savetosql{  // save data into MySQL\n\t\twrite \"begin save of: \"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"bounds\"\n\t\t\t\t\t  columns: [\"geom\"]\n\t\t\t\t\t  values: [myself.shape];\n\t\t}\n\t    write \"finished save of: \"+ name;\n\t}\t\t\n}\n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\n\t}\n\t\n\treflex savetosql{  // save data into MySQL\n\t\twrite \"begin save of: \"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"buildings\"\n\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\n\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\n\t\t}\n\t    write \"finished save of: \"+ name;\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}     \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that showcases various interactive elements in a GUI, including sliders, check boxes, combo boxes, file choosers, and monitors, with the ability to disable or enable parameters based on boolean variables.", "gaml_code": "/***\n* Name: GUI Interactive Elements\n* Author: Benoit Gaudou/Alexis Drogoul\n* Description: This model illustrates the various possible interactive elements that can be used in the parameters pane.\n* Tags: experiment, GUI, parameter\n***/\n\nmodel GUIInteractiveElements\n\n\nglobal {\n\t// The various global variables can be used as parameter of an experiment.\n\t// In the simulation parameter view, their display can depend on their type or on other facets (e.g. min and max).\n\n\t// Definition of a set of global parameters of several types.\n\tint an_integer_without_limits <- 0;\n\tint an_integer <-0;\n\tfloat a_float_variable <- 0.0;\n\tfloat another <- 10.0;\t\n\tbool a_boolean_variable <- true;\n\tbool a_boolean_variable2 <- true;\n\tbool a_boolean_variable3 <- true;\n\t\n\tstring a_string ;\n\trgb a_color <- #yellow;\n\tfile a_fil <- shape_file(\"../../Data/Data Importation/includes/test.shp\");\n\tfile a_fil2 <- file(\"../../Data/Data Importation/includes/hab10.asc\");\n\tlist<string> list_of_string <- [\"A\",\"B\",\"C\"];\n\tmatrix<string> matrix_of_string <- matrix([[\"R1C1\",\"R2C1\"],[\"R1C2\",\"R2C2\"],[\"R1C3\",\"R2C3\"]]);\n\t\n\tbool a_boolean_to_disable_parameters <- true;\n\tpair<string,int> pair_of_string_int <- \"B\"::2;\n\tpoint point_3D <- {12,45,2};\n\n\tbool a_boolean_to_enable_parameters <- true;\n\tstring multiple_choice;\n\t\n\tfloat float_on_change <- 1.0;\n\t\n\t// Action that will be called from the parameter pane\n\taction writing_parameters {\n\t\twrite \"Float on change: \" + float_on_change;\n\t}\n} \n\nexperiment \"Show Parameters\" type: gui {\n\t\n\t// Variables can also be declared in the experiment\n\tint an_int_to_build_a_list <- 10;\n\tstring a_string_among_others <- \"10\";\n\tint an_int_with_an_updated_slider <- 2;\n\t\n\t\n\t// Texts can be inserted in the parameters pane to explain, for instance, how the model works\n\t// Category: Explanation\t\n\t////////////////////////////////////////////// \n\tcategory \"Explanation\" expanded: false color: #green; \n\tcategory \"Various types\" expanded: false color: #orange;\n\tcategory \"Monitors\" expanded: false color: #red;\n\ttext \"This is a simple text using default values. It adapts automatically to the light/dark themes\" category: \"Explanation\";\n\ttext \"This is in a different color and a background\" color: #white background: #violet category: \"Explanation\";\n\ttext \"This is a text in a different font, in italic and a size of 12\" category: \"Explanation\" color: #orange font: font(\"Times New Roman\",16,#italic); \n\ttext \"Texts are justified on both sides by default. There is no possiblity so far to specify a left, right or no justification\" category: \"Explanation\" color: #lightgray background: #black font: font(\"Courier New\",12); \n\ttext \"This bold light green text \\rspans over \\r3 lines.\" category: \"Explanation\" color: #lightgreen background: #black font: font(\"Helvetica\",12,#bold); \n\t\n\t// Category: Various types\t\n\t//////////////////////////////////////////////\n\t// When min: and max: facets are used, the input chooser for a numerical value appears as a slider. \n\tparameter \"An integer with limits\" category:\"Various types\" var: an_integer_without_limits min: 0 max: 100 step: 1;\n\t// Without these facets, the parameter value chooser appears only as a textfield. \t\n\tparameter \"An integer without limit\" category:\"Various types\" var: an_integer ;\n\tparameter \"Slider of a float\" category:\"Various types\" var: a_float_variable min: 0.0 max: 100.0 step: 0.5;\n\tparameter \"Slider of a float with a color\" category:\"Various types\" var: another min: 0.0 max: 100.0 step: 0.5 colors: [#red, #purple, #blue];\n\t// When a variable of type boolean is a parameter, its input chooser appears as a check box.\n\tparameter \"Boolean variable\" category:\"Various types\" var: a_boolean_variable;\n\tparameter \"Boolean variable with different colors\" category:\"Various types\" var: a_boolean_variable2 colors: [#blue, #lightskyblue];\n\tparameter \"Boolean variable with the same colors\" category:\"Various types\" var: a_boolean_variable3 colors: [#orange];\n\t// A color parameter can be modified using a color chooser.\n\tparameter \"A color\" category:\"Various types\" var: a_color;\n\t// For any parameter, if the possible values are described using the among: facet, a ComboBox is used to choose the parameter value.\n\tparameter \"Choice Box 1\" category:\"Various types\" var: a_string <- \"choice1\" among: [\"choice1\",\"choice2\",\"choice3\"];\n\t// For a file variable, a FileChooser is used to choose the file. \n\tparameter \"File chooser\" category:\"Files\" var: a_fil ; \n\tparameter \"File Chooser (only .asc and .shp)\" category: \"Files\" var: a_fil2 extensions: [\"asc\",\"shp\"] in_workspace: true;\n\t// For both lists and matrices, an list/matrix modifier can be opened to modify the list or matrix.\n\tparameter \"List parameter\" category:\"Various types\" var: list_of_string ; \n\tparameter \"Matrix parameter\" category:\"Various types\" var: matrix_of_string ; \n\t\n\t// Category: interactive disable\n\t//////////////////////////////////////////////\n\t// When the parameter corresponds to a boolean attribute, the facet disables: (resp. enables:) can be added to \n\t// disable (resp. enable) the edition of some parameters (listed as a list of global variables).\n\t// In the following, when a_boolean_to_disable_parameters is true, this disables the input chooser for point_3D\n\t// and pair_of_string_int parameters.\n\tparameter \"Disable following parameters\" category:\"Disable parameters\" var: a_boolean_to_disable_parameters disables: [point_3D,pair_of_string_int];\t\t\n\tparameter \"Pair parameter\" category: \"Disable parameters\" var: pair_of_string_int ; \n\tparameter \"Point parameter\" category: \"Disable parameters\" var: point_3D;\n\t\n\t// Category: interactive enable\n\t//////////////////////////////////////////////\n\t// In the following, when a_boolean_to_enable_parameters is true, it enables the input chooser for multiple_choice.\n\tparameter \"Activate the following parameter\" category:\"Enable parameters\" var:a_boolean_to_enable_parameters enables: [multiple_choice];\n\tparameter \"Choice Box 2\" category:\"Activable parameters\" var: multiple_choice <- \"choice1\" among: [\"choice1\",\"choice2\",\"choice3\"];\n\t\n\t// Category: interactive update\n\t//////////////////////////////////////////////\n\tparameter \"Update the among and max values of next parameters\" category: \"Update parameters\" var: an_int_to_build_a_list min: 1 updates: [a_string_among_others, an_int_with_an_updated_slider];\n\tparameter \"A string to choose among updated values\" category: \"Update parameters\" var: a_string_among_others among: (0 to an_int_to_build_a_list) collect string(each);\n\tparameter \"An int with an updated slider\" slider: true category: \"Update parameters\" var: an_int_with_an_updated_slider min: 0 max: an_int_to_build_a_list;\n\t\n\t// Category: interaction through button\t\n\t//////////////////////////////////////////////\n\t// Any input chooser can have the on_change: facet in order to call a set of statements (or a single action) every time the associated \n\t// parameter is modified.\n\tparameter \"Float (with on_change listener)\" category:\"Interactive\" var: float_on_change {write \"\"+float_on_change;}\n\t// A user_command adds a button to the interface in order to call an action or a set of statements when it is clicked.\n\tuser_command \"Display parameter\" category: \"Interactive\" color:#darkblue {ask world {do writing_parameters;}}\n\tuser_command \"Light color for commands\" category: \"Interactive\" color:#lightgray {ask world {do writing_parameters;}}\n\tuser_command \"Default color for commands\" category: \"Interactive\" {ask world {do writing_parameters;}}\n\ttext \"Monitors can now be added to the parameters view (see Preferences>Interface)\" category: \"Monitors\" color: #gray font: font(\"Helvetica\",14, #bold);\n\n\t\n\toutput {\n\t\tmonitor \"A simple random monitor\" value: rnd(100) color: #red;\n\t\tmonitor \"A monitor with the color of the simulation\" value: 1000 + rnd(10) ;\n\t\tmonitor \"A monitor on an agent\" value: simulation color: #lightgray;\n\t}\n}"}
{"prompt": "Create a 3D visualization of text strings using various fonts, colors, and anchors, demonstrating different attributes such as depth, border, precision, wireframe, and texture.", "gaml_code": "/***\n* Name: TextDisplay\n* Author: A. Drogoul\n* Description: A simple model to show the usage of the 'anchor' facet to draw strings in display. Also demonstrates some of the attributes with which text can be drawn (depth, border, precision, wireframe...)\n* Tags: Display, Draw, String\n***/\nmodel TextDisplay\n\nglobal {}\n\nexperiment Strings {\n\t\n\tlist<font> fonts <- [font(\"Helvetica\", 48, #plain),font(\"Times\", 30, #plain) ,font(\"Courier\", 30, #plain), font(\"Arial\", 24, #bold),font(\"Times\", 30, #bold+#italic) ,font(\"Geneva\", 30, #bold)];\n\tmap<string, point> anchors <- [\"center\"::#center, \"top_left\"::#top_left, \"left_center\"::#left_center, \"bottom_left\"::#bottom_left, \"bottom_center\"::#bottom_center, \"bottom_right\"::#bottom_right, \"right_center\"::#right_center, \"top_right\"::#top_right, \"top_center\"::#top_center];\n\tfont current_font <- one_of(fonts) update: one_of(fonts);\n\trgb current_color <- rnd_color(255) update: rnd_color(255);\n\tfloat current_depth <- rnd(16) - 8.0 update: rnd(16) - 8.0;\n\tint y_step <- 5;\n\timage_file g <- image_file(\"3D Visualization/images/building_texture/texture3.jpg\");\n\n\n\toutput synchronized: true{\n\t\tlayout #split;\n\t\tdisplay \"Strings\" type: 3d  axes: false {\n\t\t\tgraphics Strings {\n\t\t\t\tdraw world.shape wireframe: true color: #black;\n\t\t\t\tint y <- 5;\n\t\t\t\tfloat precision <- 0.01;\n\t\t\tloop p over: anchors.pairs {\n\t\t\t\t\tdraw circle(0.5) at: {50, y} color: #red;\n\t\t\t\t\tdraw p.key + \" ABCDE...WXYZ 1234567890 precision: \"+precision at: {50, y} anchor: p.value color: rnd_color(255) font: current_font depth: 8 precision: precision ;\n\t\t\t\t\ty <- y + y_step;\n\t\t\t\t\tprecision <- precision * 2;\n\t\t\t\t}\n\n\t\t\t\tdraw circle(0.5) at: {50, y} color: #green;\n\t\t\t\tdraw \"custom {0.6, 0.1} wireframe\" at: {50, y} anchor: {0.6, 0.1} border: current_color font:  one_of(fonts)  wireframe: true width: 2;\n\t\t\t\tdraw circle(0.5) at: {50, y + 5} color: #red;\n\t\t\t\tdraw \"custom {0.2, 0.2} with border\" at: {50, y + y_step} anchor: {0.2, 0.2} color: current_color   depth: 3 border: rnd_color(255) width: 2;\n\t\t\t\tdraw circle(0.5) at: {50, y + 10} color: #red;\n\t\t\t\tdraw \"custom {0.8, 0.8} with texture\" at: {50, y + 2*y_step} anchor: {0.8, 0.8}  font:  one_of(fonts) with_size 100  depth: 8 texture: g ;\n\t\t\t\tdraw circle(0.5) at: {50, y + 10} color: #red;\n\t\t\t\tdraw \"custom {0.8, 0.8} 3D Wireframe\" at: {50, y + 3*y_step} anchor: {0.8, 0.8}  font:  current_font  depth: 8 wireframe: true ;\n\t\t\t\tdraw circle(0.5) at: {50, y + 15} color: #red;\n\t\t\t\tdraw \"custom {0.4, 0.1} Flat with border\" at: {50, y + 4*y_step} anchor: {0.4, 0.1}  font:  one_of(fonts)  border: #black ;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t//display \"Without antialias\" parent: \"With antialias\" antialias: false {}\n\n\t}\n\n}"}
{"prompt": "Create a graphical model that demonstrates how to use overlay layers in a 3D display, including a grid of cells with random types and colors, and an overlay layer with squares and text labels for each type.", "gaml_code": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}"}
{"prompt": "Create a simple simulation of a worm population that generates a heatmap to visualize their distribution and movement patterns.", "gaml_code": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"}
{"prompt": "Generate a procedural terrain model with customizable parameters for width, height, details, smoothness, scattering, and palette. The output should be a 3D mesh that can be visualized and saved as an image file.", "gaml_code": "/**\n* Name: DEMGenerator\n* Based on Damien Philippon's initial work, a model that generates maps with several features (which can be interpreted at will: sea, shore, mountain...). \n* Author: Alexis Drogoul\n* Tags: \n*/\nmodel RandomMaps\n\nglobal {\n\t// the generation is mostly governed by these values (see the documentation of 'generate_terrain')\n\tfloat details <- 0.5;\n\tfloat smoothness <- 0.4;\n\tfloat scattering <- 0.7;\n\tint width <- 250;\n\tint height <- 250;\n\tfield terrain;\n\tstring palette_name <- \"Seaside\";\n\tint generator_seed <- 1;\n\n\tinit {\n\t\tdo generate();\n\t}\n\n\taction generate {\n\t\t// the generate_terrain operator returns a field where the elevations are between 0 and 1. It can be scaled afterwards.\n\t\tint scale_factor <- palette_name = \"Seaside\" ? 20 : 10;\n\t\tterrain <- generate_terrain(generator_seed, width, height, details, smoothness, scattering) * scale_factor;\n\t}\n\n}\n\nexperiment Terrain type: gui {\n\t\n\tparameter \"Seed for the generator\" var: generator_seed <- 1 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Width of the environment\" var: width min: 50 max: 2000 {\n\t\tdo update();\n\t}\n\tparameter \"Height of the environment\" var: height min: 50 max: 2000 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Level of details\" var: details min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\n\tparameter \"Level of smoothness\" var: smoothness min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\n\tparameter \"Level of scattering\" var: scattering min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Palette\" var: palette_name  among: [\"Countryside\",\"Seaside\"] {\n\t\tdo update();\n\t}\n\t\n\tuser_command \"Save\" {\n\t\tdo save_tif();\n\t}\n\n\taction update {\n\t\task simulation {\n\t\t\tdo generate();\n\t\t}\n\t\tdo update_outputs();\n\t}\n\t\n\taction save_tif {\n\t\tstring file_name <- \"seed\"+generator_seed+\"w\"+width+\"h\"+height+\"d\"+(details with_precision 2)+\"smooth\"+(smoothness with_precision 2)+\"scatter\"+(scattering with_precision 2)+\".tif\";\n\t\tsave grid_file(file_name, terrain);\n\t}\n\n\taction _init_ {\n\t\t\n\t// A trick to make sure the parameters are expanded and visible when the simulation is launched.\n\t\tbool previous <- gama.pref_experiment_expand_params;\n\t\tgama.pref_experiment_expand_params <- true;\n\t\tcreate simulation;\n\t\tgama.pref_experiment_expand_params <- previous;\n\t}\n\n\tlist<rgb> land_and_sea <- palette(reverse([#darkgreen, #darkgreen, #green, rgb(32, 176, 0), rgb(224, 224, 0), rgb(128, 128, 255), #blue, #blue]));\n\tlist<rgb> field_and_forest <- palette(reverse([#sienna, #olive, #darkgreen, #green, #forestgreen,  #lightgreen]));\n\toutput {\n\t\tlayout #split consoles: false toolbars: false;\n\t\tdisplay \"Terrain\" type: 3d axes: false camera: #from_up_front {\n\t\t\tmesh terrain color: palette_name = \"Seaside\" ? land_and_sea : field_and_forest triangulation: true;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Design and visualize various aspects of displaying agents in 3D, including geometries, textures, lighting, transparency, and focus on specific agents.", "gaml_code": "/***\n* Name: Aspects\n* Author: Benoit Gaudou\n* Description: This model details the various possibility of agent's drawing in an aspect.\n* In particular, it attempts to answer questions such as:\n* 1. how to display agents using geometries ? text ? images ?\n* 2. how to display them in 3D ? with texture ? taken into account the light ?\n* 3. how to display the link between 2 agents ?\n* 4. how to deal with transparency in agents ?\n* 5. how to focus on some agents ?\n* \n* Tags: aspect, 3D, draw, transparency, focus\n***/\nmodel Aspects\n\nglobal {\n\timage_file wood0_image_file <- image_file(\"3D Visualization/includes/wood.jpg\");\n\n\tinit {\n\t//\n\t// 1. How to display agents using geometries ? text ? images ?\n\t// \n\t// All the agents are displayed using a single circle and text comment (their aspect)\n\t\tcreate people with: [location::{25, 25}, aspect_type::\"Asp. default\"];\n\t\t// The agent people(1) will be displayed using several geometries, that can be empty or not\t\n\t\tcreate people with: [location::{25, 75}, aspect_type::\"Asp. simple\"];\n\t\t// The agent people(2) will be displayed using advanced features on text: a font, perspective ...\t\t\t\t\n\t\tcreate people with: [location::{25, 50}, aspect_type::\"Asp. text\"];\n\t\t// The agent people(3) will be displayed in a location that is not its own location \n\t\t//    (to illustrate that the way the agent is displayed can be totally different from its actual state).\t\t\t\t\t\t\n\t\tcreate people with: [location::{50, 25}, aspect_type::\"Asp. centered\"];\n\t\t// The agent people(4) will be displayed in using a picture that is resize\t\n\t\tcreate people with: [location::{50, 12}, aspect_type::\"Asp. img\"];\n\n\t\t//\n\t\t// 2. how to display them in 3D ? with texture ? taken into account the light ?\n\t\t//\n\t\t// The agent people(5) will be displayed with 3d  or isometric 2D geometries\t\t\n\t\tcreate people with: [location::{85, 50}, aspect_type::\"Asp. 3D\"];\n\t\t// The agent people(6) will be displayed using texture and material\n\t\tcreate people with: [location::{50, 75}, aspect_type::\"Asp. textured\"];\n\n\t\t//\n\t\t// 3. how to display the link between 2 agents ?\n\t\t//\n\t\t// The agent people(7) is displayed to show its relation with another agent,\n\t\t//    drawing a line between them and arrows at the beginning and the end of the line.\t\t\n\t\tcreate people with: [location::{75, 75}, aspect_type::\"Asp. arrows\"];\n\n\t\t//\n\t\t// 4. how to deal with transparency in agents ?\n\t\t//\n\t\t// The agent people(8) is displayed using a square with transparency \n\t\tcreate people with: [location::{75, 25}, aspect_type::\"Asp. cube\"];\n\t\t// Note that the transparency facet can only be defined in the display, not in the aspect.\n\t\t// To display agents of a species with a transparency that is different for each agent,\n\t\t//    GAMA provides the possibility to define a color with a transparency that can be different \n\t\t//    depending in the agent. \n\t\t//\n\t\t// In the following, all the people agent have the attribute color_transparency, a color with a transparency depending on the agent\n\t\t// and the aspect big_circle_with_transparency that draws all of them with a big circle with a transparency depending on the agent.\n\t}\n\n\t// In addition, every 100 cycles, the camera will focus on one specific random agent.\n\treflex focus when: every(100 #cycles) and (cycle > 0) {\n\t\twrite \"Change the focus\";\n\t\tfocus_on one_of(agents);\n\t}\n\n}\n\nspecies people {\n\tstring aspect_type;\n\trgb color_transparency <- rgb(#darkred, 0.4 / (1 + int(self)));\n\n\t// aspect blocks defines how each agent is displayed\n\taspect default {\n\t// The draw statement takes any drawable objects (geometry, text, image)...\n\t// The aspect color: defines the inner color of the geometry or the color of the text.\n\t// The aspect border: defines the geometry border color.\n\t\tdraw circle(0.5) color: #red border: #yellow;\n\t\tdraw aspect_type color: #black at: location + {0, 4, 1} anchor: #bottom_center depth: 3;\n\t}\n\n\t// In an aspect, it is possible to draw several layers one after the other.\t\n\taspect simple {\n\t\tdraw circle(0.5) color: #grey border: #darkgrey;\n\t\t// The facet wireframe: sets whether the drawn geometry is plain or empty.  \n\t\tdraw circle(1.0) border: #darkgreen wireframe: true;\n\t\tdraw square(3.0) border: #darkgreen wireframe: true;\n\t}\n\n\t// In an aspect, it is possible to draw several layers one after the other.\t\n\taspect big_square_for_transparency {\n\t\tdraw square(3.0) color: #darkblue border: #black;\n\t}\n\n\t// In an aspect, it is possible to draw several layers one after the other.\t\n\taspect big_circle_with_transparency {\n\t\tdraw circle(5.0) color: color_transparency border: #black;\n\t}\n\n\t// The object to draw can be text.\n\t// The draw can be configured using the color: facet and the font: one.\n\t// font: facet is expecting a font obbject composed by the name of the font, its size and #bold/#italic/#plain/#bold+#italic.\t\n\taspect simple_text {\n\t// perspective: facet specifies whether to render the text in perspective or facing the user.\t\t\n\t\tdraw \"Agent: \" + name + \"(rotate!)\" at: location + {0, 8, 0} color: #green font: font(\"Arial\", 10, #bold) perspective: false;\n\t\tdraw \"Agent: \" + name at: location + {0, 6, 0} color: #blue font: font(\"SansSerif\", 15, #italic) perspective: true;\n\t}\n\n\t// When a line is drawn, it could be interesting to also draw an arrow at one of the extremities of the line\n\taspect arrows {\n\t// begin_arrow: and end_arrow: facets are used to define the size of the drawn line.\n\t// width: facet can be used to increase the width of a line \n\t// (the use of width with other geometry will provide unexpected result, as it increase each line of the geometry)\n\t\tdraw line([self.location, people(8).location]) color: #orange end_arrow: 1 begin_arrow: 2.2 width: 3.0;\n\t}\n\n\t// at (point): location where the shape/text/icon is drawn\n\t// rotate (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}\n\t// The elements drawn are by default located on the agent location, but they can be moved anywhere in the environment.\n\t// They can also be rotated.\t\t\n\taspect locate_geometry {\n\t\tdraw square(1.0) color: #silver border: #black at: world.location rotate: 45;\n\t\tdraw \"Agent in center\" color: #green font: font(\"Arial\", 15, #bold) at: world.location + {0.0, 2.0, 0.0} anchor: #bottom_center;\n\t}\n\n\t// In an OpenGL display, the various geometries can be displayed in 3d, or more specifically with a depth (facet depth:).\n\t// for example, a circle with depth, will be displayed as a cylinder.\n\t// These 3D objects be displayed taken into account the light or not with the lighted facet:\n\taspect col3D {\n\t\tdraw circle(1.0) color: #tomato depth: 5.0 lighted: true;\n\t\tdraw sphere(1.0) at: (location - {2.0, 0.0, 0.0}) color: #tomato;\n\t\tdraw cube(1.0) at: (location - {-2.0, 0.0, 0.0}) color: #tomato;\n\t\tdraw square(1.0) at: (location - {-2.0, 2.0, 0.0}) color: #tomato depth: 5.0 lighted: true;\n\t}\n\n\t// In a 3D display (openGL), agents can add texture (i.e. a picture on the geometry) and can be lighted or not.\n\taspect textured {\n\t\tdraw sphere(2.0) color: #tomato;\n\t\tdraw sphere(2.0) at: (location - {4.0, 0.0, 0.0}) color: #tomato lighted: false;\n\t\tdraw sphere(2.0) at: (location - {-4.0, 0.0, 0.0}) color: #tomato texture: wood0_image_file;\n\t}\n\n\t// When an agent is displayed drawing a picture, that picture can be resize (using the size: facet).\n\taspect image {\n\t\tdraw wood0_image_file size: {50.0, 10.0, 0.0};\n\t}\n\n}\n\n//experiment expe type: gui {\n//\toutput {\n//\t\tdisplay my_display {\n//\t\t\tgraphics \"layer1\" position: {0, 0} size: {0.5, 0.8} {\n//\t\t\t\tdraw shape color: #darkorange;\n//\t\t\t}\n//\n//\t\t\tgraphics \"layer2\" position: {0.3, 0.1} size: {0.6, 0.2} {\n//\t\t\t\tdraw shape color: #cornflowerblue;\n//\t\t\t}\n//\n//\t\t\tgraphics \"layer3\" position: {0.4, 0.2} size: {0.3, 0.8} {\n//\t\t\t\tdraw shape color: #gold;\n//\t\t\t}\n//\t\t}\n//\t}\n//}\n\nexperiment Aspects type: gui {\n\tfloat minimum_cycle_duration <- 0.01;\n\toutput {\n\t\tlayout #split;\n\t\tdisplay displ_openGL type: 3d {\n\t\t\tspecies people aspect: big_circle_with_transparency;\n\t\t\t//\t\t\n\t\t\tagents \"layer simple\" value: [people(1)] aspect: simple;\n\t\t\tagents \"Text\" value: [people(2)] aspect: simple_text;\n\t\t\tagents \"locate geom\" value: [people(3)] aspect: locate_geometry;\n\t\t\tagents \"image\" value: [people(4)] aspect: image;\n\t\t\t//\n\t\t\tagents \"3D\" value: [people(5)] aspect: col3D;\n\t\t\tagents \"Textured\" value: [people(6)] aspect: textured;\n\t\t\t//\n\t\t\tagents \"Arrows\" value: [people(7)] aspect: arrows;\n\t\t\t//\n\t\t\tagents \"simple with transparency\" value: [people(8)] aspect: big_square_for_transparency transparency: 0.5;\n\t\t\t//\n\t\t\t// when no aspect: facet is specified, GAMA tries to use the aspect named default. \n\t\t\t// If no such an aspect exists, it draws the shape of the agent with a color defined in the preferences.\t\t\t\t\n\t\t\tspecies people;\n\t\t}\n\n\t\t//\t\tdisplay displ_2D type: 2d {\n\t\t//\t\t\tspecies people aspect: big_circle_with_transparency;\n\t\t//\t\t\t//\t\t\n\t\t//\t\t\tagents \"layer simple\" value: [people(1)] aspect: simple;\n\t\t//\t\t\tagents \"Text\" value: [people(2)] aspect: simple_text;\n\t\t//\t\t\tagents \"locate geom\" value: [people(3)] aspect: locate_geometry;\t\t\t\n\t\t//\t\t\tagents \"image\" value: [people(4)] aspect: image;\n\t\t//\t\t\t//\n\t\t//\t\t\tagents \"3D\" value: [people(5)] aspect: col3D;\t\n\t\t//\t\t\tagents \"Textured\" value: [people(6)] aspect: textured;\t\t\t\n\t\t//\t\t\t//\n\t\t//\t\t\tagents \"Arrows\" value: [people(7)] aspect: arrows;\n\t\t//\t\t\t//\n\t\t//\t\t\tagents \"simple with transparency\" value: [people(8)] aspect: big_square_for_transparency transparency: 0.5;\t\t\t\t\t\n\t\t//\t\t\t//\n\t\t//\t\t\t// when no aspect: facet is specified, GAMA tries to use the aspect named default. \n\t\t//\t\t\t// If no such an aspect exists, it draws the shape of the agent with a color defined in the preferences.\t\t\t\t\n\t\t//\t\t\tspecies people;\t\t\t\t\t\n\t\t//\t\t}\t\t\n\t}\n\n}"}
{"prompt": "Show a GUI application that displays and compares different Color Brewer palettes for sequential, diverging, and qualitative colors, allowing users to select and visualize various color schemes.", "gaml_code": "/**\n* Name: Color defined by choosing a Color Brewer\n* Author:  Arnaud Grignard & Patrick Taillandier\n* Description: A model to show how to use color brewer. In this model, two experiments are presents : one just to show the different colors present \n* \tin some selected brewer, and a second one to show in a grid the different colors of the brewer having at least a minimal number of colors passed \n* \tin parameter.\n* Tags: color\n*/\n\n\nmodel ColorBrewer\n\n\nglobal {\n\n\t//number of colors\n\tint nb_classes<-14 min:1 max: 15;\n\t\n\t\n\t//list of palettes that have at least nb_classes\n\tlist<string> palettes <- brewer_palettes(nb_classes);\n\t\n\t//the current sequential palette from the list of all available sequential Palettes\n\tstring sequentialPalette <- \"YlOrRd\" among:[\"YlOrRd\",\"Grays\",\"PuBu\",\"BuPu\",\"YlOrBr\",\"Greens\",\"BuGn\",\"GnBu\",\"PuRd\",\"Purples\",\"Blues\",\"Oranges\",\"OrRd\",\"Reds\",\"YlGn\",\"YlGnBu\"] on_change:update_colors;\n\t\n\t//the current diverging palette from the list of all available diverging Palettes\n\tstring divergingPalette <- \"BrBG\" among:[\"PRGn\",\"PuOr\",\"RdGy\",\"Spectral\",\"RdYlGn\",\"RdBu\",\"RdYlBu\",\"PiYG\",\"BrBG\"] on_change:update_colors;\n\t\n\t//the current qualitative palette from the list of all available qualitative Palettes\n\tstring qualitativePalette <- \"Pastel1\" among:[\"Accents\",\"Paired\",\"Set3\",\"Set2\",\"Set1\",\"Dark2\",\"Pastel2\",\"Pastel1\"] on_change:update_colors;\n\t\n\t//build the lists of colors from the palettes\n\tlist<rgb> SequentialColors <- brewer_colors(sequentialPalette);\n\tlist<rgb> DivergingColors <- brewer_colors(divergingPalette);\n\tlist<rgb> QualitativeColors <- brewer_colors(qualitativePalette);\n\t\n\taction update_colors{\n\t\tSequentialColors <-  brewer_colors(sequentialPalette);\n\t\tDivergingColors <- brewer_colors(divergingPalette);\n\t\tQualitativeColors <- brewer_colors(qualitativePalette);\n\t\task experiment{\n\t\t\tdo update_outputs(true);\n\t\t}\n\t}\n\t\n\tinit {\n\t\t//if the palettes is not empty\n\t\tif (not empty(palettes)) {\n\t\t\t//for each palette\n\t\t\tloop i from: 0 to: length(palettes) - 1 {\n\t\t\t\t//define a  list of nb_classes colors from the current palette\n\t\t\t\tlist<rgb> colors <- brewer_colors(palettes[i],nb_classes);\n\t\t\t\t\n\t\t\t\t//define the colors of the corresponding cells\n\t\t\t\task cell where (each.grid_y = i){\n\t\t\t\t\tpalette <- palettes[i];\n\t\t\t\t\tcolor <- colors[grid_x,i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ngrid cell width:nb_classes height: max([1,length(palettes)]) {\n\tstring palette;\n}\n\n\n//in this experiment, we do not use the cell agents, but we directlty draw the different palettes of colors\nexperiment BrewerPalette type: gui {\n\t\n\tfont base_font <- font(\"helvetica\", 12, #bold);\n\tfloat legend_offset <- 11.0;\n\tfloat square_size;\n\t\n\t\n\t\n\tparameter \"Sequential Palettes\" var:sequentialPalette category:\"Brewer\";\n\tparameter \"Diverging Palettes\" var:divergingPalette category:\"Brewer\";\n\tparameter \"Qualitatives Palettes\" var:qualitativePalette category:\"Brewer\";\n\t\n\tinit {\n\t\tsquare_size <- (world.shape.width - legend_offset) / nb_classes;\t\t\n\t} \n\t\n\t\n\toutput {\n\t\tdisplay View1 type:3d antialias:false axes:false{\n\t\t\tgraphics \"brewer\" position:{0, 20} {\n\t\t\t\t//Sequential\n\t\t\t\tdraw \"Sequential\" at:{0,square_size/2} color:#black perspective:true font:base_font;\n\t\t\t\tloop i from:0 to:length(SequentialColors)-1{\n\t\t\t\t\tdraw square(square_size) color:SequentialColors[i] at: {legend_offset +  square_size*(0.5 + i), square_size/2, 0};\n\t\t\t\t}\n\t\t\t\t//Diverging\n\t\t\t\tdraw \"Diverging\" at:{0,1.5*square_size} color:#black perspective:true  font:base_font;\n\t\t\t\tloop i from:0 to:length(DivergingColors)-1{\n\t\t\t\t\tdraw square(square_size) color:DivergingColors[i] at: {legend_offset + square_size*(0.5 + i), 1.5*square_size, 0};\n\t\t\t\t}\n\t\t\t\t//Qualitative\t\t\n\t\t\t\tdraw \"Qualitative\" at:{0,2.5*square_size} color:#black perspective:true  font:base_font;\n\t\t\t\tloop i from:0 to:length(QualitativeColors)-1{\n\t\t\t\t\tdraw square(square_size) color:QualitativeColors[i] at: {legend_offset + square_size*(0.5 + i), 2.5*square_size, 0};\n\t\t\t\t}\n\t\t    }\n\t\t}\t\n\t}\n}\n\n//in this experiment, we display the cell agents with the  different aspects\nexperiment BrewerColoredAgent type: gui {\n\tparameter \"Number of data classes\" var:nb_classes category:\"Brewer\";\n\toutput {\n\t\tdisplay View1 antialias:false axes:false{\n\t\t\tgrid cell border: #black ;\n\t\t\tgraphics \"Names\" {\n\t\t\t\tloop i from:0 to:length(palettes)-1 {\n\t\t\t\t\tdraw string(i)+\":\"+cell[0,i].palette at:cell[0,i].location-{9,-1,0} color:#black;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}"}
{"prompt": "Create a 3D visualization of a city's heatmap that displays the number of people passed through each area without modifying the original imported model.", "gaml_code": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it WITHOUT CHANGING A LINE OF THE ORIGINAL MODEL IMPORTED. \n* This heatmap records the number of people passed in each area of the city.\n* Author: Alexis Drogoul\n* Tags: \n*/\nmodel BuildingHeatmap\n\nimport \"3D Visualization/models/Building Elevation.gaml\"\n\nglobal {\n\tint size <- 300;\n\tfield instant_heatmap <- field(size, size);\n\tfield history_heatmap <- field(size, size);\n\treflex update {\n\t\tinstant_heatmap[] <- 0 ;\n\t\task people {\n\t\t\tinstant_heatmap[location] <- instant_heatmap[location] + 10;\n\t\t\thistory_heatmap[location] <- history_heatmap[location] + 1;\n\t\t}\n\t}\n}\n\nexperiment \"Show heatmap\" type: gui {\n\toutput synchronized:true{\n\t\tlayout #split;\n\t\t\n\t\tdisplay city_display type: 3d {\n\t\t\tcamera 'default' location: {1318.6512,3.5713,945.6612} target: {431.7016,495.2155,0.0};\n\t\t\tlight #ambient intensity: 180;\n\t\t\tlight #default intensity: 180 direction: {0.5, 0.5, -1};\n\t\t\tevent #mouse_down {ask simulation {do resume;}}\n\t\t\tspecies building aspect: base refresh: false;\n\t\t\tspecies road aspect: base refresh: false;\n\t\t\tspecies people refresh: true;\n\t\t}\n\t\tdisplay \"Instant heatmap with palette\" type: 3d axes: false background: #black  {\n\t\t\t// The field is displayed  without 3D rendering, a palettre of warm colors and a smoothness of 2 (meaning two passes of box blur are being done to \"spread\" the values)\n\t\t\tmesh instant_heatmap scale: 0 color: palette([ #black, #black, #orange, #orange, #red, #red, #red]) smooth: 2 ;\n\t\t}\n\t\tdisplay \"History heatmap with gradient\" type: 3d axes: false background: #black camera: #from_up_front {\n\t\t\t// The field is displayed a little bit above the other layers, with a slight 3D rendering, and a smoothness of 1 (meaning one pass of box blur is being done to \"spread\" the values). The colors are provided by a gradient with three stops\n\t\t\tmesh history_heatmap scale: 0.01 color: gradient([#black::0, #cyan::0.5, #red::1]) transparency: 0.2 position: {0, 0, 0.001} smooth:1 ;\n\t\t }\n\t\t\n\n\t}\n\n}"}
{"prompt": "Create a 3D visualization of various color palettes and gradients using NetLogo's GAML language.", "gaml_code": "/**\n* Name: PalettesandGradients\n* Based on the internal empty template. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel PalettesandGradients\n\nglobal {\n\t\n\tgrid_file volcano <- grid_file(\"includes/vulcano_50.asc\");\n\tfield cells <- field(volcano);\n\tgeometry shape <- square(200);\n\tinit {\n\t\twrite max(cells);\n\t\twrite min(cells);\n\t}\n}\n\n\nexperiment Palettes type: gui {\n\toutput synchronized: true {\n\t\tlayout #split;\n\t\tdisplay \"Brewer\" type: 3d {\n\t\t\tmesh cells  color:(brewer_colors(\"Set3\")) triangulation: true smooth: true;\n\t\t}\n\n\n\t\tdisplay \"One Color\" type: 3d  {\n\t\t\tmesh cells  color: #green triangulation: true border: #yellow smooth: true;\n\t\t}\n\t\t\n\t\t\n\t\tdisplay \"Scale\" type: 3d  {\n\t\t\tmesh cells  color: scale([#red::1, #yellow::2, #green::3, #blue::6]) triangulation: true smooth: true;\n\t\t}\n\t\t\n\n\t\tdisplay \"Texture \" type: 3d { \n\t\t\tmesh cells texture: file(\"includes/Texture.jpg\") triangulation: true border: #black smooth: true;\n\t\t\t\n\t\t}\n\t\tdisplay \"Simple gradient\" type: 3d { \n\t\t\tmesh cells color: palette([#darkgreen, #darkgreen, #green, #green, #sienna, #sienna, #white]) triangulation: true border: #black ;\n\t\t\t\n\t\t}\n\t}\n\n}"}
{"prompt": "Design a graphical model that demonstrates conditional aspect selection using GAML, allowing users to toggle between light and dark modes.", "gaml_code": "/**\n* Name: Conditional_aspect_selection\n* Author: Baptiste Lesquoy\n* Tags: \n*/\n\n\nmodel Conditional_aspect_selection\n\nglobal {\n\t\n\tbool dark_mode <- false;\n\tfont my_font <- font(\"Helvetica\", 16, #bold);\n\tinit {\n\t\tcreate dummy number:10;\n\t}\n\t\n}\n\nspecies dummy {\n\t\n\taspect light {\n\t\tdraw circle(2) color:#red;\n\t}\n\taspect dark {\n\t\tdraw circle(2) color:#darkred;\n\t}\n}\n\n\nexperiment test {\n\tparameter \"Toggle dark mode\" var:dark_mode;\n\toutput{\n\t\tdisplay main background:dark_mode?#black:#white{\n\t\t\tspecies dummy {\n\t\t\t\tif dark_mode {\n\t\t\t\t\tdraw dark;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdraw light;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tgraphics \"Instructions\"{\n\t\t\t\tdraw \"Toggle the dark mode parameter and run a simulation step\" at:{5,5} color:dark_mode?#white:#black font:my_font;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that allows users to interactively create and customize agents using GUI commands.", "gaml_code": "/**\n* Name: User Command\n* Author: Patrick Taillandier\n* Description: Model which shows how to use the user commands in order to create agents in the display. The user has two possibilities : \n* \tcreate one agent, or create a number of agents, with the possibility to change their shape and a pink color. The user also has the possibility \n* \tto change the color and the shapes of the agents.\n* Tags: gui\n */\n\nmodel usercommand\n\nglobal {\n\t//Number of agent to initialise\n\tint nbAgent <- 1;\n\t\n\tinit {\n\t\t//Create the agent\n\t\tcreate cell number: nbAgent {\n\t\t\tcolor <-#green;\n\t\t}\n\t}\n\t\n\t//These commands are displayed in the world layer\n\t//User command to create an agent according to the location where the user right click\n\tuser_command \"Create an agent\" {\n   \t\tcreate cell number: nbAgent with: [location::#user_location]  {\n   \t\t\tcolor <-#green;\n   \t\t} \n\t}\n\t//User command to create a given number of agents according\n\tuser_command \"Create agents\" {\n\t\t map input_values <- user_input_dialog([enter(\"Number\" , nbAgent), choose(\"shape\", string, \"circle\", [\"circle\", \"square\"])]);\n     \t create cell number: int(input_values at \"Number\") with: [color:: #pink, is_square:: string(input_values at \"shape\") = \"square\"];\n\t}\n\t\n}\n\n//Species that will be used\nspecies cell {\n\trgb color;\t\n\tbool is_square <- false; \n\t\n\t//These commands will be displayed in the cells layer, after right clicking on a agent\n\tuser_command \"change color\"action: change_color;\n\tuser_command \"change shape\" action: change_shape;\n\t\n\t//Action to change the color of the agent triggered by change color user command\n\taction change_color \n    {\n     color <- color = #green ? #pink : #green;\n    } \n\t//Action to change the shape of the agent triggered by change shape user command\n    action change_shape\n    {\n       is_square <- not (is_square);\n    }\n\taspect default {\n\t\tdraw is_square ? square(2): circle(1) color: color;\n\t}\n}\n\n\nexperiment Displays type: gui {\n\toutput {\n\t\tdisplay map { \n\t\t\tspecies cell;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates moving agents on a grid, allowing users to select and manipulate groups of agents using mouse clicks and keyboard shortcuts.", "gaml_code": "/**\n* Name: MovingAgents\n* Author: drogoul\n* Description: Shows how to move agents using two event layers : \n* \n* Click to grab an group of agents, click again to drop them. Press the keys \"r\" to kill the agents in the selection, and \"c\" to duplicate them.\n* Tags: gui\n*/\nmodel MovingAgents\n\nglobal\n{\n\tlist<being> moved_agents ;\n\tgeometry shape <- square(1000);\n\tgeometry zone <- circle(100);\n\tbool can_drop;\n\tinit\n\t{\n\t\tcreate being number: 100;\n\t}\n\n\taction kill \n\t{\n\t\task moved_agents\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tmoved_agents <- [];\n\t}\n\n\taction duplicate \n\t{\n\t\tgeometry available_space <- (zone at_location #user_location) - (union(moved_agents) + 10);\n\t\tcreate being number: length(moved_agents) with: (location: any_location_in(available_space));\n\t}\n\n\taction click \n\t{\n\t\tif (empty(moved_agents))\n\t\t{\n\t\t\tmoved_agents <- being inside (zone at_location #user_location);\n\t\t\task moved_agents\n\t\t\t{\n\t\t\t\tdifference <- #user_location - location;\n\t\t\t\tcolor <- # olive;\n\t\t\t}\n\n\t\t} else if (can_drop)\n\t\t{\n\t\t\task moved_agents\n\t\t\t{\n\t\t\t\tcolor <- # burlywood;\n\t\t\t}\n\n\t\t\tmoved_agents <- [];\n\t\t}\n\n\t}\n\n\taction move \n\t{\n\t\tcan_drop <- true;\n\t\tlist<being> other_agents <- (being inside (zone at_location #user_location)) - moved_agents;\n\t\tgeometry occupied <- geometry(other_agents);\n\t\task moved_agents\n\t\t{\n\t\t\tlocation <- #user_location - difference;\n\t\t\tif (occupied intersects self)\n\t\t\t{\n\t\t\t\tcolor <- # red;\n\t\t\t\tcan_drop <- false;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tcolor <- # olive;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies being skills: [moving]\n{\n\tgeometry shape <- square(10);\n\tpoint difference <- { 0, 0 };\n\trgb color <- # burlywood;\n\treflex r\n\t{\n\t\tif (!(moved_agents contains self))\n\t\t{\n\t\t\tdo wander amplitude: 30.0;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color at: location + {1,0,1};\n\t}\n\n}\n\nexperiment \"Click and Move\" type: gui\n{\n\tfont regular <- font(\"Helvetica\", 14, # bold);\n\trgb c1 <- rgb(#darkseagreen, 120);\n\trgb c2 <- rgb(#firebrick, 120);\n\toutput\n\t{\n\t\tlayout #split;\n\t\tdisplay \"Click and Move [JAVA3D]\" type: 3d  axes: false parent: \"Click and Move [JAVA2D]\"\n\t\t{\n\t\t\tlight #ambient intensity: 100;\n\t\t}\n\t\t\n\t\t\n\t\tdisplay \"Click and Move [JAVA2D]\" type: 2d \n\t\t{\n\n\t\t\tgraphics \"Full target\" \n\t\t\t{\n\t\t\t\tint size <- length(moved_agents);\n\t\t\t\tif (size > 0)\n\t\t\t\t{\n\t\t\t\t\tdraw zone at: #user_location wireframe: false border: false color: (can_drop ? c1 : c2);\n\t\t\t\t\tdraw string(size) at: #user_location + { -30, -30 } font: regular color: # white;\n\t\t\t\t\tdraw \"'r': remove\" at: #user_location + { -30, 0 } font: regular color: # white;\n\t\t\t\t\tdraw \"'c': copy\" at: #user_location + { -30, 30 } font: regular color: # white;\n\t\t\t\t} else {\n\t\t\t\t\tdraw zone at: #user_location wireframe: false border: false color: #wheat;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tspecies being;\n\t\t\tevent #mouse_move {ask simulation {do move;}} \n\t\t\tevent #mouse_up {ask simulation {do click;}} \n\t\t\tevent 'r' {ask simulation {do kill;}} \n\t\t\tevent 'c'{ask simulation {do duplicate;}} \n\n\n\t\t}\n\n\t\t\n\t\t\n\t}\n\n}"}
{"prompt": "Design a simple GUI model that demonstrates how to use wizards with two pages and validation of user input.", "gaml_code": "/**\n* Name: Wizard_example\n* Author: Patrick Taillandier\n* Description: Model which shows how to use wizards \n* Tags: gui\n */\n\nmodel Wizard_example\n\nglobal {\n\tinit {\n\t\tmap results <-  wizard(\"My wizard\", eval_finish,\n\t\t\t[ \n\t\t\twizard_page(\"page1\",\"enter info page 1\" ,[enter(\"file\" , file), choose(\"shape\", string, \"circle\", [\"circle\", \"square\"])], font(\"Helvetica\", 14 , #bold)),\n\t\t\twizard_page(\"page2\",\"enter info page 2\" ,[enter(\"var2\",string), enter(\"to consider\", bool, true)], font(\"Arial\", 10 , #bold))\n\t\t\t] \n\t\t);\n\t\twrite sample(results);  \n\t}\n\t\n\tbool eval_finish(map<string,map> input_map) {\n\t\twrite input_map;\n\t\t\n\t\t return input_map[\"page2\"][\"var2\"] != nil;\n\t}\n}\n\nexperiment Wizard_example type: gui ;"}
{"prompt": "Create a simple GUI model that demonstrates how to use a confirmation dialog box and write the result of the user's response.", "gaml_code": "/**\n* Name: Confirmdialog_example\n* Author: Patrick Taillandier\n* Description: Model which shows how to use confirm dialog box \n* Tags: gui\n */\n\nmodel Confirmdialog_example\n\nglobal {\n\tinit {\n\t\tbool  result <- user_confirm(\"Confirmation dialog box\",\"Do you want to confirm?\");\n\t\twrite sample(result);\n\t}\n}\n\nexperiment Confirmdialog_example type: gui ;"}
{"prompt": "Create a GUI model that simulates mouse interactions (drag, down, up) to move an agent on a canvas, using OpenGL and Java2D displays.", "gaml_code": "/**\n* Name: MouseDrag\n* \n* Demonstrates the usage of the mouse_drag events to move an agent using user\n* interactions. Drag events are triggered when the mouse is moving with the\n* mouse button down. Notice that move events are not triggered when the mouse\n* button is down.\n* \n* Author: breugnot\n* Tags: gui, event, mouse_move, mouse_drag, mouse_down, mouse_up\n*/\n\nmodel mouse_event\n\nglobal {\n\tgeometry shape <- square(20);\n\tDraggedAgent selected_agent <- nil;\n\tinit {\n\t\tcreate DraggedAgent with: (location: {10, 10});\n\t}\n\t\n\t/** Insert the global definitions, variables and actions here */\n\taction mouse_down {\n\t\task DraggedAgent {\n\t\t\tif( self covers #user_location) {\n\t\t\t\t// Selects the agent\n\t\t\t\tselected_agent <- self;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction mouse_up {\n\t\tif(selected_agent != nil) {\n\t\t\tselected_agent <- nil;\n\t\t}\n\t}\n\t\n\taction mouse_drag {\n\t\t// Makes the agent follow the mouse while the mouse button is down\n\t\tif(selected_agent != nil) {\n\t\t\task selected_agent {\n\t\t\t\tlocation <- #user_location;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies DraggedAgent {\n\tinit {\n\t\tshape <- circle(1);\n\t}\n\taspect default {\n\t\tdraw shape at: location;\n\t}\n}\n\nexperiment \"Mouse Drag\" type: gui {\n\t/** Insert here the definition of the input and output of the model */\n\toutput {\n\t\tdisplay \"Mouse Drag [in OpenGL]\" type:opengl {\n\t\t\tcamera #from_above locked:true;\n\t\t\tevent #mouse_down {ask simulation {do mouse_down;}}\n\t\t\tevent #mouse_up {ask simulation {do mouse_up;}}\n\t\t\tevent #mouse_drag {ask simulation {do mouse_drag;}}\n\t\t\t\n\t\t\tgraphics \"world\" {\n\t\t\t\tdraw world color: #white border:#black;\n\t\t\t}\n\n\t\t\tspecies DraggedAgent aspect:default;\n\t\t}\n\n\t\tdisplay \"In Java2D, one needs to lock the surface first \" type:java2D {\n\t\t\tevent #mouse_down {ask simulation {do mouse_down;}}\n\t\t\tevent #mouse_up {ask simulation {do mouse_up;}}\n\t\t\tevent #mouse_drag {ask simulation {do mouse_drag;}}\n\t\t\t\n\t\t\tgraphics \"world\" {\n\t\t\t\tdraw world color: #white border:#black;\n\t\t\t}\n\t\t\t\n\t\t\tspecies DraggedAgent aspect:default;\n\t\t}\n\t}\n}"}
{"prompt": "Create a graphical user interface (GUI) model that demonstrates how to use event layers to define a tools panel for selecting and applying actions on a map display.", "gaml_code": "/***\n* Name: ToolsPanel\n* Author: Patrick Taillandier\n* Description: Model which shows how to use the event layer to define a tools panel. In this model, the modelers can select one of \n* the 4 tools (icon - building1, building2, building3 and eraser) to carry out action on the map display. More precisely, when one tool \n* is selected (red rectangle), the tool change the color of the selected cells and display the corresponding icon (in map display).\n* Tags: gui, user event, tool panel\n***/\n\nmodel ToolsPanel\n\nglobal {\n\n\t//current action type\n\tint action_type <- -1;\t\n\t\n\t//images used for the buttons\n\tlist<file> images <- [\n\t\tfile(\"../images/building1.png\"),\n\t\tfile(\"../images/building2.png\"),\n\t\tfile(\"../images/building3.png\"),\n\t\tfile(\"../images/eraser.png\")\n\t\t\n\t]; \n\t\n\t\n\taction activate_act {\n\t\tbutton selected_but <- first(button overlapping (circle(1) at_location #user_location));\n\t\tif(selected_but != nil) {\n\t\t\task selected_but {\n\t\t\t\task button {bord_col<-#black;}\n\t\t\t\tif (action_type != id) {\n\t\t\t\t\taction_type<-id;\n\t\t\t\t\tbord_col<-#red;\n\t\t\t\t} else {\n\t\t\t\t\taction_type<- -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction cell_management {\n\t\tcell selected_cell <- first(cell overlapping (circle(1.0) at_location #user_location));\n\t\tif(selected_cell != nil) {\n\t\t\task selected_cell {\n\t\t\t\tbuilding <- action_type;\n\t\t\t\tswitch action_type {\n\t\t\t\t\tmatch 0 {color <- #red;}\n\t\t\t\t\tmatch 1 {color <- #white;}\n\t\t\t\t\tmatch 2 {color <- #yellow;}\n\t\t\t\t\tmatch 3 {color <- #black; building <- -1;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\ngrid cell width: 10 height: 10 {\n\trgb color <- #black ;\n\tint building <- -1;\n\taspect default {\n\t\tif (building >= 0) {\n\t\t\tdraw image_file(images[building]) size:{shape.width * 0.5,shape.height * 0.5} ;\n\t\t}\n\t\t \n\t}\n}\n\ngrid button width:2 height:2 \n{\n\tint id <- int(self);\n\trgb bord_col<-#black;\n\taspect normal {\n\t\tdraw rectangle(shape.width * 0.8,shape.height * 0.8).contour + (shape.height * 0.01) color: bord_col;\n\t\tdraw image_file(images[id]) size:{shape.width * 0.5,shape.height * 0.5} ;\n\t}\n}\n\n\nexperiment ToolsPanel type: gui {\n\toutput {\n\t\t\tlayout horizontal([0.0::7285,1::2715]) tabs:true;\n\t\tdisplay map type:2d antialias:false{\n\t\t\tgrid cell border: #white;\n\t\t\tspecies cell;\n\t\t\tevent #mouse_down {ask simulation {do cell_management;}}\n\t\t\t\n\t\t}\n\t\t//display the action buttons\n\t\tdisplay action_button background:#black name:\"Tools panel\"  type:2d antialias:false{\n\t\t\tspecies button aspect:normal ;\n\t\t\tevent #mouse_down {ask simulation {do activate_act;}}  \n\t\t}\n\t}\n}"}
{"prompt": "Design a GUI-based model for simulating agent creation and death using a user control interface, allowing users to switch between basic and advanced modes.", "gaml_code": "/**\n* Name: User Command\n* Author: Patrick Taillandier\n* Description: Model which shows how to use the advanced user control, to create and kill agents. \n* Tags: gui, architecture\n */\n\n\nmodel user_control\n\nglobal {\n\n\tint nbAgent <- 10;\n\tbool advanced_user_control <- false;\n\tinit {\n\t\tcreate cell number: nbAgent {\n\t\t\tcolor <-#green;\n\t\t}\n\t\tcreate user;\n\t}\n}\n\nspecies cell {\n\trgb color;\t\n\taspect default {\n\t\tdraw circle(1) color: color;\n\t}\n}\n\nspecies user control:user_only {\n   user_panel \"Default\" initial: true {\n      transition to: \"Basic Control\" when: every (10#cycles) and !advanced_user_control;\n      transition to: \"Advanced Control\" when: every(10#cycles) and advanced_user_control;\n   }\n   \n   user_panel \"Basic Control\" {\n      user_command \"Kill one cell\" {\n         ask (one_of(cell)){\n            do die;\n         }\n      }\n      user_command \"Create one cell\" {\n        create cell { \n\t\t\tcolor <-#green; \n\t\t}\n      } \n      transition to: \"Default\" when: true;                    \n   }\n   user_panel \"Advanced Control\" {\n      user_command \"Kill cells\" color: #red continue: true{\n        user_input \"Number\" returns: number type: int <- 10;\n        ask (number among cell){\n           do die;\n        }\n      }\n      user_command \"Create cells\" color: #green {\n        user_input \"Number\" returns: number type: int <- 10;\n        create cell number: number{ \n\t\t\tcolor <-#green; \n\t\t}\n      } \n      transition to: \"Default\" when: true;        \n   }\n}\n\n\nexperiment Displays type: gui {\n\tparameter \"advanced user control\" var: advanced_user_control <- false;\n\toutput { \n\t\tdisplay map { \n\t\t\tspecies cell;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that displays user location and mouse movement on two different types of displays (2D and 3D) using constants.", "gaml_code": "/**\n* Name: DisplayConstants\n* This model shows the use of some \"constants\" defined in GAML that allow to gather information about the user manipulation / actions in displays \n* Author: drogoul\n* Tags: Display, \n*/\n\n\nmodel DisplayConstants\n\nexperiment \"Run\" {\n\n\toutput {\n\t\tdisplay \"Display2d\" background: #black type: 2d {\n\t\t\tgraphics back {\n\t\t\t\tdraw rectangle(shape.width, shape.height) color: #blue;\n\t\t\t}\n\t\t\tgraphics g {\n\t\t\t\tdraw \"In world: \" + #user_location at: #user_location;\n\t\t\t\tdraw \"In display: \" + #user_location_in_display at: #user_location + {0,5};\n\t\t\t}\n\t\t\tevent #mouse_move {do update_outputs;}\n\t\t\t\n\t\t}\n\t\tdisplay \"Display3d\" background: #black type: 3d {\n\t\t\tgraphics back {\n\t\t\t\tdraw rectangle(shape.width, shape.height) color: #blue;\n\t\t\t}\n\t\t\tgraphics g {\n\t\t\t\tdraw \"In world: \" + #user_location at: #user_location;\n\t\t\t\tdraw \"In display\" + #user_location_in_display at: #user_location + {0,5};\n\t\t\t}\n\t\t\tevent #mouse_move {do update_outputs;}\n\t\t\t\n\t\t}\n\n\n\n\t}\n\t\n}"}
{"prompt": "Create an example GAML model that demonstrates how to use user_input_dialog to collect input from a GUI and write it to the console.", "gaml_code": "/**\n* Name: UserInputdialog_example\n* Author: Patrick Taillandier\n* Description: Model which shows how to use user_input_dialog \n* Tags: gui\n */\n\nmodel Confirmdialog_example\n\nglobal {\n\tinit {\n\t\t//2 types of elements can be added: enter (enter a value) and choose (choose a value among a list of possible values)\n\t\tmap  result <- user_input_dialog(\"Main title\",[enter(\"Enter a value\", 0.0) , choose(\"Choose a value\",string,\"value 1\", [\"value 1\",\"value 2\"])]);\n\t\t\n\t\twrite sample(result);\n\t}\n}\n\nexperiment UserInputdialog_example type: gui ;"}
{"prompt": "Create a NetLogo model that demonstrates how to use the event layer to trigger actions based on user interactions (mouse clicks and movements) in a GUI environment. The model should include two displays, one for changing color and one for changing shape, with agents that respond to these changes.", "gaml_code": "/**\n* Name: Event Feature\n* Author: Arnaud Grignard & Patrick Taillandier & Jean-Daniel Zucker\n* Description: Model which shows how to use the event layer to trigger an action according to an event occuring in the display. The experiment \n* has two displays : one for the changing color event, one for the changing shape event.\n* Tags: gui\n */\nmodel event_layer_model\n\n\nglobal\n{\n\n//number of agents to create\n\tint nbAgent <- 200;\n\tint radius <- 10;\n\tdummy pointClicked;\n\n\tinit {\n\t//creation of the agents\n\t\tcreate cell number: nbAgent\n\t\t{\n\t\t\tcolour <- #darkgreen;\n\t\t}\n       create dummy number:1 returns: temp with: [dummyRadius :: radius];\n       pointClicked <- first(temp);\n   }\n\n\t//Action to change the color of the agents, according to the point to know which agents we're in intersection with the point\n\taction change_color \n\t{\n\n\t//change the color of the agents\n\t\t\n\t\tlist<cell> selected_agents <- cell overlapping (circle(10) at_location #user_location);\n\t\task selected_agents\n\t\t{\n\t\t\tcolour <- colour = #lightgreen ? #darkgreen : #lightgreen;\n\t\t}\n\n\t}\n\n\taction draw_clicked_area_in_view_color\n\t{\n\t\tpointClicked.location <- #user_location;\n\t\tpointClicked.visibleViewColor <- true;\n\t}\n\taction draw_clicked_area_in_view_shape\n\t{\n\t\tpointClicked.location <- #user_location;\n\t\tpointClicked.visibleViewShape <- true;\n\t}\n\n\taction hide_clicked_area\n\t{\n\t\tpointClicked.visibleViewColor <- false;\n\t\tpointClicked.visibleViewShape <- false;\n\t}\n\n\n\t//Action to change the shape of the agents, according to the point to know which agents we're in intersection with the point\n\taction change_shape \n\t{\n\t\tlist<cell> selected_agents <- cell overlapping (circle(radius) at_location #user_location);\n\t\task selected_agents\n\t\t{\n\n\t\t//change the bool attribute is_square to change the shape in the display\n\t\t\tis_square <- not (is_square);\n\t\t}\n\n\t}\n\n}\n\n//Species cells moving randomly\nspecies cell skills: [moving]\n{\n\trgb colour;\n\tbool is_square <- false;\n\treflex mm\n\t{\n\t\tdo wander amplitude: 30.0;\n\t}\n\n\taspect default\n\t{\n\t\tdraw is_square ? square(2) : circle(1) color: colour;\n\t}\n\n}\n\nspecies dummy  {\n\tint dummyRadius <- 10;\n\tbool visibleViewColor <- false;\n\tbool visibleViewShape <- false;\n\t\n\taspect aspect4ViewChangeColor {\n\t\tif visibleViewColor {draw circle(radius) color: #grey;}\n\t}\n\t\n\taspect aspect4ViewChangeShape {\n\t\tif visibleViewShape {draw circle(radius) color: #grey;}\n\t}\n\t\n}\n\n\n\nexperiment Displays type: gui\n{\n\tparameter \"Radius of selection\" var: radius ;\t// The radius of the disk around the click \n\toutput synchronized:true\n\t{    \n\t\tlayout horizontal([0::5000,1::5000]) tabs:true editors: false;\n\t\tdisplay View_change_color\n\t\t{\n\t\t\tspecies cell;\n\t\t\tspecies dummy transparency:0.9 aspect: aspect4ViewChangeColor;\n\t\t\t// event, launches the action change_color if the event mouse_down (ie. the user clicks on the layer event) is triggered\n\t\t\t// the action can be either in the experiment or in the global section. If it is defined in both, the one in the experiment will be chosen in priority\n\t\t\tevent #mouse_down {ask simulation {do change_color;}}  \n\t\t\tevent #mouse_move {ask simulation {do draw_clicked_area_in_view_color;}} \n\t\t\tevent #mouse_exit {ask simulation {do hide_clicked_area;}}\n\t\t\t// Shows how to manipulate the cells using keyboard events\n\t\t\tevent #arrow_left {ask (cell) {location <- location - {1,0};}}\n\t\t\tevent #arrow_right {ask (cell) {location <- location + {1,0};}}\n\t\t\tevent #arrow_up {ask (cell) {location <- location - {0,1};}}\n\t\t\tevent #arrow_down {ask (cell) {location <- location + {0,1};}}\n\t\t\tevent #escape {ask (cell) {location <- rnd(point(100,100));}}\n\t\t\t\n\t\t}\n\n\t\tdisplay View_change_shape type: 3d\n\t\t{\n\t\t\tlight #ambient active: false;\n\t\t\tspecies cell;\n\t\t\tspecies dummy transparency:0.9 aspect: aspect4ViewChangeShape ;\n\t\t\t//event, launches the action change_shape if the event mouse_down (ie. the user clicks on the layer event) is triggered\n\t\t\t// The block is executed in the context of the experiment, so we have to ask the simulation to do it. \n\t\t\tevent #mouse_down {ask simulation {do change_shape;}}  \n\t\t\tevent #mouse_move {ask simulation {do draw_clicked_area_in_view_shape;}} \n\t\t\tevent #mouse_exit {ask simulation {do hide_clicked_area;}} \n\t\t\t// Shows how to manipulate the cells using keyboard events, disactivating the \"regular\" arrow / esc keys behavior\n\t\t\tevent #arrow_left {ask (cell) {location <- location - {1,0};}}\n\t\t\tevent #arrow_right {ask (cell) {location <- location + {1,0};}}\n\t\t\tevent #arrow_up {ask (cell) {location <- location - {0,1};}}\n\t\t\tevent #arrow_down {ask (cell) {location <- location + {0,1};}}\n\t\t\tevent #escape {ask (cell) {location <- rnd(point(100,100));}}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of two eyes that follow and respond to mouse movement, opening when the mouse enters the screen and closing when it exits.", "gaml_code": "/***\n* Name: MouseExitandEnter\n* Author: A. Drogoul\n* Description:  Shows the use of the two mouse events : mouse_exit and mouse_enter. The display shows two eyes. When the mouse enters it, the eyes open and follow its movement. When the mouse exits the screen, they close.\n* Tags: user, mouse, interaction\n***/\n\nmodel MouseExitandEnter \n\n\nglobal {\n\tbool closed <- false;\n\tinit {\n\t\tcreate eyes with: [location::{25,30}];\n\t\tcreate eyes with: [location::{65,30}];\n\t}\n}\n\nspecies eyes {\n\tpoint look_at <- location;\n\t\n\taction follow {\n\t\tfloat heading <- location towards #user_location;\n\t\tlook_at <- location + {5*cos(heading), 5*sin(heading)};\n\t}\n\t\n\taspect outside {\n\t\t\tdraw sphere(15) color: #white ;\n\t}\n\t\n\taspect inside {\n\t\tdraw sphere(5) color: #blue wireframe: false at: look_at;\n\t}\n}\n\nexperiment Run {\n\toutput {\n\t\tdisplay Eyes type: 3d axes: false {\n\t\t\tgraphics face {\n\t\t\t\tdraw circle(60) color: #gamaorange;\n\t\t\t}\n\n\t\t\tgraphics mouth {\n\t\t\t\tdraw curve({20, 80}, {70, 80}, (cos(location towards #user_location))) + 5 depth: 5;\n\t\t\t}\n\n\t\t\tspecies eyes aspect: inside;\n\t\t\tspecies eyes aspect: outside transparency: closed ? 0.1 : 0.5;\n\t\t\tevent #mouse_exit {\n\t\t\t\tclosed <- true;\n\t\t\t}\n\n\t\t\tevent #mouse_enter {\n\t\t\t\tclosed <- false;\n\t\t\t}\n\n\t\t\tevent #mouse_move {\n\t\t\t\task eyes {\n\t\t\t\t\tdo follow;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tevent #mouse_menu {\n\t\t\t\tclosed <- !closed;\n\t\t\t}\n\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that demonstrates user interaction with a simulation, allowing users to pause and resume the simulation by clicking on an icon.", "gaml_code": "/***\n* Name: UserPauseandResume\n* Author: A. Drogoul\n* Description: Shows how to use the simulation actions 'pause' and 'resume' within a user interaction\n* Tags: simulation, pause, resume\n***/\nmodel UserPauseandResume\n\nglobal {\n\tgeometry shape <- square(400);\n\timage_file play <- image_file(\"../images/play.png\");\n\timage_file stop <- image_file(\"../images/stop.png\");\n\n\taction toggle {\n\t\tif paused {\n\t\t\task sign{\n\t\t\t\ticon <- stop;\n\t\t\t}\n\t\t\tdo resume;\n\t\t} else {\n\t\t\t\n\t\t\task sign{\n\t\t\t\ticon <- play;\n\t\t\t}\n\t\t\tdo pause;\n\t\t}\n\n\t}\n\n\tinit {\n\t\tcreate sign;\n\t}\n\n}\n\nspecies sign skills: [moving] {\n\n\tpoint location <- centroid(world);\n\timage_file icon <- play;\n\n\taspect default {\n\t\tdraw icon size: {100, 100};\n\t}\n\n\treflex wander {\n\t\tdo wander(speed: 0.3);\n\t} }\n\nexperiment 'Try Me !' {\n\toutput {\n\t\tdisplay Interaction {\n\t\t\tspecies sign;\n\t\t\tevent #mouse_down {\n\t\t\t\tif ((#user_location distance_to sign[0]) < 50) {\n\t\t\t\t\task world {\n\t\t\t\t\t\tdo toggle;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D model of an environment with various objects and lighting effects, using OpenGL rendering. Include interactive elements such as buttons to turn on/off lights.", "gaml_code": "/**\n* Name: Advanced 3D properties : specular light\n* Author: Julien Mazars\n* Description: Model presenting how to add materials to the objects, tunning the two properties of the material :\n* the damping factor (the larger this value is, the larger the reflection zone will be) and the reflectivity factor (between \n* 0 and 1, the ratio of light that is reflected). Notice that in order to run this model, you need to have a graphical card \n* and the facet \"use_shader\" activated in your display definition.\n* Tags: 3d, light\n*/\nmodel specular_light\n\nglobal {\n\t\n\tbool button;\n\n\tinit {\n\t\tcreate sphere_species {\n\t\t\tlocation <- {50, 50, 15};\n\t\t\tcolor <- #grey;\n\t\t\tsize <- 10.0;\n\t\t}\n\n\t\tcreate cube_species {\n\t\t\tlocation <- {70, 20, 5};\n\t\t\tcolor <- #orange;\n\t\t\tsize <- 14.0;\n\t\t}\n\n\t\tcreate sphere_species {\n\t\t\tlocation <- {30, 55, 13};\n\t\t\tcolor <- #red;\n\t\t\tsize <- 8.0;\n\t\t}\n\n\t\tcreate cylinder_species {\n\t\t\tlocation <- {80, 65, 4};\n\t\t\tcolor <- #darkolivegreen;\n\t\t\tsize <- 8.0;\n\t\t}\n\n\t\tcreate board {\n\t\t\tlocation <- myself.location;\n\t\t}\n\n\t\tcreate lamp {\n\t\t\tlocation <- {0, 0, 0};\n\t\t}\n\n\t}\n\n}\n\nspecies sphere_species {\n\trgb color;\n\tfloat size;\n\n\taspect base {\n\t\tdraw sphere(size) color: color;\n\t}\n\n}\n\nspecies cube_species {\n\trgb color;\n\tfloat size;\n\n\taspect base {\n\t\tdraw cube(size) color: color;\n\t}\n\n}\n\nspecies cylinder_species {\n\trgb color;\n\tfloat size;\n\n\taspect base {\n\t\tdraw cone3D(size, size * 2) rotated_by (90, {1, 0, 0}) color: color;\n\t}\n\n}\n\nspecies board {\n\n\n\taspect base {\n\t\tdraw rectangle(100, 100) texture: \"../includes/wood.jpg\";\n\t\tdraw rectangle(100, 10) at: {50, 5} depth: 10 texture: \"../includes/wood.jpg\";\n\t\tdraw rectangle(100, 10) at: {50, 95} depth: 10 texture: \"../includes/wood.jpg\";\n\t\tdraw rectangle(10, 100) at: {5, 50} depth: 10 texture: \"../includes/wood.jpg\";\n\t\tdraw rectangle(10, 100) at: {95, 50} depth: 10 texture: \"../includes/wood.jpg\";\n\t}\n\n}\n\nspecies lamp {\n\n\taspect base {\n\t\tdraw cylinder(2, 50) color: #darkgrey;\n\t\tdraw cylinder(10, 10) rotate: (45::{1, 1, 1}) at: {5, 5, 50} color: #darkgrey;\n\t}\n\n}\n\nexperiment specular_light type: gui autorun:true{\n\tparameter \"turn on/off the ligth\" var:button init:true;\n\toutput {\n\t\tlayout #split;\n\n\t\tdisplay \"OpenGL\" type: 3d background:#black  {\n\t\t\tcamera 'default' location: {-50.692,109.4647,74.8304} target: {60.563,33.0012,0.0};\n\t\t\tlight #ambient intensity: 20;\n\t\t\tlight #default active:button type: #point location: {7, 7, 48} intensity: #white show: true;\n\t\t\tspecies sphere_species aspect: base;\n\t\t\tspecies cube_species aspect: base;\n\t\t\tspecies cylinder_species aspect: base;\n\t\t\tspecies board aspect: base;\n\t\t\tspecies lamp aspect: base;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D visualization of GIS data from a shapefile, displaying buildings as textured shapes and images.", "gaml_code": "/**\n* Name: Visualization of GIS data\n* Author:  Patrick Taillandier\n* Description:  this model shows how to visualize GIS data without having to create agents  \n* Tags: 3d, shapefile, texture\n*/\n\nmodel GIS_visualization\n\nglobal {\n\tshape_file shape_file_buildings <- shape_file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(shape_file_buildings);\n\tstring texture <- \"../images/building_texture/texture1.jpg\";\n\tstring roof_texture <- \"../images/building_texture/roof_top.jpg\";\t\n}\n\nexperiment GIS_visualization type: gui {\n\tfloat minimum_cycle_duration <- 1#s;\n\n\t\n\toutput {\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false;\n\t\t// display of buildings in 3D with texture and with reading their HEIGHT attribute from the shapefile\n\t\tdisplay gis_displays_graphics type: 3d  {\n\t\t\tcamera 'default' location: {809.5553,1386.2038,705.1688} target: {301.1933,449.9174,0.0};\n\t\t\tgraphics \"Buildings as shapes\" refresh: false {\n\t\t\t\tloop bd over: shape_file_buildings {\n\t\t\t\t\tdraw bd depth: rnd(50) + 50 texture:[roof_texture,texture] border:false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//display of the building as an image\n\t\tdisplay gis_displays_image type: 3d {\n\t\t\timage \"Buildings as images\" gis: shape_file_buildings.path color: rgb(\"gray\") refresh: false;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a spot light with adjustable quadratic, linear, and constant attenuation using GAML.", "gaml_code": "/**\n* Name: QuadraticLinearandConstantatenuation\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n\nmodel QuadraticLinearandConstantattenuation\n\n\nglobal {\n\n\tinit {\n\t\tcreate GAMAGeometry2D number: 1 {\n\t\t\tlocation <- {world.shape.width / 2, world.shape.height / 2, 0};\n\t\t}\n\n\t}\n\n}\n\nspecies GAMAGeometry2D {\n\n\taspect default {\n\t\tdraw sphere(10) at: location color: #white border: #gray;\n\t}\n\n}\n\n\n\nexperiment Display type: gui autorun: true {\n\tfloat minimum_cycle_duration <- 0.01;\n\tfloat quad;\n\tfloat constant;\n\tfloat linear;\n\tint angle;\n\tint height;\n\tint distance;\n\tparameter \"Spot light angle\" var:angle <- 0 min:0 max:360 slider:true category:\"Spot light location\";\n\tparameter \"Spot light height\" var:height <- 0 min:-30 max:30 slider:true category:\"Spot light location\";\n\tparameter \"Spot light distance from ball\" var:distance <- 10 min:2 max:30 slider:true category:\"Spot light location\";\n\tparameter \"Quadratic attenuation\" var:quad <- 0.0001 min:0.0000001 max:0.001 slider:true category:\"Light attenuation\";\n\tparameter \"Linear attenuation\" var:linear <- 0.001 min:0.0000001 max:0.1 slider:true category:\"Light attenuation\";\n\tparameter \"Constant attenuation\" var:constant <- 0.1 min:0.0000001 max:9.0 slider:true category:\"Light attenuation\";\n\t\n\toutput {\n\t\tlayout #split;\n\t\t// display using spot lights\n\t\t// we set the ambient light to 0 to see better the directional lights (as if we were at night time)\n\t\tdisplay SpotLights type: 3d background: rgb(10, 40, 55) {\n\t\t\t\n\t\t\tcamera 'default' location: {-87.5648,126.2534,134.3343} target: {50.0,50.0,0.0};\n\t\t\tlight #ambient intensity: 0;\n\t\t\tlight #default intensity: 0;\n\t\t\tlight \"1\" \n\t\t\t\ttype: #spot \n\t\t\t\tlocation: {(world.shape.width/2 + distance) * cos(angle) + world.shape.width/2, (world.shape.height/2 + distance) * sin(angle) + world.shape.height / 2, height} \n\t\t\t\tdirection:{cos(angle + 180), sin(angle + 180), 0} \n\t\t\t\tintensity: #red \n\t\t\t\tshow: true \n\t\t\t\tlinear_attenuation:linear \n\t\t\t\tconstant_attenuation:constant \n\t\t\t\tquadratic_attenuation: quad \n\t\t\t\tdynamic: true;\n\t\t\t\n\t\t\tspecies GAMAGeometry2D;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that demonstrates various camera positions and movements in a 3D display, including fixed, dynamic, first-person, and isometric views.", "gaml_code": "/**\n* Name: Camera Position\n* Author: Arnaud Grignard & Alexis Drogoul\n* Description: A model presenting how to manipulate cameras in a 3D display\n* Tags: 3d\n*/\nmodel camera_locationition\n\nglobal {\n\n\tinit {\n\t\tcreate object;\n\t}\n\n}\n\nspecies object skills: [moving] {\n\n\treflex move {\n\t\tdo wander amplitude: 20.0 speed: 1.0;\n\t}\n\n\taspect default {\n\t\tdraw sphere(5) at: location color: #white border: #gray;\n\t}\n\n}\n\nexperiment Display type: gui autorun: true {\n\tfloat w -> simulation.shape.width; \n\tfloat h -> simulation.shape.height;\n\tpoint p -> first(object).location;\n\tfloat factor <- 1.0;\n\tparameter \"Shared zoom\" var: factor min: 0.01 max: 10.0;\n\tfloat minimum_cycle_duration <- 0.01;\n\toutput {\n\t\tlayout #split;\n\t\tdisplay shared type: 3d virtual: true {\n\t\t\timage \"../includes/wood.jpg\";\n\t\t\tspecies object;\n\t\t}\n\t\tdisplay \"Changing every 500\" parent: shared camera: [#from_up_front, #from_up_left, #from_up_right, #from_above, #from_front, #from_left, #from_right] at ((cycle / 500) mod 7) {\n\t\t}\n\t\tdisplay \"Fixed location\" parent: shared camera: \"fixed\" {\n\t\t\tcamera \"fixed\" locked: true location: {w / 2, h * 2, w / factor} target: {w / 2, h / 2, 0} dynamic: true;\n\t\t}\n\t\tdisplay \"Dynamic location\" parent: shared camera: #default {\n\t\t\tcamera #default location: {w * cos(cycle), w * sin(cycle), w / factor} target: {w / 2, h / 2, 0} dynamic: true;\n\t\t}\n\t\tdisplay \"Follow object\" parent: shared {\n\t\t\tcamera #default target: p distance: 150 / factor location: #from_above dynamic: true;\n\t\t}\n\t\tdisplay \"First person\" type: opengl{\n\t\t\timage \"../includes/wood.jpg\";\n\t\t\tcamera #default dynamic: true location: {int(first(object).location.x), int(first(object).location.y), 5/factor} target:\n\t\t\t{cos(first(object).heading) * first(object).speed + int(first(object).location.x), sin(first(object).heading) * first(object).speed + int(first(object).location.y), 5/factor};\n\t\t}\n\t\tdisplay \"Camera & rotation\" parent: shared {\n\t\t\trotation angle: 1.0 axis: {0,1,0} dynamic: true;\n\t\t\tcamera #default location: #from_right distance: 40 / factor target: {w, p.y, 0} dynamic: true;\n\t\t}\n\t\tdisplay \"Isometric\" parent: shared {\n\t\t\tcamera #default location: #isometric target: {p.x, p.y, 0} dynamic: true;\n\t\t}\n\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that demonstrates the manipulation of lights (spot lights and point lights) in a 3D display, including their movement, direction, and intensity, with a GUI interface to visualize the effects.", "gaml_code": "/**\n* Name: Light definition\n* Author: Arnaud Grignard & Julien Mazars\n* Description: Model presenting how to manipulate lights (spot lights and point lights) in a 3D display \n* Tags: 3d, light\n*/\nmodel lighting\n\nglobal {\n\n\tinit {\n\t\tcreate lightMoving number: 2;\n\t\tcreate GAMAGeometry2D number: 1 {\n\t\t\tlocation <- {world.shape.width / 2, world.shape.height / 2, 0};\n\t\t}\n\n\t}\n\n}\n\nspecies GAMAGeometry2D {\n\n\taspect default {\n\t\tdraw sphere(10) at: location color: #white border: #gray;\n\t}\n\n}\n\nspecies lightMoving skills: [moving] {\n\n\treflex update {\n\t\tdo wander amplitude: 180.0;\n\t}\n\n}\n\nexperiment Display type: gui autorun: true {\n\tfloat minimum_cycle_duration <- 0.01;\n\toutput {\n\t\tlayout #split;\n\t\t// display using spot lights\n\t\t// we set the ambient light to 0 to see better the directional lights (as if we were at night time)\n\t\tdisplay SpotLights type: 3d background: rgb(10, 40, 55) {\n\t\t// we define 3 lights : the blue and red turn around the scene, changing their orientation so that the scene is always lightened\n\t\t// the green light does not change its position, but the angle of the spot changes\n\t\t\tcamera 'default' location: {-87.5648,126.2534,134.3343} target: {50.0,50.0,0.0};\n\t\t\tlight #ambient intensity: 0;\n\t\t\tlight #default intensity: 0;\n\t\t\tlight \"1\" type: #spot location: {world.shape.width * cos(cycle) + world.shape.width / 2, world.shape.height * sin(cycle) + world.shape.height / 2, 20} direction:\n\t\t\t{cos(cycle + 180), sin(cycle + 180), -1} intensity: #red show: true quadratic_attenuation: 0.0001 dynamic: true;\n\t\t\tlight \"2\" type: #spot location: {world.shape.width * cos(cycle + 180) + world.shape.width / 2, world.shape.height * sin(cycle + 180) + world.shape.height / 2, 20} direction:\n\t\t\t{cos(cycle), sin(cycle), -1} intensity: #blue show: true quadratic_attenuation: 0.0001 dynamic: true;\n\t\t\tlight \"3\" type: #spot location: {world.shape.width / 2, world.shape.height / 2, world.shape.width / 2} direction: {0, 0, -1} intensity: #green show: true angle:\n\t\t\t30 * (1 + cos(2 * cycle)) quadratic_attenuation: 0.0001 dynamic: true;\n\t\t\tspecies GAMAGeometry2D;\n\t\t}\n\t\t// display using point lights\n\t\t// we set the ambient light to 0 to see better the directional lights (as if we were at night time)\n\t\tdisplay PointLights type: 3d background: rgb(10, 40, 55) {\n\t\t// we define 3 lights : the blue and red turn around the scene\n\t\t// the green light change its location up and down, we can see the quadratic_attenuation effect : the farther the light is, the less power it has\t\t\t\n\t\t\tlight #ambient intensity: 0;\n\t\t\tlight #default intensity: 0;\n\t\t\tlight \"1\" type: #point location: {world.shape.width * cos(cycle) + world.shape.width / 2, world.shape.height * sin(cycle) + world.shape.height / 2, 20} intensity: #red show: true\n\t\t\tquadratic_attenuation: 0.0001 dynamic: true;\n\t\t\tlight \"2\" type: #point location: {world.shape.width * cos(cycle + 180) + world.shape.width / 2, world.shape.height * sin(cycle + 180) + world.shape.height / 2, 20} intensity:\n\t\t\t#blue show: true quadratic_attenuation: 0.0001 dynamic: true;\n\t\t\tlight \"3\" type: #point location: {world.shape.width / 2, world.shape.height / 2, world.shape.width * cos(cycle)} intensity: #green show: true quadratic_attenuation: 0.0001\n\t\t\tdynamic: true;\n\t\t\tspecies GAMAGeometry2D aspect: default;\n\t\t}\n\t\t// display using direction lights\n\t\t// we set the ambient light to 0 to see better the directional lights (as if we were at night time)\n\t\tdisplay DirectionLights type: 3d background: rgb(10, 40, 55) {\n\t\t// we define 3 lights : the blue and red change their direction\n\t\t// the green light change its intensity\n\t\t\tlight #ambient intensity: 0;\n\t\t\tlight #default intensity: 0;\n\t\t\tlight \"1\" type: #direction direction: {cos(cycle + 180), sin(cycle + 180), -1} intensity: #red show: true dynamic: true;\n\t\t\tlight \"2\" type: #direction direction: {cos(cycle), sin(cycle), -1} intensity: #blue show: true dynamic: true;\n\t\t\tlight \"3\" type: #direction direction: {0, 0, -1} intensity: rgb(0, 255 * (1 + cos(cycle)), 0) show: true dynamic: true;\n\t\t\tspecies GAMAGeometry2D aspect: default;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of a city with moving people and buildings using shapefiles, allowing for customization of parameters such as time of day, speed, and number of agents.", "gaml_code": "/**\n* Name: 3D Display model and Height of Building using shapefiles\n* Author: Arnaud Grignard\n* Description: Model presenting a 3D display of people and buildings moving on a road network imported thanks to shapefiles. \n* \n* Two experiments are proposed : one showing people represented by a yellow sphere moving from a living 3D building to a working 3D building and coming back \n* using a road network (road_traffic). The second experiment distinguish the species by using different layers for species (road_traffic_multi_layer).\n* Tags: 3d, shapefile, gis\n*/\nmodel tutorial_gis_city_traffic\n\nglobal {\n\t\n\t\n//Load of the different shapefiles used by the model\n\tfile shape_file_buildings <- shape_file('../includes/building.shp', 0);\n\tfile shape_file_roads <- shape_file('../includes/road.shp', 0);\n\tfile shape_file_bounds <- shape_file('../includes/bounds.shp', 0);\n\n\t//Definition of the shape of the world as the bounds of the shapefiles to show everything contained\n\t// by the area delimited by the bounds\n\tgeometry shape <- envelope(shape_file_bounds);\n\tint nb_people <- 1000;\n\tint day_time update: cycle mod 144;\n\tint min_work_start <- 36 const: true;\n\tint max_work_start <- 60 const: true;\n\tint min_work_end <- 84 const: true;\n\tint max_work_end <- 132 const: true;\n\tfloat min_speed <- 50.0 const: true;\n\tfloat max_speed <- 100.0 const: true;\n\tlist<building> residential_buildings;\n\tlist<building> industrial_buildings;\n\n\t//Declaration of a graph that will represent our road network\n\tgraph the_graph;\n\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type:: string(read('NATURE'))] {\n\t\t\tif type = \"Industrial\" {\n\t\t\t\tcolor <- #blue;\n\t\t\t}\n\n\t\t\theight <- 10 + rnd(90);\n\t\t}\n\n\t\tresidential_buildings <- building where (each.type = 'Residential');\n\t\tindustrial_buildings <- building where (each.type = 'Industrial');\n\t\tcreate road from: shape_file_roads;\n\t\tthe_graph <- as_edge_graph(road);\n\t\tcreate people number: nb_people;\n\t}\n\n}\n\nspecies building {\n\tstring type;\n\trgb color <- #gray;\n\tint height;\n\n\taspect base {\n\t\tdraw shape color: color depth: height;\n\t}\n\n}\n\nspecies road {\n\trgb color <- #black;\n\n\taspect base {\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies people skills: [moving] {\n\tfloat speed <- min_speed + rnd(max_speed - min_speed);\n\trgb color <- rnd_color(255);\n\tbuilding living_place <- one_of(residential_buildings);\n\tbuilding working_place <- one_of(industrial_buildings);\n\tpoint location <- any_location_in(living_place) + {0, 0, living_place.height};\n\tint start_work <- min_work_start + rnd(max_work_start - min_work_start);\n\tint end_work <- min_work_end + rnd(max_work_end - min_work_end);\n\tstring objectif;\n\tpoint the_target;\n\n\treflex time_to_work when: day_time = start_work {\n\t\tobjectif <- 'working';\n\t\tthe_target <- any_location_in(working_place);\n\t}\n\n\treflex time_to_go_home when: day_time = end_work {\n\t\tobjectif <- 'go home';\n\t\tthe_target <- any_location_in(living_place);\n\t}\n\n\treflex move when: the_target != nil {\n\t\tdo goto(target: the_target, on: the_graph);\n\t\tswitch the_target {\n\t\t\tmatch location {\n\t\t\t\tthe_target <- nil;\n\t\t\t\tlocation <- {location.x, location.y, objectif = 'go home' ? living_place.height : working_place.height};\n\t\t\t}\n\n\t\t} }\n\n\taspect default {\n\t\tdraw sphere(3) color: color;\n\t} }\n\nexperiment \"Road Traffic\" type: gui record: true{\n\tparameter 'Shapefile for the buildings:' var: shape_file_buildings category: 'GIS';\n\tparameter 'Shapefile for the roads:' var: shape_file_roads category: 'GIS';\n\tparameter 'Shapefile for the bounds:' var: shape_file_bounds category: 'GIS';\n\tparameter 'Earliest hour to start work' var: min_work_start category: 'People';\n\tparameter 'Latest hour to start work' var: max_work_start category: 'People';\n\tparameter 'Earliest hour to end work' var: min_work_end category: 'People';\n\tparameter 'Latest hour to end work' var: max_work_end category: 'People';\n\tparameter 'minimal speed' var: min_speed category: 'People';\n\tparameter 'maximal speed' var: max_speed category: 'People';\n\tparameter 'Number of people agents' var: nb_people category: 'People' min: 0 max: 100000 {\n\t\tint nb <- length(people);\n\t\task simulation {\n\t\t\tif (nb_people > nb) {\n\t\t\t\tcreate people number: nb_people - nb;\n\t\t\t} else {\n\t\t\t\task (nb - nb_people) among people {\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\toutput {\n\t\tdisplay city_display type: 3d {\n\t\t\tcamera 'default' location: {1318.6512,3.5713,945.6612} target: {431.7016,495.2155,0.0};\n\t\t\tlight #ambient intensity: 180;\n\t\t\tlight #default intensity: 180 direction: {0.5, 0.5, -1};\n\t\t\tevent #mouse_down {ask simulation {do resume;}}\n\t\t\tspecies building aspect: base refresh: false;\n\t\t\tspecies road aspect: base refresh: false;\n\t\t\tspecies people refresh: true;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Multiple Layers\" type: gui {\n\tparameter 'Shapefile for the buildings:' var: shape_file_buildings category: 'GIS';\n\tparameter 'Shapefile for the roads:' var: shape_file_roads category: 'GIS';\n\tparameter 'Shapefile for the bounds:' var: shape_file_bounds category: 'GIS';\n\tparameter 'Earliest hour to start work' var: min_work_start category: 'People';\n\tparameter 'Latest hour to start work' var: max_work_start category: 'People';\n\tparameter 'Earliest hour to end work' var: min_work_end category: 'People';\n\tparameter 'Latest hour to end work' var: max_work_end category: 'People';\n\tparameter 'minimal speed' var: min_speed category: 'People';\n\tparameter 'maximal speed' var: max_speed category: 'People';\n\tparameter 'Number of people agents' var: nb_people category: 'People' min: 0 max: 1000 {\n\t\tint nb <- length(people);\n\t\task simulation {\n\t\t\tif (nb_people > nb) {\n\t\t\t\tcreate people number: nb_people - nb;\n\t\t\t} else {\n\t\t\t\task (nb - nb_people) among people {\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\toutput {\n\t\tdisplay city_display type: 3d {\n\t\t\tcamera 'default' location: {-714.7717,73.4541,1495.3716} target: {572.8473,542.1091,0.0};\n\t\t\tspecies road aspect: base;\n\t\t\tspecies building aspect: base position: {0, 0, 0.25};\n\t\t\tspecies people position: {0, 0, 0.5};\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of a building elevation with multiple displays, each focusing on a different part of the building and allowing for shared zooming.", "gaml_code": "/**\n* Name: CameraSharedZoom\n* A simple demonstration on how to implement shared zooms \n* Author: A. Drogoul\n* Tags: 3D, zoom, camera\n*/\nexperiment \"Shared Zoom Example\" model: 'Building Elevation.gaml' type: gui {\n\tfloat factor <- 1.0;\n\tint target1 <- 50;\n\tint target2 <- 20;\n\tint target4 <- 75;\n\tint target3 <- 5;\n\tfloat distance -> 500 / factor;\n\tparameter \"Shared zoom\" var: factor min: 0.1 max: 2.0;\n\tparameter \"Display 1 focuses on building \" var: target1;\n\tparameter \"Display 2 focuses on building \" var: target2;\n\tparameter \"Display 3 focuses on building \" var: target3;\n\tparameter \"Display 4 focuses on building \" var: target4;\n\t\n\toutput {\n\t\tdisplay base type: 3d light: true virtual: true toolbar: false {\n\t\t\tspecies building aspect: base refresh: false;\n\t\t\tspecies road aspect: base refresh: false;\n\t\t\tspecies people refresh: true;\n\t\t}\n\n\t\tlayout #split;\n\t\tdisplay \"1\" parent: base {\n\t\t\tcamera #default location: #isometric target: building at target1 distance: distance dynamic: true;\n\t\t}\n\n\t\tdisplay \"2\" parent: base {\n\t\t\tcamera #default target: building at target2 distance: distance dynamic: true;\n\t\t}\n\n\t\tdisplay \"3\" parent: base {\n\t\t\tcamera #default target: building at target3 distance: distance dynamic: true;\n\t\t}\n\n\t\tdisplay \"4\" parent: base {\n\t\t\tcamera #default target: building at target4 distance: distance dynamic: true;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates a moving boat in 3D, loading an OBJ file and applying rotations to it. The simulation should include a GUI display of the boat in a water environment.", "gaml_code": "/**\n* Name: OBJ File Drawing and Moving\n* Author:  Patrick Taillandier, Tri Nguyen-Huu, Arnaud Grignard \n* Description: Model which shows how to draw a moving objet as a OBJ File and how to apply a 3D rotation to the object\n* Tags:  load_file, 3d, skill, obj, moving, goto\n*/\n\nmodel Moving3Dobject\n\nglobal {\n\t\n\tinit { \n\t\tcreate boat;\n\t}  \n} \n\nspecies boat skills: [moving]{\n\tpoint target <- any_location_in(world);\n\treflex move {\n\t\tdo goto target: target speed:0.5;\n\t\tif (target = location) {\n\t\t\ttarget <- any_location_in(world);\n\t\t}\t\n\t}\n\taspect obj {\n\t\t//we draw an obj file in the aspect apply an initial rotation r0 to give the boat the right orientation and apply a composition of rotation (pitch,roll,yaw) and \n\t\t//the location of a obj file is centroid of the bounding box, so we add with the \"at\" facet a translated along the z axis to place the boat on the water and not inside\n\t\t//the size represents here the max size of the bounding box\n\t\t//at last, we dynamically apply a rotation to the boat to make it head in direction of the heading of the agents. \n\t\tpair<float,point> r0 <-  -90::{1,0,0};\t\n\t\tpair<float,point> pitch <-  5 * cos(cycle*10) ::{1,0,0};\n\t\tpair<float,point> roll <- 20*sin(cycle*3)::{0,1,0};\n\t\tpair<float,point> yaw <- 1*sin(cycle*7)::{0,0,1};\n\t\tdraw obj_file(\"../includes/boat/fishing-boat.obj\", rotation_composition(r0,pitch,roll,yaw)) at: location + {0,0,9} size: 5 rotate: heading + 90;\n\t}\t\n}\t\n\n\nexperiment Display  type: gui {\n\toutput synchronized: true {\n\t\tdisplay ComplexObject type: 3d background: #black axes:false{\n\t\t\tcamera 'default' location: {-34.826,115.0892,54.4789} target: {50.0,50.0,0.0};\n\t\t\tlight #ambient intensity: 100;\n\t\t\tspecies boat aspect:obj;\t\n\t\t\tgraphics world transparency: 0.4 { \n\t\t\t\tdraw world depth: 5 texture:(\"../images/water.gif\") ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D model of a city with procedurally generated buildings, using textures and dynamic lighting effects.", "gaml_code": "/**\n* Name: Procedural City\n* Author: Arnaud Grignard\n* Description: Model with a 3D Display representing buildings with a random size. The model proposes two experiments : the first one represents \n*      the buildings with 3D shapes with textures, the second one without textures but the color of the buildings depends on the rotation of a ball-shaped light\n* Tags: 3d, texture, light\n*/\n\nmodel procedural_city   \n\nglobal {\n\tint number_of_building min: 1 <- 300;\n\tint width_and_height_of_environment min: 10 <- 500;\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\t\n\tfile roof_texture <- file('../images/building_texture/roof_top.jpg') ;\t\t\n\tlist textures <- [file('../images/building_texture/texture1.jpg'),file('../images/building_texture/texture2.jpg'),file('../images/building_texture/texture3.jpg'),file('../images/building_texture/texture4.jpg'),file('../images/building_texture/texture5.jpg'),\n\tfile('../images/building_texture/texture6.jpg'),file('../images/building_texture/texture7.jpg'),file('../images/building_texture/texture8.jpg'),file('../images/building_texture/texture9.jpg'),file('../images/building_texture/texture10.jpg')];\n\n\tinit { \n      create Building number:number_of_building{\n      \t     width <- (rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100)*50+10;\n\t\t\t depth <-\t(rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100*width)*10+10;\n\t\t\tshape <- box(width, width, depth) rotated_by rnd(360);\n\t\t\ttexture <- textures[rnd(9)];\n\t\t}\n\t}  \n\n} \n\nspecies Building{\n\tfloat width;\n\tfloat height;\n\tfloat depth;\n\tint angle;\t\t\t\n\tfile texture;\n\t\n\treflex shuffle{\n\t\t width <- (rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100)*50+10;\n\t\t depth <-\t(rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100*width)*10+10;\n\t\tshape <- box(width, width, depth) rotated_by rnd(360);\n\t}\n\t\n\taspect base {\n\t\tdraw shape color:#white;\n\t}\n\t\n\taspect textured {\n\t\tdraw shape texture:[roof_texture.path,texture.path] color: rnd_color(255);\n\t}\n}\t\n\n\nexperiment base virtual:true{\n\n\tparameter 'Number of Agents' var:number_of_building  category: 'Initialization';\n\tparameter 'Dimensions' var:width_and_height_of_environment category: 'Initialization';\n\t\n}\n\nexperiment DisplayTextured  type: gui parent:base{\n\t\n\t\n\t\n\tinit {\n\t\tgama.pref_texture_orientation <- true;\n\t}\n\t\n\toutput {\n\t  display City type:3d background:#white axes:false{\n\t  \tcamera 'default' location: {178.9256,868.4599,470.2417} target: {274.5961,228.3136,0.0};\n\t\t\tspecies Building aspect:textured;\t\t\t\t\t\t\t\n\t\t}\n\t}\n}\n\nexperiment DisplayWithDynamicDiffuseLight  type: gui parent:base{\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t  display City type:3d background:rgb(10,40,55) axes:false{\n\t  \t\tcamera 'default' location: {178.9256,868.4599,470.2417} target: {274.5961,228.3136,0.0};\n\t  \t\tlight #ambient intensity: 0;\n\t  \t\tlight #default \n\t\t  \t\ttype:#point \n\t\t  \t\tintensity:hsb((time mod 255) /255,1.0 ,0.5) \n\t\t  \t\tlocation:{world.shape.width*0.5+ world.shape.width*1.5*sin(time*2),world.shape.width*0.5,world.shape.width*cos(time*2)} \n\t\t  \t\tshow:true \n\t\t  \t\tdynamic:true\n\t\t  \t\t;\n\t\t\tspecies Building aspect:base;\t\t\t\t\t\t\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D visualization of various geometric shapes (2D and 3D) with and without textures, arranged on a grid, allowing for rotation.", "gaml_code": "/**\n* Name: Visualisation of the primitive shapes\n* Author: Arnaud Grignard\n* Description: Model presenting a 3D display with all the primitive shapes existing in GAMA in 2D and 3D, with or without textures. \n* Tags: 3d, shape, texture\n*/\n\nmodel shape   \n\nglobal {\n\t\n\tfile gamaRaster <- file('../images/Gama.jpg');\n\t\n\tbool emptiness <- false;\n\t\n\tint size <- 10 ;\n\tlist<geometry> geometries2D <-[ point([0,0]),circle(size),line ([{0,0},{size,size}]),polyline([{0,0},{size/2,size/2},{0,size}]),line ([{0,0},{size,size}]),polyline([{0,0},{size/2,size/2},{0,size}]),circle(size),square(size),rectangle(size,size*1.5),triangle(size),hexagon(size), square(size) - square(size / 2)];\n\tlist<geometry> texturedGeometries2D <-[point([0,0]), circle(size),line ([{0,0},{size,size}]),polyline([{0,0},{size/2,size/2},{0,size}]),line ([{0,0},{size,size}]),polyline([{0,0},{size/2,size/2},{0,size}]),circle(size),square(size),rectangle(size,size*1.5),triangle(size),hexagon(size),square(size) - square(size / 2) ];\t\n\tlist<geometry> geometries3D <-[sphere(size), cone3D(size, size*2),line ([{0,0},{size,size}],1), polyline([{0,0},{size/2,size/2},{0,size}],1),plan ([{0,0},{size,size}],size),polyplan([{0,0},{size/2,size/2},{0,size}],size),cylinder(size,size),cube(size),box(size,size*1.5,size*0.5),pyramid(size),polyhedron([{-1*size/2,0.5*size/2}, {-0.5*size/2,1*size/2}, {0.5*size/2,1*size/2}, {1*size/2,0.5*size/2},{1*size/2,-0.5*size/2},{0.5*size/2,-1*size/2},{-0.5*size/2,-1*size/2},{-1*size/2,-0.5*size/2}],size), cube(size) - cube(size / 2)];\n    list<geometry> texturedGeometries <-[sphere(size), cone3D(size, size*2), line ([{0,0},{size,size}],1), polyline([{0,0},{size/2,size/2},{0,size}],1), plan ([{0,0},{size,size}],size),polyplan([{0,0},{size/2,size/2},{0,size}],size),cylinder(size,size),cube(size),box(size,size*1.5,size*0.5),pyramid(size),polyhedron([{-1*size/2,0.5*size/2}, {-0.5*size/2,1*size/2}, {0.5*size/2,1*size/2}, {1*size/2,0.5*size/2},{1*size/2,-0.5*size/2},{0.5*size/2,-1*size/2},{-0.5*size/2,-1*size/2},{-1*size/2,-0.5*size/2}],size), cube(size) - cube(size / 2)];\n    \n   \tint angle <- 0 update: (angle+1) mod 360;\n\t\n\tgeometry shape <- rectangle(length(geometries3D)*size*2,size*6);\n\n\tinit { \n\t\t\n\t\tint curGeom2D <-0;\n\t\tcreate Geometry2D number: length(geometries2D){ \n\t\t\tlocation <- {size+curGeom2D*size*2, 0, 0};\t\n\t\t\tmyGeometry <- geometries2D[curGeom2D];\n\t\t\tcurGeom2D <- curGeom2D+1;\n\t\t}\n\t\t\n\t\tint curTextGeom2D <-0;\n\t\tcreate TexturedGeometry2D number: length(texturedGeometries2D){ \n\t\t\tlocation <- {size+curTextGeom2D*size*2, size*2, 0};\t\n\t\t\tmyGeometry <- texturedGeometries2D[curTextGeom2D];\n\t\t\tmyTexture <- gamaRaster;\n\t\t\tcurTextGeom2D <- curTextGeom2D+1;\t\t\n\t\t}\n\t\t\n\t\tint curGeom3D <-0;\n\t\tcreate Geometry3D number: length(geometries3D){ \n\t\t\tlocation <- {size+curGeom3D*size*2, size*4.0, 0};\t\n\t\t\tmyGeometry <- geometries3D[curGeom3D];\n\t\t\tcurGeom3D <- curGeom3D+1;\n\t\t} \n\n\n\t\tint curTextGeom <-0;\n\t\tcreate TexturedGeometry3D number: length(texturedGeometries){ \n\t\t\tlocation <- {size+curTextGeom*size*2, size*6.0, 0};\t\n\t\t\tmyGeometry <- texturedGeometries[curTextGeom];\n\t\t\tmyTexture <- gamaRaster;\n\t\t\tcurTextGeom <- curTextGeom+1;\n\t\t}\n\t}  \n} \n \nspecies Geometry2D{  \n\n\tgeometry myGeometry;\n\t\n\treflex rotate {\n\t\tmyGeometry <- myGeometry rotated_by (1,{1,1,0});\n\t}\n\t\n\taspect default {\n\t\tdraw myGeometry color:#gamaorange at:location border:#gamablue wireframe: emptiness ;\n    }\n} \n\nspecies TexturedGeometry2D{  \n\n\tgeometry myGeometry;\n\tfile myTexture;\n\t\n\taspect default {\n\t\tdraw myGeometry texture:myTexture.path at:location rotate: angle::{0,1,0};\n    }\n} \n    \nspecies Geometry3D{  \n\n\tgeometry myGeometry;\n\n\treflex rotate {\n\t\tmyGeometry <- myGeometry rotated_by (-1,{1,0,0});\n\t}\n\taspect default {\n\t\tdraw myGeometry color:#gamaorange at:location border: #gamablue wireframe: emptiness ;\n    }\n}\n\nspecies TexturedGeometry3D{  \n\n\tgeometry myGeometry;\n\tfile myTexture;\n\n\taspect default {\n\t\tdraw myGeometry rotate: (-angle::{0,0,1}) texture:myTexture.path at:location ;\n    }\n}\n\nexperiment \"3D Shapes\"  type: gui {\n\tparameter \"Are geometries empty?\" var: emptiness ;\n\tinit {\n\t\tgama.pref_display_slice_number <- 64;\n\t\tgama.pref_texture_orientation <- false;\n\t}\n\t\n\n\toutput synchronized:true{\n\t\tdisplay View1 type:3d background:rgb(10,40,55)   {\n\t\t\tspecies Geometry2D aspect:default;\n\t\t\tspecies TexturedGeometry2D aspect:default;\n\t\t\tspecies Geometry3D aspect:default;\n\t\t\tspecies TexturedGeometry3D aspect:default;\n\t\t}\n\n\t}\n}"}
{"prompt": "Create a GAML model that visualizes the effect of depth on 2D and 3D objects using OpenGL.", "gaml_code": "/**\n* Name: Depth attribute\n* Author: Patrick Taillandier\n* Description: Model presenting the impact of the depth facet on visualization\n* Tags: 3d, depth\n*/\n\n\nmodel DepthAttribute\n\nglobal {\n\t\n\tgeometry line2D <- line([{20,30}, {40,30}]);\n\tgeometry line3D <- line([{20,60}, {40,60}]);\n\t\n\n\tgeometry polygon2D <- square(10) at_location {70,30};\n\tgeometry polygon3D <- square(10) at_location {70,60};\n\t\n}\n\nexperiment DepthAttribute type: gui {\n\toutput {\n\t\tdisplay view type: opengl {\n\t\t\tcamera 'default' location: {-21.6032,7.1358,17.3394} target: {47.9384,49.7931,0.0};\n\t\t\tgraphics \"Lines\" {\n\t\t\t\tdraw line2D color: #red;\n\t\t\t\tdraw line3D depth: 10 color: #red;\n\t\t\t}\n\t\t\tgraphics \"Polygons\" {\n\t\t\t\tdraw polygon2D color: #blue;\n\t\t\t\tdraw polygon3D depth: 10 color: #blue;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that displays an xy chart of a parabolic function and its evolution over time.", "gaml_code": "/**\n* Name: XY Examples\n* Author: Patrick Taillandier\n* Description: A demonstration of how to display a simple xy chart\n* Tags: gui, chart\n*/\n\n\nmodel example_xy\n\nglobal {\n\t\n\t//values that will be recomputed at each simulation step\n\tfloat x <- rnd(10.0) update: rnd(10.0);\n\tfloat y <- a_function(x) update: a_function(x);\n\t\n\t//contains a serie of x,y values\n\tlist<float> serie_x;\n\tlist<float> serie_y;\n\t\n\t//function that we want to display\n\tfloat a_function(float val) {\n\t\treturn val ^2;\n\t}\n\t\n\t//at the init of the simulation, we fill the serie_x and serie_y with 101 values\n\tinit {\n\t\tloop i from: 0 to: 100 {\n\t\t\tfloat v <- (i / 50.0) - 1;\n\t\t\tserie_x << v;\n\t\t\tserie_y << a_function(v);\n\t\t}\t\t\n\t}\n}\n\nexperiment main {\n\toutput {\n\t\tdisplay charts  type: 2d {\n\t\t\t//chart displaying the values of serie_y according to serie_x (for i from 0 to 100, x = serie_x[i], y = serie_y[i])\n\t\t\tchart \"serie_x and serie_y\" type: xy size: {1.0,0.5}{\n\t\t\t\t data legend: \"x\" value:rows_list(matrix([serie_x,serie_y])) ;\n\t\t\t}\n\t\t\t\n\t\t\t//at each simulation step, display the value of y according to the value of x\n\t\t\tchart \"x and y\" type: xy size: {1.0,0.5} position: {0,0.5}{\n\t\t\t\t data legend: \"x\" value:[x,y] line_visible: false color: #green;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a GUI-based simulation of heatmaps with interactive charts and customizable visualizations for demonstration purposes.", "gaml_code": "/**\n* Name: Heatmap Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts composed of heatmaps\n* Tags: gui, chart\n*/\nmodel heatmaps\n\n\nglobal\n{\n\tlist<float> myldata <- [];\n\tlist<list<float>> mylldata <- [[]];\n\tlist<list<float>> mylldata2 <- [[]];\n\tint xsize <- 100;\n\tint ysize <- 100;\n\tinit\n\t{\n\t\tdo update_chart();\n\t}\n\n\treflex do_action\n\t{\n\t\tdo update_chart();\n\t}\n\n\taction update_chart\n\t{\n\t\tmyldata <- [];\n\t\tmylldata <- [];\n\t\tloop xi from: 0 to: xsize - 1\n\t\t{\n\t\t\tadd cos((xi + cycle * 20) * 2) to: myldata;\n\t\t\tadd [] to: mylldata;\n\t\t\tloop yi from: 0 to: ysize - 1\n\t\t\t{\n\t\t\t\tadd cos((xi + cycle * 10)) + cos((yi + cycle * 10)) to: mylldata[xi];\n\t\t\t}\n\n\t\t}\n\n\t\tmylldata2 <- [];\n\t\tloop xi from: 0 to: xsize - 1\n\t\t{\n\t\t\tadd [] to: mylldata2;\n\t\t\tloop yi from: 0 to: ysize - 1\n\t\t\t{\n\t\t\t\tadd sin((xi + cycle * 10)) + sin((yi)) to: mylldata2[xi];\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Different heatmaps\" type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tlayout #split\n\t\tparameters: false \n\t\tnavigator: false \n\t\teditors: false \n\t\tconsoles: false \n\t\ttoolbars: false \n\t\ttray: false \n\t\ttabs: true\n\t\t;\t\n\t\t\n\t\tdisplay \"Nice Heatmap\" type: 2d\n\t\t{\n\t\t\tchart \"Nice Heatmap\" type: heatmap background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32, #italic) tick_font:\n\t\t\tfont('Monospaced', 14, #bold) label_font: font('Serif', 18, #plain) legend_font: font('SanSerif', 18, #bold) x_label: 'Nice Xlabel' y_label: 'Nice Ylabel'\n\t\t\t{\n\t\t\t\tdata \"test\" value: mylldata color: [# darkblue, # orange] accumulate_values: false;\n\t\t\t}\n\t\t}\n\n\t\tdisplay \"listOflist_heatmap\" type: 2d\n\t\t{\n\t\t\tchart \"listOflist_heatmap\" type: heatmap\n\t\t\t{\n\t\t\t\tdata \"cosX\" value: mylldata color: [# blue] accumulate_values: false;\n\t\t\t\tdata \"sinY\" value: mylldata2 color: [# darkred] accumulate_values: false;\n\t\t\t}\n\t\t}\n\n\t\tdisplay \"list_heatmap\" type: 2d antialias:false\n\t\t{\n\t\t\tchart \"list_heatmap\" type: heatmap \n\t\t\t{\n\t\t\t\tdata \"test\" value: myldata color: [# cyan, # red] accumulate_values: false;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"simple_heatmap2\" type: 2d\n\t\t{\n\t\t\tchart \"simple heatmap2\" type: heatmap\n\t\t\t{\n\t\t\t\tdata \"test\" value: [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]] color: [# cyan, # red] accumulate_values: false;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment Heatmap type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tdisplay \"list_heatmap\" type: 2d antialias:false\n\t\t{\n\t\t\tchart \"list_heatmap\" type: heatmap\n\t\t\t{\n\t\t\t\tdata \"test\" value: myldata color: [# cyan, # red] accumulate_values: false;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML code that generates various types of charts (series, xy, cumulative) with multiple series and custom styles, including different colors, markers, and error bars.", "gaml_code": "/**\n* Name: Series Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts composed of series\n* Tags: gui, chart\n*/\nmodel series\n\n\nglobal\n{\n}\n\nexperiment \"Different series\" type: gui\n{\n\t\n\t\n\n\t\n\toutput synchronized: true\n\t{\n\t\tlayout #split toolbars: false;\n\t\tdisplay \"data_cumulative_serie_spline_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Nice cumulative series chart\" type: series background: # darkblue color: # lightgreen axes: # lightgreen title_font: font( 'Serif' , 32.0, #italic)\n\t\t\t tick_font: font('Monospaced' , 14 #bold) label_font: font('Serif', 18 #plain) legend_font: font('SanSerif', 18 #bold) x_range: 50 x_tick_unit: 5 x_serie_labels: (\"T+\" + cycle) x_label: 'Nice Xlabel' y_label: 'Nice Ylabel'\n\t\t\t{\n\t\t\t\tdata \"Spline\" value: cos(100 * cycle) * cycle * cycle color: # orange marker_shape: marker_empty style: spline;\n\t\t\t\tdata \"Step\" value: cycle * cycle style: step color: # lightgrey;\n\t\t\t\tdata \"Classic\" value: [cycle + 1, cycle] marker_shape: marker_circle color: # yellow;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"style_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: series\n\t\t\t{\n\t\t\t\tdata \"Spline\" value: cos(100 * cycle) color: # orange style: spline;\n\t\t\t\tdata \"area\" value: cos(100 * cycle) * 0.3 color: # red style: \"area\";\n\t\t\t\tdata \"dot\" value: cos(100 * cycle + 60) color: # green style: dot;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"style_cumulative_style_chart_without_axes\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart Without axes\" type: series \n\t\t\t\ty_tick_values_visible: false y_tick_line_visible: false x_tick_values_visible: false x_tick_line_visible: false\n\t\t\t{\n\t\t\t\tdata \"Spline\" value: cos(100 * cycle) color: # orange style: spline;\n\t\t\t\tdata \"area\" value: cos(100 * cycle) * 0.3 color: # red style: \"area\";\n\t\t\t\tdata \"dot\" value: cos(100 * cycle + 60) color: # green style: dot;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_xy_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_xy_cumulative_chart\" type: xy\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] value:\n\t\t\t\t[[cycle * cos(cycle * 100), cycle * sin(cycle * 100), 2], [cycle / 2 * sin(cycle * 100), cycle * 2 * cos(cycle * 100), 1], [cycle + 2, cycle - 2, cos(cycle * 100)]]\n\t\t\t\tx_err_values: [3, 2, 10] y_err_values: [3, cos(cycle * 100), 2 * sin(cycle * 100)] marker_shape: marker_circle // same for all\n\t\t\t\tcolor: [# green, # blue, # red];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_xy_line_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_xy_cumulative_chart\" type: xy\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\"] value: [[cycle * cos(cycle * 100), cycle * sin(cycle * 100), 2], [cycle / 2 * sin(cycle * 100), cycle * 2 * cos(cycle * 100), 1]] marker_shape:\n\t\t\t\tmarker_circle // same for all\n\t\t\t\tcolor: [# green, # blue] style: line;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_xy_non_cumulative_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_xy_non_cumulative_chart\" type: xy\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] value: [[10, 10], [12, 10], [20 + cycle, 10]] accumulate_values: false x_err_values: [3, 1, 2] y_err_values:\n\t\t\t\t[[9, 20], [5, 11], [8, 10 + cycle / 2]] // different low/high values for yerr\n\t\t\t\tmarker_size: [1, cycle, 2] // size keyword instead of size in values\n\t\t\t\tmarker_shape: marker_circle // same for all\n\t\t\t\tcolor: [# green, # blue, # red];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_serie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_cumulative_serie_chart\" type: series x_serie_labels: (cycle * cycle)\n\t\t\t{\n\t\t\t\tdata \"A\" value: [1, 2];\n\t\t\t\tdata \"ABC\" value: [cycle, cycle] marker_shape: marker_circle x_err_values: 2 * cos(cycle * 100) y_err_values: 2 * sin(cycle * 100) color: # black;\n\t\t\t\tdata \"BCD\" value: [cycle / 2 + cos(cycle * 100), 1] style: spline;\n\t\t\t\tdata \"BCC\" value: [2, cycle];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"my_data_cumulative_xy\" type: 2d\n\t\t{\n\t\t\tchart \"my_data_cumulative_xy\" type: xy\n\t\t\t{\n\t\t\t\tdata \"123\" value: [1 + cycle, 2, 3] marker_shape: marker_down_triangle;\n\t\t\t\tdata \"ABC\" value: [cycle + 1, cycle * 2, cos(cycle)] marker_shape: marker_circle fill: false line_visible: false color: # black x_err_values: ln(cycle) y_err_values:\n\t\t\t\tcos(cycle * 100) * 3;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tdisplay \"double axes\"  type: 2d {\n\t\t\tchart \"double Y axes\" y_label: \"axis 1\" y2_label: \"axis 2\" y_range: {-1,1} y2_range: {0,1000} y2_log_scale: true {\n\t\t\t\tdata \"cos\" value: cos(100 * cycle) color: #red;\n\t\t\t\tdata \"cycle\" value: cycle color: #green use_second_y_axis: true;\n\t\t\t}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Generate a GUI model that displays three types of pie charts (ring, 3D, and exploded) using sample data, with customizable labels and colors.", "gaml_code": "/**\n* Name: Pie Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts composed of pies\n* Tags: gui, chart\n*/\nmodel pies\n\n\nglobal\n{\n}\n\nexperiment \"Different Pies\" type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false ;\t\n\t\t\n\t\tdisplay \"data_pie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Nice Ring Pie Chart\" type: pie style: ring background: # darkblue color: # lightgreen label_text_color: #red label_background_color: #lightgray axes: #red  title_font: font( 'Serif', 32.0, #italic)\n\t\t\ttick_font: font('Monospaced' , 14, #bold) label_font: font('Arial', 32 #bold) x_label: 'Nice Xlabel' y_label:\n\t\t\t'Nice Ylabel'\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 100 + cos(100 * cycle) * cycle * cycle color: # black;\n\t\t\t\tdata \"ABC\" value: cycle * cycle color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_3Dpie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_3Dpie_chart\" type: pie style: 3d\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 2 * cycle color: # black;\n\t\t\t\tdata \"ABC\" value: cycle * cycle color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_pie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_pie_chart\" type: pie style: exploded  series_label_position: \"none\" \n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] value: [[cycle, cycle + 1, 2], [cycle / 2, cycle * 2, 1], [cycle + 2, cycle - 2, cycle]] x_err_values: [3, 2, 10] y_err_values:\n\t\t\t\t[3, cycle, 2 * cycle]\n\t\t\t\t//\t\t\t\t\tcategoriesnames:[\"C1\",\"C2\",\"C3\"]\n\t\t\t\tcolor: [# black, # blue, # red];\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML code that generates multiple bar charts with various styles and customization options for each chart.", "gaml_code": "/**\n* Name: Bar Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts composed of bars\n* Tags: gui, chart\n*/\n\nmodel bars \n\nglobal\n{\n}\n\nexperiment \"Multiple displays\" type: gui {\n\toutput synchronized: false {\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false toolbars: false tray: false tabs: false;\t\n\t\tdisplay \"nice_bar_chart\"  type: 2d {\n\t\t\tchart \"Nice Cumulative Bar Chart\" type:histogram \n\t\t\t \tbackground: #darkblue\n\t\t\t \tcolor: #lightgreen \n\t\t\t \taxes: #lightgreen\n\t\t\t \ttitle_font: font('Serif', 32.0, #italic)\n\t\t\t \ttick_font: font('Monospaced', 14, #bold) \n\t\t\t \tlabel_font: font('Arial', 18, #bold) \n\t\t\t \tlegend_font: font('SanSerif', 14, #bold) \n\t\t\t \ty_range:[-20,40]\n\t\t\t \ty_tick_unit:10\n\t\t\t \tx_label:'Nice Xlabel'\n\t\t\t \ty_label:'Nice Ylabel'\n\t\t\t {\n\t\t\t\tdata \"BCC\" value:10*cos(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle:stack\n\t\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:10*sin(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle: stack\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:(cycle mod 10)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle: stack  \n\t\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n\t\tdisplay \"data_cumulative_bar_chart\" type:2d {\n\t\t\tchart \"data_cumulative_bar_chart\" type:histogram \n\t\t\tstyle:stack\n\t\t\tx_serie_labels:(\"cycle\"+cycle)\n\t\t\tx_range:5\n\t\t\t{\n\t\t\t\tdata \"BCC\" value:cos(100*cycle)*cycle*cycle\n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:cycle*cycle \n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:cycle+1\n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n \t\t\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d {\n\t\t\tchart \"data_non_cumulative_bar_chart\" type:histogram \n\t\t\tx_serie_labels: [\"categ1\",\"categ2\"]\n\t\t\tstyle:\"3d\"\n\t\t\tseries_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"BCC\" value:cos(100*cycle)*cycle*cycle\n//\t\t\t\tstyle:stack\n\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:cycle*cycle \n//\t\t\t\tstyle: stack\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:[cycle+1,cycle]\n//\t\t\t\tstyle: stack  \n\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n \t\t\n\t\tdisplay \"datalist_bar_cchart\" type:2d {\n\t\t\tchart \"datalist_bar\" type:histogram \n\t\t\tseries_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend:[\"cycle\",\"cosinus normalized\",\"offsetted cosinus normalized\"] \n\t\t\t\t\tstyle: bar\n\t\t\t\t\tvalue:[cycle,(sin(100*cycle) +  1) * cycle/2,(sin(100*(cycle+30)) + 1) * cycle/2] \n\t\t\t\t\tcolor:[#green,#black,#purple];\n\t\t\t}\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type:2d {\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type:histogram \n\t\t\tseries_label_position: yaxis\n\t\t\tx_label: \"my_time_label\"\n\t\t\t{\n\t\t\t\tdata \"unique data value\" \n\t\t\t\t\tvalue:cos(cycle*10) \n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay \"data_cumulative_style_chart\" type:2d {\n\t\t\tchart \"Style Cumulative chart\" type:histogram style:stack\n\t\t\t \t{ \n\t\t\t\tdata \"Step\" value:cos(100*cycle+40)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"Bar\" value:cos(100*cycle+60)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#green;\n\t\t\t\tdata \"Line\" value:cos(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#orange;\n\t\t\t\tdata \"Dot\" value:cos(100*cycle)*0.3\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#red;\n\t\t\t}\n\t\t} \n\n\n\t}\n}"}
{"prompt": "Create a GAML model that generates various types of radar charts with different data sets and customization options.", "gaml_code": "/**\n* Name: Radar Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts composed of radars\n* Tags: gui, chart\n*/\nmodel radars\n\n\nglobal \n{\n}\n\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 10 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a simulation of an ant colony foraging behavior, including pheromone diffusion and food gathering, using a grid-based model with GUI visualization.", "gaml_code": "/**\n* Name: Ant Foraging (Charts examples)\n* Author: Philippe Caillou\n* Description: How ants search food and use pheromons to return to their nest once they find it.\n* Tags: gui, skill, chart, grid, diffusion\n*/\nmodel ants\n\nglobal {\n\t\n\tlist<rgb> colors <- reverse(brewer_colors(\"Spectral\", 11));\t\n\t\n\t//Number of ants\n\tint ants_number <- 100 min: 1 max: 2000 ;\n\t//Evaporation value per cycle for the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;\n\t//Diffusion rate for the pheromons\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;\n\t//Size of the grid\n\tint gridsize <- 75 ;\n\t//Center of the grid to put the location of the nest\n\tpoint center const: true <- { (gridsize / 2),  (gridsize / 2)} ;\n\tfile types const: true <- (pgm_file('../images/environment75x75.pgm')) ;\n\tint food_gathered <- 0 ;   \n\tgeometry shape <- square(gridsize);\n\tinit{  \n\t\t//Ant are placed randomly in the nest\n\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\n\t}\n\t\n\t//Reflex to diffuse the road of pheromon on the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n\n\n}\n\n//Grid to discretize space for the food and the nest\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\n\tbool multiagent <- true ;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\tint type <- int(types at {grid_x,grid_y}) ;\n\tbool isNestLocation <- (self distance_to center) < 4 ; \n\tbool isFoodLocation <- type = 2 ; \n\trgb color <- isNestLocation ? colors[7]:((food > 0)? colors[1] : ((road < 0.001)? colors[2] : ((road > 2)? colors[3] : ((road > 0.5)? colors[4] : ((road > 0.2)? (colors[5]) : (colors[6])))))) \n\t\t  update:isNestLocation ? colors[7]:((food > 0)? colors[1] : ((road < 0.001)? colors[2] : ((road > 2)? colors[3] : ((road > 0.5)? colors[4] : ((road > 0.2)? (colors[5]) : (colors[6])))))) ;\n\tint food <- isFoodLocation ? 5 : 0 ;\n\tint nest const: true <- 300 - int(self distance_to center) ;\n\t\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 2.0 ;\n\tant_grid place update: ant_grid (location ); \n\tbool hasFood <- false ;\n\n\n\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n   //Action to pick food\n\taction pick {\n\t\thasFood <- true ;\n\t\tplace.food <- place.food - 1 ;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1 ;\n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\t//Action to chose the best place according to the possible food in the neighbour cells\n\taction choose_best_place type: ant_grid {\n\t\tlist<ant_grid> list_places <- place.neighbors ;\n\t\tif (list_places count (each.food > 0)) > 0  {\n\t\t\treturn (list_places first_with (each.food > 0)) ;\n\t\t} else {\n\t\t\t\tint min_nest  <-  (list_places min_of (each.nest)) ;\n\t\t\t\tlist_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\n\t\t\t\treturn last(list_places) ;\n\t\t\t}\n\t}\n\t\n\t//Initial state of the ant : wander until it finds food or find a road to follow\n\tstate wandering initial: true {\n\t\tdo wander amplitude:120.0 ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: followingRoad when: place.road > 0.05 ;\n\t}\n\t//State to carry food to the nest once the food is found\n\tstate carryingFood {\n\t\tdo goto target: center ;\n\t\ttransition to: wandering when: place.isNestLocation { \n\t\t\tdo drop ;\n\t\t}\n\t}\n\t//State to follow a road \n\tstate followingRoad {\n\t\tlocation <- (choose_best_place()) as point ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: wandering when: (place.road < 0.05) ;\n\t}\n\n\taspect default {\n\t\tdraw circle(1.0) wireframe: !hasFood color: colors[8] ; \n\t}\n}\nexperiment \"Experiment\" type: gui {\n\t\n\tfont title_font <- font(\"Helvetica\", 11, #bold);\n\tfont chart_font <- font(\"Helvetica\", 10);\n\n\t\n\t\n\t\n\t\n\t//Parameters to play with  in the gui\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"wandering\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\n\t//Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\n\treflex update_charts\n\t{\n\t\tnbants<-list<list<int>>([]);\n\t\tstatesnames<-list<string>([]);\n\t\tcategnames<-[\"empty\",\"carry\"];\n\t\tnbantsbydist<-list<list<int>>([]);\n\t\tloop x over:(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(ant count (each.state=x.state and !each.hasFood)),(ant count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tlist<int> nl<-list<int>([]);\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (ant count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n\t\t}\n\t\n\t}\n\t//The different displays\n\toutput {\n\t     layout horizontal([vertical([0::6721,1::3279])::2403,vertical([2::3668,horizontal([3::5175,4::4825])::6332])::7597])  editors: false consoles: false parameters: false;\n\t\t\n\t\tdisplay Ants type: 2d antialias:false toolbar: false{\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant  ;\n\t\t}\n\t\tdisplay ProportionCarryFood  type: 2d toolbar: false {\n\t\t\tchart \"Proportions carrying: Pie\"  size: {0.5,0.5} position: {0, 0} type:pie  title_font: title_font label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:(ant count (!each.hasFood)) color:colors[0];\n\t\t\t\tdata \"carry_food_ants\" value:(ant count (each.hasFood)) color:colors[1];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportions carrying: Radar\"  size: {0.5,0.5} position: {0.5, 0} type:radar  title_font: title_font label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\t\n\n\t\t\t{\n\t\t\t\tdata \"empty\" value:(ant count (!each.hasFood)) accumulate_values:true color:colors[0];\t\t\t\t\n\t\t\t\tdata \"carry\" value:(ant count (each.hasFood)) accumulate_values:true color:colors[1];\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportion: series\"   size: {1.0,0.5} position: {0, 0.5} type:series  title_font: title_font label_font: chart_font tick_font: chart_font legend_font: chart_font tick_line_color: #white color: #black\n\t\t\tseries_label_position: legend \n\t\t\tstyle:stack\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] accumulate_values:true \n\t\t\t\tvalue:[(ant count (!each.hasFood)),(ant count (each.hasFood))]  thickness: 0.5 marker: false\n\t\t\t\tcolor:colors;\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tdisplay CentroidPosition  type: 2d toolbar: false {\n\t\t\tchart \"Positions and History of centroid and size by state\" type:scatter title_font: title_font  label_font: chart_font tick_font: chart_font legend_font: chart_font tick_line_color: #white color: #black\n\t\t\t{\n\t\t\t\tdatalist [\"avg-carry\",\"avg-empty\"] \n\t\t\t\t\tvalue:[mean((ant where (each.hasFood)) collect each.location),\n\t\t\t\t\t\t\t\tmean((ant where (!each.hasFood)) collect each.location)]\n\t\t\t\t\tmarker_size: [(ant count (each.hasFood))/20,(ant count (!each.hasFood))/20]\n\t\t\t\t\t color:colors\n\t\t\t\t\t fill:false\n\t\t\t\t\t line_visible:true;\t\t\t\t\n\t\t\t\tdata \"empty_ants\" value:((ant where (!each.hasFood)) collect each.location) color:colors[0] \n\t\t\t\t\taccumulate_values:false\n\t\t\t\t\tline_visible:false;\n\t\t\t\tdata \"carry_food_ants\" value:((ant where (each.hasFood)) collect each.location) \n\t\t\t\t\taccumulate_values:false\n\t\t\t\t\tcolor:colors[3] line_visible:true;\n\n\t\t\t}\n\t\t}\t\n\t\tdisplay Distribution2dPosition  type: 2d toolbar: false {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.65,0.3} position: {0.05, 0} type:histogram  title_font: title_font  label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\tx_tick_line_visible: false y_tick_line_visible: false flat: false\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\") color: colors;\n\t\t\t}\n\t\t\tchart \"Distribution of the Y positions\"   size: {0.3,0.7} position: {0.7, 0.28} type:histogram  title_font: title_font  label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\treverse_axes:true x_tick_line_visible: false y_tick_line_visible: false flat: false\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist reverse(distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:reverse(distribution_of(ant collect each.location.x,10,0,100) at \"values\") color: reverse(colors);\n\t\t\t}\n\n\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap  title_font: title_font  label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\tseries_label_position:none x_tick_line_visible: false y_tick_line_visible: false axes: #white\n\t\t\t{\n\t\t\t\tdata  \"XYdistrib\"\n\t\t\t\t\tvalue:(distribution2d_of(ant collect each.location.x,ant collect each.location.y,10,0,100,10,0,100) at \"values\")\n\t\t\t\t\tline_visible: false\n\t\t\t\t\tcolor:colors; \n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay DistributionPosition  type: 2d toolbar: false{\n\t\t\tchart \"Distribution of the X positions\"   size: {0.92,0.3} position: {0, 0} type:histogram  title_font: title_font  label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\") color: reverse(colors);\n\t\t\t}\n\t\t\tchart \"Distribution of the X positions- heatmap\"   size: {1.0,0.7} position: {0, 0.3} type:heatmap  title_font: title_font label_font: chart_font tick_font: chart_font legend_font: chart_font\n\t\t\tx_serie_labels: (distribution_of(ant collect each.location.x,10,0,100) at \"legend\")\n\t\t\ty_range:50\n\t\t\t{\n\t\t\t\tdata  \"Xdistrib\"\n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\")\n\t\t\t\t\tcolor:(colors);\n\t\t\t}\n\t\t}\t\n\t\t}\n\t}"}
{"prompt": "Create a GUI-based simulation that visualizes and compares the histograms of various probability distributions (Gaussian, Gamma, LogNormal, Weibull, Exponential) with and without truncation.", "gaml_code": "/**\n* Name: Distribution Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts using the distribution of values in a list\n* Tags: gui, chart\n*/\nmodel distribution\n\n\nglobal {\n\tmap<string, list> gauss_distrib;\n\tmap<string, list> gamma_distrib;\n\tmap<string, list> lognormal_distrib;\n\tmap<string, list> weibull_distrib;\n\tmap<string, list> weibull_trunc_distrib;\n\tmap<string, list> lognormal_trunc_distrib;\n\tmap<string, list> gamma_trunc_distrib;\n\tmap<string, list> gauss_trunc_distrib;\t\n\tmap<string, list> exp_distrib;\n\t\n\tlist<float> gauss_test;\n\tlist<float> gamma_test;\n\tlist<float> lognormal_test;\n\tlist<float> weibull_test;\n\tlist<float> weibull_trunc_test;\n\tlist<float> lognormal_trunc_test;\n\tlist<float> gamma_trunc_test;\n\tlist<float> gauss_trunc_test;\n\tlist<float> exp_test;\n\t\n\tinit {\n\t\tgauss_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\tgauss_distrib <- distribution_of(gauss_test, 5);\n\t\t\n\t\tgamma_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\tgamma_distrib <- distribution_of(gamma_test, 5);\n\t\t\n\t\tlognormal_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\tlognormal_distrib <- distribution_of(lognormal_test, 5);\n\t\t\n\t\tweibull_test <- [1, 2, 4, 1, 2, 5, 10.0];\t\t\n\t\tweibull_distrib <- distribution_of(weibull_test, 5);\n\n\t\tgauss_trunc_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\tgauss_trunc_distrib <- distribution_of(gauss_trunc_test, 5);\n\t\t\n\t\tgamma_trunc_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\tgamma_trunc_distrib <- distribution_of(gamma_trunc_test, 5);\n\t\t\n\t\tlognormal_trunc_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\tlognormal_trunc_distrib <- distribution_of(lognormal_trunc_test, 5);\n\t\t\n\t\tweibull_trunc_test <- [1, 2, 4, 1, 2, 5, 10.0];\t\t\n\t\tweibull_trunc_distrib <- distribution_of(weibull_trunc_test, 5);\t\n\t\t\n\t\texp_test <- [1, 2, 4, 1, 2, 5, 10.0];\n\t\texp_distrib <- distribution_of(exp_test, 5);\n\t\t\t\n\t}\n\n\treflex update_distrib {\n\t\tadd gauss_rnd(10,10) to: gauss_test; \n\t\tgauss_distrib <- distribution_of(gauss_test, 15);\n\t\t\n\t\tadd gamma_rnd(10,0.5) to: gamma_test; \n\t\tgamma_distrib <- distribution_of(gamma_test, 15);\n\t\t\n\t\tadd lognormal_rnd(10,0.5) to: lognormal_test; \n\t\tlognormal_distrib <- distribution_of(lognormal_test, 15);\n\t\t\n\t\tadd weibull_rnd(10,10) to: weibull_test; \n\t\tweibull_distrib <- distribution_of(weibull_test, 15);\t\n\t\t\n\t\t\n\t\tadd truncated_gauss(10,10) to: gauss_trunc_test; \n\t\tgauss_trunc_distrib <- distribution_of(gauss_trunc_test, 15);\n\t\t\n\t\tadd gamma_trunc_rnd(10,0.5,6,true) to: gamma_trunc_test; \n\t\tgamma_trunc_distrib <- distribution_of(gamma_trunc_test, 15);\n\t\t\n\t\tadd lognormal_trunc_rnd(10,0.5,17000,false) to: lognormal_trunc_test; \n\t\tlognormal_trunc_distrib <- distribution_of(lognormal_trunc_test, 15);\n\t\t\n\t\tadd weibull_trunc_rnd(10,10,7,12) to: weibull_trunc_test; \n\t\tweibull_trunc_distrib <- distribution_of(weibull_trunc_test, 15);\t\t\n\t\t\n\t\tadd exp_rnd(10) to: exp_test; \n\t\texp_distrib <- distribution_of(exp_test, 15);\n\t\t\t\t\t\t\t\n\t}\n}\n\nexperiment \"Example of Distribution\" type: gui {\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Gauss Distribution\"  type: 2d {\n\t\t\tchart \"Gauss Distribution\" type: histogram {\n\t\t\t\tdatalist (gauss_distrib at \"legend\") value: (gauss_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t\tdisplay \"Gamma Distribution\"  type: 2d {\n\t\t\tchart \"Gamma Distribution\" type: histogram {\n\t\t\t\tdatalist (gamma_distrib at \"legend\") value: (gamma_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t\tdisplay \"LogNormal Distribution\"  type: 2d {\n\t\t\tchart \"LogNormal Distribution\" type: histogram {\n\t\t\t\tdatalist (lognormal_distrib at \"legend\") value: (lognormal_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t\tdisplay \"Weibull Distribution\"  type: 2d {\n\t\t\tchart \"Weibull Distribution\" type: histogram {\n\t\t\t\tdatalist (weibull_distrib at \"legend\") value: (weibull_distrib at \"values\");\n\t\t\t}\n\t\t}\t\n\t\t\n\t\t\n\t\tdisplay \"Truncated Gauss Distribution\"  type: 2d {\n\t\t\tchart \"Truncated Gauss Distribution truncated_gauss(10,10)\" type: histogram {\n\t\t\t\tdatalist (gauss_trunc_distrib at \"legend\") value: (gauss_trunc_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t\tdisplay \"Truncated Gamma Distribution\"  type: 2d {\n\t\t\tchart \"Truncated Gamma Distribution gamma_trunc_rnd(10,0.5,6,true)\" type: histogram {\n\t\t\t\tdatalist (gamma_trunc_distrib at \"legend\") value: (gamma_trunc_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t\tdisplay \"Truncated LogNormal Distribution\"  type: 2d {\n\t\t\tchart \"Truncated LogNormal Distribution lognormal_trunc_rnd(10,0.5,17000,false)\" type: histogram {\n\t\t\t\tdatalist (lognormal_trunc_distrib at \"legend\") value: (lognormal_trunc_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t\tdisplay \"Truncated Weibull Distribution\"  type: 2d {\n\t\t\tchart \"Truncated Weibull Distribution weibull_trunc_rnd(10,10,7,12)\" type: histogram {\n\t\t\t\tdatalist (weibull_trunc_distrib at \"legend\") value: (weibull_trunc_distrib at \"values\");\n\t\t\t}\n\t\t}\t\n\t\tdisplay \"Exponential Distribution\"  type: 2d {\n\t\t\tchart \"Exponential Distribution exp_rnd(10)\" type: histogram {\n\t\t\t\tdatalist (exp_distrib at \"legend\") value: (exp_distrib at \"values\");\n\t\t\t}\n\t\t}\t\t\t\t\t\t\t\t\n\t\t\n\t\t\t\t\t\t\t\t\t\n\t}\n}"}
{"prompt": "Create a GUI chart that displays long series of cosine and sine values over 1000 points, with customizable x-axis labels.", "gaml_code": "/**\n* Name: Long Series Examples\n* Author: Philippe Caillou\n* Description: A demonstration of charts composed of very long series\n* Tags: gui, chart\n*/\nmodel long_series\n\nglobal {\n\tint serie_length <- 1000;\n\tlist<float> xlist <- [];\n\tlist<float> coslist <- [];\n\tlist<float> sinlist <- [];\n\tfloat base;\n\n\treflex update_sinchart {\n\t\tloop i from: 0 to: serie_length {\n\t\t\tbase <- float(serie_length * cycle + i);\n\t\t\tadd base to: xlist;\n\t\t\tadd cos(base / 1000) to: coslist;\n\t\t\tadd sin(base / 1000) to: sinlist;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Long series\" type: gui {\n\toutput synchronized: true {\n\t\tdisplay \"long_series\" type: 2d {\n\t\t\tchart \"Long series values\" type: series x_label: \"#points to draw at each step\" memorize: false {\n\t\t\t\tdata \"Cosinus\" value: coslist color: #blue marker: false style: line;\n\t\t\t\tdata \"Sinus\" value: sinlist color: #red marker: false style: line;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a model that simulates the Lotka-Volterra predator-prey system using the Runge-Kutta 4 method, allowing for user-defined parameters and displaying time series and phase portrait plots.", "gaml_code": "/**\n* Name: ODE_LotkaVolterra\n* Author: Huynh Quang Nghi & Nathalie Corson\n*  Description: Lotka Volterra Predator Prey Model - ODE solved with Runge-Kutta 4 method with different integration time step with only one agent\n* Tags: equation, math\n*/\n\nmodel ODE_LotkaVolterra\n\nglobal {\n\n\tfloat prey_birth_rate<- 0.05 ; \t\t// natural birth rate of preys\n\tfloat predation_rate <- 0.001; \t\t\t// death rate of preys due to predators\n\tfloat predator_death_rate<- 0.03 ; \t// natural death rate of predators\n\tfloat predation_efficiency<- 0.0002 ; \t// birth rate of predators due to prey consumption\n\n\tfloat nb_prey_init <- 250.0; \t\t\t// initial number of preys\n\tfloat nb_predator_init <- 45.0 ; \t\t// initial number of predators\n\n\tfloat integration_time_step <- 0.01; \t// integration time step used in the Runge Kutta 4 method\n\tfloat t; \t\t\t\t\t\t// simulation time : t = n * integration_time_step  where n is the number of already computed time step\n\n\tinit{\n\t\tcreate LotkaVolterra_agent number:1 ; \t// creation of an agent containing the ODE model\n\t}\n}\n\nspecies LotkaVolterra_agent {\n\n\tfloat nb_prey <- nb_prey_init ; \t\t\t// number of preys initialized with the values given by the user\n\tfloat nb_predator <- nb_predator_init ; \t\t// number of predators initialized with the values given by the user\n\n\tequation lotka_volterra {\n\t\tdiff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator); \t\t\t\t\t// evolution of the number of preys duting an integration time step\n\t\tdiff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey); \t\t// evolution of the number of predator during an integration time step\n      }\n      reflex solving {\n       \tsolve lotka_volterra method: \"rk4\" step_size:integration_time_step ;\t\t\t\t\t \t\t\t// use of runge kutta 4 method with an integration time step of value integration_time_step\n       }\n}\n\n\nexperiment maths type: gui {\n\n\tparameter \"Prey birth rate\" var: prey_birth_rate <- 0.05 min: 0.0 max: 1.0 category: \"Prey\";\t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1\n\tparameter \"Predation rate\" var: predation_rate <- 0.001 min: 0.0 max: 1.0 category: \"Prey\"; \t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1\n\tparameter \"Predator death rate\" var: predator_death_rate <- 0.03 min: 0.0 max: 1.0 category: \"Predator\";\t \t\t// the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1\n\tparameter \"Predation efficiency\" var: predation_efficiency <- 0.0002 min: 0.0 max: 1.0 category: \"Predator\";\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1\n\n\tparameter \"Initial number of prey\" var: nb_prey_init <- 250.0 min: 1.0 category: \"Prey\"; \t\t\t\t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1\n\tparameter \"Initial number of predator\" var: nb_predator_init <- 45.0 min: 1.0 category: \"Predator\"; \t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1\n\n\tparameter \"Integration time step\" var: integration_time_step <- 0.01 min: 0.0 max:0.1 category: \"Integration method\";  // the user defines the value of the integration step, the default value is 0.01 and this value must be between 0 and 1\n\n\toutput {\n \t\tdisplay TimeSeries  type: 2d  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// creation of a display to show time series of the model, values are plotted at every step\n\t\t\tchart \"Lotka Volterra Time Series\" type: series background: #white {  \t\t\t\t\t\t// the chart, of type 'serie', is named Lotka Volterra Time Series, it shows quantities according to time, and the background is white\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent).nb_prey color: #green ;\t\t\t// number of preys is plotted in green\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent).nb_predator color: #red ; \t// number of predators is plotted in red\n\t\t\t}\n\t\t}\n\t\tdisplay PhasePortrait  type: 2d  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// creation of a display to show the phase portait, values are plotted at every time step\n\t\t\tchart \"Lotka Volterra Phase Portrait\" type: xy background: #white {\t\t\t\t\t\t\t// the chart, os type 'xy', is named Lotka Volterra Phase portrait, it shows a quantity according to another one, and the background is white\n\t\t\tdata ' ' value: {predator_death_rate / predation_efficiency, prey_birth_rate/predation_rate} color: #blue; // equilibrium point\n\t\t\tdata 'Number of preys according to number of predators' value:{first(LotkaVolterra_agent).nb_prey, first(LotkaVolterra_agent).nb_predator} color: #black ;\t// number of predators according to the number of preys plotted in black\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Compare the behavior of a Lotka-Volterra predator-prey model under different integration time steps using Runge-Kutta 4 method and visualize the results as time series and phase portraits.", "gaml_code": "/**\n* Name: ODE_LotkaVolterra\n* Author: Huynh Quang Nghi & Nathalie Corson\n*  Description: Lotka Volterra Predator Prey Model - ODE solved with Runge-Kutta 4 method with different integration time step\n* Tags: equation, math\n*/\n\nmodel ODE_LotkaVolterra_InfluenceTimeStep\n\nglobal {\n\n\tfloat prey_birth_rate ; \t\t// natural birth rate of preys\n\tfloat predation_rate ; \t\t\t// death rate of preys due to predators\n\tfloat predator_death_rate ; \t// natural death rate of predators\n\tfloat predation_efficiency ; \t// birth rate of predators due to prey consumption\n\t\n\tfloat nb_prey_init ; \t\t\t// initial number of preys\n\tfloat nb_predator_init  ; \t\t// initial number of predators\n\t\n\tfloat integration_step ; \t// integration time step of the Runge Kutta 4 method\n\tfloat t;   \t\t\t\t\t// simulation time : t = n * integration_time_step  where n is the number of already computed time step\n\t\n\t\n\tfloat integration_time_step1  <- 1.0;  // first integration time step to compare \n\tfloat integration_time_step2  <- 0.1;  // second integration time step to compare \n\tfloat integration_time_step3  <- 0.01;  // third integration time step to compare \n\t\n\tlist<LotkaVolterra_agent> LV_agents;\n\t\n\tinit{\n\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step1]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step1\n\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step2]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step2\n\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step3]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step3\n\t\tLV_agents <- list(LotkaVolterra_agent);\n\t}\n}\n\nspecies LotkaVolterra_agent {\n\t\n    float nb_prey <- nb_prey_init ; \t\t\t\t// number of preys initialized with the values given by the user\n\tfloat nb_predator <- nb_predator_init ; \t\t// number of predators initialized with the values given by the user\n\t\n\tfloat integration_time_step ; \t\t\t\t\t// integration time step used in the Runge Kutta 4 method\n  \n\tequation lotka_volterra { \n\t\tdiff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator); \t\t\t\t\t// evolution of the number of preys duting an integration time step\n\t\tdiff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey); \t\t// evolution of the number of predator during an integration time step\n      }\n      reflex solving {        \n       \tsolve lotka_volterra method: \"rk4\" step_size:integration_time_step;\t\t\t\t\t\t\t\t\t// use of runge kutta 4 method with an integration time step of value integration_time_step\n       }\n}\n\n\nexperiment maths type: gui {\n\t\t\n\tparameter \"Prey birth rate\" var: prey_birth_rate <- 0.05 min: 0.0 max: 1.0 category: \"Prey\";\t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1\n\tparameter \"Predation rate\" var: predation_rate <- 0.001 min: 0.0 max: 1.0 category: \"Prey\"; \t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1\n\tparameter \"Predator death rate\" var: predator_death_rate <- 0.03 min: 0.0 max: 1.0 category: \"Predator\";\t \t\t// the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1\n\tparameter \"Predation efficiency\" var: predation_efficiency <- 0.0002 min: 0.0 max: 1.0 category: \"Predator\";\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1\n\t\n\tparameter \"Initial number of prey\" var: nb_prey_init <- 250.0 min: 1.0 category: \"Prey\"; \t\t\t\t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1\n\tparameter \"Initial number of predator\" var: nb_predator_init <- 45.0 min: 1.0 category: \"Predator\"; \t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1\n\t\n\tparameter \"Integration time step of the first chart \" var:  integration_time_step1 <- 1.0  min: 0.0 max:1.0 category: \"Integration time steps\"; \t// the user defines the value of the first integration step he wants to compare, the default value is 1 and this value must be between 0 and 1\n\tparameter \"Integration time step of the second chart \" var:  integration_time_step2 <- 0.1  min: 0.0 max: 1.0 category: \"Integration time steps\"; \t// the user defines the value of the second integration step he wants to compare, the default value is 0.1 and this value must be between 0 and 1\n\tparameter \"Integration time step of the third chart \" var:  integration_time_step3 <- 0.01  min: 0.0 max: 1.0 category: \"Integration time steps\"; \t// the user defines the value of the third integration step he wants to compare, the default value is 0.01 and this value must be between 0 and 1\n\t\t\n\toutput {\t\t\n \t\tdisplay TimeSeries  type: 2d  {\t// creation of a display to show time series of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size\n\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 1 \" type: series background: #white position: {0,0} size:{1,0.33} x_range: 1000 { \t\t// one chart, of type 'serie', is named Lotka Volterra Time Series - Integration time step = 1, it shows quantities according to time, and the background is white\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_prey color: #green ;\t\t\t// number of preys in the case where the integration time step is 1 is plotted in green\t\t\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_predator color: #red ; \t// number of predators in the case where the integration time step is 1 is plotted in red\t\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 0.1 \" type: series background: #white position: {0,0.33} size:{1,0.33} x_range: 1000{\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_prey color: #green ;\t\t\t\t\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_predator color: #red ;\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 0.01 \" type: series background: #white position: {0,0.66} size:{1,0.33}x_range: 1000{\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_prey color: #green ;\t\t\t\t\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_predator color: #red ;\n\t\t\t}\n\t\t}\n\t\tdisplay PhasePortrait  type: 2d {\t\t\t\n\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 1\" type: xy background: #white position: {0,0} size:{1,0.33} {\t\t// creation of a display to show phase portrait of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size\n\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[0].nb_prey, LV_agents[0].nb_predator} color: #black ;\t// number of predators are plotted in black according to the number of preys in the case where the integration time step is 1\t\t\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 0.1\" type: xy background: #white position: {0,0.33} size:{1,0.33}{\n\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;\t\t\t\t\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 0.01\" type: xy background: #white position: {0,0.66} size:{1,0.33} {\n\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates cells moving to form a circle shape, allowing users to adjust parameters such as agent size, number of agents, and repulsion strength.", "gaml_code": "/**\n* Name: Circle\n* Author: \n* Description: This model shows the movement of cells trying to do a circle shape with themselves \n* \tconsidering the other cells. The second experiment shows a bigger circle using more cell agents.\n* Tags: skill\n*/\nmodel circle_model\n\nglobal { \n\t//Number of agents to create\n\tint number_of_agents min: 1 <- 50 ;\n\t//Radius of the circle that the cells will make\n\tint radius_of_circle min: 10 <- 1000 ;\n\t//Repulsion strength of one cell to the others\n\tint repulsion_strength min: 1 <- 5 ;\n\t//Size of the environment\n\tint width_and_height_of_environment min: 10 <- 3000 ; \n\t//Range of the agents\n\tint range_of_agents min: 1 <- 25 ;\n\t//Speed of the agents\n\tfloat speed_of_agents min: 0.1  <- 2.0 ; \n\t//Size of the agents\n\tint size_of_agents <- 100;\n\t//Center of the considered circle created by the cells\n\tpoint center const: true <- {width_and_height_of_environment/2,width_and_height_of_environment/2};\n\tgeometry shape <- square(width_and_height_of_environment);\n\tinit { \n\t\t//Creation of the cell agents\n\t\tcreate cell number: number_of_agents;\n\t}  \n}  \n  \n//Species cell which represents the cell agents, using the skill moving\nspecies cell skills: [moving] {  \n\t//Color of the cell, randomly chosen\n\trgb color const: true <- [100 + rnd (155),100 + rnd (155), 100 + rnd (155)] as rgb;\n\t//Size of the cell\n\tfloat size const: true <- float(size_of_agents);\n\t//Range of the cell\n\tfloat range const: true <- float(range_of_agents); \n\t//Speed of the cell\n\tfloat speed const: true <- speed_of_agents;   \n\t//Heading of the cell, the direction it 'watches'\n\tfloat heading <- rnd(360.0);\n\t\n\t//Reflex to make the cell agent fo to the center, calling the derivated action move\n\treflex go_to_center {\n\t\theading <- (((self distance_to center) > radius_of_circle) ? self towards center : (self towards center) - 180);\n\t\tdo move speed: speed; \n\t}\n\t//Reflex to flee of the other cells agents, which will help to design the circle shape\n\treflex flee_others {\n\t\tcell close <- one_of ( ( (self neighbors_at range) of_species cell) sort_by (self distance_to each) );\n\t\tif close != nil {\n\t\t\theading <- (self towards close) - 180;\n\t\t\tfloat dist <- self distance_to close;\n\t\t\tdo move speed: dist / repulsion_strength heading: heading;\n\t\t}\n\t}\n\t\n\taspect default { \n\t\tdraw circle(size)  color: color;\n\t}\n}\n\n\nexperiment main type: gui  {\n\tparameter \"Size of Agents\" var: size_of_agents <- 100;\n\tparameter 'Number of Agents' var: number_of_agents <- 300;\n\tparameter 'Radius of Circle' var: radius_of_circle min: 10 <- 15000;\n\tparameter 'Strength of Repulsion' var: repulsion_strength min: 1 <- 50;\n\tparameter 'Dimensions' var: width_and_height_of_environment  min: 10 <- 40000;\n\tparameter 'Range of Agents' var: range_of_agents min: 1 <- 250;\n\tparameter 'Speed of Agents' var: speed_of_agents min: 0.1 <- 100.0 ;\n\n\toutput {\n\t\tdisplay Circle  type:2d{\n\t\t\tspecies cell;\n\t\t}\n\t}\n}"}
{"prompt": "Simulate an election scenario with a specified number of electors and candidates, allowing for various distribution types and candidate strategies to influence voter behavior.", "gaml_code": "/**\n* Name: vote\n* Author: MAPS TEAM (Frederic Amblard, Thomas Louail, Romain Reulier, Paul Salze et Patrick Taillandier) \n* Description: Modeling of an election\n* Tags: gui\n*/\n \nmodel vote\n\nglobal {\n\t//Shape of the environment\n\tgeometry shape <- rectangle({200, 200});\n\t\n\t//Number of electors\n\tint nb_electors <- 1500;\n\t//Number of candidates\n\tint nb_candidates <- 7;\n\t//Weight of each candidates\n\tint weight_candidates <- 50;\n\t//Threshold for the attraction candidates\n\tint threshold_attraction_candidates <- 80;\n\t//Threshold for the repulsion candidates\n\tint threshold_repulsion_candidates <- 200;\n\t//Threshold for the attraction electors\n\tint threshold_attraction_electors <- 20;\n\t\n\t//Distance traveled\n\tfloat distance_traveled <- 7.0;\n\t//Distribution of the electors\n\tstring distribution_electors <- \"Uniform\" among: [\"Uniform\", \"Normal\"];\n\t//Distribution of candidates\n\tstring distribution_candidates <- \"Polygon\" among: [\"Random\", \"Polygon\", \"Line\", \"Diagonal\"];\n\t//Strategy of the candidates\n\tstring strategy_candidates <- \"No strategy\" among: [\"No strategy\", \"Search electors\", \"Distinction\", \"Group\", \"Go closer to the best\",\"Random\" ];\n\t//Count of max group\n\tint cpt_Group_max <- 5;\n\t//Count  of group\n\tint cpt_Group <- cpt_Group_max;\n\t\n\tfloat entropy;\n\t\n\t//List of all the active candidates\n\tlist<candidate> active_candidates ;\n\t\n\tinit {\n\t\t//Creation of the elector\n\t\tcreate elector number: nb_electors;\n\t\tdo creation_candidates;\n\t}\n\t//Action to create the candidates according to the distribution of candidates\n\taction creation_candidates {\n\t\tswitch distribution_candidates { \n\t\t\tmatch \"Polygon\" {\n\t\t\t\tlist<point> liste_points <- list(nb_candidates points_at 50.0);\n\t\t\t\tint cpt <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\t color <- rgb (rnd(255), rnd(255), rnd(255)); \n\t\t\t\t\t location <- liste_points at cpt;\n\t\t\t\t\t cpt <- cpt + 1; \n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch \"Line\" {\n\t\t\t\tint cpt  <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\tcolor <- rgb ([rnd(255), rnd(255), rnd(255)]); \n\t\t\t\t\tfloat x_cord  <- 200 * cpt / nb_candidates;\n\t\t\t\t\tfloat y_cord <- 100.0;\n\t\t\t\t\tlocation <- {x_cord, y_cord};\n\t\t\t\t\tcpt <- cpt + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch \"Diagonal\" {\n\t\t\t\tint cpt <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\tcolor <- rgb ([rnd(255), rnd(255), rnd(255)]); \n\t\t\t\t\tfloat x_cord <- 200 * cpt / nb_candidates;\n\t\t\t\t\tfloat y_cord <- x_cord;\n\t\t\t\t\tlocation <- {x_cord, y_cord};\n\t\t\t\t\tcpt <- cpt + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch \"Random\" {\n\t\t\t\tint cpt <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\tcolor <- rgb ([rnd(255), rnd(255), rnd(255)]); \n\t\t\t\t\tlocation <- any_location_in(world);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Initialization of all the active candidates as the list of candidates\n\t\tactive_candidates <- list(copy(candidate));\t\n\t}\n\t//Reflex representing the dynamics of the models\n\treflex dynamique {\n\t\t//For each elector, ask to move\n\t\task elector {\n\t\t\tdo moving;\n\t\t}\n\t\t//For each candidate, ask to move\n\t\task active_candidates{\n\t\t\tdo moving;\n\t\t\tmy_electors <- list<elector>([]);\n\t\t}\n\t\t//For each elector, do its definition\n\t\task elector {\n\t\t\tdo definition_candidate;\n\t\t}\n\t\tint nb_electors_max <- 0;\n\t\tcandidate candidat_elected <- nil; \n\t\t\n\t\t//Ask to all the active candidates to compute their percentage of vote and set the number of maximum electors to know which candidate is elected\n\t\task active_candidates{ \n\t\t\tint nb_el <- length(my_electors) ;\n\t\t\tpercentage_vote <- (nb_el/nb_electors * 100) with_precision 2;\n\t\t\tif (nb_el > nb_electors_max) {\n\t\t\t\tnb_electors_max <- nb_el;\n\t\t\t \tcandidat_elected <- self;\n\t\t\t}\n\t\t}\n\t\t//update of the state of the candidate\n\t\task candidate {\n\t\t\tis_elected <- false; \n\t\t}\n\t\task candidat_elected {\n\t\t\tis_elected <- true; \n\t\t}\n\t}\n\t//Reflex to show the final results\n\treflex resultats_finaux when: time = 72 {\n\t\tcandidate elected <- active_candidates with_max_of (each.percentage_vote);\n\t\t//Display a window telling who is the winner and halt the model\n\t\tdo tell msg: \"The winner is \" + elected.name; \n\t\tdo pause;\n\t}\n\t\n\t//Reflex to compute the creation of group when one candidate chooses this strategy\n\treflex creation_Group when: (strategy_candidates in [\"Group\", \"Random\"]) {\n\t\t if (cpt_Group = cpt_Group_max) {\n\t\t \t//Kill all the group of electors\n\t\t \task Group_electors as list {\n\t\t \t\tdo die;\n\t\t \t}\n\t\t \t//Compute the list of elector according to their distance\n\t\t\tlist<list<elector>> Groups;\n\t\t\tgeometry geoms <- union(elector collect (each.shape + (threshold_attraction_electors, 4, #round)));\n\t\t\t\t\tloop geom over: geoms.geometries { \n\t\t\t\tif (geom != nil and !empty(geom.points)) {\n\t\t\t\t\tlist<elector> els  <- (elector inside geom); \n\t\t\t\t\tadd els to: Groups;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Create new groups of electors according to the list of electors\n\t\t\tloop gp over: Groups {\n\t\t\t \tcreate Group_electors {\n\t\t\t\t\t effectif <- length(gp);\n\t\t\t \t\t electors_dans_Group <- gp;\n\t\t\t \t\t location <- mean(electors_dans_Group collect (each.location)) ;\n\t\t\t \t}\n\t\t\t }\t \n\t\t}\n\t\tcpt_Group <- cpt_Group - 1;\n\t\tif (cpt_Group = 0) { cpt_Group <- cpt_Group_max;}\t\n\t}\n\t//Reflex to compute the entropy\n\treflex calcule_entropy {\n\t\tentropy <- 0.0;\n\t\t//Compute the abstinence rate\n\t\tfloat abst <- (nb_electors - sum (active_candidates  collect (length(each.my_electors)))) / nb_electors;\n\t\tif (abst > 0) {\n\t\t\tentropy <- entropy - (abst * ln(abst));\n\t\t}\n\t\t//Ask to all the active candidates their number of electors to compute the entropy\n\t\task active_candidates {\n\t\t\tfloat p <- length(my_electors) / nb_electors;\n\t\t\tif (p > 0) {\n\t\t\t\tentropy <- entropy - (p * ln(p));\n\t\t\t}\n\t\t}\n\t\tentropy <- entropy / ln (length(active_candidates) + 1);\n\t}\n}\n\n\n\n//Species representing a group of electors\nspecies Group_electors {\n\tint effectif <- 0;\n\t//List of all the elector agents in the group\n\tlist<elector> electors_dans_Group ;\n\taspect default {\n\t\tdraw square(2) color: #orange;\n\t} \n\t\n}\n//Species representing the elector moving \nspecies elector skills: [moving]{\n\t\n\tinit {\n\t\t//At initialization, place the elector in a certain place according to the distribution of electors\n\t\tif (distribution_electors = \"Normal\") {\n\t\t\tfloat x_cord <- max([0.0, min([200.0, gauss ({100, 35})])]);\n\t\t\tfloat y_cord <- max([0.0, min([200.0, gauss ({100, 35})])]);\n\t\t\tlocation <- {x_cord, y_cord};\n\t\t}\n\t}\n\trgb color <- #white;\n\t//Candidate chosen by the elector\n\tcandidate my_candidate;  \n\t\n\taspect base {\n\t\tdraw pyramid(2) color: color ;\n\t} \n\t//Action to define the candidate\n\taction definition_candidate {\n\t\t//The candidate chosen is the one closest to the elector in the attraction range\n\t\tmy_candidate <- active_candidates with_min_of (self distance_to each);\n\t\tmy_candidate <- (self distance_to my_candidate < threshold_attraction_candidates) ? my_candidate : nil;\n\t\tif (my_candidate != nil) {\n\t\t\tadd self to: my_candidate.my_electors; \n\t\t\tcolor <- my_candidate.color;\n\t\t}\n\t}\n\t//Action to move the elector\n\taction moving {\n\t\t//Make the agent move closer to another elector, representing the influence of this one\n\t\tif ( rnd(100) > (weight_candidates)) {\n\t\t\telector my_elector <- shuffle(elector) first_with ((self distance_to each) < threshold_attraction_electors);\n\t\t\tif (my_elector != nil) {\n\t\t\t\tdo goto target:my_elector speed: distance_traveled;\n\t\t\t} \n\t\t} else {\n\t\t\t//Move the elector closer to one of the candidate to represent its repulsion or attraction\n\t\t\tcandidate the_candidate <- one_of(candidate) ;\n\t\t\tif (the_candidate != nil) {\n\t\t\t\tfloat dist <- self distance_to the_candidate;\n\t\t\t\tif dist < threshold_attraction_candidates {\n\t\t\t\t\tdo goto target: the_candidate speed: distance_traveled;\n\t\t\t\t} else if dist > threshold_repulsion_candidates {\n\t\t\t\t\tdo goto target: location + location - the_candidate.location speed: distance_traveled;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t} \n\t\n}\n//Species candidate using the skill moving\nspecies candidate skills:[moving]{\n\trgb color <- rgb([100 + rnd(155),100 + rnd(155),100 + rnd(155)]);\n\t//Boolean to know if the candidate is active\n\tbool active <- true;\n\t//Float representing the percentage of vote for the candidate\n\tfloat percentage_vote; \n\t//List of all the electors of the candidate\n\tlist my_electors of: elector;\n\t//Boolean to know if the candidate is elected\n\tbool is_elected <- false;\n\taspect default {\n\t\tdraw sphere(3) color: color;\n\t} \n\taspect dynamic {\n\t\tif (active) {\n\t\t\tfloat radius  <- 1 + (percentage_vote / 4.0);\n\t\t\tif (is_elected) {\n\t\t\t\tdraw cube( radius * 2) color: color.brighter.brighter; \n\t\t\t\t\n\t\t\t} \n\t\t\t\tdraw sphere(radius) color: color;\n\t\t\t\n\t\t\tdraw string(percentage_vote) size: 5 color: #white anchor: #center;\n\t\t}\n\t}\n\t//Action to move the candidate according to its strategy\n\taction moving {\n\t\tswitch strategy_candidates {\n\t\t\tmatch \"No strategy\" {}\n\t\t\tmatch \"Search electors\" {do strategy_1;}\n\t\t\tmatch \"Distinction\" {do strategy_2;}\n\t\t\tmatch \"Group\" {do strategy_3;}\n\t\t\tmatch \"Go closer to the best\" {do strategy_4;}\n\t\t\tmatch \"Random\" { \n\t\t\t\tswitch (rnd(4)) {\n\t\t\t\t\tmatch 0 {}\n\t\t\t\t\tmatch 1 {do strategy_1;}\t\n\t\t\t\t\tmatch 2 {do strategy_2;}\t\n\t\t\t\t\tmatch 3 {do strategy_3;}\t\n\t\t\t\t\tmatch 4 {do strategy_4;}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction strategy_1 {\n\t\t//go closer to electors\n\t\telector my_elector <- shuffle(elector) first_with ((self distance_to each) < threshold_attraction_electors);\n\t\tif (my_elector != nil) {\n\t\t\tdo goto target:my_elector speed: distance_traveled;\n\t\t} \n\t}\n\t\n\taction strategy_2 {\n\t\t//go in opposite directions to other candidates\n\t\tlist<candidate> cands <- list(copy(candidate));\n\t\tremove self from: cands;\n\t\tcandidate the_candidate <- one_of(cands) ;\n\t\tif (the_candidate != nil) {\n\t\t\tdo goto target: (location + location - the_candidate.location) speed: distance_traveled;\t\n\t\t}\n\t}\n\t\n\taction strategy_3 {\n\t\t//go closer to a group of electors\n\t\tGroup_electors mon_Group  <- (Group_electors where ((self distance_to each) < threshold_attraction_electors)) with_max_of (each.effectif);\n\t\tif (mon_Group != nil) {\n\t\t\tdo goto target:mon_Group speed: distance_traveled;\n\t\t} \n\t}\n\t\n\taction strategy_4 {\n\t\t//go toward the candidate with max of votes\n\t\tcandidate the_candidate <- candidate with_max_of (percentage_vote) ;\n\t\tif (the_candidate != nil) {\n\t\t\tdo goto target:the_candidate speed: distance_traveled;\t\n\t\t}\n\t}\n\t\n}\n\n\nexperiment vote type: gui {\n\t/** Insert here the definition of the input and output of the model */\n\tparameter \"Number of electors : \" var: nb_electors category: \"elector\";\n\tparameter \"Moving speed of electors toward another electors : \" var: distance_traveled category: \"elector\";\n\tparameter \"Attraction distance between electors : \" var: threshold_attraction_electors category: \"elector\";\n\tparameter \"Number of candidates : \" var: nb_candidates category: \"Candidate\";\n\tparameter \"Attraction distance between candidates and electors : \" var: threshold_attraction_candidates category: \"elector\";\n\t\n\tparameter \"Repulsion distance between candidates : \" var: threshold_repulsion_candidates category: \"elector\";\n\tparameter \"weight of candidates : \" var: weight_candidates category: \"Candidate\";\n\t\n\tparameter \"Distribution type of electors : \" var: distribution_electors category: \"elector\";\n\tparameter \"Distribution type of  candidates : \" var: distribution_candidates category: \"Candidate\";\n\tparameter \"Strategy of candidates : \" var: strategy_candidates category: \"Candidate\";\n\t\n\toutput {\n\t\t\n\t\tlayout #split;\n\t\tdisplay \"Main\" background: #black { \n\t\t\tspecies elector aspect: base;\n\t\t\tspecies candidate aspect: dynamic;\n\t\t\tspecies Group_electors;\n\t\t\t\n\t\t}\n\t\tdisplay \"Voters\"  type: 2d {\n\t\t\tchart \"Distribution of electors\" type: pie background: #white  {\n\t\t\t \tloop cand over: candidate {\n\t\t\t \t\tdata  cand.name value:cand.percentage_vote color: cand.color ;\n\t\t\t \t}\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tdisplay \"Indicators\"  type: 2d {\n\t\t\tchart \"Shannon Entropy\" type: series background: #white size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"entropy\" value: entropy color: #blue ;\n\t\t\t}\n\t\t\tchart \"Opinion distribution\" type: series background: #white size: {1,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"Space area covered\" value: (union(candidate collect (each.shape buffer threshold_attraction_candidates))).area / 40000 color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a model of the Game of Life using cellular automata, allowing for user-defined parameters and visualization of the simulation.", "gaml_code": "/**\n* Name: Life\n* Author: \n* Description: A model using a cellular automata to represent the Game of Life, the most famous \n* \texample of cellular automata. Each cell will see if the number of living neighbours meets the \n* \tcondition to emerge or to live.\n* Tags: grid\n*/\nmodel life\n\n//Declare the world as a torus or not torus environment\nglobal torus: torus_environment {\n\t//Size of the environment\n\tint environment_width <- 200 min: 10 max: 1000;\n\tint environment_height <- 200 min: 10 max: 1000;\n\tbool parallel <- true;\n\t//Declare as torus or not\n\tbool torus_environment <- true;\n\t//Density \n\tint density <- 25 min: 1 max: 99;\n\t//Conditions to live\n\tlist<int> living_conditions <- [2, 3];\n\t//Conditions to birth\n\tlist<int> birth_conditions <- [3];\n\t//Color for living cells\n\trgb livingcolor <- #white;\n\t//Color for dying cells\n\trgb dyingcolor <- #red;\n\t//Color for emerging cells\n\trgb emergingcolor <- #orange;\n\t//Color for dead cells\n\trgb deadcolor <- #black;\n\t//Shape of the environment\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\t\n\t//Initialization of the model by writing the description of the model in the console\n\tinit {\n\t\tdo description;\n\t}\n\t\n\t//Ask at each life_cell to evolve and update\n\treflex generation {\n\t\t// The computation is made in parallel\n\t\task life_cell parallel: parallel {\n\t\t\tdo evolve;\n\t\t}\n\t}\n\t//Write the description of the model in the console\n\taction description {\n\t\twrite 'Description:'  ;\n\t\twrite 'The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970.';\n\t\twrite 'It is the best-known example of a cellular automaton.';\n\t\twrite 'The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input from humans.';\n\t\twrite 'One interacts with the Game of Life by creating an initial configuration and observing how it evolves.';\n\t\twrite 'The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead.';\n\t\twrite 'Every cell interacts with its eight neighbors, which are the cells that are directly horizontally, vertically, or diagonally adjacent.';\n\t\twrite 'At each step in time, the following transitions occur:';\n\t\twrite '\\t 1.Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.';\n\t\twrite '\\t 2.Any live cell with more than three live neighbours dies, as if by overcrowding.';\n\t\twrite '\\t 3.Any live cell with two or three live neighbours lives on to the next generation.';\n\t\twrite '\\t 4.Any dead cell with exactly three live neighbours becomes a live cell.';\n\t\twrite 'The initial pattern constitutes the seed of the system.';\n\t\twrite 'The first generation is created by applying the above rules simultaneously to every cell in the seed; births and deaths happen simultaneously,';\n\t\twrite 'and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the one before).';\n\t\twrite 'The rules continue to be applied repeatedly to create further generations.';\n\t}\n\n}\n\n//Grid species representing a cellular automata\ngrid life_cell width: environment_width height: environment_height neighbors: 8  use_individual_shapes: false use_regular_agents: false \nuse_neighbors_cache: false parallel: parallel{\n\t//Boolean to know if it is the new state of the cell\n\tbool new_state;\n\t//List of all the neighbours\n\tlist<life_cell> neighbours <- self neighbors_at 1;\n\t//Boolean  to know if it is a living or dead cell\n\tbool alive <- (rnd(100)) < density;\n\t\n\trgb color <- alive ? livingcolor : deadcolor;\n\t\n\t//Action to evolve the cell considering its neighbours\n\taction evolve {\n\t\t//Count the number of living neighbours of the cells\n\t\tint living <- neighbours count each.alive;\n\t\tif alive {\n\t\t\t//If the number of living respect the conditions, the cell is still alive\n\t\t\tnew_state <- living in living_conditions;\n\t\t\tcolor <- new_state ? livingcolor : dyingcolor;\n\t\t} else {\n\t\t\t//If the number of living meets the conditions, the cell go to born\n\t\t\tnew_state <- living in birth_conditions;\n\t\t\tcolor <- new_state ? emergingcolor : deadcolor;\n\t\t}\n\n\t}\n\t//Action to update the new state of the cell\n\treflex update {\n\t\talive <- new_state;\n\t}\n\n}\n\n\nexperiment \"Game of Life\" type: gui {\n\tparameter \"Run in parallel \" var: parallel category: 'Board';\n\tparameter 'Width:' var: environment_width category: 'Board';\n\tparameter 'Height:' var: environment_height category: 'Board';\n\tparameter 'Torus?:' var: torus_environment category: 'Board';\n\tparameter 'Initial density of live cells:' var: density category: 'Cells';\n\tparameter 'Numbers of live neighbours required to stay alive:' var: living_conditions category: 'Cells';\n\tparameter 'Numbers of live neighbours required to become alive:' var: birth_conditions category: 'Cells';\n\tparameter 'Color of live cells:' var: livingcolor category: 'Colors';\n\tparameter 'Color of dying cells:' var: dyingcolor category: 'Colors';\n\tparameter 'Color of emerging cells:' var: emergingcolor category: 'Colors';\n\tparameter 'Color of dead cells:' var: deadcolor category: 'Colors';\n\toutput {\n\t\tdisplay Life type: 3d axes:false antialias:false{\n\t\t\tgrid life_cell;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a cellular automaton-based urban growth model that simulates the development of cities based on three criteria: density of construction, distance to roads, and distance to city center. The model should use a grid representation and include species for roads and city center. Allow users to adjust weights for each criterion.", "gaml_code": "/**\n* Name: Cellular Automaton Based Urban Growth\n* Author: Truong Chi Quang, Patrick Taillandier, Benoit Gaudou & Alexis Drogoul\n* Description: model based on the one proposed by (Raimbault et al., 2014): \n* At each simulation step the nb_plots_to_build empty plots with the highest constructability are built \n* The constructability is computed from 3 criteria: the density of construction in the neighborhood, the distance to a road, the distance to the city center (using the road network). \n* Tags: gis, shapefile, grid, graph\n*/\n\nmodel raster3\n\n\nglobal\n{ \n\t//File for the ascii grid\n\tfile asc_grid <- grid_file(\"../includes/cantho_1999_v6.asc\");\n\t//Shapefile for the road\n\tfile road_shapefile <- shape_file(\"../includes/roads15_3.shp\");\n\t//Shapefile for the city\n\tfile city_center_shapefile <- shape_file(\"../includes/city center.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(asc_grid);\n\t//Graph of the roads\n\tgraph roads_network;\n\t\n\t// Dynamic list of the cells to consider at each cycle\n\tlist<plot> empty_plots <- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));\n\t\n\tlist<rgb> plot_colors <- [ \n\t\t#lightgray, //empty\n\t\t#orange, // 1 built\n\t\t#blue // 2 River-lake\n\t];\n\t//Radius of density\n\tint density_radius <- 4;\n\t//Weight of density\n\tfloat weight_density <- 0.05;\n\t//Weight of the road distance\n\tfloat weight_road_dist <- 0.5;\n\t//Weight of the city center distance\n\tfloat weight_cc_dist <- 0.3;\n\t//Number of plot allowing to build a building\n\tint nb_plots_to_build <- 195;\n\n\tinit\n\t{\n\t\t//Creation of the roads using the shapefile of the road\n\t\tcreate roads from: road_shapefile;\n\t\t//Creation of the city center using the city center shapefile\n\t\tcreate city_center from: city_center_shapefile;\n\t\t//Creation of the graph of the road network\n\t\troads_network <- as_edge_graph(roads);\n\t\t\n\t\t//Each road has to compute its distance from the city center\n\t\task roads {\n\t\t\tdo compute_cc_dist;\n\t\t}\n\t\t//Compute the city distance for each plot\n\t\task empty_plots {\n\t\t\tdo compute_distances;\n\t\t}\n\t\t//Normalization of the distance\n\t\tdo normalize_distances;\n\t}\n\t//Action to normalize the distance\n\taction normalize_distances {\n\t\t//Maximum distance from the road of all the plots\n\t\tfloat max_road_dist <- empty_plots max_of each.dist_route;\n\t\t//Maximum distance from the city center for all the plots\n\t\tfloat max_cc_dist <- empty_plots max_of each.dist_cv;\n\t\t//Normalization of  each empty plot according to the maximal value of each attribute\n\t\task empty_plots {\n\t\t\tdist_cv <- 1 - dist_cv / max_cc_dist;\n\t\t\tdist_route <- 1 - dist_route / max_road_dist;\n\t\t}\n\t}\n\t\n\t\n\t//Reflex representing the global dynamic of the model\n\treflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {\n\t\t//Ask to each empty plot to compute its constructability\n\t\task empty_plots {\n\t\t\tconstructability <- compute_constructability();\n\t\t}\n\t\tlist<plot> ordered_plots <- empty_plots sort_by (each.constructability);\n\t\tordered_plots <- nb_plots_to_build last ordered_plots;\n\t\t//Build on each empty plot having the highest constructability\n\t\task ordered_plots\n\t\t{\n\t\t\tdo build;\n\t\t}\n\t}\t\n}\n//Species representing the city center\nspecies city_center {\n\taspect default {\n\t\tdraw circle(300) color: #cyan;\n\t}\t\n}\n//Species representing the roads\nspecies roads\n{\n\tfloat dist_cv;\n\t//Action to compute the city center distance for the road\n\taction compute_cc_dist {\n\t\tusing topology(roads_network)\n\t\t{\n\t\t\tdist_cv <- self distance_to first(city_center);\n\t\t}\n\t}\n\taspect default {\n\t\tdraw shape color: #black;\t\n\t}\n}\n//Grid species to represent the different building plots\ngrid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4\n{\n\trgb color <- grid_value = -1 ? #white : plot_colors[int(grid_value)];\n\t//Distance from the road\n\tfloat dist_route <- 0.0;\n\t//Distance from the city center\n\tfloat dist_cv <- 0.0;\n\t//Constructability of the plot\n\tfloat constructability;\n\t\n\t//Action to compute all the distances for the cell\n\taction compute_distances\n\t{\n\t\troads route_pp <- roads closest_to self;\n\t\tdist_route <- (self distance_to route_pp) using topology(world);\n\t\tdist_cv <- dist_route + route_pp.dist_cv;\n\t}\n\t//Action to build on the cell\n\taction build\n\t{\n\t\tgrid_value <- 1.0;\n\t\tcolor <- plot_colors[1];\n\t}\n\t//Action to compute the constructability of the plot cell\n\tfloat compute_constructability\n\t{\n\t\t//Get all the neighbours plots\n\t\tlist<plot> voisins <- (self neighbors_at density_radius);\n\t\t//Compute the density of all the neighbours plots\n\t\tfloat densite <- (voisins count (each.grid_value = 1.0)) / length(voisins);\n\t\treturn (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist);\n\t}\t\t\t\n}\n\nexperiment raster type: gui {\n \tparameter \"Weight of the density criteria\" var: weight_density;\n \tparameter \"Weight of the distance to roads criteria\" var: weight_road_dist;\n \tparameter \"Weight of the distance to city center criteria\" var: weight_cc_dist;\n \toutput {\n \t\tdisplay map type: 2d axes:false antialias:false {\n\t\t\tgrid plot;\n\t\t\tspecies roads;\n\t\t\tspecies city_center;\n\t\t}\n\t}\n}"}
{"prompt": "Create a model that compares the behavior of a split SIR (Susceptible-Infected-Recovered) system with a unified SIR system using ordinary differential equations. The split system should have three separate agent species for susceptible, infected, and recovered populations, while the unified system should use a single agent species to solve the equations simultaneously.", "gaml_code": "/**\n* Name: SIR_split_in_agents\n* Author: hqnghi \n* Description: This model illustrates the possibility to split an equation system into several agents. \n*       All the equations are solved together thanks to the `simultaneously` facet of the equation statement. \n*       We also compare the split model with the simple SIR one. \n* Tags: equation, math\n*/\n\nmodel SIR_split_in_agents\n\nglobal {\n\tint number_S <- 495 ; // The number of susceptible\n\tint number_I <- 5   ; // The number of infected\n\tint number_R <- 0   ; // The number of removed \n\n\tfloat beta  <- 1.0  ; // The parameter Beta\n\tfloat delta <- 0.01 ; // The parameter Delta\n\t\n\t// Note that N will remain constant as demography is not taken into account in the SIR model.\n\tint N <- number_S + number_I + number_R ;\n\tfloat hKR4 <- 0.07 ;\n\n\tinit {\n\t\t//Creation of the representation of the susceptible agents\n\t\tcreate S_agt {\n\t\t\tSsize <- float(number_S) ;\n\t\t\tself.beta <- myself.beta ;\n\t\t}\n\t\t//Creation of the representation of the infected agents\n\t\tcreate I_agt {\n\t\t\tIsize <- float(number_I) ;\n\t\t\tself.beta <- myself.beta ;\n\t\t\tself.delta <- myself.delta ;\n\t\t}\n\t\t//Creation of the representation of the recovered agents\n\t\tcreate R_agt {\n\t\t\tRsize <- float(number_R) ;\n\t\t\tself.delta <- myself.delta ;\n\t\t}\n\t\t//Creation of the representation of the SIR agent representing the non split system\n\t\tcreate SIR_agt {\n\t\t\tself.Sm <- float(number_S) ;\n\t\t\tself.Im <- float(number_I) ;\n\t\t\tself.Rm <- float(number_R) ;\n\t\t\t\n\t\t\tself.beta <- myself.beta ;\n\t\t\tself.delta <- myself.delta ;\n\t\t}\n\t}\n}\n\n//Species which represent the susceptible agents compartiment\nspecies S_agt {\n\tfloat t ;\t\t\n\tfloat Ssize ; //number of susceptible\n\t\n\tfloat beta ;\n\t//Equation that will be solved simultaneously with the two other equations systems\n\tequation evol simultaneously: [  ( I_agt ) ,  ( R_agt ) ] {\n\t\tdiff ( first ( S_agt ) . Ssize , t ) = \n\t\t\t( - beta * first ( S_agt ) . Ssize * first (\tI_agt ) . Isize / N ) ;\n\t}\n\t\n\treflex solving {solve evol method: \"rk4\" step_size: 0.01 ;}\n}\n//Species which represent the infected agents compartiment\nspecies I_agt {\n\tfloat t ;\n\tfloat Isize ; // number of infected\n\t\n\tfloat beta ;\n\tfloat delta ;\n\n\t//Equation that will be solved simultaneously with the two other equations systems\n\tequation evol simultaneously: [  ( S_agt ) ,  ( R_agt ) ] {\n\t\tdiff ( first ( I_agt ) . Isize , t ) = \n\t\t\t( beta * first ( S_agt ) . Ssize * first ( I_agt ) . Isize / N ) \n\t\t\t- ( delta * first ( I_agt ) . Isize ) ;\n\t}\n}\n//Species which represent the resistant agents compartiment\nspecies R_agt {\n\tfloat t ;\t\t\n\tfloat Rsize ; //number of resistant\n\t\n\tfloat delta ;\n\n\t//Equation that will be solved simultaneously with the two other equations systems\n\tequation evol simultaneously: [ ( S_agt ) + ( I_agt ) ] {\n\t\tdiff ( first ( R_agt ) . Rsize , t ) = \n\t\t\t( delta * first ( I_agt ) . Isize ) ;\n\t}\n}\n\n//Species which represent the ordinary differential equations system\nspecies SIR_agt {\n\tfloat t ;\n\tfloat Im ;\n\tfloat Sm ;\n\tfloat Rm ;\n\t\n\tfloat beta ;\n\tfloat delta ;\n\t\n\tequation SIR {\n\t\tdiff ( Sm , t ) = ( - beta * Sm * Im / N ) ; \n\t\tdiff ( Im , t ) = ( beta * Sm\t* Im / N ) - ( delta * Im ) ; \n\t\tdiff ( Rm , t ) = ( delta * Im ) ;\n\t}\n\t\n\treflex solving {solve SIR method: \"rk4\" step_size: 0.01 ;}\n}\n\n\nexperiment Simulation type: gui {\n\tparameter 'Number of Susceptible' type: int var: number_S <- 495 category: \"Initial population\"; // The initial number of susceptibles\n\tparameter 'Number of Infected'    type: int var: number_I <- 5   category: \"Initial population\";\n\tparameter 'Number of Removed'     type: int var: number_R <- 0   category: \"Initial population\";\n\n\tparameter 'Beta (S->I)'  type: float var: beta <- 1.0   category: \"Parameters\";\n\tparameter 'Delta (I->R)' type: float var: delta <- 0.01 category: \"Parameters\";\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"split system\"  type: 2d {\n\t\t\tchart 'Susceptible' type: series background: #white {\n\t\t\t\tdata 'susceptible' value: first ( S_agt ) . Ssize color: rgb(46,204,113) ;\n\t\t\t\tdata 'infected' value: first ( I_agt ) . Isize color: rgb(231,76,60) ;\n\t\t\t\tdata 'removed' value: first ( R_agt ) . Rsize color: rgb(52,152,219) ;\n\t\t\t}\n\t\t}\n\t\tdisplay \"unified system\"  type: 2d {\n\t\t\tchart 'Susceptible' type: series background: #white {\n\t\t\t\tdata 'susceptible_maths' value: first( SIR_agt ).Sm color: rgb(46,204,113) ;\n\t\t\t\tdata 'infected_maths' value: first( SIR_agt ).Im color: rgb(231,76,60) ;\n\t\t\t\tdata 'removed_maths' value: first( SIR_agt ).Rm color: rgb(52,152,219) ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Implement a simple agent-based SIR model using the FSM control architecture and visualize its dynamics.", "gaml_code": "/**\n* Name: SIR with FSM\n* Shows how to code a simple agent-based SIR model using the FSM control architecture\n* Author: Alexis Drogoul\n* Tags: SIR, FSM, control\n*/\n\nmodel SIRWithFSM\n\nglobal {\n\t\n\tint number_of_people <- 1000;\n\tint number_of_infected <- 2;\n\tfloat contact_distance <- 1#m;\n\tint recovery_time <- 80;\n\t\n\n\tinit {\n\t\tcreate people number: number_of_people;\n\t\task number_of_infected among people {\n\t\t\tstate <- \"I\";\n\t\t}\n\t}\n\t\n\treflex should_stop when: people count (each.state = 'I') = 0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [moving] control: fsm {\n\t\n\tint time_of_infection;\n\t\n\tstate S initial: true {} //Nothing to do\n\t\t\n\tstate R {} //Nothing to do\n\t\n\tstate I {\n\t\tenter {\n\t\t\ttime_of_infection <- world.cycle;\n\t\t}\n\t\task people at_distance contact_distance where (each.state=\"S\") {\n\t\t\t\tstate <- \"I\";\n\t\t}\n\t\ttransition to: R when: world.cycle - time_of_infection >= recovery_time;\n\t}\n\t\n\treflex moving {\n\t\tdo wander amplitude: 30.0;\n\t}\n\t\n}\n\nexperiment FirstModel type: gui {\n\tmap<string, rgb> colors <- [\"S\"::#green,\"I\"::#red,\"R\"::#blue];\n\tparameter \"Recovery time \" var: recovery_time min: 10 max: 100;\n\tparameter \"Number of people\" var: number_of_people min: 10 max: 2000;\n\tparameter \"Number of initially infected agents\" var: number_of_infected min: 1 max: number_of_people;\n\tparameter \"Contact radius\" var: contact_distance min: 1.0 max: 10.0;\n\t\n\toutput {\n\t\tdisplay \"My Display\" type:2d{\n\t\t\tspecies people {\n\t\t\t\tdraw circle(1) color: (state = \"I\")? #red : ((state=\"R\") ? #blue : #green);\n\t\t\t}\n\t\t}\n\t\tdisplay \"Chart\" type:2d {\n\t\t\tchart \"Infected people\" {\n\t\t\t\tloop s over: [\"S\",\"I\",\"R\"] {\n\t\t\t\t\tdata s value: people count (each.state = s) color: colors[s];\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple SIR model without ODEs, where agents move randomly on a grid and become infected or resistant to a disease, with parameters for infection rate, mortality rate, and resistance rate.", "gaml_code": "/**\n* Name: SIR without ODE\n* Author: \n* Description: A simple SIR model without Ordinary Differential Equations showing agents \n* \tmoving randomly among a grid and becoming infected then resistant to a disease\n* Tags: grid\n*/\n\nmodel si\n\nglobal { \n\t//Number of susceptible host at init\n    int number_S <- 495;\n    //Number of infected host at init\n    int number_I <- 5 ;\n    //Number of resistant host at init\n    int number_R <- 0 ;\n    //Rate for the infection success \n\tfloat beta <- 0.05 ;\n\t//Mortality rate for the host\n\tfloat nu <- 0.001 ;\n\t//Rate for resistance \n\tfloat delta <- 0.01;\n\t//Number total of hosts\n\tint numberHosts <- number_S+number_I+number_R;\n\t//Boolean to represent if the infection is computed locally\n\tbool local_infection <- true;\n\t//Range of the cells considered as neighbours for a cell\n\tint neighbours_size <- 2 min:1 max: 5 ;\n\t\n\tfloat R0 ;\n\tgeometry shape <- square(50);\n\t\n\tinit {\n\t\t//Creation of all the susceptible Host\n\t\tcreate Host number: number_S {\n        \tis_susceptible <- true;\n        \tis_infected <-  false;\n            is_immune <-  false; \n            color <-  rgb(46,204,113);\n        }\n        //Creation of all the infected Host\n        create Host number: number_I {\n            is_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false; \n            color <-  rgb(231,76,60); \n       }\n       //Creation of all the resistant Host\n       create Host number: number_R {\n            is_susceptible <-  false;\n            is_infected <-  false;\n            is_immune <-  true; \n            color <-  rgb(52,152,219); \n       }\n       \n       \n       R0 <- beta/(delta+nu);\n\t\twrite \"Basic Reproduction Number: \"+ R0;\n   }\n   \n   //Reflex to update the number of infected\n   reflex compute_nb_infected {\n   \t\tnumber_I <- Host count (each.is_infected);\n   }       \n}\n\n\n//Grid used to discretize space \ngrid sir_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\n\trgb color <- #white;\n\tlist<sir_grid> neighbours <- (self neighbors_at neighbours_size) ;       \n}\n\n//Species host which represent the Host of the disease\nspecies Host  {\n\t//Booleans to represent the state of the host agent\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n    bool is_immune <- false;\n    rgb color <- rgb(46,204,113);\n    sir_grid myPlace;\n    \n    init {\n    \t//Place the agent randomly among the grid\n    \tmyPlace <- one_of (sir_grid as list);\n    \tlocation <- myPlace.location;\n    }     \n    //Reflex to make the agent move   \n    reflex basic_move {\n    \tmyPlace <- one_of (myPlace.neighbours) ;\n        location <- myPlace.location;\n    }\n    //Reflex to make the agent infected if it is susceptible\n    reflex become_infected when: is_susceptible {\n    \tfloat rate  <- 0.0;\n    \t//computation of the infection according to the possibility of the disease to spread locally or not\n    \tif(local_infection) {\n    \t\tint nb_hosts  <- 0;\n    \t\tint nb_hosts_infected  <- 0;\n    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {\n    \t\t\tnb_hosts <- nb_hosts + 1;\n    \t\t\tif (hst.is_infected) {nb_hosts_infected <- nb_hosts_infected + 1;}\n    \t\t}\n    \t\trate <- nb_hosts_infected / nb_hosts;\n    \t} else {\n    \t\trate <- number_I / numberHosts;\n    \t}\n    \tif (flip(beta * rate)) {\n        \tis_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false;\n            color <-  rgb(231,76,60);    \n        }\n    }\n    //Reflex to make the agent recovered if it is infected and if it success the probability\n    reflex become_immune when: (is_infected and flip(delta)) {\n    \tis_susceptible <- false;\n    \tis_infected <- false;\n        is_immune <- true;\n        color <- rgb(52,152,219);\n    }\n    //Reflex to kill the agent according to the probability of dying\n    reflex shallDie when: flip(nu) {\n    \t//Create another agent\n\t\tcreate species(self)  {\n\t\t\tmyPlace <- myself.myPlace ;\n\t\t\tlocation <- myself.location ; \n\t\t}\n       \tdo die;\n    }\n            \n    aspect basic {\n        draw circle(1) color: color; \n    }\n}\n\n\nexperiment Simulation type: gui { \n\t\n\t\n \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible\n    parameter \"Number of Infected\" var: number_I ;\t// The number of infected\n    parameter \"Number of Resistant\" var:number_R ;\t// The number of removed\n\tparameter \"Beta (S->I)\" var:beta; \t// The parameter Beta\n\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\n\tparameter \"Delta (I->R)\" var: delta; // The parameter Delta\n\tparameter \"Is the infection is computed locally?\" var:local_infection ;\n\tparameter \"Size of the neighbours\" var:neighbours_size ;\n \toutput { \n \t\tlayout #split;\n\t    display sir_display  type:2d antialias:false {\n\t        grid sir_grid border: #lightgray;\n\t        species Host aspect: basic;\n\t    }\n\t        \n\t    display chart refresh: every(10#cycles) type: 2d {\n\t\t\tchart \"Susceptible\" type: series background: #white style: exploded {\n\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: rgb(46,204,113);\n\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: rgb(231,76,60);\n\t\t\t\tdata \"immune\" value: Host count (each.is_immune) color: rgb(52,152,219);\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}"}
{"prompt": "Create a simple SI model without ODEs to simulate the spread of disease on a grid, where agents move randomly and become infected based on local infection rates.", "gaml_code": "/**\n* Name: SI without ODE\n* Author: \n* Description: A simple SI model without Ordinary Differential Equations showing agents \n* \tmoving randomly among a grid and becoming infected\n* Tags: grid\n*/\n\nmodel si\n\nglobal { \n\t\n    int number_S <- 495;  // The number of susceptible\n    int number_I <- 5 ;\t// The number of infected\n    float survivalProbability <- 1/(70*365) ; // The survival probability\n\tfloat beta <- 0.05 ; \t// The parameter Beta\n\tfloat nu <- 0.001 ;\t// The parameter Nu\n\tint numberHosts <- number_S+number_I; //Total number of hosts\n\tbool local_infection <- true ; //Infection spread locally or not\n\tint neighbours_size <- 2 ; //Size of the neighbourhood\n\tgeometry shape <- square(50);\n\tinit { \n\t\t//Creation of all the susceptible hosts\n\t\tcreate Host number: number_S {\n        \tis_susceptible <- true;\n        \tis_infected <-  false;\n            is_immune <-  false; \n            color <-  rgb(46,204,113);\n        }\n        //Creation of all the infected hosts\n        create Host number: number_I {\n            is_susceptible <-  false; \n            is_infected <-  true;\n            is_immune <-  false; \n            color <-  rgb(231,76,60);  \n       }\n   }\n   //Reflex to update the number of infected hosts\n   reflex compute_nb_infected {\n   \t\tnumber_I <- Host count (each.is_infected);\n   }  \n}\n\n//Grid to discretize space\ngrid si_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\n\trgb color <- #white;\n\tlist<si_grid> neighbours <- (self neighbors_at neighbours_size) ;       \n}\n//Species host which represent the possible hosts of a disease\nspecies Host  {\n\t//Booleans to represent the state of the agent\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n    bool is_immune <- false;\n    rgb color <- rgb(46,204,113);\n    int sic_count <- 0;\n    si_grid myPlace;\n    \n    //The agent is placed randomly among the grid\n    init {\n    \tmyPlace <- one_of (si_grid as list);\n    \tlocation <- myPlace.location;\n    }        \n    //Reflex to move the agents in its neighbourhood\n    reflex basic_move {\n    \tmyPlace <- one_of (myPlace.neighbours) ;\n        location <- myPlace.location;\n    }\n    //Reflex to infect the agent if it is susceptible and according to the other infected agents\n    reflex become_infected when: is_susceptible {\n    \tfloat rate <- 0.0;\n    \tif(local_infection) {\n    \t\tint nb_hosts <- 0;\n    \t\tint nb_hosts_infected <- 0;\n    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {\n    \t\t\tnb_hosts <- nb_hosts + 1;\n    \t\t\tif (hst.is_infected) {\n    \t\t\t\tnb_hosts_infected <- nb_hosts_infected + 1;\n    \t\t\t}\n    \t\t}\n    \t\trate <- nb_hosts_infected / nb_hosts;\n    \t} else {\n    \t\trate <- number_I / numberHosts;\n    \t}\n    \tif (flip(beta * rate)) {\n        \tis_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false;\n            color <-  rgb(231,76,60);    \n        }\n    }\n    //Reflex to kill the agent according to the death rate\n    reflex shallDie when: flip(nu) {\n\t\tcreate species(self) {\n\t\t\tmyPlace <- myself.myPlace ;\n\t\t\tlocation <- myself.location ; \n\t\t}\n       \tdo die;\n    }\n            \n    aspect basic {\n        draw circle(1) color: color; \n    }\n}\n\n\nexperiment Simulation type: gui { \n \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible\n    parameter \"Number of Infected\" var: number_I ;\t// The number of infected\n    parameter \"Survival Probability\" var: survivalProbability ; // The survival probability\n\tparameter \"Beta (S->I)\" var:beta; \t// The parameter Beta\n\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\n\tparameter \"Is the infection is computed locally?\" var:local_infection ;\n\tparameter \"Size of the neighbours\" var:neighbours_size ;\n\t\n \toutput {\n \t\tlayout #split; \n\t    display si_display  type:2d antialias:false{\n\t        grid si_grid border: #lightgray;\n\t        species Host aspect: basic;\n\t    }\n\t        \n\t    display chart refresh: every(10#cycles)  type: 2d  {\n\t\t\tchart \"Susceptible\" type: series background: #white style: exploded {\n\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: rgb(46,204,113);\n\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: rgb(231,76,60);\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}"}
{"prompt": "Compare and visualize the dynamics of an SIR model implemented as both an agent-based model (ABM) and an equation-based model (EBM), using a grid to discretize space and ODEs for the EBM, with parameters such as beta, gamma, and initial population sizes.", "gaml_code": "/**\n* Name: comparison_ABM_EBM_SIR\n* Author: Benoit Gaudou \n* Description: Comparison between an agent-based and an equation-based model of the SIR model. \n* \tThe ABM use a grid to place the agents, and each cell will be the location of an agent, while the EBM \n* \tis only using a ODE System and no geographical representation.\n* Tags: equation, math, grid\n*/\nmodel comparison_ABM_EBM_SIR\n\nglobal {\n\t//Number of susceptible individuals\n\tint number_S <- 499; \n\t//Number of infectious individuals\n\tint number_I <- 1; \n\t//Number of Resistant individuals\n\tint number_R <- 0; \n\t//Beta parameter used for the infection of susceptible individuals\n\tfloat beta <- 0.1; \n\t//Gamma parameter used for the resistance gained by the infectious individuals\n\tfloat gamma <- 0.01;\n\t//Size of the neighbours\n\tint neighbours_size <- 2;\n\t//Total number of individuals\n\tint N <- number_S + number_I + number_R;\n\t//Number of hosts (for ABM)\n\tint nb_hosts <- number_S + number_I + number_R update: length(Host);\n\t//Number of infected hosts (for ABM)\n\tint nb_infected <- number_I update:  Host count (each.is_infected);\n\tfloat hKR4 <- 0.7;\n\tgeometry shape <- square(50);\n\tinit {\n\t\t//Create the number of hosts susceptibles\n\t\tcreate Host number: number_S {\n\t\t\tis_susceptible <- true;\n\t\t\tis_infected <- false;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- rgb(46,204,113);\n\t\t}\n\t\t//Create the number of hosts infectious\n\t\tcreate Host number: number_I {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- true;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- rgb(231,76,60);\n\t\t}\n\t\t//Create the node agent for the SIR ODE System\n\t\tcreate node_agent number: 1 {\n\t\t\tS <- float(number_S);\n\t\t\tI <- float(number_I);\n\t\t\tR <- float(number_R);\n\t\t}\n\t}\n\n}\n//Grid that will be used to discretize space\ngrid sir_grid width: 50 height: 50 {\n\t\trgb color <- #white;\n\t\tlist<sir_grid> neighbours <- (self neighbors_at neighbours_size) of_species sir_grid;\n\t}\n\t\n//Species host which represents the host of the disease\nspecies Host {\n\t\n\t//Different booleans to know in which state is the host\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\t\n\t//Color of the host\n\trgb color <- rgb(46,204,113);\n\t\n\t//Location of the agent among the grid\n\tsir_grid myPlace;\n\t//Count of neighbors infected \n    int ngb_infected_number function: self neighbors_at(neighbours_size) count(each.is_infected);\n\t\n\tinit {\n\t\t//The location is chosen randomly\n\t\tmyPlace <- one_of(sir_grid);\n\t\tlocation <- myPlace.location;\n\t}\n\t//Reflex to move the agent in the neighbours cells\n\treflex basic_move {\n\t\tmyPlace <- one_of(myPlace.neighbours);\n\t\tlocation <- myPlace.location;\n\t}\n\t//Reflex to pass the agent to the state infected \n\treflex become_infected when: is_susceptible {\n\t\t\t//Probability of being infected according to the number of infected among the neighbours\n    \t\tif (flip(1 - (1 - beta)  ^ ngb_infected_number)) {\n        \t\tis_susceptible <-  false;\n\t            \tis_infected <-  true;\n\t            \tis_immune <-  false;\n\t            \tcolor <-  rgb(231,76,60);       \t\t\t\n\t\t\t}    \t\t\t\t\n\t}\n\t//Reflex to pass the agent to the state immune\n\treflex become_immune when: (is_infected and flip(gamma)) {\n\t\tis_susceptible <- false;\n\t\tis_infected <- false;\n\t\tis_immune <- true;\n\t\tcolor <- rgb(52,152,219);\n\t} \n\t\n\taspect basic {\n\t\tdraw circle(1) color: color;\n\t}\n\n}\n//Species node agent that will represent the SIR Ordinary differential equations system\nspecies node_agent {\n\tfloat t;\n\tfloat I;\n\tfloat S;\n\tfloat R;\n\tequation eqSIR {\n\t\tdiff(S,t) = -beta * S * I / N ;\n\t\tdiff(I,t) = beta * S * I / N - gamma* I;\n\t\tdiff(R,t) = gamma* I;\n    }\n\treflex solving {solve eqSIR method:#rk4 step_size: 1;}\n\t\n}\n\nexperiment Simulation_ABM_EBM type: gui {\n\tparameter 'Number of Susceptible' type: int var: number_S <- 495 category: \"Initial population\";\n\tparameter 'Number of Infected' type: int var: number_I <- 5 category: \"Initial population\";\n\tparameter 'Number of Removed' type: int var: number_R <- 0 category: \"Initial population\";\n\tparameter 'Beta (S->I)' type: float var: beta <- 0.1 category: \"Parameters\";\n\tparameter 'Gamma (I->R)' type: float var: gamma <- 0.01 category: \"Parameters\";\n\tparameter 'Size of the neighbours' type: int var: neighbours_size <- 1 min: 1 max: 5 category: \"Infection\";\n\toutput {\n\t\tlayout #split;\n\t\tdisplay sir_display type:2d antialias:false { \n\t\t\tgrid sir_grid border: #lightgray;\n\t\t\tspecies Host aspect: basic;\t\n\t\t}\n\t\tdisplay ABM  type: 2d  { \n\t\t\tchart 'Population' type: series background: #white style: exploded {\n\t\t\t\tdata 'susceptible' value: (Host as list) count (each.is_susceptible) color: rgb(46,204,113) marker_size: 0.5;\n\t\t\t\tdata 'infected' value: (Host as list) count (each.is_infected) color: rgb(231,76,60) marker_size: 0.5;\n\t\t\t\tdata 'immune' value: (Host as list) count (each.is_immune) color: rgb(52,152,219) marker_size: 0.5;\n\t\t\t}\n\t\t}\n\t\tdisplay EBM  type: 2d  { \n\t\t\tchart \"Population\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(node_agent).S color: rgb(46,204,113) marker: false;\n\t\t\t\tdata 'I' value: first(node_agent).I color: rgb(231,76,60) marker: false;\n\t\t\t\tdata 'R' value: first(node_agent).R color: rgb(52,152,219) marker: false;\n\t\t\t}\n\t\t}\n\t\tdisplay ABM_EBM   type: 2d  { \n\t\t\tchart 'Population' type: series background: #white style: exploded {\n\t\t\t\tdata 'susceptible' value: (Host as list) count (each.is_susceptible) color: rgb(39,174,96) marker_size: 0.5;\n\t\t\t\tdata 'infected' value: (Host as list) count (each.is_infected) color: rgb(192,57,43) marker_size: 0.5;\n\t\t\t\tdata 'immune' value: (Host as list) count (each.is_immune) color: rgb(41,128,185) marker_size: 0.5;\n\t\t\t\tdata 'S' value: first(node_agent).S color: rgb(46,204,113) marker: false;\n\t\t\t\tdata 'I' value: first(node_agent).I color: rgb(231,76,60) marker: false;\n\t\t\t\tdata 'R' value: first(node_agent).R color: rgb(52,152,219) marker: false;\n\t\t\t}\n\t\t}\n\t}\n\n}"}
{"prompt": "Create a SIR model that switches between an individual-based model and a mathematical ODE model based on population size, with adjustable parameters for beta, delta, initial susceptible, infected, and removed individuals.", "gaml_code": "/**\n* Name: SIR_switch\n* Author: tri and hqnghi \n* Description: A model which show how to implement ODE system, IBM model, and to switch \n* \tfrom one to another using a threshold. Another interesting point seen in this model is the \n* \tthe minimization of the execution time by reducing the number of agents to compute infections.\n* Tags: equation, math, grid\n*/\nmodel SIR_switch\n\nglobal {\n\t// Parameters\n\tint initial_S; // The number of susceptible\n\tint initial_I; // The number of infected\n\tint initial_R; // The number of removed \n\n\tfloat beta; // The parameter Beta \n\tfloat delta; // The parameter Delta\t\n\t\n\tint switch_threshold <- 120 ; // threshold for switching models\n\tbool local_infection <- true ;\n\tint neighbours_range <- 2 ;\n\tbool local_random_walk <- true ; \n\t\n\t\n\t// Global variables\n\tint grid_size <- 50;\n\tgeometry shape <- square(grid_size);\n\tint number_Hosts <- initial_S + initial_I + initial_R; // Total number of individuals\n\tSIR_model current_model; // serves as an interface, it is transparent to user if model is maths or IBM\n\n\tfloat beta_maths;\n\tint gridSize <- 1; //size of the grid\n\tfloat neighbourhoodSize <- 1.0; // average size of the neighbourhood (in number of cells)\t\n\tfloat adjust <- 0.721; // to adjust math model to ABM when using random walk\n\tbool computeInfectionFromS <- initial_S < initial_I; // if true, use the S list to compute infections. If false, use I list.\n\t// the purpose is to minimize the number of evaluation by using the smallest list.\n\t\n\tinit {\n\t\tcreate new_scheduler;\n\t\t/* determine the size of the neighbourhood and the average count of hosts neighbours */\n\t\tgridSize <- length(sir_grid);\n\t\tint nbCells <- 0;\n\t\t\n\t\tloop cell over: sir_grid {\n\t\t\tnbCells <- nbCells + length(cell.neighbours);\n\t\t}\n\n\t\tneighbourhoodSize <- nbCells / gridSize + 1; // +1 to count itself in the neighbourhood;\n\t\tbeta_maths <- beta * neighbourhoodSize * number_Hosts / gridSize * adjust;\n\t\t\n\t\twrite 'Switch will happen at population sizes around ' +switch_threshold;\n\t\twrite 'Basic Reproduction Number (R0): ' + string(beta / delta) + '\\n';\n\t\t\n\t\t//Creation of the switch_model agent that will manage the switch between the mathematical and the individual based models\n\t\tcreate switch_model {\n\t\t\tthreshold_to_IBM <- switch_threshold;\n\t\t\tthreshold_to_Maths <- switch_threshold;\n\t\t}\n\t\t//Creation of the model according to the one to begin with\n\t\tif (first(switch_model).start_with_IBM) {\n\t\t//\t\twrite 'Starting with IBM model';\n\t\t\tcreate IBM_model;\n\t\t\tcurrent_model <- first(IBM_model);\n\t\t} else {\n\t\t//\t\twrite 'Starting with Maths model';\n\t\t\tcreate Math_model;\n\t\t\tcurrent_model <- first(Math_model);\n\t\t}\n\t\t//Initialization of the Susceptible, Infected, Resistant and Total Compartiment\n\t\tcurrent_model.S <- float(initial_S);\n\t\tcurrent_model.I <- float(initial_I);\n\t\tcurrent_model.R <- float(initial_R);\n\t\tcurrent_model.N <- number_Hosts;\n\t\t\n\t\t//Ask to the model to initialize itself according to the value initialized\n\t\task current_model {\n\t\t\tdo initialize;\n\t\t}\n\t\t\n\t\t//Create the SIR maths with ODE to compare\n\t\tcreate my_SIR_maths {\n\t\t\tself.S <- float(myself.initial_S);\n\t\t\tself.I <- float(myself.initial_I);\n\t\t\tself.R <- float(myself.initial_R);\n\t\t\tself.N <- number_Hosts;\n\t\t\tself.beta1 <- beta * neighbourhoodSize * (N / gridSize)* adjust;\n\t\t\tself.alpha <- delta;\n\t\t}\n\n\t}\n\n\treflex infection_computation_method {\n\t/* computing infection from S has a complexity of S*ngb, where ngb is the size of the neighbourhood.\n\t * computing infection from I has a complexity of I*ngb.\n\t * this reflex determine which method has the lowest cost.\n\t * */\n\t\tcomputeInfectionFromS <- (Host count (each.is_susceptible)) < (Host count (each.is_infected));\n\t}\n\n}\n//Grid which represent the discretized space for the host agents\n\tgrid sir_grid width: grid_size height: grid_size {\n\t\trgb color <- #white;\n\t\tlist<sir_grid> neighbours <- (self neighbors_at neighbours_range) of_species sir_grid;\n\t}\n\n\n//Species which allows the execution of only Host, IBM_model, Math_model and switch_model at each cycle\nspecies new_scheduler schedules: (Host + IBM_model + Math_model + switch_model) ;\n\n//Species which represent the manager between IBM and Math model\nspecies switch_model schedules: [] {\n\tint threshold_to_IBM <- 45; // threshold under which the model swith to IBM\n\tint threshold_to_Maths <- 50; // threshold under which the model swith to Maths model \n\tbool start_with_IBM function:  (initial_S < threshold_to_IBM or initial_I < threshold_to_IBM) ;\n\n\t//Switch the model used to IBM when the threshold is higher than the population\n\treflex switch_to_IBM when: (current_model.model_type = 'Maths') {\n\t\tif (current_model.S < threshold_to_IBM or current_model.I < threshold_to_IBM) {\n\t\t\twrite 'Switch to IBM model at cycle ' + string(cycle);\n\t\t\tcreate IBM_model {\n\t\t\t\tself.S <- current_model.S;\n\t\t\t\tself.I <- current_model.I;\n\t\t\t\tself.R <- current_model.R;\n\t\t\t\tself.N <- current_model.N;\n\t\t\t\tdo initialize;\n\t\t\t}\n\n\t\t\task current_model {\n\t\t\t\tdo remove_model;\n\t\t\t}\n\n\t\t\tcurrent_model <- first(IBM_model);\n\t\t}\n\n\t}\n\t//Switch the model used to Maths when the threshold is lower than the population\n\treflex switch_to_Maths when: (current_model.model_type = 'IBM') {\n\t\tif (current_model.S > threshold_to_Maths and current_model.I > threshold_to_Maths) {\n\t\t\twrite 'Switch to Maths model at cycle ' + cycle;\n\t\t\tcreate Math_model {\n\t\t\t\tself.S <- current_model.S;\n\t\t\t\tself.I <- current_model.I;\n\t\t\t\tself.R <- current_model.R;\n\t\t\t\tself.N <- current_model.N;\n\t\t\t\tdo initialize;\n\t\t\t}\n\n\t\t\task current_model {\n\t\t\t\tdo remove_model;\n\t\t\t}\n\n\t\t\tcurrent_model <- first(Math_model);\n\t\t}\n\n\t}\n\n}\n//Species which represent the SIR model used by the IBM and the Math models \nspecies SIR_model schedules: [] {\n\tfloat S;\n\tfloat I;\n\tfloat R;\n\tint N;\n\tstring model_type <- 'none';\n\t\n\taction remove_model {\n\t\tdo die;\n\t}\n\n\taction initialize ;\n\n}\n\n//Species IBM Model which represent the Individual based model, derivated from SIR_model\nspecies IBM_model schedules: [] parent: SIR_model {\n\tstring model_type <- 'IBM';\n\t\n\t//Action to initialize the Model with SIR compartiments\n\taction initialize {\n\t\t\n\t\twrite 'Initializing IBM model with S=' + round(S) + ', I=' + round(I) + ', R=' + round(R) + '\\n';\n\t\t//Creation of the host agents\n\t\tcreate Host number: round(S) {\n\t\t\tis_susceptible <- true;\n\t\t\tis_infected <- false;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- rgb(46,204,113);\n\t\t}\n\n\t\tcreate Host number: round(I) {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- true;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- rgb(231,76,60);\n\t\t}\n\n\t\tcreate Host number: round(R) {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- false;\n\t\t\tis_immune <- true;\n\t\t\tcolor <- rgb(52,152,219);\n\t\t}\n\t\tdo count;\n\t}\n\n\treflex count {\n\t\tdo count;\n\t}\n\t//Action to update the different compartiments\n\taction count {\n\t\tS <- float(Host count (each.is_susceptible));\n\t\tI <- float(Host count (each.is_infected));\n\t\tR <- float(Host count (each.is_immune));\n\t}\n\t//Action to remove the model and kill all the agents it contains\n\taction remove_model {\n\t\task Host {\n\t\t\tdo die;\n\t\t}\n\n\t\tdo die;\n\t}\n\n}\n\n//Species Math Model which represent the mathematical Ordinary Differential Equations model, derivated from SIR_model\nspecies Math_model schedules: [] parent: SIR_model {\n\tstring model_type <- 'Maths';\n\tfloat t;\n\t\n\taction initialize {\n\t\twrite 'Initializing Maths model with S=' + S + ', I=' + I + ', R=' + R + '\\n';\n\t}\n\n\tequation SIR {\n\t\tdiff(S, t) = (-beta_maths * S * I / N);\n\t\tdiff(I, t) = (beta_maths * S * I / N) - (delta * I);\n\t\tdiff(R, t) = (delta * I);\n\t}\n\n\treflex solving {solve SIR method: \"rk4\" step_size: 0.01 ;}\n}\n//Species host used by the Individual Based Model which move from one cell to another\nspecies Host schedules: [] skills: [moving] {\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tsir_grid myPlace;\n\t\n\t/* next function computes the number of neighbours of the agent */\n\tint ngb_number function: \n\t\tlength(((self) neighbors_at (2)) of_species Host) - 1 // -1 is because the agent counts itself\n\t;\n\t\n\tinit {\n\t\tmyPlace <- one_of(sir_grid as list);\n\t\tlocation <- myPlace.location;\n\t}\n\n\t//Reflex to move the agents among the cells\n\treflex basic_move {\n\t\tif (!local_random_walk) {\n\t\t/* random walk among neighbours */\n\t\t\tmyPlace <- one_of(myPlace.neighbours);\n\t\t\tlocation <- myPlace.location;\n\t\t} else {\n\t\t/* move agent to a random place anywhere in the grid */\n\t\t\tmyPlace <- any(sir_grid);\n\t\t\tlocation <- myPlace.location;\n\t\t}\n\n\t}\n\t//Reflex to make the agent infected when the infection is computed from S for a better execution time\n\treflex become_infected when: (is_susceptible and computeInfectionFromS) {\n\t\tif (flip(1 - (1 - beta) ^ (((self) neighbors_at (2)) of_species Host) count (each.is_infected))) {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- true;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- rgb(231,76,60);\n\t\t}\n\n\t}\n\t//Reflex to make the agent infect others when the infection is not computed from S for a better execution time\n\treflex infecte_others when: (is_infected and not (computeInfectionFromS)) {\n\t\tloop hst over: ((self) neighbors_at (2)) {\n\t\t\tif (hst.is_susceptible) {\n\t\t\t\tif (flip(beta)) {\n\t\t\t\t\thst.is_susceptible <- false;\n\t\t\t\t\thst.is_infected <- true;\n\t\t\t\t\thst.is_immune <- false;\n\t\t\t\t\thst.color <- rgb(231,76,60);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Reflex to make the agent resistant\n\treflex become_immune when: (is_infected and flip(delta)) {\n\t\tis_susceptible <- false;\n\t\tis_infected <- false;\n\t\tis_immune <- true;\n\t\tcolor <- rgb(52,152,219);\n\t}\n\n\taspect basic {\n\t\tdraw circle(1) color: color;\n\t}\n\n}\n//Species which represent the SIR mathematical model \nspecies my_SIR_maths {\n\tfloat t;\n\tfloat I <- float(iInit);\n\tfloat S <- N - I;\n\tfloat R <- 0.0;\n\t\t\t\n\tfloat alpha <- 0.01 min: 0.0 max: 1.0;\n\tfloat beta1 <- 0.1 min: 0.0 max: 1000.0;\n\tint N <- 500 min: 1 max: 3000;\n\tint iInit <- 1;\n\n\tequation SIR {\n\t\tdiff(S, t) = (-beta1 * S * I / N);\n\t\tdiff(I, t) = (beta1 * S * I / N) - (alpha * I);\n\t\tdiff(R, t) = (alpha * I);\n\t}\n\t\n\treflex solving {solve SIR method:\"rk4\" step_size:0.01;}\n\n}\n\n\n\nexperiment mysimulation type: gui {\n\tparameter 'Number of Susceptible' type: int var: initial_S <- 495 category: \"Initial population\"; \n\tparameter 'Number of Infected'    type: int var: initial_I <- 5   category: \"Initial population\";\n\tparameter 'Number of Removed'     type: int var: initial_R <- 0   category: \"Initial population\";\n\n\tparameter 'Beta (S->I)'  type: float var: beta <- 0.1   category: \"Parameters\";\n\tparameter 'Delta (I->R)' type: float var: delta <- 0.01 category: \"Parameters\";\t\n\t\n\tparameter 'Is the infection is computed locally?' type: bool var: local_infection <- true category: \"Infection\";\n\tparameter 'Size of the neighbours' type: int var: neighbours_range <- 2 min:1 max: 5 category: \"Infection\";\n\n\tparameter 'Local Random Walk' type: bool var: local_random_walk <- true category: \"Agents\";\t\n\t\n\tparameter 'Switch models at' type: int var: switch_threshold <- 120 category: \"Model\";\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay 'sir display'  type:2d antialias:false {\n\t\t\tgrid sir_grid border: #lightgray;\n\t\t\tspecies Host aspect: basic;\n\t\t}\n\t\n\t\tdisplay 'Switch model' type: 2d {\n\t\t\tchart 'Susceptible' type: series background: #white style: exploded {\n\t\t\t\tdata 'susceptible' value: current_model.S color: rgb(46,204,113);\n\t\t\t\tdata 'infected' value: current_model.I color: rgb(231,76,60);\n\t\t\t\tdata 'immune' value: current_model.R color: rgb(52,152,219);\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay SI_maths type: 2d {\n\t\t\tchart \"SI\" type: series background: #white {\n\t\t\t\tdata 'S' value: first((my_SIR_maths)).S color: rgb(46,204,113);\n\t\t\t\tdata 'I' value: first((my_SIR_maths)).I color: rgb(231,76,60);\n\t\t\t\tdata 'R' value: first((my_SIR_maths)).R color: rgb(52,152,219);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a graphical simulation of a digital clock that displays time elapsed and alarm settings, allowing users to customize zoom level and cycle duration.", "gaml_code": "/**\n* Name: Clock\n* Author: JD ZUCKER\n* Description: This model supports defining a clock whose minutes corresponds to the tick of the simulation \n* By default 1000 milliseconds=1s correspond to 1 cycle. \n* Tags: 6/5/2019\n*/\nmodel Clock\n\nglobal {\n\t//Time value for a cycle by default 1s/cycle\n\tfloat stepDuration<-1000.0#ms min: 100.0#ms max: 600000#ms;\n\t//Background of the clock\n\timage_file clock_normal     const: true <- image_file(\"../images/clock.png\");\n\t//Image for the big hand \n\timage_file clock_big_hand   const: true <- image_file(\"../images/big_hand.png\");\n\t//Image for the small hand\n\timage_file clock_small_hand const: true <- image_file(\"../images/small_hand.png\");\n\t//Image for the clock alarm\n\timage_file clock_alarm \t  const: true <- image_file(\"../images/alarm_hand.png\");\n\t//Zoom to take in consideration the zoom in the display, to better write the cycle values\n\tint zoom <- 4 min:2 max:10;\n\t//Postion of the clock\n\tfloat clock_x <- world.shape.width/2;\n\tfloat clock_y <- world.shape.height/2;\n\t\n\t//Alarm parameters\n\tint alarm_days <- 0 min:0 max:365;\n\tint alarm_hours <- 2 min:0 max:11;\n\tint alarm_minutes <- 0 min:0 max:59;\n\tint  alarm_seconds <- 0 min:0 max:59;\n\tbool alarm_am <- true;\n\t//Compute the number of cycles corresponding to the time of alarm\n\tint  alarmCycle <-  int((alarm_seconds+alarm_minutes*60+alarm_hours*3600 + (alarm_am ? 0 : 3600*12) + alarm_days*3600*24) * 1000#ms / stepDuration);\n\t\n\t//Time elapsed since the beginning of the experiment\n\tint timeElapsed <- 0 update:  int(cycle * stepDuration);\n\tstring reflexType <-\"\";\n\tinit {\n\t\t//Creation of the clock\n\t\tcreate clock number: 1 {\n\t\t\tlocation <- {clock_x,clock_y};\n\t\t}\n\t}\n}\n//Species that will represent the clock\nspecies  clock { \n\t\tfloat nb_minutes<-0.0 update: ((timeElapsed mod 3600#s))/60#s; //Mod with 60 minutes or 1 hour, then divided by one minute value to get the number of minutes\n\t\tfloat nb_hours<-0.0 update:((timeElapsed mod 86400#s))/3600#s;\n\t\tfloat nb_days <- 0.0 update:((timeElapsed mod 31536000#s))/86400#s;\n\t\t\n\t\treflex update when: cycle=alarmCycle {\n\t\t\t write \"\" + int(nb_hours) + \":\" + int(nb_minutes) + \": Time to leave !\" ; \n\t\t}\n\t\t\n\t\taspect default {\n\t\t\tdraw clock_normal size: 10*zoom;\n\t\t\tdraw string(\" \" + cycle + \" cycles\")  size:zoom/2 font:\"times\" color:#black at:{clock_x-5,clock_y+5};\n\t\t\tdraw clock_big_hand rotate: nb_minutes*(360/60)  + 90  size: {7 * zoom, 2} at:location + {0,0,0.1}; //Modulo with the representation of a minute in ms and divided by 10000 to get the degree of rotation\n\t\t\tdraw clock_small_hand rotate: nb_hours*(360/12)  + 90  size:{5*zoom, 2} at:location + {0,0,0.1};\t\t\t\n\t\t\tdraw clock_alarm rotate:      (alarmCycle/12000)  size: zoom/3 at:location + {0,0,0.1}; // Alarm time\n\t\t\tdraw string( \" \" + int(nb_days) + \" Days\")  size:zoom/2 font:\"times\" color:#black at:{clock_x-5,clock_y+8};\n\t\t\tdraw string( \" \" + int(nb_hours) + \" Hours\")  size:zoom/2 font:\"times\" color:#black at:{clock_x-5,clock_y+10};\n\t\t\tdraw string( \" \" + int(nb_minutes) + \" Minutes\")  size:zoom/2 font:\"times\" color:#black at:{clock_x-5,clock_y+12};\n\t\t\tdraw string( \" \" + timeElapsed + \" Seconds\")  size:zoom/2 font:\"times\" color:#black at:{clock_x-5,clock_y+14};\n\t\t\t \n\t\t}\n \n}\n\nexperiment Display type: gui autorun:true{\n\tfloat minimum_cycle_duration <- 0.001#s;\n\tparameter 'Zoom: ' var: zoom category: 'Init' ;\n\tparameter 'Milliseconds/cycle' var: stepDuration category: 'Init';\n\tparameter 'alarm Day' var: alarm_days;\n\tparameter 'alarm Hour' var: alarm_hours;\n\tparameter 'alarm Am' var: alarm_am;\n\tparameter 'alarm Minutes' var: alarm_minutes;\n\tparameter 'alarm Seconds' var: alarm_seconds;\n\toutput {\n\t\tdisplay ClockView type: 3d axes:false{ \n\t\t\tspecies clock ;\n\t\t}\n\t}\n\n}"}
{"prompt": "Create a simulation of ants sorting colors on a grid using multi-agent modeling, where agents move randomly and pick up colors based on density and drop them when they encounter similar colors.", "gaml_code": "/**\n* Name: Ant Sorting\n* Author: Alexis Drogoul\n* Description: This model is loosely based on the behavior of ants sorting different elements in their nest . \n*\t\n* \tA group of mobile agents - the ants - is placed on a grid. \n* \t\n* \tThe grid itself contains cells of different colors. \n* \t\n* \tEach step, the agents move randomly. \n* \t\n* \tIf they enter a colored cell, they pick this color if its density in the neighbourhood \n* \tis less than *number_of_objects_around*. \n* \t\n* \tIf they have picked a color, they drop it on a black cell if they have encountered at least \n* \t*number_of_objects_in_history* cells with the same color.\n* \t\n* \tAfter a while, colors begin to be aggregated.\n*  \n* Tags: gui, skill, grid\n*/\nmodel ant_sort\n\nglobal {\n// Parameters \n\tint number_of_different_colors <- 5 max: 9 min: 1;\n\tint density_percent <- 30 min: 0 max: 99;\n\tint number_of_objects_in_history <- 3 min: 0;\n\tint number_of_objects_around <- 5 min: 0 max: 8;\n\tint width_and_height_of_grid <- 200 max: 400 min: 10;\n\tint ants <- 200 min: 1;\n\tlist<rgb> all_colors <- brewer_colors(any(brewer_palettes(number_of_different_colors)));\n\tlist<rgb> colors_to_use;\n\n\tinit {\n\t\tcolors_to_use <- number_of_different_colors among all_colors;\n\t\tcreate ant number: ants;\n\t\task ((density_percent / 100) * (width_and_height_of_grid * width_and_height_of_grid)) among ant_grid {\n\t\t\tcolor <- one_of(colors_to_use);\n\t\t}\n\n\t}\n\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\trgb color <- #white;\n\tant_grid place -> ant_grid(location);\n\timage_file img <- image_file(\"../images/ant.png\");\n\n\t//Reflex to make the ant wander\n\treflex wandering {\n\t\tdo wander amplitude: 120.0;\n\t}\n\t//Initial state that will change to full\n\tstate empty initial: true {\n\t\ttransition to: full when: place.color != #black and ((place.neighbors count (each.color = place.color)) < number_of_objects_around) {\n\t\t\tcolor <- place.color;\n\t\t\tplace.color <- #black;\n\t\t}\n\n\t}\n\n\t//State full that will change to black if the place color is empty and drop the color inside it\n\tstate full {\n\t\tenter {\n\t\t\tint encountered <- 0;\n\t\t}\n\n\t\tif place.color = color {\n\t\t\tencountered <- encountered + 1;\n\t\t}\n\n\t\ttransition to: empty when: (place.color = #black) and (encountered > number_of_objects_in_history) {\n\t\t\tplace.color <- color;\n\t\t\tcolor <- #black;\n\t\t}\n\n\t}\n\n\taspect default {\n\t\tdraw circle(3) color: rgb(color, 0.8) wireframe: true width: 3;\n\t\tdraw img size: 1 at: location;\n\t}\n\n}\n//Grid that will use the density to determine the color\ngrid ant_grid width: width_and_height_of_grid height: width_and_height_of_grid neighbors: 8 use_regular_agents: false frequency: 0 {\n\trgb color <- #black;\n}\n\nexperiment \"Color sort\" type: gui {\n\tparameter \"Number of colors:\" var: number_of_different_colors category: \"Environment\";\n\tparameter \"Density of colors:\" var: density_percent category: \"Environment\";\n\tparameter \"Number of similar colors in memory necessary to put down:\" var: number_of_objects_in_history category: \"Agents\";\n\tparameter \"Number of similar colors in perception necessary to pick up:\" var: number_of_objects_around category: \"Agents\";\n\tparameter \"Width and height of the grid:\" var: width_and_height_of_grid category: \"Environment\";\n\tparameter \"Number of agents:\" var: ants category: \"Agents\";\n\toutput synchronized: false {\n\t\tdisplay view type: 3d antialias: true {\n\t\t\tgrid ant_grid;\n\t\t\tspecies ant transparency: 0.05;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Design a simulation of ant foraging behavior using a grid-based model, incorporating pheromone diffusion and food gathering, with visualizations and analysis tools.", "gaml_code": "/**\n* Name: Ant Foraging (Complex)\n* Author: \n* Description: Toy Model ant using the question of how ants search food and use pheromons to return to their \n* nest once they did find food.\t\n* Tags: gui, fsm, grid, diffusion\n*/\n@no_warning\nmodel ants\n\nglobal {\n//Utilities\n\n\tbool use_icons <- true;\n\tbool display_state <- false;\n\t//Evaporation value per cycle\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0;\n\t//Diffusion rate of the pheromon among the grid  \n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0;\n\t//Size of the grid\n\tint gridsize <- 100 min: 30;\n\t//Number of ants\n\tint ants_number <- 200 min: 1;\n\t//Frequency of update of the grid\n\tint grid_frequency <- 1 min: 1 max: 100;\n\t//Number of food places among the grid\n\tint number_of_food_places <- 5 min: 1; \n\tfloat grid_transparency <- 1.0; \n\timage_file ant_shape const: true <- file('../images/ant.png');\n\tgeometry ant_shape_svg const: true <- geometry(svg_file(\"../images/ant.svg\"));\n\tobj_file ant3D_shape const: true <- obj_file('../images/fire-ant.obj', '../images/fire-ant.mtl', -90::{1, 0, 0});\n\tfont regular <- font(\"Helvetica\", 14, #bold);\n\tfont bigger <- font(\"Helvetica\", 18, #bold);\n\n\t//The center of the grid that will be considered as the nest location\n\tpoint center const: true <- {round(gridsize / 2), round(gridsize / 2)};\n\tint food_gathered <- 1;\n\tint food_placed <- 1;\n\trgb background const: true <- rgb(99, 200, 66);\n\trgb food_color const: true <- rgb(31, 22, 0);\n\trgb nest_color const: true <- rgb(0, 0, 0);\n\tgeometry shape <- square(gridsize);\n\timage_file terrain <- image_file(\"../images/soil.jpg\");\n\tmatrix<float> grid_values <- matrix<float>(as_matrix(terrain, {gridsize, gridsize}));\n\n\tinit {\n\n\t// Normalization of the grid values\n\t\tfloat min <- min(grid_values);\n\t\tfloat max <- max(grid_values);\n\t\tfloat range <- (max - min) / 2.5;\n\t\tloop i from: 0 to: gridsize - 1 {\n\t\t\tloop j from: 0 to: gridsize - 1 {\n\t\t\t\tgrid_values[i, j] <- (grid_values[i, j] - min) / range;\n\t\t\t}\n\n\t\t}\n\n\t\t//Creation of the food places placed randomly with a certain distance between each\n\t\tloop times: number_of_food_places {\n\t\t\tpoint loc <- {rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5};\n\t\t\tlist<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));\n\t\t\task food_places {\n\t\t\t\tif food = 0 {\n\t\t\t\t\tfood <- 5;\n\t\t\t\t\tfood_placed <- food_placed + 5;\n\t\t\t\t\tcolor <- food_color;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\t//Creation of the ants that will be placed in the nest\n\t\tcreate ant number: ants_number with: (location: center);\n\t}\n\t//Reflex to diffuse the pheromon among the grid\n\treflex diffuse {\n\t\tdiffuse var: road on: ant_grid proportion: diffusion_rate radius: 3 propagation: gradient method: convolution;\n\t} }\n\n\t//Grid used to discretize the space to place food\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false {\n\tbool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;\n\tfloat road <- 0.0 max: 240.0 update: (road <= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;\n\trgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(0, 99, 0) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?\n\tfood_color : ((road < 0.001) ? background : rgb(0, 99, 0) + int(road * 5)));\n\tint food <- 0;\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 1.0;\n\tbool has_food <- false;\n\n\t//Reflex to place a pheromon stock in the cell\n\treflex diffuse_road when: has_food = true {\n\t\tant_grid(location).road <- ant_grid(location).road + 100.0;\n\t}\n\t//Action to pick food\n\taction pick (int amount) {\n\t\thas_food <- true;\n\t\tant_grid place <- ant_grid(location);\n\t\tplace.food <- place.food - amount;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1;\n\t\thas_food <- false;\n\t\theading <- heading - 180;\n\t}\n\t//Action to find the best place in the neighborhood cells\n\tpoint choose_best_place {\n\t\tlist<ant_grid> list_places <- ant_grid(location).neighbors;\n\t\tif (list_places count (each.food > 0)) > 0 {\n\t\t\treturn point(list_places first_with (each.food > 0));\n\t\t} else {\n\t\t\tlist_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);\n\t\t\treturn point(last(list_places));\n\t\t}\n\n\t}\n\t//Reflex to drop food once the ant is in the nest\n\treflex drop when: has_food and (ant_grid(location)).is_nest {\n\t\tdo drop();\n\t}\n\t//Reflex to pick food when there is one at the same location\n\treflex pick when: !has_food and (ant_grid(location)).food > 0 {\n\t\tdo pick(1);\n\t}\n\t//Initial state to make the ant wander \n\tstate wandering initial: true {\n\t\tdo wander(amplitude: 90.0);\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: followingRoad when: (pr > 0.05) and (pr < 4);\n\t}\n\t//State to carry food once it has been found\n\tstate carryingFood {\n\t\tdo goto(target: center);\n\t\ttransition to: wandering when: !has_food;\n\t}\n\t//State to follow a pheromon road if once has been found\n\tstate followingRoad {\n\t\tpoint next_place <- choose_best_place();\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\tlocation <- next_place;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: wandering when: (pr < 0.05) or (next_place = nil);\n\t}\n\n\taspect info {\n\t\tif (use_icons) {\n\t\t\tdraw ant_shape size: {7, 5} rotate: my heading + 1;\n\t\t} else {\n\t\t\tdraw circle(1) wireframe: !has_food color: #red;\n\t\t}\n\n\t\tdraw line([location + {0, 0, 0.5}, {location.x + 5 * cos(heading), location.y + 5 * sin(heading)} + {0, 0, 0.5}]) + 0.1 color: #white border: false end_arrow: 1.2;\n\n\t\tif (display_state) {\n\t\t\tdraw string(self as int) color: #white font: regular at: my location + {0, -1, 0.5} anchor: #center;\n\t\t\tdraw state color: #yellow font: bigger at: my location + {0, 0, 0.5} anchor: #center;\n\t\t}\n\n\t}\n\n\taspect threeD {\n\t\tdraw ant3D_shape size: {7, 5} at: (location + {0, 0, 1}) rotate: heading;\n\t}\n\n\taspect icon {\n\t\tdraw ant_shape size: {7, 5} rotate: my heading + 1 wireframe: true;\n\t}\n\n\taspect icon_svg {\n\t\tdraw (ant_shape_svg) size: {5, 7} at: (location)rotate: my heading + 90 color: #black;\n\t} \n}\n\nexperiment base virtual:true {\n\t\t\n\tparameter 'Evaporation of the signal (unit/cycle):' var:evaporation_per_cycle category: 'Signals';\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var:diffusion_rate category: 'Signals';\n\tparameter 'Width and Height of the grid:' var:gridsize category: 'Environment and Population';\n\tparameter 'Number of ants:' var:ants_number category: 'Environment and Population';\n\tparameter 'Grid updates itself every:' var:grid_frequency category: 'Environment and Population';\n\tparameter 'Number of food depots:' var:number_of_food_places category: 'Environment and Population';\n\t\n}\n\n\t//Complete experiment that will inspect all ants in a table\nexperiment \"With Inspector\" type: gui parent:base{\n\t\n\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n\n\t\n\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\toutput {\n\t\tlayout #split editors: false;\n\t\tdisplay Ants type: 3d axes:false{\n\t\t\timage terrain position: {0.05, 0.05} size: {0.9, 0.9} refresh: false;\n\t\t\tagents \"agents\" transparency: 0.7 position: {0.05, 0.05} size: {0.9, 0.9} value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant position: {0.05, 0.05, 0.05} size: {0.9, 0.9} aspect: icon_svg;\n\t\t\toverlay transparency: 0.3 background: rgb(99, 85, 66, 255) position: {50 #px, 50 #px} size: {250 #px, 150 #px} border: rgb(99, 85, 66, 255) rounded: true {\n\t\t\t\tdraw ant_shape at: {60 #px, 70 #px} size: {140 #px, 100 #px} rotate: -60;\n\t\t\t\tdraw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40 #px, 70 #px} font: font(\"Arial\", 18, #bold) color:\n\t\t\t\t#white;\n\t\t\t\tdraw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = \"followingRoad\")) / length(ant)) with_precision 2) + '%') at: {40 #px, 100 #px} font:\n\t\t\t\tfont(\"Arial\", 18, #bold) color: #white;\n\t\t\t}\n\n\t\t}\n\n\t\tinspect \"All ants\" type: table value: ant attributes: ['name', 'state'];\n\t}\n\n}\n\nexperiment \"Classic\" type: gui record: every(10) parent:base{\n\t\n\tparameter 'Number of ants:' var: ants_number category: 'Model';\n\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model';\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model';\n\tparameter 'Use icons for the agents:' var: use_icons category: 'Display';\n\tparameter 'Display state of agents:' var: display_state category: 'Display';\n\t\n\tuser_command \"Save\" {\tsave simulation to: '../result/file.simulation' format: \"json\" ;}\n\t\n\toutput {\n\t\tdisplay Ants antialias: false type: 3d {\n\t\t\tlight #ambient intensity: 127;\n\t\t\tlight #default intensity: 127;\n\t\t\timage terrain refresh: false;\n\t\t\tagents \"Grid\" transparency: 0.4 value: ant_grid where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant aspect: info;\n\t\t}\n\n\t}\n\n}\n\n//Complete experiment that will inspect all ants in a table\nexperiment \"3D View\" type: gui parent:base{\n\tparameter 'Number:' var: ants_number init: 30 unit: 'ants' category: 'Environment and Population';\n\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\toutput {\n\t\t\n\n\t\tdisplay Ants3D type: 3d show_fps: true antialias: false{\n\t\t\tgrid ant_grid elevation: grid_values triangulation: true texture: terrain refresh: false;\n\t\t\tagents \"Trail\" transparency: 0.7 position: {0.05, 0.05, 0.02} size: {0.9, 0.9} value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant position: {0.05, 0.05, 0.025} size: {0.9, 0.9} aspect: threeD;\n\t\t}\n\n\t}\n\n}\n\n//Experiment to show how to make multi simulations\nexperiment \"3 Simulations\" type: gui  parent:base{\n\t\n\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\t\n\n\t// We create 2 supplementary simulations using the species name 'ants_model' (automatically created from the name of the model + '_model')\n\tinit {\n\t\tcreate ants_model with: [ants_number::200, evaporation_per_cycle::100, diffusion_rate::0.2];\n\t\tcreate ants_model with: [ants_number::10, evaporation_per_cycle::72, diffusion_rate::0.6];\n\t}\n\n\n\tpermanent {\n\t\t\n\t\tdisplay Comparison background: #white type:2d{\n\t\t\tchart \"Food Gathered\" type: series {\n\t\t\t\tloop s over: simulations {\n\t\t\t\t\tif (!dead(s)) {\n\t\t\t\t\tdata \"Food \" + int(s) value: s.food_gathered color: s.color marker: false style: line thickness: 5;\n\t\t\t\t}}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\toutput {\n\t\tlayout #split editors: false consoles: false toolbars: true tabs: true tray: false parameters: true background: #red;\n\t\tdisplay Ants background: color type: 3d toolbar: color axes: false {\n\t\t\timage terrain position: {0.05, 0.05} size: {0.9, 0.9} refresh: false;\n\t\t\tagents \"agents\" transparency: 0.5 position: {0.05, 0.05} size: {0.9, 0.9} value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant position: {0.05, 0.05} size: {0.9, 0.9} aspect: icon;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates Voronoi clustering using a grid-based approach, allowing for user-adjustable parameters such as number of points, environment size, and color palette.", "gaml_code": "/**\n* Name: Voronoi\n* Author: \n* Description: A model showing how to clusterize space using the closest center as the kernel of our cluster. The space \n* \t is discretized using a grid, each cell computing its distance from a center to know in which cluster it is. \n* Tags: skill, agent_movement, grid\n*/\nmodel voronoi\n\nglobal {\n// Parameters \n//Number of points\n\tint num_points <- 15 min: 1 max: 1000;\n\t//Size of the environment\n\tint env_width <- 150 min: 10 max: 400;\n\tint env_height <- 150 min: 10 max: 400;\n\tint num_neighbours <- 4 among: [4, 8];\n\tstring palette <- 'PRGn' among: brewer_palettes(15);\n\tlist<rgb> colors <- brewer_colors(palette);\n\tbool blur1 <- false;\n\tbool blur2 <- false;\n\ttopology w;\n\n\t// Environment\n\tgeometry shape <- rectangle(env_width, env_height);\n\n\tinit {\n\t\twrite\n\t\t'This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations.';\n\t\t//Creation of all the points\n\t\tcreate center number: num_points;\n\t\tw <- topology(self);\n\t}\n\n}\n//Grid for the voronoi clustering\ngrid cell width: env_width height: env_height neighbors: num_neighbours use_neighbors_cache: true use_individual_shapes: false use_regular_agents: false parallel: true {\n// Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances\n\trgb color <- #white update: ((center closest_to location) using w).color;\n\n\treflex when: blur1 {\n\t\tcolor <- blend(color, one_of(neighbors).color, 0.7);\n\t}\n\n\treflex when: blur2 {\n\t\tloop n over: neighbors {\n\t\t\tcolor <- blend(color, n.color, 0.8);\n\t\t}\n\n\t}\n\n}\n//Species representing the center of a Voronoi polygon\nspecies center skills: [moving] {\n\trgb color <- colors[int(self) mod length(colors)]; //rnd_color(255);\n\t//Make the center of the cluster wander in the environment       \n\treflex wander {\n\t\tdo wander amplitude: 90.0;\n\t}\n\n\taspect default {\n\t\tdraw circle(1.0) color: color border: #black;\n\t}\n\n}\n\nexperiment voronoi type: gui autorun: true {\n\tparameter 'Number of points:' var: num_points {\n\t\tif (num_points > length(center)) {\n\t\t\tcreate center number: num_points - length(center);\n\t\t} else {\n\t\t\task (length(center) - num_points) among center {\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t}\n\n\t}\n\tparameter 'Number of neighbours in the grid:' var: num_neighbours;\n\tparameter 'Color palette' var: palette  {\n\t\tcolors <- brewer_colors(palette);\n\t\task center {\n\t\t\tcolor <- colors[int(self) mod length(colors)];\n\t\t}\n\n\t}\n\tparameter 'Width of the environment:' var: env_width;\n\tparameter 'Height of the environment:' var: env_height;\n\tparameter \"Simple blur\" var: blur1;\n\tparameter \"Complex blur\" var: blur2;\n\t\n\tfloat minimum_cycle_duration <- 0.05#s;\n\toutput {\n\t\tlayout #split navigator: false tray: false toolbars: false consoles: false editors: false;\n\t\tdisplay \"Voronoi 2D\" background: #black type: 3d axes:false{\n\t\t\tlight #ambient intensity: 100;\n\t\t\tgrid cell;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D generative art piece inspired by Radiohead's OK Computer album, allowing users to interact with it using keyboard keys.", "gaml_code": "/**\n* Name: gam_ashapedthom_10K_comp\n* Author: Arnaud Grignard and Tri Nguyen-Huu \n* Description: Press \"r\",\"a\",\"d\",\"i\",\"o\",\"h\",\"e\",\"a\",\"d\"\n* Forked from agrignard/r_adiohead_10kandOK forked from dataarts/radiohead - 2019\n* Tags: art\n*/\nmodel hail_to_pablo_the_king_of_the_amnesiac_kid_in_a_computer_shaped_thom\n\nglobal{\n\t\n  matrix<float> idioteque <-  matrix<float>(csv_file(\"../includes/ok_computer.csv\",\"\"));\n  float no_surprises <- 1.0;\n  bool it_might_be_wrong <- true;\n  bool pyramid_song <- false;\n  point the_bend <-{1,1,1}; \n  point everything_in_its_right_place <-{0,0,0};\n  geometry shape<- box(max(column_at (idioteque , 0))-min(column_at (idioteque , 0)),max(column_at (idioteque , 1))-min(column_at (idioteque , 1)),max(column_at (idioteque , 2))-(min(column_at (idioteque , 2)))) \n    at_location {(max(column_at (idioteque , 0))-min(column_at (idioteque , 0)))/2,(max(column_at (idioteque , 1))-min(column_at (idioteque , 1)))/2,min(column_at (idioteque , 2))};\n  \n \n  init {\n    everything_in_its_right_place<-{min(column_at (idioteque , 0)),min(column_at (idioteque , 1)),min(column_at (idioteque , 2))};\n\tloop i from: 1 to: idioteque.rows -1{\n\t  create paranoid_android with:[the_numbers::idioteque[3,i]]{\t\t\n\t    location<-{-everything_in_its_right_place.x+idioteque[0,i],-everything_in_its_right_place.y+idioteque[1,i],(idioteque[2,i])-everything_in_its_right_place.z};\t\n      }\t  \n\t}\n  }\n}\n\nspecies paranoid_android skills:[moving]{\n\tfloat the_numbers;\n\taspect house_of_cards{\n\t\tif(it_might_be_wrong){\n\t\t\tif(pyramid_song){\n\t\t\t  draw pyramid(no_surprises*the_numbers/100) color:rgb(the_numbers*1.1,the_numbers*1.6,200,50) rotate: cycle*the_numbers/10::the_bend;\n\t\t\t}else{\n\t\t\t  draw square(no_surprises*the_numbers/100) color:rgb(the_numbers*1.1,the_numbers*1.6,200,50) rotate: cycle*the_numbers/10::the_bend;\t\n\t\t\t}\n\t\t  \t\t\n\t\t}else{\n\t\t  draw square(no_surprises) color:rgb(the_numbers*1.1,the_numbers*1.6,200,50) rotate: cycle*the_numbers/10::the_bend;\t\t\n\t\t}  \n\t}\n}\n\nexperiment OK_Computer type:gui autorun:true{\n\toutput synchronized:true{\n\t\tdisplay videotape type:3d background:rgb(0,0,15) axes:false fullscreen:true toolbar:false{\n\t    species paranoid_android aspect:house_of_cards;\n\t    \tevent \"r\"  {pyramid_song<-!pyramid_song;}\n\t    \tevent \"a\"  {the_bend<-{1,0,0};}\n\t\t\tevent \"d\"  {the_bend<-{1,0,0};}\n\t\t\tevent \"i\"  {it_might_be_wrong<-!it_might_be_wrong;}\n\t\t\tevent \"o\"  {the_bend<-{0,1,0};}\n\t\t\tevent \"h\"  {the_bend<-{0,0,1};}\n\t\t\tevent \"e\"  {the_bend<-{1,1,1};}\n\t\t\tevent \"a\"  {the_bend<-{1,1,1};}\n\t\t\tevent \"d\"  {the_bend<-{1,1,1};}\n\t\t}\t\n\t}\n}"}
{"prompt": "**This is a Lindenmayer system (L-System) tree simulation written in StarLogo TNG.**", "gaml_code": "/**\n *  Author: Tri Nguyen-Huu\n *  Description: growing tree using L-systems.\n */\nmodel tree\n\nglobal {\n\tfloat rigidity;\n\tint max_level <- 8;\n\tfloat min_energy <- 300.0;\n\tfloat main_split_angle_alpha <- 30.0;\n\tfloat secondary_split_angle_alpha <- 90.0;\n\tfloat main_split_angle_beta <- 20.0;\n\tfloat secondary_split_angle_beta <- 90.0;\n\tfloat length_max <- 100.0;\n\tfloat width_ini <- 1.0;\n\tfloat level_step <- 0.8;\n\tseasons season;\n\tfloat width <- shape.width;\n\tfloat height <- shape.height;\n\tfloat env_size <- 0.5 * length_max / (1 - level_step);\n\tpoint seed_pos <- {width / 2, height / 2};\n\n\tinit {\n\t\tcreate plant_seed {\n\t\t\tlocation <- seed_pos;\n\t\t\twrite location;\n\t\t}\n\n\t\tcreate seasons number: 1 {\n\t\t\tseason <- self;\n\t\t}\n\t}\n}\n\nspecies seasons {\n\tint season_duration <- 600;\n\tint shift_cycle <- season_duration * 4 update: season_duration * 4 + int(cycle - floor(season_duration / 2));\n\tlist<string> season_list <- [\"winter\", \"spring\", \"summer\", \"autumn\"];\n\tstring current_season <- \"winter\" update: season_list[(cycle div season_duration) mod 4];\n\tint current_day <- 0 update:  cycle mod season_duration;\n\tint shift_current_day <- 0 update: shift_cycle mod season_duration;\n\tfloat energy <- 0.0 update: energy_map[current_season];\n\tint se <- 0 update: (shift_cycle div season_duration) mod 4;\n\tint next_se <- 1 update: (se + 1) mod 4;\n\tint ns_se <- 0 update: (cycle div season_duration) mod 4;\n\tint ns_next_se <- 1 update: (ns_se + 1) mod 4;\n\tlist<rgb> sky_color_list <- [rgb(238, 238, 238), rgb(129, 207, 224), rgb(25, 181, 254), rgb(254, 224, 144)];\n\tlist<rgb> leaf_color_list <- [rgb(150, 40, 27), rgb(134, 174, 83), rgb(30, 130, 76), rgb(192, 57, 43)];\n\tlist<rgb> ground_color_list <- [rgb(236, 240, 241), rgb(46, 204, 113), rgb(38, 166, 91), rgb(95, 104, 40)];\n\t//\t\tlist<rgb> branch_color_list <- [rgb(97,73,52),rgb(90,139,140),rgb(90,139,140),rgb(90,139,140)];\n\tlist<rgb> branch_color_list <- [rgb(77, 67, 62), rgb(60, 45, 32), rgb(115, 77, 64), rgb(90, 68, 48)];\n\tlist<rgb> fruit_color_list <- [rgb(102, 62, 81), rgb(200, 247, 197), rgb(135, 211, 124), rgb(211, 84, 0)];\n\trgb sky_color <- sky_color_list[0];\n\trgb leaf_color <- leaf_color_list[0];\n\trgb ground_color <- ground_color_list[0];\n\trgb branch_color <- branch_color_list[0];\n\trgb fruit_color <- fruit_color_list[0];\n\tmap<string, float> energy_map <- [\"winter\"::0.0, \"spring\"::0.3, \"summer\"::0.08, \"autumn\"::0];\n\n\tinit {\n\t\tdo change_color;\n\t}\n\n\taction change_color {\n\t\tleaf_color <- blend(leaf_color_list[se], leaf_color_list[next_se], 1 - shift_current_day / season_duration);\n\t\tsky_color <- blend(sky_color_list[se], sky_color_list[next_se], 1 - shift_current_day / season_duration);\n\t\tground_color <- blend(ground_color_list[se], ground_color_list[next_se], 1 - shift_current_day / season_duration);\n\t\tbranch_color <- blend(branch_color_list[ns_se], branch_color_list[ns_next_se], 1 - current_day / season_duration);\n\t\tfloat scale <- 500.0;\n\t\tfruit_color <- blend(fruit_color_list[ns_se], fruit_color_list[ns_next_se], exp(-current_day / scale));\n\t}\n\n\treflex update {\n\t\tdo change_color;\n\t}\n\n}\n\nspecies tree_part {\n\ttree_part parent <- nil;\n\tpoint vector <- {0, 0, 0};\n\tpoint base <- {0, 0, 0};\n\tpoint end <- {0, 0, 0};\n\tfloat alpha <- 0.0;\n\tfloat beta <- 0.0;\n\tfloat level <- 1.0;\n\tlist children <- nil;\n\tfloat energy <- 0.0;\n}\n\nspecies plant_seed parent: tree_part {\n\tbool has_tree <- false;\n\tpoint end -> self.location;\n\tpoint vector <- {0, 0, 1};\n\n\treflex create_tree when: (!has_tree and season.current_season = \"spring\") {\n\t\tcreate trunk {\n\t\t\tbase <- myself.location;\n\t\t\tself.end <- self.base;\n\t\t\talpha <- rnd(100) * 360 / 100;\n\t\t\tbeta <- 90.0;\n\t\t\tlevel <- 1.0;\n\t\t\tparent <- myself;\n\t\t}\n\n\t\thas_tree <- true;\n\t}\n\n\taspect default {\n\t\tdraw\n\t\tpolygon([location + {env_size / 2, 0, -1}, location + {0.5 * env_size / 2, 0.86 * env_size / 2, -1}, location + {-0.5 * env_size / 2, 0.86 * env_size / 2, -1}, location + {-env_size / 2, 0, -1}, location + {-0.5 * env_size / 2, -0.86 * env_size / 2, -1}, location + {0.5 * env_size / 2, -0.86 * env_size / 2, -1}])\n\t\tcolor: season.ground_color border: season.ground_color;\n\t\tdraw cone3D(6, 6) at: location color: rgb(108, 122, 137);\n\t\tdraw polygon([location + {0, 0, 3}, location + {env_size / 6, 0, 0}, location + {0.5 * env_size / 6, 0.86 * env_size / 6, 0}]) color: rgb(135, 121, 78) border:\n\t\trgb(135, 121, 78);\n\t\tdraw polygon([location + {0, 0, 3}, location + {0.5 * env_size / 6, 0.86 * env_size / 6, 0}, location + {-0.5 * env_size / 6, 0.86 * env_size / 6, 0}]) color: rgb(115, 101, 58)\n\t\tborder: rgb(115, 101, 58);\n\t\tdraw polygon([location + {0, 0, 3}, location + {-0.5 * env_size / 6, 0.86 * env_size / 6, 0}, location + {-env_size / 6, 0, 0}]) color: rgb(115, 101, 58) border:\n\t\trgb(115, 101, 58);\n\t\tdraw polygon([location + {0, 0, 3}, location + {-env_size / 6, 0, 0}, location + {-0.5 * env_size / 6, -0.86 * env_size / 6, 0}]) color: rgb(135, 121, 78) border:\n\t\trgb(135, 121, 78);\n\t\tdraw polygon([location + {0, 0, 3}, location + {-0.5 * env_size / 6, -0.86 * env_size / 6, 0}, location + {0.5 * env_size / 6, -0.86 * env_size / 6, 0}]) color:\n\t\trgb(135, 121, 78) border: rgb(135, 121, 78);\n\t\tdraw polygon([location + {0, 0, 3}, location + {0.5 * env_size / 6, -0.86 * env_size / 6, 0}, location + {env_size / 6, 0, 0}]) color: rgb(135, 121, 78) border:\n\t\trgb(135, 121, 78);\n\t}\n\n}\n\nspecies burgeon parent: tree_part {\n\n\treflex growth {\n\t\tenergy <- energy + first(season).energy;\n\t}\n\n\treflex bloom when: flip(energy / 1) {\n\t\tbranch tmp <- nil;\n\t\tcreate branch number: 1 {\n\t\t\ttmp <- self;\n\t\t\tself.level <- myself.level;\n\t\t\tself.base <- myself.base;\n\t\t\tself.end <- self.base;\n\t\t\tself.alpha <- myself.alpha;\n\t\t\tself.beta <- myself.beta;\n\t\t\tself.parent <- myself.parent;\n\t\t\tif myself.parent != nil {\n\t\t\t\tmyself.parent.children <- myself.parent.children + tmp;\n\t\t\t}\n\n\t\t}\n\n\t\tcreate leaf {\n\t\t\tself.level <- myself.level;\n\t\t\tself.parent <- tmp;\n\t\t\tself.alpha <- myself.alpha;\n\t\t\tself.beta <- myself.beta;\n\t\t\tself.base <- tmp.end;\n\t\t\tself.end <- self.base + {5 * cos(beta) * cos(alpha), 5 * cos(beta) * sin(alpha), 5 * sin(beta)};\n\t\t\ttmp.children <- tmp.children + self;\n\t\t\tself.creation_cycle <- cycle;\n\t\t}\n\n\t\tdo die;\n\t}\n\n}\n\nspecies trunk parent: tree_part {\n\tfloat length <- 0.0;\n\tfloat width <- 0.0;\n\tbool can_split <- true;\n\n\taspect default {\n\t\tdraw line([base, end], width) color: season.branch_color; // border: #red;\n\t}\n\n\treflex growth {\n\t\tbase <- parent.end;\n\t\tenergy <- energy + first(season).energy;\n\t\tfloat level_correction <- 1.8 * 0.3 ^ level;\n\t\tlength <- level_correction * (length_max * (1 - min([1, exp(-energy / 1000)])));\n\t\twidth <- length / level_correction / 13.0;\n\t\tend <- base + {length * cos(beta) * cos(alpha), length * cos(beta) * sin(alpha), length * sin(beta)};\n\t}\n\n\treflex split when: can_split and (level < max_level) and (min_energy < energy) {\n\t\tfloat branch1_alpha <- rnd(100) / 100 * 360;\n\t\tfloat branch1_beta <- 30 + rnd(100) / 100 * 40;\n\t\tfloat branch2_alpha <- rnd(100) / 100 * 360;\n\t\tfloat branch2_beta <- 30 + rnd(100) / 100 * 40;\n\t\tcan_split <- false;\n\t\tcreate burgeon number: 1 {\n\t\t\tself.level <- myself.level + 1.9;\n\t\t\tself.base <- myself.end;\n\t\t\tself.end <- self.base;\n\t\t\tself.alpha <- branch1_alpha;\n\t\t\tself.beta <- branch1_beta;\n\t\t\tself.parent <- myself;\n\t\t}\n\n\t\tif flip(0.7) {\n\t\t\tcreate burgeon number: 1 {\n\t\t\t\tself.level <- myself.level + 2.1;\n\t\t\t\tself.base <- myself.end;\n\t\t\t\tself.end <- self.base;\n\t\t\t\tself.alpha <- branch2_alpha;\n\t\t\t\tself.beta <- branch2_beta;\n\t\t\t\tself.parent <- myself;\n\t\t\t}\n\n\t\t}\n\n\t\tcreate trunk number: 1 {\n\t\t\tself.level <- myself.level + 0.3;\n\t\t\tself.base <- myself.end;\n\t\t\tself.end <- self.end;\n\t\t\tself.alpha <- myself.alpha - 10 + rnd(200) / 10;\n\t\t\tself.beta <- myself.beta - 10 + rnd(200) / 10;\n\t\t\tself.parent <- myself;\n\t\t}\n\n\t}\n\n}\n\nspecies branch parent: tree_part {\n\tfloat length <- 0.0;\n\tfloat width <- 0.0;\n\tbool can_split <- true;\n\n\treflex growth {\n\t\tbase <- parent.end;\n\t\tenergy <- energy + first(season).energy;\n\t\tlength <- level_step ^ level * (length_max * (1 - min([1, exp(-energy / 1000)])));\n\t\twidth <- length / 10 * (4 + max_level - level) / (4 + max_level);\n\t\tend <- base + {length * cos(beta) * cos(alpha), length * cos(beta) * sin(alpha), length * sin(beta)};\n\t}\n\n\taspect default {\n\t\tdraw line([base, end], width) color: season.branch_color; // border: #green;\n\t\tif (season.current_season = \"winter\") and (abs(beta) < 50) {\n\t\t\tdraw line([base + {0, 0, 1.2 * width}, end + {0, 0, 1.2 * width}], width * sin(180 * season.current_day / season.season_duration)) color: #white;\n\t\t}\n\n\t}\n\n}\n\nspecies leaf {\n\tint creation_cycle <- -1;\n\tfloat level <- 1.0;\n\tbranch parent;\n\tpoint base;\n\tpoint end;\n\tfloat alpha <- 0.0;\n\tfloat beta <- 0.0;\n\tfloat fall <- 0.0;\n\tint fall_shift <- int(rnd(season.season_duration / 2.5));\n\tfloat size <- 3.0;\n\tpair<float, point> rota <- rotation_composition(float(rnd(180))::{1, 0, 0}, float(rnd(180))::{0, 1, 0}, float(rnd(180))::{0, 0, 1}); //////////////////////////\n\taspect default {\n\t\tdraw line([base, end], min([parent.width, 1])) color: season.leaf_color;\n\t\t//\t\t\tdraw circle(size) at: (end - {0,0,fall*end.z}) color: season.leaf_color border: season.leaf_color;\n\t\tdraw circle(size) rotate: rota at: (end - {0, 0, fall * end.z}) color: season.leaf_color; // border: #black; //season.leaf_color;\n\t}\n\n\treflex update {\n\t\tbase <- parent.end;\n\t\tend <- base + {5 * cos(beta) * cos(alpha), 5 * cos(beta) * sin(alpha), 5 * sin(beta)};\n\t\tif (season.current_season = \"autumn\") {\n\t\t\tfall <- 1 - exp(-max([0, 5 * (season.current_day - fall_shift) / season.season_duration * 3]));\n\t\t} else if (season.current_season = \"winter\") {\n\t\t\tsize <- 3 * (season.season_duration - season.current_day) / season.season_duration;\n\t\t} else if (season.current_season = \"spring\") {\n\t\t\tfall <- 0.0;\n\t\t\tsize <- 3 * season.current_day / season.season_duration;\n\t\t}\n\n\t}\n\n\treflex split when: (level < max_level) and flip(1 - exp(level * (min_energy - parent.energy) / 50)) {\n\t\tint side1 <- -1 + 2 * rnd(1);\n\t\tint side2 <- -1 + 2 * rnd(1);\n\t\tint side3 <- -1 + 2 * rnd(1);\n\t\tint side4 <- -1 + 2 * rnd(1);\n\t\tfloat factor <- secondary_split_angle_alpha / 100;\n\t\tfloat branch1_alpha <- parent.alpha + side1 * rnd(100) / 100 * main_split_angle_alpha;\n\t\tfloat branch2_alpha <- parent.alpha - side1 * rnd(100) * factor;\n\t\tfloat branch3_alpha <- parent.alpha + side3 * rnd(100) * factor;\n\t\tfloat branch4_alpha <- parent.alpha - side3 * rnd(100) * factor;\n\t\tint sideb <- -1 + 2 * rnd(1);\n\t\t factor <- secondary_split_angle_beta / 100;\n\t\tfloat branch1_beta <- parent.beta + sideb * rnd(100) / 100 * main_split_angle_beta;\n\t\tfloat branch2_beta <- -20 + rnd(100) * factor;\n\t\tfloat branch3_beta <- -20 + rnd(100) * factor;\n\t\tfloat branch4_beta <- -20 + rnd(100) * factor;\n\t\tcreate burgeon number: 1 {\n\t\t\tself.level <- myself.parent.level + 1;\n\t\t\tself.base <- myself.base;\n\t\t\tself.end <- self.base;\n\t\t\tself.alpha <- branch1_alpha;\n\t\t\tself.beta <- branch1_beta;\n\t\t\tself.parent <- myself.parent;\n\t\t}\n\n\t\tcreate burgeon number: 1 {\n\t\t\tself.level <- myself.parent.level + 1.2;\n\t\t\tself.base <- myself.base;\n\t\t\tself.end <- self.base;\n\t\t\tself.alpha <- branch2_alpha;\n\t\t\tself.beta <- branch2_beta;\n\t\t\tself.parent <- myself.parent;\n\t\t}\n\n\t\tif flip(0.6) {\n\t\t\tcreate burgeon number: 1 {\n\t\t\t\tself.level <- myself.parent.level + 1.7;\n\t\t\t\tself.base <- myself.base;\n\t\t\t\tself.end <- self.base;\n\t\t\t\tself.alpha <- branch3_alpha;\n\t\t\t\tself.beta <- branch3_beta;\n\t\t\t\tself.parent <- myself.parent;\n\t\t\t}\n\n\t\t}\n\n\t\tif flip(0.3) {\n\t\t\tcreate burgeon number: 1 {\n\t\t\t\tself.level <- myself.parent.level + 2;\n\t\t\t\tself.base <- myself.base;\n\t\t\t\tself.end <- self.base;\n\t\t\t\tself.alpha <- branch4_alpha;\n\t\t\t\tself.beta <- branch4_beta;\n\t\t\t\tself.parent <- myself.parent;\n\t\t\t}\n\n\t\t}\n\n\t\tif flip(0.8) {\n\t\t\tcreate burgeon number: 1 {\n\t\t\t\tself.level <- myself.parent.level + 3.5;\n\t\t\t\tself.base <- myself.base;\n\t\t\t\tself.end <- self.base;\n\t\t\t\tself.alpha <- branch4_alpha;\n\t\t\t\tself.beta <- branch4_beta;\n\t\t\t\tself.parent <- myself.parent;\n\t\t\t}\n\n\t\t}\n\n\t\tif flip(0.9) {\n\t\t\tcreate fruit number: (1 + rnd(2)) {\n\t\t\t\tself.base <- myself.base;\n\t\t\t\tself.end <- myself.base + {3 * cos(beta) * cos(alpha), 3 * cos(beta) * sin(alpha), 3 * sin(beta)};\n\t\t\t\tself.parent <- myself.parent;\n\t\t\t\tself.alpha <- myself.alpha + (-1 + 2 * rnd(1)) * 30;\n\t\t\t\tself.beta <- -40.0 + rnd(80);\n\t\t\t}\n\n\t\t}\n\n\t\tself.parent.children <- self.parent.children - self;\n\t\tdo die;\n\t}\n\n}\n\nspecies fruit {\n\tbranch parent;\n\tpoint base;\n\tpoint end;\n\tfloat alpha;\n\tfloat beta;\n\tfloat fall <- 0.0;\n\tint fall_shift <- int(rnd(season.season_duration / 2.5)); //unused\n\taspect default {\n\t\tif (season.current_season = \"spring\") {\n\t\t\tdraw line([base, end], 0.1) color: season.leaf_color;\n\t\t\tdraw circle(1 * sin(180 * season.current_day / season.season_duration)) at: end color: #pink border: #pink;\n\t\t} else if (season.current_season = \"summer\") {\n\t\t\tdraw line([base, end], 0.1) color: season.leaf_color;\n\t\t\tdraw sphere(1 * sin(90 * season.current_day / season.season_duration)) at: end color: season.fruit_color border: season.fruit_color;\n\t\t}\n\n\t}\n\n\treflex update {\n\t\tbase <- parent.end;\n\t\tif (season.current_season = \"spring\") {\n\t\t\tend <- base + {3 * cos(beta) * cos(alpha), 3 * cos(beta) * sin(alpha), 3 * sin(beta)};\n\t\t} else if (season.current_season = \"summer\") {\n\t\t\tfloat beta2 <- -90 + (beta + 90) * exp(-season.current_day / 100);\n\t\t\tend <- base + {3 * cos(beta2) * cos(alpha), 3 * cos(beta2) * sin(alpha), 3 * sin(beta2)};\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Random\" type: gui autorun: true {\n\toutput {\n\t\tdisplay 'Tree' type: 3d background: season.sky_color axes: false toolbar: false fullscreen: true {\n\t\t\tlight #ambient intensity: 150;\n\t\t\trotation angle: cycle/1000000 dynamic: true;\n\t\t\tcamera #default location: {50.0,450,250} target: {50.0,50.0,40+80*(1-exp(-cycle/50000))} dynamic: true;\n\t\t\tspecies branch aspect: default;\n\t\t\tspecies leaf aspect: default;\n\t\t\tspecies trunk aspect: default;\n\t\t\tspecies plant_seed aspect: default;\n\t\t\tspecies fruit aspect: default;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"4 simulations\" type: gui autorun: true {\n\n\tinit {\n\t\tcreate simulation number: 3  {\n\t\t\tself.seed <- rnd(1000.0);\n\t\t}\n\t}\n\n\toutput {\n\t\tdisplay 'Tree' type: 3d background: season.sky_color axes: false toolbar: false {\n\t\t\tlight #ambient intensity: 150;\t\n\t\t\trotation angle: cycle/1000000 dynamic: true;\n\t\t\tcamera #default location: {50.0,450,250} target: {50.0,50.0,40+80*(1-exp(-cycle/50000))} dynamic: true;\n\t\t\tspecies branch aspect: default;\n\t\t\tspecies leaf aspect: default;\n\t\t\tspecies trunk aspect: default;\n\t\t\tspecies plant_seed aspect: default;\n\t\t\tspecies fruit aspect: default;\n\t\t}\n\n\t\tlayout #split toolbars: false tabs: false parameters: false consoles: false navigator: false controls: false tray: false;\n\t}\n\n}\n\nexperiment L_Tri type: gui autorun: true {\n\tfloat minimum_cycle_duration <- 0.0009;\n\tfloat seed <- 0.05387546426306633;\n\toutput {\n\t\tdisplay 'Tree' type: 3d background: season.sky_color axes: false toolbar: false {\n\t\t\tlight #ambient intensity: 150;\n\t\t\trotation angle: cycle/1000000 dynamic: true;\n\t\t\tcamera #default location: {50.0,450,250} target: {50.0,50.0,40+80*(1-exp(-cycle/50000))} dynamic: true;\n\t\t\tspecies branch aspect: default;\n\t\t\tspecies leaf aspect: default;\n\t\t\tspecies trunk aspect: default;\n\t\t\tspecies plant_seed aspect: default;\n\t\t\tspecies fruit aspect: default;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Generate a model that creates digital art inspired by Piet Mondrian's 'Composition II en rouge, bleu et jaune', allowing for user-adjustable parameters such as square and line counts.", "gaml_code": "/***\n* Name: MondrianGenerator\n* Author: ben\n* Description: Model generating displays inspired by the \"Composition II en rouge, bleu et jaune\" of Piet Mondrian (1930)\n* Tags: art, Mondrian, generator\n***/\n\nmodel MondrianGeneratorComposition\n\nglobal {\n\t// Parameters\n\tint nb_max_squares <- 5;\t\n\tint nb_max_lines <- 7;\n\tint nb_max_columns <- 7; \n\t\n\tint nb_lines <- rnd(2,nb_max_lines) update: rnd(2,nb_max_lines);\n\tint nb_columns <- rnd(2,nb_max_columns) update: rnd(2,nb_max_columns);\t\n\tint nb_squares <- rnd(2,nb_max_squares) update: rnd(2,nb_max_squares);\n\t\n\tlist<rgb> colors <- [#yellow,#red,#blue];\n\t\n\t\n\tinit {\n\t\tdo new_paint;\n\t}\n\t\n\treflex repaint {\n\t\tdo new_paint;\n\t}\n\t\n\t// The action that first cleans the previous painting, then generates a new one. \n\taction new_paint {\n\t\tfloat x_max <- world.shape.width;\n\t\tfloat y_max <- world.shape.height;\n\t\t\n\t\task lines {do die;}\n\t\task squares {do die;}\t\t\n\t\t\n\t\tcreate lines number: nb_lines {\n\t\t\tfloat x <- rnd(x_max);\n\t\t\tshape <- line({x,0.0},{x,x_max}) + 1;\n\t\t\thorizontal <- false;\n\t\t\t\n\t\t\tif( !empty( (lines where !each.horizontal) overlapping self)) {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\tcreate lines number: nb_columns {\n\t\t\tfloat y <- rnd(y_max);\n\t\t\tshape <- line({0.0,y},{y_max,y}) + 1;\n\t\t\thorizontal <- true;\t\t\n\t\t\t\n\t\t\tif( !empty( (lines where each.horizontal) overlapping self)) {\n\t\t\t\tdo die;\n\t\t\t}\t\t\t\t\n\t\t}\n\t\t\n\t\tcreate squares number: nb_squares {\n\t\t\tlist<lines> ll <- (2 among (lines where each.horizontal)) + (2 among (lines where !each.horizontal));\n\t\t\tgeometry temp_shape;\n\t\t\tloop l over: ll {\n\t\t\t\tif(temp_shape = nil) {\n\t\t\t\t\ttemp_shape <- world.shape - l.shape;\n\t\t\t\t} else {\n\t\t\t\t\ttemp_shape <- temp_shape - l.shape;\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tshape <- one_of(temp_shape.geometries);\n\t\t}\n\t\t\n\t\task squares {\n\t\t\tlist<squares> over_squares <- squares overlapping self;\n\t\t\t\n\t\t\tloop s over: over_squares {\n\t\t\t\tif(s covers shape) {\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\tshape <- shape - s;\n\t\t\t}\n\t\t\tif(!empty(over_squares)) {\n\t\t\t\tloop l over: lines {\n\t\t\t\t\tshape <- shape -l; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies lines {\n\tbool horizontal;\n\t\n\taspect default {\n\t\tdraw shape color: #black ;\n\t}\n}\n\nspecies squares {\n\trgb col <- one_of(colors);\n\t\n\taspect default {\n\t\tdraw shape color: col  ;\n\t}\n}\n\nexperiment MondrianGenerator type: gui {\n\tfloat minimum_cycle_duration<-0.1;\n\tparameter \"Nb max of squares: \" var: nb_max_squares;\n\tparameter \"Nb max of border: \" var: nb_max_lines;\n\tparameter \"Nb max of columns: \" var: nb_max_columns;\n\t\n\toutput {\n\t\tdisplay map type: 3d axes:false{\n\t\t\tspecies lines ;\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tspecies squares ;\t\n\t\t}\n\t}\n}"}
{"prompt": "**This is a NetLogo model for simulating a city with different transportation modes. The model includes parameters for adjusting the levels of mobility1, mobility2, and mobility3, as well as population level. It also has output displays for visualizing the simulation results.**", "gaml_code": "/***\n* Name: Mondrian City\n* Author: Arnaud Grignard, Tri Nguyen-Huu and Patrick Taillandier \n* Description: An abstract mobilty Model represented in a Mondrian World. \n* Tags: art, interaction, mobility\n***/\n\nmodel Mondrian_City\n\n\nglobal{\n\t\n\tfloat weight_mobility1;\n\tfloat weight_mobility2;\n\tfloat weight_mobility3;\n\tint population_level;\n\n\t\n\tfloat spacing <- 0.75;\n\tfloat line_width <- 0.65;\n\tbool dynamical_width <- true;\n\t\n\tfloat building_scale <- 0.65; \n\tbool show_cells <- false;\n\tbool show_building <- true;\n\tbool show_road <- true;\n\tbool show_agent <- true;\n\t\t \n\tint grid_height <- 6;\n\tint grid_width <- 6;\n\tfloat environment_height <- 5000.0;\n\tfloat environment_width <- 5000.0;\n\tint global_people_size <-50;\n\t\t\t\n\tfloat computed_line_width;\n\tfloat road_width;\n\tfloat block_size;\n\t\n\tbool on_modification_cells <- false update: show_cells != show_cells_prev;\n\tbool show_cells_prev <- show_cells update: show_cells ;\n\tbool on_modification_bds <- false update: false;\t\n\t\t\n\tmap<string,int> max_traffic_per_mode <- [\"mobility1\"::50, \"mobility2\"::50, \"walk\"::50];\n\tmap<string,int> mode_order <- [\"mobility1\"::0, \"mobility2\"::1, \"walk\"::2]; \n\tmap<string,rgb> color_per_mode <- [\"mobility1\"::rgb(52,152,219), \"mobility2\"::rgb(192,57,43), \"walk\"::rgb(161,196,90), \"mobility3\"::#magenta];\n\tmap<string,geometry> shape_per_mode <- [\"mobility1\"::circle(global_people_size*0.225), \"mobility2\"::circle(global_people_size*0.21), \"walk\"::circle(global_people_size*0.2), \"mobility3\"::circle(global_people_size*0.21)];\n\t\n\tmap<string,point> offsets <- [\"mobility1\"::{0,0}, \"mobility2\"::{0,0}, \"walk\"::{0,0}];\n\tmap<string,list<rgb>> colormap_per_mode <- [\"mobility1\"::[rgb(107,213,225),rgb(255,217,142),rgb(255,182,119),rgb(255,131,100),rgb(192,57,43)], \"mobility2\"::[rgb(107,213,225),rgb(255,217,142),rgb(255,182,119),rgb(255,131,100),rgb(192,57,43)], \"walk\"::[rgb(107,213,225),rgb(255,217,142),rgb(255,182,119),rgb(255,131,100),rgb(192,57,43)]];\n\tmap<string,rgb> color_per_id <- [\"residentialS\"::#blue,\"residentialM\"::#white,\"residentialL\"::#cyan,\"officeS\"::#yellow,\"officeM\"::#red,\"officeL\"::#green];\n\tmap<string,float> nb_people_per_size <- [\"S\"::10.0, \"M\"::50.0, \"L\"::100.0];\n\tmap<string,float> proba_choose_per_size <- [\"S\"::0.1, \"M\"::0.5, \"L\"::1.0];\n\tmap<int, list<string>> id_to_building_type <- [1::[\"residential\",\"S\"],2::[\"residential\",\"M\"],3::[\"residential\",\"L\"],4::[\"office\",\"S\"],5::[\"office\",\"M\"],6::[\"office\",\"L\"]];\n\t\t\n\tfloat weight_mobility1_prev <- weight_mobility1;\n\tfloat weight_mobility2_prev <- weight_mobility2;\n\tfloat weight_mobility3_prev <- weight_mobility3;\n\t\n\tlist<building> residentials;\n\tmap<building, float> offices;\n\n\tmap<string,graph> graph_per_mode;\n\tfloat road_capacity <- 10.0;\n\tgeometry shape<-rectangle(environment_width, environment_height);\n\tfloat step <- sqrt(shape.area) /2000.0 ;\n\t\n\tmap<string,list<float>> speed_per_mobility <- [\"mobility1\"::[20.0,40.0], \"mobility2\"::[5.0,15.0], \"walk\"::[3.0,7.0], \"mobility3\"::[15.0,30.0]];\n\t\n\tinit {\n\t\tlist<geometry> lines;\n\t\tfloat cell_w <- first(cell).shape.width;\n\t\tfloat cell_h <- first(cell).shape.height;\n\t\tloop i from: 0 to: grid_width {\n\t\t\tlines << line([{i*cell_w,0}, {i*cell_w,environment_height}]);\n\t\t}\n\t\tloop i from: 0 to: grid_height {\n\t\t\tlines << line([{0, i*cell_h}, {environment_width,i*cell_h}]);\n\t\t}\n\t\tcreate road from: split_lines(lines) {\n\t\t\tcreate road with: [shape:: line(reverse(shape.points))];\n\t\t}\n\t\tdo update_graphs;\n\t\tblock_size <- min([first(cell).shape.width,first(cell).shape.height]);\n\t}\n\t\n\taction update_graphs {\n\t\tloop mode over: [\"walk\", \"mobility1\", \"mobility2\"] {\n\t\t\tgraph_per_mode[mode] <- directed(as_edge_graph(road where (mode in each.allowed_mobility)));\n\t\t}\n\t}\n\t\n\treflex update_mobility  {\n\t\tif(weight_mobility1_prev != weight_mobility1) or (weight_mobility2_prev != weight_mobility2) or (weight_mobility3_prev != weight_mobility3) {\n\t\t\task people {\n\t\t\t\tknow_mobility3 <- flip(weight_mobility3);\n\t\t\t\thas_mobility1 <- flip(weight_mobility1);\n\t\t\t\thas_mobility2 <- flip(weight_mobility2);\n\t\t\t\t\n\t\t\t\tdo choose_mobility;\n\t\t\t\tdo mobility;\n\t\t\t}\n\t\t}\n\t\tweight_mobility1_prev <- weight_mobility1;\n\t\tweight_mobility2_prev <- weight_mobility2;\n\t\tweight_mobility3_prev <-weight_mobility3;\n\t\t\n\t}\n\t\t\n\treflex randomGridUpdate when:every(1000#cycle){\n\t\tdo randomGrid;\n\t} \n\t\t\n\treflex compute_traffic_density{\n\t\task road {traffic_density <- [\"mobility1\"::[0::0,1::0], \"mobility2\"::[0::0,1::0], \"walk\"::[0::0,1::0], \"mobility3\"::[0::0,1::0]];}\n\n\t\task people{\n\t\t\tif current_path != nil and current_path.edges != nil{\n\t\t\t\task list<road>(current_path.edges){\n\t\t\t\t\ttraffic_density[myself.mobility_mode][myself.heading_index]  <- traffic_density[myself.mobility_mode][myself.heading_index] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex precalculate_display_variables{\n\t\troad_width <- block_size * 2/3 * (1-building_scale);\n\t\tcomputed_line_width <- line_width * road_width/10;\n\t\tloop t over: mode_order.keys{\n\t\t\toffsets[t] <- {0.5*road_width*spacing*(mode_order[t]+0.5)/(length(mode_order)-0.5),0.5*road_width*spacing*(mode_order[t]+0.5)/(length(mode_order)-0.5)};\n\t\t}\t\t\n\t}\n\t\t\n\taction manage_road{\n\t\troad selected_road <- first(road overlapping (circle(sqrt(shape.area)/100.0) at_location #user_location));\n\t\tif (selected_road != nil) {\n\t\t\tbool with_mobility1 <- \"mobility1\" in selected_road.allowed_mobility;\n\t\t\tbool with_mobility2 <- \"mobility2\" in selected_road.allowed_mobility;\n\t\t\tbool with_pedestrian <- \"walk\" in selected_road.allowed_mobility;\n\t\t\tmap input_values <- user_input_dialog([enter(\"mobility1 allowed\",with_mobility1),enter(\"mobility2 allowed\",with_mobility2),enter(\"pedestrian allowed\",with_pedestrian)]);\n\t\t\tif (with_mobility1 != input_values[\"mobility1 allowed\"]) {\n\t\t\t\tif (with_mobility1) {selected_road.allowed_mobility >> \"mobility1\";}\n\t\t\t\telse {selected_road.allowed_mobility << \"mobility1\";}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (with_mobility2 != input_values[\"mobility2 allowed\"]) {\n\t\t\t\tif (with_mobility2) {selected_road.allowed_mobility >> \"mobility2\";}\n\t\t\t\telse {selected_road.allowed_mobility << \"mobility2\";}\n\t\t\t}\n\t\t\tif (with_pedestrian != input_values[\"pedestrian allowed\"]) {\n\t\t\t\tif (with_pedestrian) {selected_road.allowed_mobility >> \"walk\";}\n\t\t\t\telse {selected_road.allowed_mobility << \"walk\";}\n\t\t\t}\n\t\t\tpoint pt1 <- first(selected_road.shape.points);\n\t\t\tpoint pt2 <- last(selected_road.shape.points);\n\t\t\troad reverse_road <- road first_with ((first(each.shape.points) = pt2) and (last(each.shape.points) = pt1));\n\t\t\tif (reverse_road != nil) {\n\t\t\t\treverse_road.allowed_mobility <-  selected_road.allowed_mobility;\n\t\t\t}\n\t\t\tdo update_graphs;\n\t\t}\t\n\t}\n\t\n\taction createCell(int id, int x, int y){\n\t\tlist<string> types <- id_to_building_type[id];\n\t\tstring type <- types[0];\n\t\tstring size <- types[1];\n\t\tcell current_cell <- cell[x,y];\n\t\tbool new_building <- true;\n\t\tif (current_cell.my_building != nil) {\n\t\t\tbuilding build <- current_cell.my_building;\n\t\t\tnew_building <- (build.type != type) or (build.size != size);\n\t\t}\n\t\tif (new_building) {\n\t\t\tif (type = \"residential\") {\n\t\t\t\task current_cell {do new_residential(size);}\n\t\t\t} else if (type = \"office\") {\n\t\t\t\task current_cell {do new_office(size);}\n\t\t\t}\n\t\t}\n\t} \n\t\n   action randomGrid{\n   \tint id;\n   \tloop i from: 0 to: 5 {\n\t\tloop j from: 0 to: 5 {\n\t\t    if (flip(0.5)){\n\t\t        id <- 1+rnd(5);\t\n\t\t    }else{\n\t\t    \tid<--1;\n\t\t    }\t\t\t\n\t\t\tif (id > 0) {\n             do createCell(id, j, i);\n\t\t\t}\n\t\t\tcell current_cell <- cell[j,i];\n\t\t\tcurrent_cell.is_active <- id<0?false:true;\n\t\t\tif (id<=0){\t\t\t\t\t\n\t\t\t\task current_cell{ do erase_building;}\n\t\t\t}\n\t\t}\n\t}\n   }\t\t\n}\n\n\nspecies building {\n\tstring size <- \"S\" among: [\"S\", \"M\", \"L\"];\n\tstring type <- \"residential\" among: [\"residential\", \"office\"];\n\tlist<people> inhabitants;\n\trgb color;\n\tgeometry bounds;\n\n\taction initialize(cell the_cell, string the_type, string the_size) {\n\t\tthe_cell.my_building <- self;\n\t\ttype <- the_type;\n\t\tsize <- the_size;\n\t\tdo define_color;\n\t\tshape <- the_cell.shape;\n\t\tif (type = \"residential\") {residentials << self;}\n\t\telse if (type = \"office\") {\n\t\t\toffices[self] <- proba_choose_per_size[size];\n\t\t}\n\t\tbounds <- the_cell.shape + 0.5 - shape;\n\t\t\t\n\t}\n\t\n\treflex populate when: (type = \"residential\"){\n\t\tint pop <- int(population_level/100 * nb_people_per_size[size]);\n\t\tif length(inhabitants) < pop{\n\t\t\tcreate people number: 1 with: [location::any_location_in(bounds)] {\n\t\t\t\torigin <- myself;\n\t\t\t\torigin.inhabitants << self;\n\t\t\t\t\n\t\t\t\tdo reinit_destination;\n\t\t\t}\n\t\t}\n\t\tif length(inhabitants) > pop{\n\t\t\tpeople tmp <- one_of(inhabitants);\n\t\t\tinhabitants >- tmp;\n\t\t\task tmp {do die;}\n\t\t}\n\t}\n\t\n\taction remove {\n\t\tif (type = \"office\") {\n\t\t\toffices[] >- self;\n\t\t\task people {\n\t\t\t\tdo reinit_destination;\n\t\t\t}\n\t\t} else {\n\t\t\task inhabitants {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t}\n\t\tcell(location).my_building <- nil;\n\t\tdo die;\n\t\t\n\t}\n\taction define_color {\n\t\tcolor <- color_per_id[type+size];\n\t}\n\taspect default {\n\t\tif show_building {draw shape scaled_by building_scale*1.1 wireframe:true color: color;}\n\t}\n}\n\nspecies road {\n\tint nb_people;\n\tmap<string,map<int,int>> traffic_density <- [\"mobility1\"::[0::0,1::0], \"mobility2\"::[0::0,1::0], \"walk\"::[0::0,1::0], \"mobility3\"::[0::0,1::0]];\n\trgb color <- rnd_color(255);\n\tlist<string> allowed_mobility <- [\"walk\",\"mobility2\",\"mobility1\"];\n\n\tinit {\n\t}\n\t\n\tint total_traffic{\n\t\treturn sum(traffic_density.keys collect(sum(traffic_density[each])));\n\t}\n\t\n\t\n\tint total_traffic_per_mode(string m){\n\t\treturn sum(traffic_density[m]);\n\t}\n\t\n\t\n\trgb color_map(rgb c, float scale){\n\t\treturn rgb(255+scale * (c.red - 255),255+scale * (c.green - 255),255+scale * (c.blue - 255));\n\t}\n\n\taspect default {\n\t\tif(show_road){\n\t\t\tloop t over: mode_order.keys{\n\t\t\t\t\tfloat scale <- min([1,traffic_density[t][0] / max_traffic_per_mode[t]]);\t\n\t\t\t\t\tif dynamical_width{\n\t\t\t\t\t\tif scale > 0 {draw shape + computed_line_width * scale color: color_per_mode[t] at: self.location+offsets[t];}\n\t\t\t\t\t\tscale <- min([1,traffic_density[t][1] / max_traffic_per_mode[t]]);\t\n\t\t\t\t\t\tif scale > 0 {draw shape + computed_line_width * scale color: color_per_mode[t] at: self.location-offsets[t];}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif scale > 0 {draw shape + computed_line_width color: color_map(color_per_mode[t],scale) at: self.location+offsets[t];}\n\t\t\t\t\t\tscale <- min([1,traffic_density[t][1] / max_traffic_per_mode[t]]);\t\n\t\t\t\t\t\tif scale > 0 {draw shape + computed_line_width color: color_map(color_per_mode[t],scale) at: self.location-offsets[t];}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\t\n\n\t}\n}\n\nspecies people skills: [moving]{\n\n\tint heading_index <- 0;\n\tstring mobility_mode <- \"walk\"; \n\tfloat display_size <-sqrt(world.shape.area)* 0.01;\n\tbuilding origin;\n\tbuilding dest;\n\tbool to_destination <- true;\n\tpoint target;\n\tbool know_mobility3 <- false;\n\tbool has_mobility1 <- flip(weight_mobility1);\n\tbool has_mobility2 <- flip(weight_mobility2);\n\tfloat max_dist_walk <- 1000.0;\n\tfloat max_dist_mobility2 <- 3000.0;\n\tfloat max_dist_mobility3 <- 5000.0;\n\taction choose_mobility {\n\t\tif (origin != nil and dest != nil) {\n\t\t\tfloat dist <- manhattan_distance(origin.location, dest.location);\n\t\t\tif (dist <= max_dist_walk ) {\n\t\t\t\t\tmobility_mode <- \"walk\";\n\t\t\t} else if (has_mobility2 and dist <= max_dist_mobility2 ) {\n\t\t\t\t\tmobility_mode <- \"mobility2\";\n\t\t\t} else if (know_mobility3 and (dist <= max_dist_mobility3 )) {\n\t\t\t\t\tmobility_mode <- \"mobility3\";\n\t\t\t} else if has_mobility1 {\n\t\t\t\t\tmobility_mode <- \"mobility1\";\n\t\t\t} else {\n\t\t\t\t\tmobility_mode <- \"walk\";\n\t\t\t}\n\t\tspeed <- rnd(speed_per_mobility[mobility_mode][0],speed_per_mobility[mobility_mode][1]) #km/#h;\n\t\t}\n\t}\n\t\n\tfloat manhattan_distance (point p1, point p2) {\n\t\treturn abs(p1.x - p2.x) + abs(p1.y - p2.y);\n\t}\n\treflex update_heading_index{\n\t\tif (mod(heading+90,360) < 135) or (mod(heading+90,360) > 315){\n\t\t\t\t\t\theading_index <- 0;\n\t\t\t\t\t} else{\n\t\t\t\t\t\theading_index <- 1;\n\t\t\t\t\t}\n\t}\n\taction reinit_destination {\n\t\tdest <- empty(offices) ? nil : offices.keys[rnd_choice(offices.values)];\n\t\ttarget <- nil;\n\t}\n\t\n\taction mobility {\n\t\tdo unregister;\n\t\tdo goto target: target on: graph_per_mode[(mobility_mode = \"mobility3\") ? \"mobility2\" : mobility_mode] recompute_path: false ;\n\t\tdo register;\n\t}\n\taction update_target {\n\t\tif (to_destination) {target <- any_location_in(dest);}//centroid(dest);}\n\t\telse {target <- any_location_in(origin);}//centroid(origin);}\n\t\tdo choose_mobility;\n\t\tdo mobility;\n\t}\n\t\n\taction register {\n\t\tif ((mobility_mode = \"mobility1\") and current_edge != nil) {\n\t\t\troad(current_edge).nb_people <- road(current_edge).nb_people + 1;\n\t\t}\n\t}\n\taction unregister {\n\t\tif ((mobility_mode = \"mobility1\") and current_edge != nil) {\n\t\t\troad(current_edge).nb_people <- road(current_edge).nb_people - 1;\n\t\t}\n\t}\n\n\treflex move when: dest != nil{\n\t\tif (target = nil) {\n\t\t\tdo update_target;\n\t\t}\n\t\tdo mobility;\n\t\tif (target = location) {\n\t\t\ttarget <- nil;\n\t\t\tto_destination <- not to_destination;\n\t\t\tdo update_target;\n\t\t}\n\t}\n\t\n\treflex wander when: dest = nil and origin != nil {\n\t\tdo wander bounds: origin.bounds;\n\t}\n\n\t\n\taspect default{\n\t\tif(show_agent){\n\t\tpoint offset <- {0,0};\n\t\tif self.current_edge != nil {\n\t\t  offset <- offsets[mobility_mode]*(heading_index > 0 ? (-1): 1);\t\n\t\t}\n\t\tif (target != nil or dest = nil) {\n\t\t\tif(mobility_mode =\"mobility1\"){\n\t\t\t  draw copy(shape_per_mode[mobility_mode])  color: color_per_mode[mobility_mode] border:color_per_mode[mobility_mode] rotate:heading +90 at: location+offset;\n\t\t\t}else{\n\t\t\t  draw copy(shape_per_mode[mobility_mode])  color: color_per_mode[mobility_mode] rotate:heading +90 at: location+offset;\t\n\t\t\t}\n\t\t}\t\n\t  }\n\t}\n}\n\ngrid cell width: grid_width height: grid_height { \n\tbuilding my_building;\n\tbool is_active <- true;\n\taction new_residential(string the_size) {\n\t\tif (my_building != nil and (my_building.type = \"residential\") and (my_building.size = the_size)) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (my_building != nil ) {ask my_building {do remove;}}\n\t\t\tcreate building returns: bds{\n\t\t\t\tdo initialize(myself, \"residential\", the_size);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\taction new_office (string the_size) {\n\t\tif (my_building != nil and (my_building.type = \"office\") and (my_building.size = the_size)) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (my_building != nil) {ask my_building {do remove;}}\n\t\t\tcreate building returns: bds{\n\t\t\t\tdo initialize(myself, \"office\",the_size);\n\t\t\t}\n\t\t\task people {\n\t\t\t\tdo reinit_destination;\n\t\t\t}\n\t\t}\n\t}\n\taction erase_building {\n\t\tif (my_building != nil) {ask my_building {do remove;}}\n\t}\n\t\n\taspect default{\n\t\tif show_cells {draw shape scaled_by (0.5) color: rgb(100,100,100) ;}\n\t}\n}\n\nexperiment MondrianCity type: gui autorun: true{\n\tfloat minimum_cycle_duration <- 0.05;\n\tparameter \"mobility1 level\" var: weight_mobility1 min: 0.1 max: 1.0 step: 0.1 colors: [#gamablue] <-0.5;\n\tparameter \"mobility2 level\" var: weight_mobility2 min: 0.1 max: 1.0 step: 0.1 colors: [#gamablue] <-0.5;\n\tparameter \"mobility3 level\" var: weight_mobility3 min: 0.1 max: 1.0 step: 0.1 colors: [#gamablue] <-0.5;\n\tparameter \"Population level\" var: population_level min: 0 max: 100 step: 1 colors: [#gamablue] <-50;\n\n\toutput synchronized:true{\n\t\tdisplay map background:#black toolbar:false type:3d  axes:false fullscreen:false{\n\t\t\tspecies cell aspect:default;\n\t\t\tspecies road ;\n\t\t\tspecies people;\n\t\t\tspecies building;\n\t\t\tevent \"a\" {show_agent<-!show_agent;}\n\t\t\tevent \"r\" {show_road<-!show_road;}\n\t\t\tevent \"b\"  {show_building<-!show_building;}\t\t  \t\n\t\t}\t\t\n\t}\n}"}
{"prompt": "Create a 3D animation of the GAMA logo using a shapefile, with customizable color mode and inner rings, and display it in a GUI window.", "gaml_code": "/**\n* Name: Gama 1.9\n* Author:  Arnaud Grignard - Tri Nguyen-Huu\n* Description: A toy model animating the GAMA logo\n* Tags:  \n*/\n\nmodel GAMA  \n\nglobal {\n\n\tfile Gama_shape_file <- shape_file(\"../includes/GamaVectorized.shp\");\n\tstring mode <- \"Light to dark\" among: [\"Light to dark\", \"Dark to light\", \"Light\", \"Dark\"];\n\tbool inner_rings <- false;\n\tpoint origin <- {490,490,0};\n\tfloat color_speed <- 2.0;\n\n\t//definition of the geometry of the world agent (environment) as the envelope of the shapefile\n\tgeometry shape <- envelope(Gama_shape_file);\n\t\n\t// auxiliary sigmoid function for smooth transitions\n\tfloat sigmoid(int t, int mid_course, float speed){\n\t\treturn 1/(1+exp(-speed*(t-mid_course)));\n\t}\n\t\n\t// time-depedent color change\n\trgb changeColor(int t){\n\t\tint mid_course <- 400;\n\t\tfloat lambda <- 0.04;\n\t\tfloat sig;\n\t\tswitch mode{\n\t\t\tmatch \"Light to dark\"{\n\t\t\t\tsig <- 1 - sigmoid(cycle,mid_course,lambda);\n\t\t\t}\t\t\t\n\t\t\tmatch \"Dark to light\"{\n\t\t\t\tsig <- sigmoid(cycle,mid_course,lambda);\n\t\t\t}\n\t\t\tmatch \"Light\"{\n\t\t\t\tsig <- 1.0;\n\t\t\t}\n\t\t\tmatch \"Dark\"{\n\t\t\t\tsig <- 0.0;\n\t\t\t}\n\t\t}\n\t\treturn rgb(255*sig,255*sig,255*sig);\n\t}\n\n\tinit { \n\n\t\tGama_shape_file <- shape_file(\"../includes/GamaVectorized.shp\");\n\t\t\n\t\tcreate object from:Gama_shape_file with:[type::string(get(\"type\")), name::string(get(\"name\")),level::int(get(\"level\"))]{\n\t\t    origin <- myself.origin;\n\t\t    color<-#white;\n\t\t    if (name = \"gamablue\"){\n\t\t    \tcolor<-#gamablue;\n\t\t    \tdepth <- 0.0001;\n\t\t    }\n\t\t    if (name = \"gamared\"){\n\t\t    \tcolor<-#gamared;\n\t\t    \tdepth <- 0.0001;\n\t\t    }\n\t\t    if (name = \"gamaorange\"){\n\t\t    \tcolor<-#gamaorange;\n\t\t    \tdepth <- 0.0001;\n\t\t    }\n\t\t    if (name = \"donut1\"){\n\t\t    \tcolor<-rgb(#gamablue,25);\n\t\t    }\n\t\t    if (name = \"donut3\"){\n\t\t    \tcolor<-rgb(#gamared,25);\n\t\t    }\n\t\t    if (name = \"donut5\"){\n\t\t    \tcolor<-rgb(#gamaorange,25);\n\t\t    }\n\t\t    if (name = \"circle\"){\n\t\t    \tcolor<-rgb(#gamared,70);\n\t\t    \tcolor<-#gamared;\n\t\t    \trotation_speed <- -2 * rotation_speed;\n\t\t    \taxe <- {1,-1,0};\n\t\t    }\n\t\t     if (name = \"1.9\"){\n\t\t\t \trotation_speed <- 0.0; \n\t\t    \tdepth <- 1.0;\n\t\t    }\n\t\t    location<-location  - {0,0,depth/2};\n\t\t}\n\n\t\task object{\n\t\t\t if (name = \"1.9\"){\n\t\t    \torigin <- first(object where (each.name=\"circle\")).location;\n\t\t    }\n\t\t\tswitch level {\n\t\t\t\tmatch 5 {\n\t\t\t\t\taxe <- {1,0,0};\n\t\t\t\t}\n\t\t\t\tmatch 4 {\n\t\t\t\t\taxe <- {0,1,0};\n\t\t\t\t}\n\t\t\t\tmatch 3 {\n\t\t\t\t\taxe <- {1,0,0};\n\t\t\t\t}\n\t\t\t\tmatch 2 {\n\t\t\t\t\taxe <- {0,1,0};\n\t\t\t\t\trotation_speed <- 3 * rotation_speed;\n\t\t\t\t}\n\t\t\t\tmatch 1 {\n\t\t\t\t\taxe <- {1,0,0};\n\t\t\t\t\trotation_speed <- -2* rotation_speed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshift <- location - origin;\n\t\t\tif level =0 {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tloop i over: remove_duplicates(object collect each.level){\n\t\t\task first(object where (each.level = i)){\n\t\t\t\tlinked_objects <- object where (each.level = i-1);\n\t\t\t}\n\t\t}\n\t}  \n\t\n\treflex end_animation when: cycle  = 650{\n\t\tdo pause;\n\t}\n} \n\n// definition of the parts of the animated 3d model\nspecies object skills:[moving]{\n\trgb color;\n\tstring type;\n\tstring name;\n\tpoint axe <- {0,1,0};\n\tfloat rotation_speed <- 1.0;\n\tint level;\n\tlist<object> linked_objects <- [];\n\tfloat depth <- 0.0;\n\tpoint origin;\n\tpoint shift;\t\t\n\n// apply rotation to linked inner objects\n\taction propagate_rotation(float angle,point ax, point centre){\n\t\torigin <- centre + (( origin - centre) rotated_by (angle::ax));\n\t\tshape <- shape rotated_by (angle,ax);\n\t    shift <-  shift rotated_by (angle::ax);\n\t    axe <-  axe rotated_by (angle::ax);\n\t   \task linked_objects{\n\t    \tdo propagate_rotation(angle, ax, centre);\n\t    }\n\t}\n\n// rotate the object and linked inner objects\n\treflex rotate{\n\t\tif cycle > 293 {\n\t\t\trotation_speed <- rotation_speed / 1.015;\n\t\t}\n\t\tif cycle = 600{\n\t\t\trotation_speed <- 0.0;\n\t\t}\n\t\tshape <- shape rotated_by (rotation_speed,axe);\n\t    shift <-  shift rotated_by (rotation_speed::axe);\n\t    ask linked_objects{\n\t    \tdo propagate_rotation(myself.rotation_speed, myself.axe, myself.origin);\n\t    }\n\t}\n\t\n\taspect obj {\n\t\tif name = \"donut2\" or name = \"donut4\"{\n\t\t\tif inner_rings{\n\t\t\t\tif mode = \"Dark\"{\n\t\t\t\t\tcolor <- rgb(20,20,20);\n\t\t\t\t}else{\n\t\t\t\t\tcolor <- world.changeColor(cycle);\t\t\t\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcolor <- rgb(#white,0);\n\t\t\t}\n\t\t}\n\t\t// change color for specific objects\n\t\tswitch name{\n\t\t\tmatch \"1.9\" {\n\t\t \t\tif cycle > 500{\n\t\t    \t\tcolor <- blend(#white,#gamared,(cycle-500)/150);\n\t\t    \t} else {\n\t\t    \t\tcolor <- rgb(#white,0);\n\t\t    \t}\n\t\t    } \n\t\t   match \"circle\"{\n\t\t    \tcolor <- rgb(#gamared,255*world.sigmoid(cycle, 380, 0.04));\n\t\t    }\n\t\t}\n\t\tdraw shape depth: depth color:color at: origin +shift;\t    \t\n\t}\n\t\t\t\n}\t\n\nexperiment \"Run me !\"   type: gui autorun:true{\n\tfloat minimum_cycle_duration<-0.025#sec;\n\tparameter 'Mode' var: mode   category: \"Preferences\";\n\tparameter 'Inner rings' var: inner_rings   category: \"Preferences\";\n\toutput {\n\t\tdisplay \"1.9\"  background: world.changeColor(cycle) type: 3d axes:false autosave:false fullscreen:false toolbar:false{\n\t\t  species object aspect:obj;\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a cityscape using GAMA, where agents (runners) morph into different shapes and colors as they move through the environment, and display images on their bodies to convey messages.", "gaml_code": "/***\n* Name: GAMA 1.8 is out ! \n* Author: A. Drogoul\n* Description: A toy model demonstrating \"morphing\" technologies in GAMA\n* Tags: image, geometries\n***/\nmodel GAMA\n\nglobal control: fsm {\n\trgb blue <- rgb(54, 112, 160);\n\trgb orange <- rgb(210, 103, 59);\n\trgb yellow <- rgb(238, 182, 79);\n\tlist<runner> runners <- list(runner);\n\tshape_file town_file <- shape_file(\"../includes/buildings2.shp\");\n\tshape_file road_file <- shape_file(\"../includes/roads.shp\");\n\tgeometry shape <- envelope(town_file);\n\tfloat size <- shape.width / 100;\n\tgraph the_graph <- as_edge_graph(road_file.contents);\n\tint distance_between (rgb c1, rgb c2) {\n\t\treturn abs(c1.red - c2.red) + abs(c1.green - c2.green) + abs(c1.blue - c2.blue);\n\t}\n\n\trgb closest_color (rgb c1) {\n\t\tint db <- distance_between(c1, blue);\n\t\tint do <- distance_between(c1, orange);\n\t\tint dy <- distance_between(c1, yellow);\n\t\tint m <- min(db, do, dy);\n\t\tif (m > 100) {\n\t\t\treturn #black;\n\t\t} else if (m = db) {\n\t\t\treturn blue;\n\t\t} else if (m = do) {\n\t\t\treturn orange;\n\t\t} else if (m = dy) {\n\t\t\treturn yellow;\n\t\t} }\n\n\taction load_image (string the_path) {\n\t\tmatrix<int> colors <- (image_file(the_path).contents);\n\t\task background {\n\t\t\tcolor <- myself.closest_color(rgb(colors[grid_x, grid_y]));\n\t\t}\n\n\t\tmap<rgb, list<background>> by_color <- background group_by (each.color);\n\t\task runner {\n\t\t\ttarget <- one_of(by_color at color);\n\t\t}\n\n\t\trunners <- list(runner);\n\t}\n\n\taction one_step {\n\t\task runners {\n\t\t\tdo goto target: target speed: 2 * size / #s;\n\t\t}\n\n\t\trunners <- runners select (each.location != each.target.location);\n\t}\n\n\tinit {\n\t\task (list(background) every 16) {\n\t\t\tcreate runner with: (location: location);\n\t\t} }\n\n\tstate phase0 initial: true {\n\t\tenter {\n\t\t\task runner {\n\t\t\t\tmy_shape <- cube(rnd(size, size * 2));\n\t\t\t\tdepth <- rnd(size * 2);\n\t\t\t}\n\n\t\t}\n\n\t\task runner {\n\t\t\tmy_shape <- cube(rnd(size, size * 2));\n\t\t\tdepth <- rnd(size * 2);\n\t\t}\n\n\t\ttransition to: phase1 when: cycle = 10;\n\t}\n\n\tstate phase1 {\n\t\tenter {\n\t\t\task runner {\n\t\t\t\tmy_shape <- cube(rnd(size, size * 2));\n\t\t\t\tdepth <- rnd(size * 2);\n\t\t\t}\n\n\t\t\tdo load_image(\"../includes/logo.png\");\n\t\t}\n\n\t\tdo one_step();\n\t\ttransition to: phase2 when: empty(runners);\n\t}\n\n\tstate phase2 {\n\t\tenter {\n\t\t\tdo load_image(\"../includes/version.png\");\n\t\t}\n\n\t\tdo one_step();\n\t\task runner {\n\t\t\tmy_shape <- cube(rnd(size, size * 2));\n\t\t\tdepth <- rnd(size * 2);\n\t\t}\n\n\t\ttransition to: phase3 when: empty(runners);\n\t}\n\n\tstate phase3 {\n\t\tenter {\n\t\t\tdo load_image(\"../includes/is_out.png\");\n\t\t}\n\n\t\tdo one_step();\n\t\task runner {\n\t\t\tmy_shape <- box(rnd(size, size * 2), rnd(size, size * 2), rnd(size * 8));\n\t\t\tdepth <- rnd(size * 4);\n\t\t}\n\n\t\ttransition to: phase4 when: empty(runners);\n\t}\n\n\tstate phase4 {\n\t\tenter {\n\t\t\task (runner) {\n\t\t\t\tif (flip(0.2)) {\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\task (runner select (each.color = yellow)) {\n\t\t\t\tcreate people with: (location: location);\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\task (runner select (each.color = orange)) {\n\t\t\t\tcreate roads with: (location: location);\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\task runner {\n\t\t\t\ttarget <- one_of(town_file.contents);\n\t\t\t}\n\n\t\t\trunners <- list(runner);\n\t\t}\n\n\t\task runners {\n\t\t\tdo goto target: target speed: 2 * size / #s;\n\t\t\tif (location = target.location) {\n\t\t\t\tmy_shape <- target;\n\t\t\t}\n\n\t\t}\n\n\t\trunners <- runners select (each.location != each.target.location);\n\t} }\n\ngrid background width: 297 height: 297;\n\nspecies roads skills: [moving] {\n\tgeometry target <- one_of(road_file.contents);\n\tgeometry my_shape <- cube(rnd(size, size * 2));\n\n\treflex go when: target != nil {\n\t\tdo goto target: target speed: 2 * size / #s;\n\t\tif (location = target.location) {\n\t\t\tmy_shape <- target + size / 8;\n\t\t}\n\n\t}\n\n\taspect default {\n\t\tdraw my_shape at: location color: orange;\n\t}\n\n}\n\nspecies people skills: [moving] {\n\n\tinit {\n\t\ttarget <- one_of(road_file.contents);\n\t}\n\n\tgeometry target;\n\trgb color;\n\n\treflex move when: target != nil {\n\t\tdo goto on: the_graph target: target speed: 2 * size / #s;\n\t\tif (location = target.location) {\n\t\t\ttarget <- one_of(road_file.contents);\n\t\t}\n\n\t}\n\n\taspect default {\n\t\tdraw circle(size / 4) color: yellow at: location + {0, 0, size};\n\t}\n\n}\n\nspecies runner skills: [moving] {\n\trgb color <- one_of(blue, orange, yellow);\n\tgeometry target;\n\tgeometry my_shape;\n\tfloat depth;\n}\n\nexperiment \"Run me !\" type: gui autorun: true {\n\toutput {\n\t\tdisplay \"1.8\" type: 3d fullscreen: true toolbar: #black background: #black axes: false {\n\t\t\tcamera #default location: {1298.0375, 3277.2938, 2177.5545} target: {1261.3366, 1174.7007, 0.0};\n\t\t\tspecies roads;\n\t\t\tspecies runner {\n\t\t\t\tdraw my_shape at: location depth: depth color: color;\n\t\t\t}\n\n\t\t\tspecies people;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Design a NetLogo model simulating a sugar-feeding animal population on a grid, where animals move to collect sugar and die if they reach their maximum age or run out of sugar. The model should include parameters for growth rate, metabolism, vision range, and initial sugar levels.", "gaml_code": "/**\n* Name: sugarscape\n* Author: \n* Description: A model with animal moving on a grid to find sugar. The animal agents \n* \thave a life duration and die if it is reached or if they don't have anymore sugar.\n* Tags: grid\n*/\nmodel sugarscape\n\n  \nglobal {\n\t// Parameters \n\t\n\t//Growth rate of the sugar\n\tint sugarGrowthRate <- 1;\n\t//Minimum age of death\n\tint minDeathAge <- 60;\n\t//Maximum age of death\n\tint maxDeathAge <- 100;\n\t//Metabolism maximum\n\tint maxMetabolism <- 3;\n\t\n\t//Maximum and Minimum initial sugar\n\tint maxInitialSugar <- 25 ;\n\tint minInitialSugar <- 5;\n\t//Maximum range\n\tint maxRange <- 6;\n\tbool replace <- true;\n\t//Number of agents\n\tint numberOfAgents <- 400;\t\n\t\n\t// Environment\n\tgeometry shape <- rectangle(50, 50);\n\t\t\n\tfile<int> types  <- file<int>('../images/sugarscape.pgm');\n\trgb FFFFAA const: true <- rgb('#FFFFAA');\n\trgb FFFF55 const: true <- rgb('#FFFF55');\n\trgb dark_yellow const: true <- rgb('#EEB422');\n\trgb less_red const: true <- rgb('#FF5F5F');\n\t\n\tinit {\n\t\t\n\t\t//Create the animal\n\t\tcreate animal number: numberOfAgents;\n\t\t\n\t\t//Ask to each sugar cell to set its sugar\n\t\task sugar_cell {\n\t\t\tmaxSugar <- (types at {grid_x,grid_y});\n\t\t\tsugar <- maxSugar;\n\t\t\tcolor <- [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;\n\t\t}\n\t}\n}\n\n\t//Grid species representing the sugar cells\n\tgrid sugar_cell width: 50 height: 50 neighbors: 4 use_individual_shapes: false use_regular_agents: false{ \n\t\t//Maximum sugar\n\t\tint maxSugar;\n\t\t//Sugar contained in thecell\n\t\tint sugar update: sugar + sugarGrowthRate max: maxSugar;\n\t\trgb color update: [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;\n\t\tmap<int,list<sugar_cell>> neighbours;\n\t\t\n\t\t//Initialization of the neighbours\n\t\tinit {\n\t\t\tloop i from: 1 to: maxRange {\n\t\t\t\tneighbours[i] <- self neighbors_at i; \n\t\t\t}\n\t\t}\n\t}\t\n\t\n//Species animal representing the animal agents\nspecies animal {\n\t//Color of the animal\n\trgb color  <- #red;\n\t//Speed of the animal\n\tfloat speed  <- 1.0;\n\t//Metabolism of the animal\n\tint metabolism  min: 1 <- rnd(maxMetabolism);\n\t//Perception range of the animal\n\tint vision  min: 1 <- rnd(maxRange);\n\t//Maximal age of the animal\n\tint maxAge  min: minDeathAge max: maxDeathAge <- rnd (maxDeathAge - minDeathAge) + minDeathAge;\n\t//Size of the animal\n\tfloat size  <- 0.5;\n\t//Sugar of the animal\n\tint sugar min: 0 <- (rnd (maxInitialSugar - minInitialSugar)) + minInitialSugar update: sugar - metabolism;\n\t//Age of the animal\n\tint age max: maxAge <- 0 update: int(age + step);\n\t//Place of the animal\n\tsugar_cell place ; \n\t\n\t//Launched at the initialization of the animal agent\n\tinit {\n\t\t//Set the place as one of the sugar cell\n\t\tplace <- one_of(sugar_cell);\n\t\tlocation <- place.location;\n\t}\n\t//Move the agent to another place and collect the sugar of the previous place\n\treflex basic_move { \n\t\tsugar <- sugar + place.sugar;\n\t\tplace.sugar <- 0;\n\t\tlist<sugar_cell> neighbours <- place.neighbours[vision];\n\t\tlist<sugar_cell> poss_targets <- (neighbours) where (each.sugar > 0);\n\t\t//If no sugar is found in the neighbours cells, move randomly\n\t\tplace <- empty(poss_targets) ? one_of (neighbours) : one_of (poss_targets);\n\t\tlocation <- place.location;\n\t}\n\t//Reflex to kill the animal once it reaches its maximal age or it doesn't have sugar anymore\n\treflex end_of_life when: (sugar = 0) or (age = maxAge) {\n\t\tif replace {\n\t\t\tcreate animal ;\n\t\t}\n\t\tdo die;\n\t}\n\taspect default {\n\t\tdraw circle(0.5) color: #red;\n\t}\n}\n\nexperiment sugarscape type: gui{\n\tfloat minimum_cycle_duration<-0.1;\n\tparameter 'Growth rate of sugar:' var: sugarGrowthRate category: 'Environment';\n\tparameter 'Minimum age of death:' var: minDeathAge <- 60 category: 'Agents';\n\tparameter 'Maximum age of death:' var: maxDeathAge <- 100 category: 'Agents';\n\tparameter 'Maximum metabolism:' var: maxMetabolism <- 3 category: 'Agents';\n\tparameter 'Maximum initial sugar per cell:'  var: maxInitialSugar <- 25 category: 'Environment';\n\tparameter 'Minimum initial sugar per cell:' var: minInitialSugar <- 5 category: 'Environment';\n\tparameter 'Maximum range of vision:' var: maxRange <- 6 category: 'Agents';\n\tparameter 'Replace dead agents ?' var: replace <- true category: 'Agents';\n\tparameter 'Number of agents:' var: numberOfAgents <- 400 category: 'Agents';\n\t\n\toutput {\n\t\tdisplay grille  type:2d antialias:false{\n\t\t\tgrid sugar_cell;\n\t\t\tspecies animal;\n\t\t}\n\t\tdisplay chart refresh: every(5#cycles)  type: 2d {\n\t\t\tchart 'Energy' type: pie background: #white style: exploded label_background_color:#white{\n\t\t\t\tdata \"strong\" value: (animal as list) count (each.sugar > 8) color: #green;\n\t\t\t\tdata \"weak\" value: (animal as list) count (each.sugar < 9) color: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay chart2 refresh: every(5#cycles) type: 2d  {\n\t\t\tchart 'Energy' type: histogram background: #white label_background_color:#white{\n\t\t\t\tdata \"strong\" value: (animal as list) count (each.sugar > 8)  color: #green;\n\t\t\t\tdata \"weak\" value: (animal as list) count (each.sugar < 9)  color: #red;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a pedestrian model based on the Moussaid et al. (2011) paper, simulating crowd behavior and visualizing local speed and compression values in a 3D corridor environment.", "gaml_code": "/**\n* Name: MoussaidModel\n* Description: Pedestrian model proposed by: \"Moussa\u00efd, M., Helbing, D., & Theraulaz, G. (2011). \n* How simple rules determine pedestrian behavior and crowd disasters. Proceedings of the National Academy of Sciences, 108(17), 6884-6888.\"\n* Based on the internal skeleton template. \n* Author: Patrick Taillandier\n* Tags: Pedestrian\n*/\n\nmodel MoussaidModel\n\nglobal {\n\tgeometry shape <- rectangle(10.0, 5);\n\tfloat step <- 0.1;\n\tpedestrian focus;\n\tbool display_field_vision <- false;\n\tgeometry east ;\n\tgeometry west; \n\t\n\tfloat P_v0_mean <- 1.3 #m/#s;\n\tfloat P_v0_std <- 0.2 #m/#s ;\n\tfloat P_teta0 <- 90.0; //degrees\n\tfloat P_disc_factor <- 10.0;\n\tfloat P_tau <- 0.5 #s;\n\tfloat P_dmax <- 8.0 #m ;\n\tfloat P_k <- 1.0 * 10^3;\n\tint num_data <- 10 ;\n\t\n\tint new_arrving_per_s <- 2;\n\t\n\tinit {\n\t\tdo create_corridor;\n\t\t\t\n\t\task local_indicator overlapping (union(east + west) + 1.0) {\n\t\t\tis_entry <- true;\n\t\t\tcol_speed<- #lightgray;\n\t\t\tcol_compression<- #lightgray;\n\t\n\t\t} \n\t\task wall {\n\t\t\task local_indicator overlapping self {\n\t\t\t\tis_wall <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\taction create_corridor {\n\t\tcreate wall with: (shape: rectangle(5.0, 1.0) at_location {2.5, -0.5});\n\t\tcreate wall with: (shape: rectangle(5.0, 1.0) at_location {2.5, 4.5});\n\t\t\n\t\tcreate wall with: (shape: rectangle(5.0, 3.0) at_location {7.5, -0.5});\n\t\tcreate wall with: (shape: rectangle(5.0, 3.0) at_location {7.5, 4.5});\n\t\t\n\t\teast <- rectangle(shape.width / 100.0, shape.height)at_location {shape.width/200.0, location.y} - union(wall collect (each.shape + 0.5));\n\t\twest <- rectangle(shape.width /100.0, shape.height) at_location {shape.width * 199.0 /200.0, location.y} - union(wall collect (each.shape + 0.5)) ;\n\t\n\t}\n\t\n\treflex add_people when: every(1#s) and (cycle < 200){\n\t\tgeometry east_tmp <- copy(east);\n\t\tgeometry west_tmp <- copy(west);\n\t\tcreate pedestrian number: new_arrving_per_s {\n\t\t\tlocation <- any_location_in(east_tmp);\n\t\t\teast_tmp <- east_tmp - shape;\n\t\t\to <- any_location_in(west);\n\t\t\tcolor <- #blue;\n\t\t}\n\t\tcreate pedestrian number: new_arrving_per_s {\n\t\t\tlocation <- any_location_in(west_tmp);\n\t\t\twest_tmp <- west_tmp - shape;\n\t\t\to <- any_location_in(east);\n\t\t\t\n\t\t\tcolor <- #red;\n\t\t}\n\t}\n\treflex end_sim when: (cycle > 300) and empty(pedestrian) {\n\t\tdo pause;\n\t}\n}\n\n\n\nspecies pedestrian {\n\tfloat m <- rnd(60.0,100.0);\n\tfloat shoulder_length <- m/320.0;\n\tfloat speed <- 0.0;\n\tgeometry shape <- circle(shoulder_length);\n\trgb color <- rnd_color(255);\n\tpoint o;\n\tfloat v0 <- gauss(P_v0_mean, P_v0_std);\n\tfloat teta0 <- P_teta0; //degrees\n\tfloat tau <- P_tau;\n\tfloat dmax <- P_dmax;\n\tfloat disc_factor <- P_disc_factor;\n\tfloat k <- P_k;\n\tfloat alpha0;\n\tfloat v;\n\tfloat dh;\n\tlist<geometry> visu_ray;\n\tlist<float> val_angles; \n\tfloat heading;\n\tpoint acc<- {0,0};\n\tpoint vi <- {0,0};\n\tfloat c;\n\t\n\tuser_command focus {\n\t\tfocus <- self;\n\t}\n\t\n\tinit {\n\t\tint num <- int(2 * teta0 / disc_factor);\n\t\theading <- location towards o;\n\t\tloop i from: 0 to: num {\n\t\t\tval_angles <<  ((i * disc_factor) - teta0);\n\t\t}\n\t}\n\t\n\treflex move_pedestrian {\n\t\tc <- 0.0;\n\t\tfloat dist_o <- location distance_to o;\n\t\talpha0 <- location towards o;\n\t\tvisu_ray <- [];\n\t\tdh <- #max_float;\n\t\tfloat dmin <- #max_float;\n\t\t\n\t\tfloat h0 <- copy(heading);\n\t\t\n\t\tloop a over:  val_angles {\n\t\t\tfloat alpha <- a + h0;\n\t\t\tlist<float> r <- compute_distance(alpha,min(dist_o,dmax));\n\t\t\t\n\t\t\tif self = focus {write name + \" \" + sample(alpha) + \" \" + sample(r) +  \" \" + sample(alpha0) + \" \" + sample(cos(alpha0 - alpha)) ;}\n\t\t\tfloat dist <- r[0];\n\t\t\tif (dist < dmin ) {\n\t\t\t\tdmin <- dist;\n\t\t\t\tdh <- r[1];\n\t\t\t\theading <- alpha;\n\t\t\t}\n\t\t}\n\t\tdo manage_move(dist_o);\n\t\tif (self distance_to o) < 1.0 {\n\t\t\tdo die;\n\t\t}\n\t\t\n\t}\n\t\n\tlist<float> compute_distance (float alpha, float dist_o){\n\t\tfloat f_alpha <- f(alpha, dist_o);\n\t\t\n\t\treturn [dist_o ^2 + f_alpha ^2 - 2 * dist_o *f_alpha * cos(alpha0 - alpha), f_alpha];\n\t}\n\t\n\tpoint force_repulsion_wall(wall w) {\n\t\t\n\t\tif (location intersects w) {\n\t\t\tfloat strength <- k * shoulder_length ;\n\t\t\tpoint pt_w <- (w.shape.contour closest_points_with location)[0];\n\t\t\tpoint vv <- {pt_w.x - location.x ,pt_w.y - location.y };\n\t\t\tfloat n <- norm(vv);\n\t\t\treturn vv * (strength/n); \n\t\t} else {\n\t\t\tfloat strength <- k * (shoulder_length - (location distance_to w));\n\t\t\tc <- c + strength;\n\t\t\tpoint pt_w <- (w closest_points_with location)[0];\n\t\t\tpoint vv <- {location.x - pt_w.x,location.y - pt_w.y };\n\t\t\tfloat n <- norm(vv);\n\t\t\treturn vv * (strength/n); \n\t\t\t\n\t\t}\n\t}\n\tpoint force_repulsion(pedestrian other) {\n\t\tfloat strength <- k * (other.shoulder_length + shoulder_length - (location distance_to other.location));\n\t\tc <- c + strength;\n\t\tpoint vv <- {location.x - other.location.x, location.y - other.location.y};\n\t\tfloat n <- norm(vv);\n\t\treturn vv * (strength/n); \n\t}\n\t\n\t\n\tfloat f(float alpha,float dmax_r) {\n\t\t\n\t\tgeometry line <- line([location, location + ({cos(alpha), sin(alpha)} * dmax_r)]);\n\t\tlist<pedestrian> ps <- (pedestrian overlapping line)  - self;\n\t\tlist<wall> ws <- wall overlapping line;\n\t\t\n\t\tloop w over: ws {\n\t\t\tline <- line - w;\n\t\t\tif line = nil {return 0.0;}\n\t\t}\n\t\tloop p over: ps {\n\t\t\tline <- line - p;\n\t\t\tif line = nil {return 0.0;}\n\t\t}\n\t\tline <- line.geometries first_with (location in each.points);\n\t\tif line = nil {\n\t\t\treturn 0.0;\n\t\t}\n\t\tline <- line - self;\n\t\tif line = nil {\n\t\t\treturn 0.0;\n\t\t}\n\t\tvisu_ray << line;\n\t\treturn line.perimeter;\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tpoint compute_sf_pedestrian {\n\t\tpoint sf <- {0.0,0.0};\n\t\tloop p over: pedestrian overlapping self {\n\t\t\tsf <- sf + force_repulsion(p);\n\t\t}\n\t\t\n\t\treturn sf/m;\n\t}\n\t\n\tpoint compute_sf_wall {\n\t\tpoint sf <- {0.0,0.0};\n\t\tloop w over: wall overlapping self {\n\t\t\tsf <- sf + force_repulsion_wall(w);\n\t\t}\n\t\t\n\t\treturn sf/m;\n\t}\n\t\n\taction manage_move (float dist_o) {\n\t\t\n\t\tfloat vdes <-  min(v0, dh/tau);\n\t\tpoint vdes_vector <-  { cos(heading),sin(heading)};\n\t\tvdes_vector <- vdes_vector * vdes;\n\t\tacc <- (vdes_vector - vi)/ tau +  compute_sf_pedestrian() +  compute_sf_wall();\n\t\tvi <- vi + (acc * step);\n\t\tlocation <- location + (vi * step);\n\t\t\n\t\t\n\t}\n\t\n\taspect default {\t\n\t\tif display_field_vision {\n\t\t\tloop l over: visu_ray {\n\t\t\t\tdraw l color: color;\n\t\t\t}\n\t\t}\n\t\n\t\tdraw  circle(shoulder_length) rotate: heading + 90.0 color: color;\n\t}\n}\n\ngrid local_indicator cell_width: 0.5 cell_height: 0.5{\n\tbool is_wall <- false;\n\tbool is_entry <- false;\n\tfloat R <- 0.7;\n\tfloat R2 <- 0.7 ^2;\n\tlist<float> local_speeds;\n\tlist<float> local_compressions;\n\trgb col_speed<- #black;\n\trgb col_compression<- #black;\n\t\n\treflex indicator_computation {\n\t\tdo compute_local_indicator;\n\t\tif not is_wall and not is_entry{\n\t\t\tfloat local_speed <- mean(local_speeds);\n\t\t\tfloat local_compression <- mean(local_compressions);\n\t\t\tcol_speed <- rgb(255 * (1 -local_speed), 255 * local_speed, 0.0  );\n\t\t\tcol_compression <- rgb(255 * (local_compression), 255 * (1.0 - local_compression), 0.0  );\n\t\t}\n\t\n\t\t\n\t}\n\taction compute_local_indicator {\n\t\tfloat sum_f;\n\t\tfloat sum_s;\n\t\tfloat sum_c;\n\t\tloop p over: pedestrian {\n\t\t\tfloat d <- location distance_to p.location;\n\t\t\tfloat f_v <- f(d);\t\n\t\t\tsum_f <- sum_f + f_v;\n\t\t\tsum_s <- sum_s + (f_v * norm(p.vi));\n\t\t\tsum_c <- sum_c + (f_v * p.c);\n\t\t}\n\t\tlocal_speeds << sum_s = 0 ? 1.0 : (sum_s/sum_f/P_v0_mean) ;\n\t\tlocal_compressions << sum_c = 0 ? 0.0 : (sum_c/sum_f/(P_k/3.0)) ;\n\t\tif length(local_speeds) > num_data {\n\t\t\tlocal_speeds >> first(local_speeds);\n\t\t\tlocal_compressions >> first(local_compressions);\n\t\t}\n\t\t\t\n\t}\n\tfloat f(float d) {\n\t\treturn 1/(#pi * R2) * exp(-(d^2) / R2);\n\t}\n\t\n\taspect speed_val {\n\t\tdraw shape color: col_speed;\n\t}\n\t\n\taspect compression_val {\n\t\tdraw shape color: col_compression;\n\t}\n\t\n\t\n}\n\nspecies wall {\n\taspect default {\t\n\t\tdraw shape  color: #black;\n\t\n\t}\n}\n\n\nexperiment corridor_xp type: gui {\n\t\n\tparameter var:display_field_vision;\n\tparameter \"desired speed mean\" var:P_v0_mean ;\n\tparameter \"desired speed standard deviation\" var:P_v0_std ;\n\tparameter \"max angle of vision\" var:P_teta0; //degree var:P_teta0 s\n\tparameter \"discretisation factor for the vision angle\" var:P_disc_factor ;\n\tparameter \"reaction time\" var:P_tau ;\n\tparameter \"distance of vision\" var:P_dmax ;\n\tparameter \"repulsion strength\" var:P_k ;\n\t\n\tfloat minimum_cycle_duration <- 0.02;\n\toutput {\n\t\tdisplay map type: 3d axes: false{\n\t\t\tgraphics \"east area\" {\n\t\t\t\tdraw east color: #blue;\n\t\t\t}\n\t\t\tgraphics \"west area\" {\n\t\t\t\tdraw west color: #red;\n\t\t\t}\n\t\t\t\n\t\t\tspecies wall;\n\t\t\tspecies pedestrian;\n\t\t}\n\t\t\n\t\tdisplay local_speed type:2d antialias:false{\n\t\t\tspecies local_indicator aspect: speed_val;\n\t\t}\n\t\t\n\t\tdisplay local_compression type:2d antialias:false{\n\t\t\tspecies local_indicator aspect: compression_val;\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple game of Snake using GAML, where the player controls the snake's movement and can start the game by pressing space.", "gaml_code": "/**\n* Name: Snake\n* Author: Patrick Taillandier\n* Tags: game, snake\n*/\n\nmodel snake\n\nglobal {\n\tlist<cell> cells_not_wall;\n\tint environment_size <- 20;\n\tbool game_is_running;\n\t\n\tgeometry shape <- square(environment_size);\n\tsnake the_snake;\n\tinit {\n\t\tcreate wall with: (shape: rectangle(environment_size,1), location:{environment_size/2.0,environment_size-0.5});\n\t\tcreate wall with: (shape: rectangle(environment_size,1), location:{environment_size/2.0,0.5});\n\t\tcreate wall with: (shape: rectangle(1, 100.0), location:{0.5,environment_size/2.0});\n\t\tcreate wall with: (shape: rectangle(1, 100.0), location:{environment_size -0.5,environment_size/2.0});\n\t\tcells_not_wall <- cell where (not each.is_wall);\n\n\t\tdo init_game;\t\t\n\t\twrite \"***** TO PLAY *****\";\n\t\twrite \"Up: 'e'/arrow up\\nDown: 'd'/arrow down\\nRight: 'f'/right arrow\\nLeft: 's'/left arrow\";\n\t\tcreate HUD;\n\n\t}\n\t\n\taction init_game {\n\t\tgame_is_running <- false;\n\t\t\n\t\task snake{\n\t\t\tdo die;\n\t\t}\n\t\task food {\n\t\t\tdo die;\n\t\t}\n\t\t\n\t\tcreate snake with:(shape: square(1), location:location, headings: [0.0]) {\n\t\t\tmy_cell <- cell(location);\n\t\t\tcells << my_cell;\n\t\t}\n\t\tthe_snake <- first(snake);\n\t\tcreate food with: (location:(one_of(free_cells()).location)) {\n\t\t\task cell(location) {\n\t\t\t\tis_food <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction move_up {\n\t\t\n\t\tif ( ! empty(the_snake.headings) and last(the_snake.headings) != 90\n\t\t\tor empty(the_snake.headings) and the_snake.current_heading != 90\n\t\t) {\n\t\t\tthe_snake.headings <+ -90.0;\n\t\t}\n\t}\n\taction move_down {\n\t\tif ( ! empty(the_snake.headings) and last(the_snake.headings) != -90\n\t\t\tor empty(the_snake.headings) and the_snake.current_heading != -90\n\t\t) {\n\t\t\tthe_snake.headings <+ 90.0;\n\t\t}\n\t}\n\taction move_left {\n\t\tif ( ! empty(the_snake.headings) and length(the_snake.headings) > 0 and last(the_snake.headings) != 0\n\t\t\tor empty(the_snake.headings) and the_snake.current_heading != 0\n\t\t) {\n\t\t\tthe_snake.headings <+ 180.0;\n\t\t}\n\t}\n\taction move_right {\n\t\tif ( ! empty(the_snake.headings) and last(the_snake.headings)!= 180\n\t\t\tor empty(the_snake.headings) and the_snake.current_heading != 180\n\t\t) {\n\t\t\tthe_snake.headings <+ 0.0;\n\t\t}\n\t}\n\taction start_count_down {\n\t\task HUD{\n\t\t\tdo start_count_down;\n\t\t}\n\t}\n\tlist<cell> free_cells {\n\t\treturn cells_not_wall - the_snake.cells;\n\t}\n}\n\ngrid cell width: environment_size height: environment_size use_individual_shapes: false use_neighbors_cache: false use_regular_agents: false{\n\tbool is_wall <-false;\n\tbool is_food <- false;\n\t\n}\n\nspecies wall {\n\t\n\tinit {\n\t\task cell overlapping self {\n\t\t\tis_wall <- true;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\nspecies food {\n\taspect default {\n\t\tdraw circle(0.5) color: #red;\n\t}\n}\nspecies snake  {\n\tfloat current_heading <- 0.0;\n\tlist<float> headings <- [0.0];\n\tcell my_cell;\n\tlist<cell> cells;\n\taspect default {\n\t\tloop c over: cells {\n\t\t\tdraw c.shape color: #blue;\n\t\t}\n\t}\n\t\n\taction end_of_game {\n\t\t\n\t\task world {\n\t\t\tdo tell(\"End of game, score: \" + length(myself.cells), false);\n\t\t\tdo init_game;\n\t\t}\n\t}\n\t\n\treflex move when:game_is_running{\n\t\tif ! empty(headings){\n\t\t\tcurrent_heading <- first(headings); \t\n\t\t\tremove from:headings index:0;\n\t\t}\n\t\tswitch current_heading {\n\t\t\tmatch 0.0 {\n\t\t\t\tmy_cell <- cell[my_cell.grid_x +1, my_cell.grid_y];\n\t\t\t\tif (my_cell.grid_x = (environment_size -1)) {\n\t\t\t\t\tdo end_of_game;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tmatch 180.0 {\n\t\t\t\tmy_cell <- cell[my_cell.grid_x -1, my_cell.grid_y];\n\t\t\t\tif (my_cell.grid_x = 0) {\n\t\t\t\t\tdo end_of_game;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch -90.0 {\n\t\t\t\tmy_cell <- cell[my_cell.grid_x, my_cell.grid_y -1];\n\t\t\t\tif (my_cell.grid_y = 0) {\n\t\t\t\t\tdo end_of_game;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch 90.0 {\n\t\t\t\tmy_cell <- cell[my_cell.grid_x, my_cell.grid_y +1];\n\t\t\t\tif (my_cell.grid_y = (environment_size -1)) {\n\t\t\t\t\tdo end_of_game;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif my_cell in cells {\n\t\t\tdo end_of_game;\n\t\t}\n\t\tcells << my_cell;\n\t\tif my_cell.is_food{\n\t\t\tmy_cell.is_food <- false;\n\t\t\task one_of(world.free_cells()) {\n\t\t\t\tis_food <- true;\n\t\t\t\tfirst(food).location <- location;\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tcells >> first(cells);\n\t\t}\n\t}\n}\n\nspecies HUD skills:[thread]{\n\t\n\tfont hud_font <- font(\"Helvetica\", 80, #bold) ;\n\tint count <- 3;\n\tbool is_counting <- false;\n\t\n\taspect default {\n\t\tif is_counting {\n\t\t\tdraw \"\"+count at:{world.shape.width/2-1, world.shape.height/2-1} \n\t\t\t\t\t\t\tcolor: rnd_color(255) \n\t\t\t\t\t\t\tfont:hud_font ;\n\t\t}\n\t\telse if ! game_is_running{\n\t\t\tdraw \"Press space to\"at:{1, 10}  font:hud_font color:#red;\n\t\t\tdraw \"start the game\" at:{2, 20}  font:hud_font color:#red;\n\t\t}\n\t}\n\t\n\taction start_count_down {\n\t\tcount <- 5;\n\t\tis_counting <- true;\n\t\t\n\t\tdo run_thread interval:1#second;\n\t}\n\t\n\t//counting down\n\taction thread_action {\n\t\tcount <- count - 1;\n\t\tif count = 0 {\n\t\t\tdo end_thread;\n\t\t\tis_counting <- false;\n\t\t\task world {\n\t\t\t\tgame_is_running <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}\n\n\nexperiment snake_game type: gui autorun: true{\n\tfloat minimum_cycle_duration <- 0.3;\n\tparameter \"Size of the environment\" var: environment_size <- 30 min: 10 max: 100;\n\tparameter \"Game speed (0.0: fast; 1.0: slow)\" var: minimum_cycle_duration <- 0.2 min: 0.0 max: 1.0;\n\toutput {\n\t\tdisplay map type:2d antialias:false {\n\t\t\tspecies wall;\n\t\t\tspecies snake;\n\t\t\tspecies food;\n\t\t\tspecies HUD;\n\t\t\tevent \"e\" {ask simulation { do move_up;}}\n\t\t\tevent #arrow_up {ask simulation { do move_up;}}\n\t\t\tevent \"d\" {ask simulation { do move_down;}}\n\t\t\tevent #arrow_down {ask simulation { do move_down;}}\n\t\t\tevent \"f\" {ask simulation { do move_right;}}\n\t\t\tevent #arrow_right {ask simulation { do move_right;}}\n\t\t\tevent \"s\" {ask simulation { do move_left;}}\n\t\t\tevent #arrow_left {ask simulation { do move_left;}}\n\t\t\tevent \" \" { ask simulation { do start_count_down;}}\n\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "**A Tetris game implemented using NetLogo. The game has a scoreboard that displays the current score and level, as well as statistics for each type of tetromino. The player can move the tetromino left or right using the arrow keys, rotate it using 'q' and 'd', and restart the game using 'r'.**", "gaml_code": "/**\n* Name: tetris\n* Based on the internal empty template. \n* Author: Loris\n* Tags: \n*/\n\n\n@no_warning\nmodel tetris\n\n\nglobal {\n\t\n\t\n\t\n\tbool left <- false;\n\tbool right <- false;\n\tbool down <- false;\n\tbool up <- false;\n\tbool q <- false;\n\tbool d <- false;\n\t\n\t\n\tbool has_started<- false;\n\t\n\tlist<int> stats <- [0,0,0,0,0,0,0];\n\t\n\tlist<rgb> tet_colors <- [#cyan, #yellow, #purple, #green, #red, #blue, #orange];\n\tfloat step <- 20#ms;\n\t\n\tint score;\n\tint level <- 1;\n\tint count_lines_level;\n\tgeometry shape <- rectangle(20,30);\n\ttetrimino initial;\n\tint next_te <- rnd(6);\n\t\n\taction reload {\n\t\task agents - cell - world{\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\tdo do_init;\n\t\t\t\tcreate fixed;\n\t\t\t\tstats <- [0,0,0,0,0,0,0];\n\t}\n\t\n\t\n\t\n\taction do_init {\n\t\tdo create_tetri;\n\t\tinitial <- tetrimino(0);\n\t\t\n\t\t\n\t\tnext_te <- rnd(6);\n\t}\n\t\n\tfloat freq(int l) {\n\t\treturn 1/sqrt(l);\n\t}\n\t\n\tinit {\n\t\tdo do_init;\n\t\tcreate fixed;\n\t}\n\t\n\tstring get_score(int scr){\n\t\tstring ret <- \"\";\n\t\tif scr < 100000 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 10000 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 1000 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 100 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 10 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\t//write ret + scr;\n\t\treturn ret + string(scr);\n\t}\n\tstring get_stat(int scr){\n\t\tstring ret <- \"\";\n\t\t\n\t\tif scr < 100 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 10 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\t//write ret + scr;\n\t\treturn ret + string(scr);\n\t}\n\t\n\t\n\tgeometry rotate_s(geometry g, point p, point l, int m) {\n\t\t//write (p + {(p-l).y, -(p-l).x});\n\t\t//write -int(2*(m-0.5));\n\t\t//write int(2*(m-0.5));\n\t\t//write (p + {int(2*(m-0.5))*(p-l).y, -int(2*(m-0.5))*(p-l).x});\n\t\treturn ((g rotated_by int(2*(m-0.5)*90.0)) at_location (p + {int(2*(m-0.5))*(p-l).y, -int(2*(m-0.5))*(p-l).x}));\n\t\t//return ((g rotated_by int(2*(m-0.5)*90.0)) at_location (p + {(p-l).y, -(p-l).x}));\n\t\t\n\t}\n\t\n\tgeometry select_shape(point l, int i) {\n\t\t\n\t\tswitch i {\n\t\t\tmatch 0 {\n\t\t\t\treturn rectangle({l.x, l.y - 2}, {l.x + 1, l.y + 2});\n\t\t\t}\n\t\t\tmatch 1 {\n\t\t\t\treturn rectangle({l.x - 1, l.y - 1}, {l.x + 1, l.y + 1});\n\t\t\t}\n\t\t\tmatch 2 {\n\t\t\t\treturn rectangle({l.x - 1.5, l.y - 1.5}, {l.x + 1.5, l.y + 0.5}) - rectangle({l.x - 1.5, l.y - 1.5}, {l.x - 0.5, l.y - 0.5}) - rectangle({l.x+0.5, l.y - 1.5}, {l.x + 1.5, l.y - 0.5});\n\t\t\t}\n\t\t\tmatch 3 {\n\t\t\t\treturn rectangle({l.x - 1.5, l.y - 1.5}, {l.x + 1.5, l.y + 0.5}) - rectangle({l.x - 1.5, l.y - 1.5}, {l.x - 0.5, l.y - 0.5}) - rectangle({l.x+0.5, l.y - 0.5}, {l.x + 1.5, l.y + 0.5});\n\n\t\t\t\t\n\t\t\t}\n\t\t\tmatch 4 {\n\t\t\t\treturn rectangle({l.x - 1.5, l.y - 1.5}, {l.x + 1.5, l.y + 0.5}) - rectangle({l.x - 1.5, l.y - 0.5}, {l.x - 0.5, l.y + 0.5}) - rectangle({l.x+0.5, l.y - 1.5}, {l.x + 1.5, l.y - 0.5});\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tmatch 5 {\n\t\t\t\treturn rectangle({l.x - 1.5, l.y - 1.5}, {l.x + 1.5, l.y + 0.5}) - rectangle({l.x - 0.5, l.y - 1.5}, {l.x + 1.5, l.y - 0.5});\n\t\t\t\t\n\t\t\t}\n\t\t\tmatch 6 {\n\t\t\t\treturn rectangle({l.x - 1.5, l.y - 1.5}, {l.x + 1.5, l.y + 0.5}) - rectangle({l.x - 1.5, l.y - 1.5}, {l.x + 0.5, l.y - 0.5});\n\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tpoint select_rotate(point p, int i) {\n\t\tswitch i {\n\t\t\tmatch 0 {\n\t\t\t\treturn location + {0,2};\n\t\t\t}\n\t\t\tmatch 1 {\n\t\t\t\treturn location + {1,1};\n\t\t\t}\n\t\t\tmatch 2 {\n\t\t\t\treturn location + {1.5, 1.5};\n\t\t\t}\n\t\t\tmatch 3 {\n\t\t\t\treturn location + {1.5, 1.5};\n\t\t\t}\n\t\t\tmatch 4 {\n\t\t\t\treturn location + {1.5, 1.5};\n\t\t\t}\n\t\t\tmatch 5 {\n\t\t\t\treturn location + {1.5, 1.5};\n\t\t\t}\n\t\t\tmatch 6 {\n\t\t\t\treturn location + {1.5, 1.5};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\taction pause_action {\n\t\task tetrimino {\n\t\t\tis_active <- false;\n\t\t\tdo die;\n\t\t}\n\t\tdo pause;\n\t}\n\t\n\taction create_tetri{\n\t\tint j <- rnd(6);\n\t\tstats[next_te] <- stats[next_te] + 1;\n\t\tcreate tetrimino {\n\t\t\ti <- next_te;\n\t\t\t\n\t\t\t\n\t\t\tcolor <-  tet_colors[i];\n\t\t\t\n\t\t\tlocation <- {15,10};\n\t\t\tif i < 2 {\n\t\t\t\tlocation <- {15,10};\n\t\t\t\tcenter_rotate<-{15,10};\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlocation <- {15.5,10.5};\n\t\t\t\tcenter_rotate <- {15.5, 10.5};\n\t\t\t}\n\t\t\tshape <- world.select_shape(location, i);\n\t\t\t\n\t\t\tfrequency <- world.freq(level);\n\t\t\tis_active <- true;\n\t\t\task tetrimino - self {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t}\n\t\tnext_te <- j;\n\t}\n}\n\ngrid cell height:30 width:20 {\n\tinit {\n\t\t\n\t}\n\taspect default {\n\t\tdraw shape color:hsb( (level mod 360)/360.0 * 20, 0.2,0.7) border:#white;\n\t}\n}\n\nspecies tetrimino {\n\t\n\tint i;\n\tint rotation;\n\tbool is_active;\n\tfloat frequency;\n\trgb color;\n\t\n\tpoint center_rotate;\n\t\n\t\n\treflex down when:every(frequency) or down {\n\t\tif down {\n\t\t\tdown <- false;\n\t\t}\n\t\tif (last(fixed).fixed_cells.keys collect (each.location + {0,-0.51})) all_match not(each intersects shape) {\n\t\t\t\t\t\tcenter_rotate <- center_rotate + {0,1};\n\t\t\t\t\t\tlocation <- location + {0,1};\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t}\n\treflex right when:right {\n\t\tright <- false;\n\t\task tetrimino select each.is_active {\n\t\t\t\t\tif not (shape intersects polyline({20,0}, {20,30})) and ((last(fixed).fixed_cells.keys collect (each.location + {0.51,0}) + last(fixed).fixed_cells.keys collect (each.location + {-0.51,0})) all_match not(each intersects shape)) {\n\t\t\t\t\t\tcenter_rotate <- center_rotate + {1,0};\n\t\t\t\t\t\tlocation <- location + {1,0};\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\treflex left when:left {\n\t\tleft <- false;\n\t\task tetrimino select each.is_active {\n\t\t\t\t\tif not (shape intersects polyline({10,0}, {10,30})) and ((last(fixed).fixed_cells.keys collect (each.location + {0.51,0}) + last(fixed).fixed_cells.keys collect (each.location + {-0.51,0})) all_match not(each intersects shape)){\n\t\t\t\t\t\tcenter_rotate <- center_rotate + {-1,0};\n\t\t\t\t\t\tlocation <- location + {-1,0};\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\n\t}\n\treflex up when:up {\n\t\tup <- false;\n\t\t\n\t\t\t\t\tint lines_count;\n\t\t\t\t\tloop dist over:range(1,30) {\n\t\t\t\t\t\tlines_count <- dist;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif not(dead(self)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tcenter_rotate <- center_rotate + {0,1};\n\t\t\t\t\t\tlocation <- location + {0,1};\n\t\t\t\t\t\tdo kill_reflex;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tscore <- score + lines_count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\treflex q when:q {\n\t\tq <- false;\n\t\t\n\t\t\t\t\tgeometry new_shape <- world.rotate_s(shape, center_rotate, location, 0);\n\t\t\t\t\tif not (new_shape intersects polyline({20.1,0}, {20.1,30}) or new_shape intersects polyline({9.9,0}, {9.9,30})) and ((last(fixed).fixed_cells.keys collect (each.location + {0.51,0}) + last(fixed).fixed_cells.keys collect (each.location + {-0.51,0})) all_match not(each intersects new_shape)){\n\t\t\t\t\t\tshape <- new_shape;\n\t\t\t\t\t}\n\t\t\t\t\n\t}\n\treflex d when:d {\n\t\td <- false;\n\t\t\n\t\t\t\t\tgeometry new_shape <- world.rotate_s(shape, center_rotate, location, 1);\n\t\t\t\t\tif not (new_shape intersects polyline({20.1,0}, {20.1,30}) or new_shape intersects polyline({9.9,0}, {9.9,30})) and ((last(fixed).fixed_cells.keys collect (each.location + {0.51,0}) + last(fixed).fixed_cells.keys collect (each.location + {-0.51,0})) all_match not(each intersects new_shape)){\n\t\t\t\t\t\tshape <- new_shape;\n\t\t\t\t\t}\n\t\t\t\t\n\t}\n\t\n\taspect default {\n\t\tdraw shape color:color border:#black at: location;\n\t\t//draw circle(0.3) at:center_rotate color:#red;\n\t}\n\t\n\t\n\t\n\taction stop {\n\t\task fixed[0] {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//self.fixed_cells <- self.fixed_cells + cell select (each.shape intersection myself.shape = nil ? false:(each.shape intersection myself.shape).area>0);\n\t\t\t\n\t\t\t//self.fixed_cells <- self.fixed_cells + ((cell overlapping first(tetrimino select (not(dead(each)) and each.is_active)).shape) select ((each.shape intersection first(tetrimino select (not(dead(each)) and each.is_active)).shape).area>0)) as_map (each::first(tetrimino select (not(dead(each)) and each.is_active)).color);\n\t\t\t\n\t\t\ttetrimino the_one <- first(tetrimino select each.is_active);\n\t\t\tlist<cell> cell_touch <- cell select (each.shape touches the_one); \n\t\t\tself.fixed_cells <- self.fixed_cells + ((cell-cell_touch) overlapping the_one) as_map (each::the_one.color);\n\t\t\t\n\t\t\t\n\t\t\tlist<int> lines;\n\t\t\tloop j over:range(10,28) {\n\t\t\t\tif (cell select (each.grid_y = j and each.grid_x >= 10)) all_match(each in fixed_cells.keys) {\n\t\t\t\t\t\n\t\t\t\t\tlines << j;\n\t\t\t\t\tmap<cell, rgb> rem <- (fixed_cells.pairs select (each.key.grid_y = j)) as_map (each.key::each.value);\n\t\t\t\t\t\n\t\t\t\t\tloop pa over:rem.pairs {\n\t\t\t\t\t\tfixed_cells <-fixed_cells - pa;\n\t\t\t\t\t}\n\t\t\t\t\t//fixed_cells <- fixed_cells - ((fixed_cells.pairs select (each.key.grid_y = j)) as_map (each.key::each.value));\n\t\t\t\t\t\n\t\t\t\t\tloop x over:range(10,19) {\n\t\t\t\t\t\tloop y over:range(j-1, 10) {\n\t\t\t\t\t\t\tif cell[x,y] in fixed_cells.keys {\n\t\t\t\t\t\t\t\trgb cc <- fixed_cells[cell[x,y]];\n\t\t\t\t\t\t\t\tfixed_cells <- fixed_cells - (cell[x,y]::cc);\n\t\t\t\t\t\t\t\tfixed_cells <- fixed_cells + (cell[x,y+1]::cc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount_lines_level <- count_lines_level + length(lines);\n\t\t\tswitch length(lines) {\n\t\t\t\tmatch 1 {\n\t\t\t\t\tscore <- score + 40;\n\t\t\t\t}\n\t\t\t\tmatch 2 {\n\t\t\t\t\tscore <- score + 100;\n\t\t\t\t}\n\t\t\t\tmatch 3 {\n\t\t\t\t\tscore <- score + 300;\n\t\t\t\t}\n\t\t\t\tmatch 4 {\n\t\t\t\t\tscore <- score + 1200;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif count_lines_level >=4 {\n\t\t\t\tlevel <- level+1;\n\t\t\t\tcount_lines_level <- 0;\n\t\t\t\task agents - cell - world - fixed{\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\task world {do do_init;}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tis_active <- false;\n\t\tif location.y >11 { \n\t\task world {\n\t\t\tdo create_tetri;\n\t\t}\n\t\tdo die;\n\t\t\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\task world{do pause_action;}\n\t\t}\n\t\t\n\t}\n\t\n\treflex kill_reflex {\n\t\tdo kill_reflex;\n\t}\n\t\n\taction kill_reflex {\n\t\t\n\t\t\tbool intersec <- false;\n\t\t\tloop p over: last(fixed).fixed_cells.keys collect each.location {\n\t\t\t\t\n\t\t\t\tif shape intersects (p + {0,-0.5}){\n\t\t\t\t\t\n\t\t\t\t\tintersec <- true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t if intersec {\n\t\t\t\tdo stop;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\n}\n\nspecies fixed {\n\tmap<cell,rgb> fixed_cells;\n\tinit {\n\t\tloop i over:range(19) {\n\t\t\tfixed_cells << (cell[i,29]::#red);\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\taspect default {\n\t\tloop c over: fixed_cells.pairs {\n\t\t\t\n\t\t\tdraw c.key.shape color:c.value at:c.key.shape.centroid border:color;\n\t\t}\n\t\t/*loop p over: fixed.fixed_cells collect (each.location) {\n\t\t\tdraw circle(0.3) at:p + {0,-0.5} color:#white;\n\t\t}*/\n\t}\n}\n\nexperiment main {\n\tfloat minimum_cycle_duration <- 20#ms;\n\toutput {\n\t\tlayout 0 tabs:false editors: false;\n\t\tdisplay main fullscreen:false type:2d antialias:false toolbar:false background:hsb( (level mod 360)/360.0 * 20, 0.2,0.7) axes:true{\n\t\t\n\t\t\t//grid cell;\n\t\t\tspecies cell;\n\t\t\tspecies tetrimino;\n\t\t\tspecies fixed;\n\t\t\t\n\t\t\tgraphics scoreboard position:{0,0} size:{20,10} background:#black border:#cyan{\n\t\t\t\tdraw shape color:#black border:#cyan;\n\t\t\t\tdraw \"Score\" at:{14.5,7} font:font(\"Arial\", 30, #bold+#italic) color:#white;\n\t\t\t\tdraw get_score(score) at: {14,12} font:font(\"Arial\", 30, #bold+#italic) color:#white;\n\t\t\t\tdraw \"Next\" at: {10,25} font:font(\"Arial\", 30, #bold+#italic) color:#white;\n\t\t\t\tdraw rectangle({14,18}, {19,29}) wireframe:true color: #white width:0.5 ;\n\t\t\t\tdraw world.select_shape({16.5, 23.9},next_te)*{0.9,2.7} color:tet_colors[next_te];\n\t\t\t\tdraw \"Level :  \"+string(level) at: {2,25} font:font(\"Arial\", 30, #bold+#italic)color:#white;\n\t\t\t\tdraw \"TETRIS\" at:{1.5,14} font:font(\"Arial\", 70, #bold)color:#white;\n\t\t\t\t\n\t\t\t}\n\t\t\tgraphics scoreboard position:{0,10} size:{10,20} background:#black border:#cyan{\n\t\t\t\tdraw shape color:#black border:#cyan;\n\t\t\t\tdraw \"Arrows to move\" at: {3,2} font:font(\"Arial\", 20, #bold+#italic) color:#white;\n\t\t\t\tdraw \"Q/D to rotate\" at: {3,3.2} font:font(\"Arial\", 20, #bold+#italic)color:#white;\n\t\t\t\tdraw \"R to restart\" at: {3,4.4} font:font(\"Arial\", 20, #bold+#italic)color:#white;\n\t\t\t\tdraw \"Statistics\" at:{3, 7.3} font:font(\"Arial\", 30, #bold+#italic)color:#white;\n\t\t\t\tloop i over:range(6) {\n\t\t\t\t\tpoint tr <- {1,3/4};\n\t\t\t\t\tif i=6 {\n\t\t\t\t\t\ttr <- {1,3/5};\n\t\t\t\t\t}\n\t\t\t\t\tpoint att <- {5, 10 + 3*i};\n\t\t\t\t\tif i<2 {\n\t\t\t\t\t\tatt <- att+{0,-0.3};\n\t\t\t\t\t}\n\t\t\t\t\tdraw world.select_shape(att,i)*{1,3/4} color:tet_colors[i];\n\t\t\t\t\tdraw get_stat(stats[i]) at:{10, 10 + 3*i} font:font(\"Arial\", 20, #bold+#italic)color:#white;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//draw \"Statistics\"\n\t\t\t}\n\t\t\tgraphics scoreboard position:{0,29} size:{20,1} background:#black border:#cyan{\n\t\t\t\tdraw shape color:#black border:#cyan;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tevent #arrow_left {\n\t\t\t\tleft <- true;\n\t\t\t\t\n\t\t\t}\n\t\t\tevent #arrow_right {\n\t\t\t\tright <- true;\n\t\t\t\t\n\t\t\t}\n\t\t\tevent #arrow_down {\n\t\t\t\tif not has_started {\n\t\t\t\t\thas_started <- true;\n\t\t\t\t\task world{do resume;}\n\t\t\t\t}\n\t\t\t\tdown <- true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tevent #arrow_up {\n\t\t\t\tup <- true;\n\t\t\t}\n\t\t\t\n\t\t\tevent \"q\" {\n\t\t\t\tq <- true;\n\t\t\t\t\n\t\t\t\n\t\t\t}\n\t\t\tevent \"d\" {\n\t\t\t\td <- true;\n\t\t\t\t\n\t\t\t\n\t\t\t}\n\t\t\tevent \"r\" {\n\t\t\t\task simulation {do reload;}\n\t\t\t\tscore <- 0;\n\t\t\t\tlevel<-1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n/* Insert your model definition here */"}
{"prompt": "Create a simulation of the classic game Flappy Bird, where a bird must navigate through pipes to gain points and avoid obstacles.", "gaml_code": "/**\n* Name: Flappy Bird, try to avoid obstacles to gain points.\n* Author: Loris Henry\n* Tags: Flappy Bird, game, user interaction\n*/\n\n\nmodel FlappyBird\n\nglobal {\n\t\n\t\n\tfloat step <- 65#ms;\n\tfloat g <- 9.81 #m/(#s^2);\n\tfloat tuyau_speed <- 0.5 #m/#s;\n\timage_file pipe <- image_file(\"../includes/pipe9.png\");\n\timage_file bird_image <- image_file(\"../includes/birdd.png\");\n\t\n\t\n\tpoint param_size <- {3.0, 4.65};\n\tpoint off_set <- {0.035,0.16,0};\n\tfloat bird_to_size <- 5.2;\n\tpoint bird_offset <- {0.017, -0.012};\n\tpoint text_point <- {0.97, 0.18};\n\tfloat text_size <- 30.0;\n\tpoint graph_position <- {0.2, 0.2};\n\t\n\tgeometry shape <- square(2#m);\n\t\n\tfloat speed_init <- -1.5#m/#s;\n\tint count<-0;\n\tbool game_over <- false;\n\t\n\tinit {\n\t\t\n\t\tdo reinit_model;\n\t}\n\taction reinit_model {\n\t\t\n\t\task texts {\n\t\t\tdo die;\n\t\t}\n\t\tcount<-0;\n\t\tgame_over <- false;\n\t\n\t\tcreate bird {\n\t\t\tlocation <- point([1, 1]);\n\t\t}\n\t\tcreate texts {\n\t\t\tmy_text <- \"0\";\n\t\t\tlocation <- text_point;\n\t\t\tf <- font(\"Flappy Bird Font\", text_size);\n\t\t}\n\t}\n\t\n\taction to_game_over {\n\t\tgame_over <- true;\n\t\task bird { \n\t\t\tdo die;\n\t\t}\n\t\task tuyau {\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex add_tuyau when:not game_over and every(9/5#s) {\n\t\t\t\tcreate tuyau {\n\t\t\t\n\t\t\tlocation <- {3,rnd(0.5, 1.5)};\n\t\t\t\n\t\t}\n\t}\n\n}\n\nspecies bird frequency: game_over ? 0 : 1{\n\tfloat speed;\n\tbool impulsion <- false;\n\tfloat size <- 1.5#cm;\n\trgb color <- #blue;\t\n\t\n\treflex move {\n\t\tspeed <- speed + g*step;\n\t\tif impulsion {\n\t\t\tspeed <- speed_init;\n\t\t\timpulsion <- false;\n\t\t}\n\t\tlocation <- point([location.x, location.y + speed*step]);\n\t}\n\t\n\treflex collision when: circle(size,location) intersects union(tuyau collect each.fake_shape){\n\t\task world {do to_game_over;}\n\t}\n\treflex border when: location.y > 2.0 - size or location.y < 0.2 + size {\n\t\task world {do to_game_over;}\n\t} \n\t\n\taspect default {\n\t\tdraw circle(size * 5) color:color;\n\t}\n\taspect png {\n\t\tdraw bird_image size:bird_to_size*size*5 at: location+bird_offset rotate:atan(speed/(4*tuyau_speed));\n\t}\n} \n\nspecies tuyau {\n\tfloat speed <- tuyau_speed;\n\t\n\tgeometry fake_shape1;\n\tgeometry fake_shape2;\n\tgeometry fake_shape3;\n\tgeometry fake_shape4;\n\tgeometry fake_shape5;\n\tgeometry fake_shape6;\n\tgeometry fake_shape;\n\tbool has_counted <- false;\n\t\n\tinit {\n\t\tfake_shape1 <- line([{location.x, 0}, {location.x, location.y - 0.25}]);\n\t\tfake_shape3 <- rectangle({location.x - 0.22, location.y + 0.25}, {location.x + 0.216, location.y + 0.45});\n\t\tfake_shape4 <- rectangle({location.x - 0.22, location.y - 0.25}, {location.x + 0.216, location.y -0.05});\n\t\t\n\t\t\n\t\tfake_shape2 <- line([{location.x, location.y + 0.25}, {location.x, 2}]);\n\t\t\n\t\tfake_shape5 <- rectangle({location.x - 0.188, location.y + 0.45}, {location.x + 0.187, location.y + 2});\n\t\tfake_shape6 <- rectangle({location.x - 0.188, location.y - 2}, {location.x + 0.187, location.y - 0.45});\n\t\tfake_shape <- union(fake_shape3, fake_shape4, fake_shape5, fake_shape6);\n\t}\n\t\n\treflex move {\n\t\tlocation <- point([location.x - speed*step, location.y]);\n\t}\n\treflex update_shape {\n\t\tfake_shape1 <- line([{location.x, 0}, {location.x, location.y - 0.25}]);\n\t\tfake_shape2 <- line([{location.x, location.y + 0.25}, {location.x, 2}]);\n\t\tfake_shape3 <- rectangle({location.x - 0.22, location.y + 0.25}, {location.x + 0.216, location.y + 0.45});\n\t\tfake_shape4 <- rectangle({location.x - 0.22, location.y - 0.25}, {location.x + 0.216, location.y -0.45});\n\t\tfake_shape5 <- rectangle({location.x - 0.188, location.y + 0.45}, {location.x + 0.187, location.y + 2});\n\t\tfake_shape6 <- rectangle({location.x - 0.188, location.y - 2}, {location.x + 0.187, location.y - 0.45});\n\t\tfake_shape <- union(fake_shape3, fake_shape4, fake_shape5, fake_shape6);\n\n\n\n\n\t}\n\treflex count when:location.x < 1.0 and not has_counted{\n\t\tcount <- count + 1;\n\t\thas_counted <- true;\n\t\twrite name;\n\t\task texts[0] {\n\t\t\tmy_text <- count as string;\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw fake_shape1 color:#lime;\n\t\tdraw fake_shape2 color:#lime;\n\t}\n\taspect png {\n\t\tdraw pipe size:param_size at: location - off_set;\n\t}\n}\n\nspecies texts {\n\tstring my_text;\n\tfont f;\n\trgb color <- #black;\n\t\n\taspect default {\n\t\tdraw rectangle(2, 0.2) color:#orange at:{1,0.1};\n\t\tdraw my_text color:color font:f size:text_size;\n\t}\n}\n\n\n\nexperiment main {\n\t\n\tfloat minimum_cycle_duration <- step;\n\t\n\tbool has_started <- false;\n\t\n\tparameter var:param_size <- {3.0, 4.65};\n\tparameter var:off_set <- {0.035,0.16,0};\n\tparameter var:bird_to_size <- 5.2 ;\n\tparameter var:bird_offset <- {0.017, -0.012} ;\n\tparameter var:text_point <- {0.97, 0.18} ;\n\tparameter var:text_size <- 30.0 ;\n\tparameter var:graph_position <- {0.2, 0.2} ;\n\t\n\t\n\toutput synchronized:true{\n\t\t\n\t\tlayout consoles:false editors:false navigator:false parameters:false toolbars:false tray:false;\n\t\n\t\t\n\t\tdisplay main fullscreen:true type:2d {\n\t\t\t\n\t\t\timage_layer \"../includes/background.png\";\n\t\t\tspecies bird aspect:png;\n\t\t\t\n\t\t\tspecies tuyau aspect:png;\n\t\t\tspecies texts;\n\t\t\tevent \"r\" {\n\t\t\t\tif (game_over) {\n\t\t\t\t\task world {\n\t\t\t\t\t\tdo reinit_model;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tevent \" \" {\n\t\t\t\tif not has_started {\n\t\t\t\t\task simulation {\n\t\t\t\t\t\tdo resume;\n\t\t\t\t\t\tmyself.has_started <- true;\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\task bird {impulsion <- true;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics \"Start\" position:{0,0} size:{0.15, 0.6}{\n\t\t\t\tif not has_started{\n\t\t\t\tdraw \"Press space to play\" font:font(\"FlappyBirdy\", 70) color:#white;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics \"Game Over\" position:{0,0} size:{0.25, 0.7}{\n\t\t\t\tif game_over{\n\t\t\t\t\tdraw \"Game Over\" font:font(\"FlappyBirdy\",120, #bold  ) color:#white;\n\t\t\t\t\tdraw \" Press R to reload\" font:font(\"FlappyBirdy\",70, #bold  ) color:#white at: {0.9, 1.4};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n}"}
{"prompt": "**This is a complex and lengthy code snippet that appears to be a simulation of a Pac-Man game written in NetLogo. It includes various models (Pac-Man, ghosts, scoreboard) and experiments (main). The code defines rules for the behavior of Pac-Man and the ghosts, as well as user interactions such as starting and restarting the game.**", "gaml_code": "/**\n* Name: pacman\n* Based on the internal empty template. \n* Author: Loris\n* Tags: \n*/\n\n\n@no_warning\nmodel pacman\n\nglobal {\n\tgeometry shape <- rectangle(17,19);\n\tfloat size_p<- 0.85;\n\tgraph the_graph;\n\tgraph the_graph2;\n\tfile map_init <- image_file(\"../includes/pacman_grid.png\");\n\tfile Blinky0 <- image_file(\"../includes/Blinky0.png\");\n\timage_file pacman_file <- image_file(\"../includes/pacman.png\");\n\tlist<point> void <- [{0, 5}, {1, 5}, {0, 6}, {1, 6}, {15, 5}, {16, 5}, {15, 6}, {16, 6}, {8, 7}, {7, 8}, {8, 8}, {9, 8}, {0, 10}, {1, 10}, {15, 10}, {16, 10}];\n\tlist<string> Ghost_Names <- [\"Blinky\", \"Pinky\", \"Inky\", \"Clyde\"];\n\tlist<rgb> Ghost_Colors <- [#red, #pink, #cyan, #orange];\n\tlist<point> Ghost_Starts <- [{8,7}, {8,8}, {7,8}, {9,8}];\n\tlist<point> ghost_scatter_points <- [{15,1}, {1,1}, {15,15}, {1,15}];\n\tlist<point> super_points <- [{1,2}, {15,2}, {1,14}, {15,14}];\n\tbool end_of_game <- false;\n\t\n\tfloat step <- 20#ms;\n\tint score;\n\tint food_unit <- 10;\n\tint super_unit <- 50;\n\tint kill_unit <- 200;\n\tfloat time_a <- 0.0#s;\n\t\n\tbool has_started <- false;\n\t\n\tint level;\n\t\n\tfloat progression <- 5.0;\n\t\n\tfloat pacman_speed{\n\t\treturn 3 + 5 *(1-exp(-level/progression));\n\t}\n//\tlist<float> ghost_speed <- [2.10, 2.40, 3.60];\n\tfloat ghost_speed{\n\t\treturn pacman_speed() * (0.3 * (1 - exp(-level/progression)) + 0.7);\n\t}\n\t//list<rgb> color_levels <- [#blue, #mediumpurple, #teal];\n\t\n\trgb color_level{\n\t\treturn hsb( (level mod 360)/360.0 * 20, 0.25,0.75);\n\t}\n\t\n\treflex add_time {\n\t\ttime_a <- time_a + step;\n\t}\n\t\n\tstring get_score(int scr){\n\t\tstring ret <- \"\";\n\t\tif scr < 100000 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 10000 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 1000 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 100 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\tif scr < 10 {\n\t\t\tret <- ret + \"0\";\n\t\t}\n\t\t//write ret + scr;\n\t\treturn ret + string(scr);\n\t}\n\t\n\taction game_over {\n\t\tdo pause;\n\t\tend_of_game <- true;\n\t}\n\t\n\n\t\n\taction init_a {\n\t\thas_started <- false;\n\t\ttime_a <- 0.0;\n\t\t\n\t\t\n\t\tcreate pac {\n\t\t\tspeed <- world.pacman_speed();\n\t\t\tlocation <- cell[8,10].location;\n\t\t\torientation <- 0;\n\t\t}\n\t\task cell {\n\t\t\tis_wall <- map_init at {grid_x, grid_y}= -16777216;\n\t\t\tcolor <- not is_wall ? #black: world.color_level();\n\t\t\thas_food <- not is_wall;\n\t\t}\n\t\tloop p over:void {\n\t\t\task cell[int(p.x), int(p.y)] {\n\t\t\t\thas_food <- false;\n\t\t\t}\n\t\t}\n\t\tloop p over:super_points {\n\t\t\task cell[int(p.x), int(p.y)] {\n\t\t\t\thas_superpower <- true;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tloop i over:range(3) {\n\t\t\tcreate ghost {\n\t\t\t\tname <- Ghost_Names[i];\n\t\t\t\tcolor <- Ghost_Colors[i];\n\t\t\t\tlocation <- cell[int(Ghost_Starts[i].x), int(Ghost_Starts[i].y)].location;\n\t\t\t\tscatter_point <- cell[int(ghost_scatter_points[i].location.x), int(ghost_scatter_points[i].location.y)].location;\n\t\t\t\tspeed <- world.ghost_speed();\n\t\t\t\tif name in [\"Blinky\", \"Pinky\"] {\n\t\t\t\t\tcan_move <- true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthe_graph <- grid_cells_to_graph(cell select not each.is_wall);\n\t\tthe_graph2 <- grid_cells_to_graph([cell[7,8], cell[8,8], cell[9,8]]);\n\t\t\n\t\tif end_of_game {\n\t\t\tlevel <- 0;\n\t\t}\n\t\tend_of_game <- false;\n\t\t\n\t}\n\tinit {\n\t\n\t\tdo init_a;\n\t\t\n\t}\n\t\n\t\n\t\n\treflex end when: cell select (each.has_food) = []{\n//\t\tif level < 2 {\n\t\t\tlevel <- level + 1;\n//\t\t}\n\t\task agents-world-cell {\n\t\t\tdo die;\n\t\t}\n\t\tdo init_a;\n\t\thas_started <- false;\n\t\tdo pause;\n\t\thas_started <- false;\n\t\t\n\t}\n\t\n}\n\nspecies pac {\n\tfloat size <- 0.4#m;\n\tint orientation <- 5;\n\tint orientation_query;\n\tcell my_cell;\n\tfloat speed;\n\t\n\t\n\treflex move {\n\t\tmy_cell <- cell closest_to self;\n\t\t\n\t\tbool is_doable <- false;\n\t\t\n\t\tswitch orientation_query {\n\t\t\tmatch 0 {\n\t\t\t\tcell to_test <- my_cell.custom_neighbors()[0];\n\t\t\t\tif not (to_test = nil) {\n\t\t\t\t\tif not to_test.is_wall {\n\t\t\t\t\t\t\n\t\t\t\t\t\tis_doable <- true;\n\t\t\t\t\t\tif orientation = 1 {\n\t\t\t\t\t\t\tif location.x < my_cell.location.x - 0.05  {\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif orientation = 3 {\n\t\t\t\t\t\t\tif location.x > my_cell.location.x + 0.05 {\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch 1 {\n\t\t\t\tcell to_test <- my_cell.custom_neighbors()[1];\n\t\t\t\tif not (to_test = nil) {\n\t\t\t\t\tif not to_test.is_wall {\n\t\t\t\t\t\tis_doable <- true;\n\t\t\t\t\t\tif orientation = 0 {\n\t\t\t\t\t\t\tif location.y > my_cell.location.y + 0.05 {\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif orientation = 2 {\n\t\t\t\t\t\t\tif location.y < my_cell.location.y - 0.05{\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch 2 {\n\t\t\t\tcell to_test <- my_cell.custom_neighbors()[2];\n\t\t\t\tif not (to_test = nil) {\n\t\t\t\t\tif not to_test.is_wall {\n\t\t\t\t\t\tis_doable <- true;\n\t\t\t\t\t\tif orientation = 1 {\n\t\t\t\t\t\t\tif location.x < my_cell.location.x - 0.05 {\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif orientation = 3 {\n\t\t\t\t\t\t\tif location.x > my_cell.location.x + 0.05 {\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch 3 {\n\t\t\t\tcell to_test <- my_cell.custom_neighbors()[3];\n\t\t\t\tif not (to_test = nil) {\n\t\t\t\t\tif not to_test.is_wall {\n\t\t\t\t\t\tis_doable <- true;\n\t\t\t\t\t\tif orientation = 0 {\n\t\t\t\t\t\t\tif location.y > my_cell.location.y + 0.05{\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif orientation = 2 {\n\t\t\t\t\t\t\tif location.y < my_cell.location.y - 0.05{\n\t\t\t\t\t\t\t\tis_doable <- false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t/*if circle(0.5) intersects union((cell select (each.is_wall)) collect each.shape) {\n\t\t\torientation <- 5;\n\t\t}*/\n\t\tif is_doable {\n\t\t\torientation <- orientation_query;\n\t\t}\n\t\t\n\t\tswitch orientation {\n\t\t\tmatch 0 { //North\n\t\t\tlocation <- {my_cell.location.x,location.y};\n\t\t\t\n\t\t\t\tif not (my_cell.custom_neighbors()[0].is_wall and location.y < my_cell.location.y) {\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tlocation <- location + {0,-speed*step};\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tmatch 1 { //East\n\t\t\tlocation <- {location.x,my_cell.location.y};\n\t\t\tif not (my_cell.custom_neighbors()[1].is_wall and location.x > my_cell.location.x) {\n\t\t\t\tlocation <- location + {speed*step,0};\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tmatch 2 { //South\n\t\t\tlocation <- {my_cell.location.x,location.y};\n\t\t\tif not (my_cell.custom_neighbors()[2].is_wall and location.y > my_cell.location.y) {\n\t\t\t\tlocation <- location + {0, speed*step};\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tmatch 3 { //West\n\t\t\tlocation <- {location.x,my_cell.location.y};\n\t\t\tif not (my_cell.custom_neighbors()[3].is_wall and location.x < my_cell.location.x) {\n\t\t\t\tlocation <- location + {-speed*step,0};\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tif location.x < 0 {\n\t\t\tlocation <- {location.x + 17, location.y};\n\t\t}\n\t\tif location.x > 17 {\n\t\t\tlocation <- {location.x - 17, location.y};\n\t\t}\n\t}\n\t\n\treflex eat {\n\t\tif my_cell.has_food {\n\t\t\task my_cell {\n\t\t\t\thas_food <- false;\n\t\t\t\tworld.score <- world.score + food_unit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex trigger_superpower {\n\t\tif my_cell.has_superpower {\n\t\t\tworld.score <- world.score + super_unit;\n\t\t\task my_cell {\n\t\t\t\thas_superpower <- false;\n\t\t\t}\n\t\t\task ghost {\n\t\t\t\tmode <- \"frightened\";\n\t\t\t\ttotal_frightened_time <- total_frightened_time + 5#s;\n\t\t\t\tstart_fright <- time;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tgeometry c <- circle(size);\n\t\tgeometry d <- arc(2*size, 90*(orientation - 1),50*(1+cos(360*time/0.5)),true);\n\t\t//write 45*(1+cos(2*#pi*time/0.5));\n\t\tdraw c-d color:#yellow;\n\t\t\n\t}\n\taspect png {\n\t\tdraw pacman_file size:size_p rotate:90*(orientation-1);\n\t}\n}\n\ngrid cell height:19 width:17 neighbors:4{\n\tbool is_wall;\n\tbool has_food <- true;\n\tbool has_superpower <- false;\n\t\n\t\n\tlist<cell> custom_neighbors {\n\t\tlist<cell> res;\n\t\tif grid_y = 0 {\n\t\t\tres << nil;\n\t\t}\n\t\telse {\n\t\t\tres << cell[grid_x, grid_y - 1];\n\t\t}\n\t\tif grid_x = 16 {\n\t\t\tres << nil;\n\t\t}\n\t\telse {\n\t\t\tres << cell[grid_x + 1, grid_y];\n\t\t}\n\t\tif grid_y = 16 {\n\t\t\tres << nil;\n\t\t}\n\t\telse {\n\t\t\tres << cell[grid_x, grid_y + 1];\n\t\t}\n\t\tif grid_x = 0 {\n\t\t\tres << nil;\n\t\t}\n\t\telse {\n\t\t\tres << cell[grid_x - 1, grid_y];\n\t\t}\n\t\tif self=cell[136] {\n\t\t\tres[3] <- cell[152];\n\t\t}\n\t\tif self=cell[152] {\n\t\t\tres[1] <- cell[136];\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\taspect default {\n\t\tif has_food {\n\t\t\tdraw circle(0.1) color:#white;\n\t\t}\n\t\tif has_superpower {\n\t\t\tdraw circle(0.3) color:#white;\n\t\t}\n\t\tif is_wall {\n\t\t\tloop c over: neighbors {\n\t\t\t\tif not c.is_wall {\n\t\t\t\t\tdraw c intersection self color:#yellow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}\n\nspecies ghost skills:[moving]{\n\tstring name;\n\tstring mode <- \"scatter\";\n\trgb color;\n\tpoint target;\n\tpoint scatter_point;\n\tbool can_move<-false;\n\tfloat total_frightened_time <- 0#s;\n\tfloat start_fright <- 0#s;\n\tbool will_move_start<-true;\n\tfloat speed update: mode=\"frightened\" ? world.ghost_speed()*0.55:world.ghost_speed();\n\t\n\treflex will_move when: (not can_move) and will_move_start{\n\t\tif name = \"Inky\" {\n\t\t\tif length(cell select each.has_food) < 112 {\n\t\t\t\tcan_move <- true;\n\t\t\t\twill_move_start <- false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif name = \"Clyde\" {\n\t\t\tif length(cell select each.has_food) < 43 {\n\t\t\t\tcan_move <- true;\n\t\t\t\twill_move_start <- false;\n\t\t\t}\n\t\t}\n\t\tif name in [\"Blinky\", \"Pinky\"] {\n\t\t\twill_move_start <- false;\n\t\t}\n\t}\n\t\n\taspect default {\n\t\t\n\t\tdraw square(0.8) color:mode=\"frightened\" ? #darkblue : color;\n\t}\n\taspect png {\n\t\timage_file select_file;\n\t\t//write \"../includes/\"+name+string(mod(int(heading/90)+1, 4))+\".png\";\n\t\tif mode=\"frightened\" {\n\t\t\tselect_file <- image_file(\"../includes/frightened.png\");\n\t\t\tif time>start_fright+3 and time<start_fright+5 {\n\t\t\t\tif round(time-start_fright) = int(time-start_fright) {\n\t\t\t\t\tselect_file <- image_file(\"../includes/frightened_2.png\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\tselect_file <- image_file(\"../includes/\"+name+string(mod(int(heading/90)+1, 4))+\".png\");\n\t\t\n\t\t}\n\t\t\n\t\tdraw select_file size:0.98#m at:location + {0,0.03};\n\t\t\n\t\t\n\t}\n\treflex scatter when:mode=\"scatter\" and can_move{\n\t\ttarget <- scatter_point;\n\t}\n\t\n\treflex chase when:mode=\"chase\" and can_move{\n\t\tswitch name {\n\t\t\tmatch \"Blinky\" {\n\t\t\t\ttarget <- pac[0].my_cell.location;\n\t\t\t}\n\t\t\tmatch \"Pinky\" {\n\t\t\t\tpoint pac_cell <- pac[0].my_cell.location;\n\t\t\t\t\n\t\t\t\tswitch pac[0].orientation {\n\t\t\t\t\tmatch 0 {\n\t\t\t\t\t\ttarget <- pac_cell + {0, -2};\n\t\t\t\t\t}\n\t\t\t\t\tmatch 1 {\n\t\t\t\t\t\ttarget <- pac_cell + {2, 0};\n\t\t\t\t\t}\n\t\t\t\t\tmatch 2 {\n\t\t\t\t\t\ttarget <- pac_cell + {0, 2};\n\t\t\t\t\t}\n\t\t\t\t\tmatch 3 {\n\t\t\t\t\t\ttarget <- pac_cell + {-2, 0};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttarget <- (cell select(not each.is_wall) closest_to target).location;\n\t\t\t\t\n\t\t\t}\n\t\t\tmatch \"Inky\" {\n\t\t\t\tpoint over_pac <- pac[0].my_cell.custom_neighbors()[pac[0].orientation].location;\n\t\t\t\ttarget <- {2*over_pac.x - ghost[0].location.x, 2*over_pac.y - ghost[0].location.y};\n\t\t\t\ttarget <- (cell select(not each.is_wall) closest_to target).location;\n\t\t\t}\n\t\t\tmatch \"Clyde\" {\n\t\t\t\tif self distance_to pac[0].location > 8 {\n\t\t\t\t\ttarget <- pac[0].my_cell.location;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttarget <- scatter_point;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treflex wanderr when:not can_move {\n\t\tif flip(step) {\n\t\ttarget <- any(cell[7,8], cell[8,8], cell[9,8]).location;\n\t\t\n\t\t}\n\t\tif target = location {\n\t\t\ttarget <- any([cell[7,8], cell[8,8], cell[9,8]] - cell closest_to self).location;\n\t\t}\n\t\tdo goto target:target on:the_graph2;\n\t}\n\treflex move when:can_move and not (mode=\"frightened\"){\n\t\tdo goto target:target on:the_graph;\n\t}\n\treflex move_frightened when:can_move and mode=\"frightened\" {\n\t\tif flip(step) {\n\t\t\t\n\t\ttarget <- any(cell).location;\n\t\t\n\t\t}\n\t\tdo goto target:target on:the_graph;\n\t\tif pac[0].my_cell = cell closest_to self {\n\t\t\tworld.score <- world.score + kill_unit;\n\t\t\tlocation <- cell[8,8].location;\n\t\t\tcan_move <- false;\n\t\t}\n\t}\n\treflex kill when: not (mode=\"frightened\"){\n\t\tif pac[0].my_cell = cell closest_to self {\n\t\t\task world{\n\t\t\t\tdo game_over;\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treflex cure when: time = start_fright + 5#s and time > 5#s{\n\t\tmode <- \"chase\";\n\t\tcan_move <- true;\n\t}\n\t\n\treflex change_mode when:time_a>=7 + total_frightened_time#s and time_a<= 27+total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"chase\";\n\t}\n\treflex change_mode2 when:time_a>=27 + total_frightened_time#s and time_a<= 34+total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"scatter\";\n\t}\n\treflex change_mode3 when:time_a>=34 + total_frightened_time#s and time_a<= 54+total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"chase\";\n\t}\n\treflex change_mode4 when:time_a>=54 + total_frightened_time#s and time_a<= 59+total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"scatter\";\n\t}\n\treflex change_mode5 when:time_a>=59 + total_frightened_time#s and time_a<= 79+total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"chase\";\n\t}\n\treflex change_mode6 when:time_a>=79 + total_frightened_time#s and time_a<= 84+total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"scatter\";\n\t}\n\treflex change_mode7 when:time_a>=84 + total_frightened_time#s and mode!=\"frightened\" {\n\t\tmode <- \"chase\";\n\t}\n\t\n\t\n}\n\n\nexperiment main {\n\tfloat minimum_cycle_duration<-20#ms;\n\t\n\t\n\t\n\toutput {\n\t\t\n\t\tlayout 0 tabs:false editors: false;\t\n\t\t\n\t\tdisplay main fullscreen:false type:2d antialias:false toolbar:false background:hsb( (level mod 360)/360.0 * 20, 0.2,0.7) axes:true{\n\n\t\t\tgrid cell ;\n\t\t\tspecies cell;\n\t\t\tspecies pac aspect:default;\n\t\t\tspecies ghost aspect:png;\n\t\t\tgraphics scoreboard position:{0,17} size:{17,2} background:#black border:#yellow{\n\t\t\t\tdraw shape color:#black;\n\t\t\t\tdraw polyline({0,0}, {17,0}) color:#yellow;\n\t\t\t\t\n\t\t\t\tdraw \"Score\" at:{15, 8.5} font:font(\"Arial\", 20);\n\t\t\t\tdraw get_score(score) at: {14.8,14} font:font(\"Arial\", 20, #bold);\n\t\t\n\t\t\t\tdraw \"Level \" at: {2,8.5} font:font(\"Arial\", 20);\n\t\t\t\tdraw string(level+1) at: {2.5,14} font:font(\"Arial\", 20, #bold);\n\t\t\t\t\n\t\t\t\tif not has_started {\n\t\t\t\t\tdraw \"Press an arrow to start\" at:{5.0,11} font:font(\"Helvetica Neue\", 25, #bold + #italic);\n\t\t\t\t}\n\t\t\t\telse if end_of_game {\n\t\t\t\t\tdraw \"Press R to restart\" at:{6.1,11} font:font(\"Helvetica Neue\", 25, #bold + #italic);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics \"borders\" {\n\t\t\t\tdraw world.shape -0.001 wireframe:true color:#black width:2;\n\t\t\t}\n\t\t\t\n\t\t\tevent #arrow_up {\n\t\t\t\task simulation {\n\t\t\t\t\tif not has_started {\n\t\t\t\t\t\thas_started <- true;\n\t\t\t\t\t\tdo resume;\n\t\t\t\t\t}\n\t\t\t\t\task pac {\n\t\t\t\t\t\torientation_query <- 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #arrow_right {\n\t\t\t\task simulation {\n\t\t\t\t\tif not has_started {\n\t\t\t\t\t\thas_started <- true;\n\t\t\t\t\t\tdo resume;\n\t\t\t\t\t}\n\t\t\t\t\task pac {\n\t\t\t\t\t\torientation_query <- 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #arrow_down {\n\t\t\t\task simulation {\n\t\t\t\t\tif not has_started {\n\t\t\t\t\t\thas_started <- true;\n\t\t\t\t\t\tdo resume;\n\t\t\t\t\t}\n\t\t\t\t\task pac {\n\t\t\t\t\t\torientation_query <- 2;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #arrow_left {\n\t\t\t\task simulation {\n\t\t\t\t\tif not has_started {\n\t\t\t\t\t\thas_started <- true;\n\t\t\t\t\t\tdo resume;\n\t\t\t\t\t}\n\t\t\t\t\task pac {\n\t\t\t\t\t\torientation_query <- 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent \" \" {\n\t\t\t\task simulation {\n\t\t\t\t\tdo resume;\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent \"r\" {\n\t\t\t\task agents-world-cell {\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\tscore <- 0;\n\t\t\t\t\n\t\t\t\task simulation {\n\t\t\t\t\tdo init_a;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates traffic flow on a road network with 25 cars, displaying their speed and acceleration over time.", "gaml_code": "/***\n* Name: NetlogoTrafficmodel\n* Author: Benoit Gaudou (for the reimplementation), Wilensky, U. (for the original model)\n* Description: This model is a reimplementation of the Netlogo model \"Traffic model\"\n*     Wilensky, U. (1997). NetLogo Traffic Basic model. http://ccl.northwestern.edu/netlogo/models/TrafficBasic. \n*     Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\n*  It has been implemented with the Netlogo platform:\n*     Wilensky, U. (1999). NetLogo. http://ccl.northwestern.edu/netlogo/. \n*     Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\n* Tags: traffic, transport, congestion, netlogo\n***/\n\nmodel NetlogoTrafficmodel\n\nglobal torus: true {\n\tint pavement_width <- 50;\n\tint pavement_height <- 9;\n\t\n\tgeometry shape <- rectangle(pavement_width * 2, pavement_height * 2);\t\n\timage_file voit_image_file <- image_file(\"../includes/voit.png\");\n\timage_file voit_red_image_file <- image_file(\"../includes/voit_red.png\");\n\n\tint y_road <- 4;\n\tcar sample_car;\n\t\n\tint nb_cars <- 25;\n\tfloat acceleration <- 0.0045 min: 0.0 max: 0.01;\n\tfloat deceleration <- 0.026 min: 0.0 max: 0.1;\t\n\t\n\tfloat max_speed <- 50.0;\n\t\n\tinit {\n\t\tlist<pavement> road <- pavement where(each.grid_y = y_road);\n\t\tcreate car number: nb_cars {\n\t\t\tpavement free_pavement <- one_of(road where(empty(car inside self)));\n\t\t\tif(free_pavement != nil) {\n\t\t\t\tmy_pavement <- free_pavement;\n\t\t\t\tlocation <- my_pavement.location;\n\t\t\t} else {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\theading <- 0.0;\n\t\t}\n\t\t\n\t\tsample_car <- one_of(car);\n\t\task sample_car {\n\t\t\tcolor <- #red;\n\t\t\ticon <- voit_red_image_file;\n\t\t}\n\t}\n}\n\ngrid pavement height: pavement_height width: pavement_width {\n\tinit {\n\t\tif( (grid_y >= 3) and (grid_y <=5) ) {\n\t\t\tcolor <- #white;\n\t\t} else {\n\t\t\tcolor <- #black;\n\t\t}\n\t}\n}\n\nspecies car skills: [moving] {\n\tfloat speed_limit;\n\tfloat speed_min;\n\trgb color;\n\timage_file icon;\n\tpavement my_pavement;\n\t\n\tinit {\n\t\tcolor <- #blue;\n\t\ticon <- voit_image_file;\n\t\tspeed <- 0.1 +rnd(0.9);\n\t\tspeed_limit <- 1.0;\n\t\tspeed_min <- 0.0;\n\t}\n\t\n\treflex patch_ahead {\n\t\tmy_pavement <- pavement first_with(each overlaps self);\n\t\tpavement next_pavement <- pavement first_with( \n\t\t\t\t\t\t\t\t\t\t(each.grid_y = my_pavement.grid_y) and \n\t\t\t\t\t\t\t\t\t\t(each.grid_x = (my_pavement.grid_x + signum(cos(heading))) mod pavement_width)\n\t\t);\n\t\tcar car_ahead <- first(car inside next_pavement);\n\t\tif(car_ahead != nil) {\n\t\t\tdo slow_down(car_ahead);\n\t\t} else {\n\t\t\tdo speed_up;\n\t\t}\n\t\t\n\t\tdo move heading: heading;\n\t}\n\n\taction slow_down(car car_ahead) {\n\t\tspeed <- max(speed_min, car_ahead.speed - deceleration) ;\n\t}\n\t\n\taction speed_up {\n\t\tspeed <- min(speed + acceleration, speed_limit);\n\t}\n\n\taspect rect {\n\t\tdraw rectangle(1.5,1) rotated_by heading color: color border: #black;\n\t}\n\t\n\taspect icon {\n\t\tdraw icon at: location size: 3 rotate: heading ;\n\t}\t\n}\n\nexperiment NetlogoTrafficmodel type: gui {\n\t\n\t\t\n\tparameter \"Number of cars\" var:nb_cars;\n\tparameter \"Acceleration\" var:acceleration;\n\tparameter \"Decdeleration\" var:deceleration;\n\t\n\tfloat minimum_cycle_duration <- 0.01;\n\t\n\toutput {\n\t\tlayout #vertical;\n\t\t\n\t\tdisplay road type: 2d antialias:false{\n\t\t\tgrid pavement;\n\t\t\tspecies car aspect: icon;\n\t\t\t\n\t\t}\n\t\t\n\t\tdisplay sp  type: 2d {\n\t\t\tchart \"speed\" type: series {\n\t\t\t\tdata \"red car\" value: sample_car.speed * max_speed color: #red;\n\t\t\t\tdata \"min speed\" value: car min_of(each.speed) * max_speed color: #blue;\n\t\t\t\tdata \"max speed\" value: car max_of(each.speed) * max_speed color: #green;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a traffic model that simulates the movement of people and vehicles on a road network, taking into account pollution levels and road capacity.", "gaml_code": "/**\n* Name: Traffic\n* Author: Patrick Taillandier & Alexis Drogoul\n* Description: A simple traffic model with a pollution model: the speed on a road depends on the number of people \n* on the road (the highest, the slowest), and the people diffuse pollution on the envrionment when moving.\n* Tags: gis, shapefile, graph, skill, transport, field\n*/\nmodel traffic\n\nglobal {\n//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/buildings.shp\");\n\t//Shapefile of the roads\n\tfile road_shapefile <- file(\"../includes/roads.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(building_shapefile) + envelope(road_shapefile);\n\t//Step value\n\tfloat step <- 10 #s;\n\tfield cell <- field(300,300);\n\t//Graph of the road network\n\tgraph road_network;\n\t//Map containing all the weights for the road network graph\n\tmap<road, float> road_weights;\n\n\tinit {\n\t//Initialization of the building using the shapefile of buildings\n\t\tcreate building from: building_shapefile;\n\n\t\t//Initialization of the road using the shapefile of roads\n\t\tcreate road from: road_shapefile; \n\n\t\t//Creation of the people agents\n\t\tcreate people number: 1000 {\n\t\t//People agents are located anywhere in one of the building \n\t\t\tlocation <- any_location_in(one_of(building));\n\t\t\tstate <- flip(0.75) ? \"ok\" : \"notok\";\n\t\t}\n\t\t//Weights of the road\n\t\troad_weights <- road as_map (each::each.shape.perimeter);\n\t\troad_network <- as_edge_graph(road);\n\t}\n\t//Reflex to update the speed of the roads according to the weights\n\treflex update_road_speed {\n\t\troad_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);\n\t\troad_network <- road_network with_weights road_weights;\n\t}\n\n\t//Reflex to decrease and diffuse the pollution of the environment\n\treflex pollution_evolution {\n\t\t//ask all cells to decrease their level of pollution\n\t\tcell <- cell * 0.8;\n\t\n\t\t//diffuse the pollutions to neighbor cells\n\t\tdiffuse var: pollution on: cell proportion: 0.9;\n\t}\n\n}\n\n//Species to represent the people using the skill moving\nspecies people skills: [moving] {\n//Target point of the agent\n\tpoint target;\n\t//Probability of leaving the building\n\tfloat leaving_proba <- 0.05;\n\t//Speed of the agent\n\tfloat speed <- rnd(10) #km / #h + 1;\n\t// Random state\n\tstring state;\n\t//Reflex to leave the building to another building\n\treflex leave when: (target = nil) and (flip(leaving_proba)) {\n\t\ttarget <- any_location_in(one_of(building));\n\t}\n\t//Reflex to move to the target building moving on the road network\n\treflex move when: target != nil {\n\t//we use the return_path facet to return the path followed\n\t\tpath path_followed <- goto(target: target, on: road_network, recompute_path: false, return_path: true, move_weights: road_weights);\n\n\t\t//if the path followed is not nil (i.e. the agent moved this step), we use it to increase the pollution level of overlapping cell\n\t\tif (path_followed != nil and path_followed.shape != nil) {\n\t\t\tcell[path_followed.shape.location] <- cell[path_followed.shape.location] + 10;\t\t\t\t\t\n\t\t}\n\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t} }\n\n\taspect default {\n\t\tdraw rectangle(4,10) rotated_by (heading+90) color:( #dodgerblue) depth: 3;\n\t\tdraw rectangle(4, 6) rotated_by (heading+90) color:( #dodgerblue) depth: 4;\n\t} }\n\t//Species to represent the buildings\nspecies building {\n\n\taspect default {\n\t\tdraw shape color: darker(#darkgray).darker depth: rnd(10) + 2;\n\t}\n\n}\n//Species to represent the roads\nspecies road {\n//Capacity of the road considering its perimeter\n\tfloat capacity <- 1 + shape.perimeter / 30;\n\t//Number of people on the road\n\tint nb_people <- 0 update: length(people at_distance 1);\n\t//Speed coefficient computed using the number of people on the road and the capicity of the road\n\tfloat speed_coeff <- 1.0 update: exp(-nb_people / capacity) min: 0.1;\n\tint buffer <- 10;\n\n\taspect default {\n\t\tdraw (shape + 5) color: #white;\n\t}\n\n}\n\nexperiment traffic type: gui autorun: true{\n\tfloat minimum_cycle_duration <- 0.01;\n\tlist<rgb> pal <- palette([ #black, #green, #yellow, #orange, #orange, #red, #red, #red]);\n\tmap<rgb,string> pollutions <- [#green::\"Good\",#yellow::\"Average\",#orange::\"Bad\",#red::\"Hazardous\"];\n\tmap<rgb,string> legends <- [rgb(darker(#darkgray).darker)::\"Buildings\",rgb(#dodgerblue)::\"Cars\",rgb(#white)::\"Roads\"];\n\tfont text <- font(\"Arial\", 14, #bold);\n\tfont title <- font(\"Arial\", 18, #bold);\n\t\n\toutput synchronized: true{\n\t\tdisplay carte type: 3d axes: false background: rgb(50,50,50) fullscreen: false toolbar: false{\n\t\t\t\n\t\t\t overlay position: { 50#px,50#px} size: { 1 #px, 1 #px } background: # black border: #black rounded: false \n            \t{\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                \n                draw \"Pollution\" at: {0, 0} anchor: #top_left  color: #white font: title;\n                float y <- 50#px;\n                draw rectangle(40#px, 160#px) at: {20#px, y + 60#px} wireframe: true color: #white;\n             \n                loop p over: reverse(pollutions.pairs)\n                {\n                    draw square(40#px) at: { 20#px, y } color: rgb(p.key, 0.6) ;\n                    draw p.value at: { 60#px, y} anchor: #left_center color: # white font: text;\n                    y <- y + 40#px;\n                }\n                \n                y <- y + 40#px;\n                draw \"Legend\" at: {0, y} anchor: #top_left  color: #white font: title;\n                y <- y + 50#px;\n                draw rectangle(40#px, 120#px) at: {20#px, y + 40#px} wireframe: true color: #white;\n                loop p over: legends.pairs\n                {\n                    draw square(40#px) at: { 20#px, y } color: rgb(p.key, 0.8) ;\n                    draw p.value at: { 60#px, y} anchor: #left_center color: # white font: text;\n                    y <- y + 40#px;\n                }\n            }\n\t\t\t\n\t\t\tlight #ambient intensity: 128;\n\t\t\tcamera 'default' location: {1254.041,2938.6921,1792.4286} target: {1258.8966,1547.6862,0.0};\n\t\t\tspecies road refresh: false;\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\n\t\t\t//display the pollution grid in 3D using triangulation.\n\t\t\tmesh cell scale: 9 triangulation: true transparency: 0.4 smooth: 3 above: 0.8 color: pal;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Simulate traffic flow on a road with multiple sections using the LWR model, allowing for congestion and varying maximum speeds, and display the concentration and flow of each section over time.", "gaml_code": "/**\n* Name: Trafic Group (R2D2) MAPS7 - LWR Model\n* Author: A. Banos, N. Corson, C. Pivano, L. Rajaonarivo, P. Taillandier\n* Description: The LWR model was proposed by Lighthill and Whitham (1955) and by Richards (1956). \n* It describes the trafic at a global level considering the speed, concentration and flows without taking into account the individual behavior af vehicles. \n* Speed, concentration and flow are the three components of the LWR model. \n* This models reproduces flow of traffic and congestion in specific conditions (homogeneous traffic), \n* going from one equilibrium state to another (see the fundamental diagramm of traffic, which gives flow according to concentration).\n* \n* In this model, a road is divided into sections and we arbitrarily give to the middle section a lower speed and critical concentration.\n* Tags: transport\n*/\n\n\nmodel TraficGroup\n\nglobal {\n\t\n\tfloat monit <- sum(section collect each.current_concentration) update: sum(section collect each.current_concentration);\n\t\t\n\tfloat road_size <- 10 #km ; \t\t\t\t\t\t// Size of the road\n\t\n\tgeometry shape <- rectangle (road_size, 200 #m) ; \t// The world is a rectangle with a length equals to the size of the road and a height of 200m\n\t\t\n\tfloat time_step <- 1.0 ; \t\t\t\t\t\t\t// Time step \n\tint nb_sections <- 10 ; \t\t\t\t\t\t\t// Number of sections of the road\n\tfloat section_size <- road_size / nb_sections ; \t// Size of a section\n\t\n\tfloat car_size <- 4 #m ;\t\t\t\t\t\t\t\t\t// Size of a car\n\tfloat nb_max_cars_on_section <- section_size / car_size ;\t// Maximum number of cars on one section \n\t\n\t   init{\n\t   \t\t\n\t   \t\t// Creation of the nb_sections sections which compose the road. \n\t   \t\t\n\t\t   loop i from: 0 to: (nb_sections - 1){\n\t\t   \t  create section with: [shape:: line([{i * section_size , 100},{(i +1) * section_size , 100}])];\n\t\t   }\n\t\t   \t\n\t\t   \t// For each section, as we need to have information concerning the previous and the next one, we define which section is the previous and which is the next.\n\t\t   \t// The previous section is the one which last point corresponds to the first point of the actual section. \n\t\t   \t// The next section is the one which first point corresponds to the last point of the actual section. \n\t\t   \t\n\t    \task section{\n\t    \t\tprevious <- section first_with (last(each.shape.points) = first(self.shape.points)) ;\n\t    \t\tnext <- section first_with (first(each.shape.points) = last(self.shape.points)) ;\n\t    \t}\n\t\n\t    \t// For each section, we define a critical concentration (see the fundamental diagram), a maximum speed, a concentration and a flow (which are = 0 at initialization). \n\t    \t// A fundamental relation about trafic gives : flow = concentration * speed.\n\t    \t\n\t    \task section{\n\t    \t\tcritical_concentration <- 125.0 ; //Kc\n\t\t\t\tmax_speed <- 50 #km/#h; // Vl\n\t\t\t\tcurrent_concentration <- 0.0 ;\n\t\t\t\tcurrent_flow <- current_concentration * max_speed ;\n\t\t\t\tmax_flow <- critical_concentration * max_speed ; \n\t    \t}\n\t    \t\t    \t\n\t    \t// The concentration and flow ot first section are initialized.\n\t    \t\n\t    \task section[0]{\n\t    \t\tcurrent_concentration <- nb_max_cars_on_section ;\n\t\t\t\tcurrent_flow <- current_concentration * max_speed ;\n\t    \t}\n\t    \t\n\t    \t// The middle section is supposed to have a different maximum speed and a different critical concentration so that we can observe congestion phenomenon.\n\t    \t// This middle section is green.\n\t    \t\n\t    \task section[int(nb_sections/2)] {\n\t    \t\t\tcritical_concentration <- 10.0 ; \n\t    \t\t\tmax_flow <- critical_concentration * max_speed ; \n\t\t\t\t    max_speed <- 10 #km/#h; \n\t\t\t\t\tcolor <- #green;\n\t    \t}\n    \t}\n    \t\n   // To update flow and concentration at each time step in each section, we use an offer and a demand function. \n   // These functions define the welcome capacity (offer) and the emission capacity (demand) of a section.\n   \n    reflex offer_function {\n\t     ask section {\n\t\t\t  if current_concentration <= critical_concentration {\n\t\t\t  \toffer <- max_flow ;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t  \toffer <- max([0 , (- max_flow / critical_concentration) * current_concentration + 2 * max_flow ]);\n\t\t\t  }\n\t\t  \n\t  }\n\t}\n\t\n\treflex demand_function {\n\t\task section{\n\t\t\t  if current_concentration <= critical_concentration {\n\t\t\t  \t\tdemand <- max([0 , ( max_flow / critical_concentration) * current_concentration]) ;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t  \t\tdemand <- max_flow ;\n\t\t\t  }\n\t\t}\n\t}\n\t\n\t// The flow and concentration are then updated according to the offer and demand functions of the current section, but also of the next and previous ones.\n\t\n\t// During a time step, the flow of a section take the minimum value between its demand and the offer of the next section.\n\t// The flow of the last section is equal to its demand.\t\n\t\n\treflex update_flow{\n\t\task section  {\n\t\t\tfloat next_offer <-  (self.next != nil) ? (self.next).offer : self.demand;\n\t\t\tcurrent_flow <- min([self.demand, next_offer]);\n\t\t}\n\t}\n\t\n\t\n\t// After a time step, the concentration is updated from the current concentration, according to the incoming and outgoing concentrations.\n\t// The first section concentration on ly takes into account the outgoing concentration of vehicles.\n\t\n\treflex update_concentration{\n\t\task section   {\n\t\t\tfloat previous_flow <- (self.previous != nil) ? (self.previous).current_flow : 0.0;\n\t\t\tcurrent_concentration <- current_concentration + time_step/section_size *(previous_flow - self.current_flow) ;\n\t\t}\t\n\t}\n\t\n\t// When there is less than one car left on the road, the simulation stops.\n\t\n\treflex stop_simulation when: sum(section collect each.current_concentration) < 1.0 {\n\t\tdo pause;\n\t}\n}\n\n// A road is divided into sections. \n// Each section has a concentration, a flow, an offer and a demand, a critical concentration, a maximum speed and a maximum flow, \n// and a previous and a next section.\n\nspecies section {\n\tfloat current_concentration  ;\n\tfloat current_flow  ;\n\t\n\tfloat offer ;\n\tfloat demand  ;\n\t\n\t\n\tfloat critical_concentration ; \n\tfloat max_speed ; \n\tfloat max_flow ; \n\n\tsection previous ;\n\tsection next ;\n\t\n\t// The width of a section depends on its concentration.\n\t\n\taspect shape_section {\n\t\tdraw shape + (10 + 15 * ln (current_concentration + 1)) color: #gray + 128*current_concentration;\t\t\n\t} \n\n}\n\n\nexperiment TraficGroup type: gui {\n\n\t// Users can chose the number of sections and the time step.\n\n    parameter 'Number of sections' var: nb_sections category: \"Section parameter\";\n    parameter 'Time step - DeltaT' var: time_step category: \"Time parameter\";\n        \n\toutput {\n\t\t\n\t\t// A monitor can give the number of cars on the road at every time step.\n\t\t\n\t\t//monitor \"Sum Concentrations\" value: sum(section collect each.current_concentration);\n\t\t layout vertical([0::3472,horizontal([1::5000,2::5000])::6528]) tabs:true editors: false;\n\t\t\n\t\t// A display shows the road. Section width depend on their concentration.\n\t\tdisplay TheRoad type:3d axes:false{\n\t\t\tcamera 'default' location: {5044.1782,104.4563,2208.909} target: {5044.1782,104.4178,0.0};\t\t\t\n\t\t\tspecies section aspect: shape_section ;\n\t\t}\n\t\t\n\t\t// The greeen time series correspond to the middle section (on which concentration and maximum speed are lower).\n\t\t// The red time series correspond to the section just before the middle one.\n\t\t\t\t\n\t\tdisplay Concentrations  type: 2d {\n\t\t\tchart \"Concentrations\" type: series  {\n\t\t\t\tdata 'Section 0' value: section[0].current_concentration color: #gray marker: false ;\t\t\t\t\n\t\t\t\tdata 'Section 1' value: section[1].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 2' value: section[2].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 3' value: section[3].current_concentration color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 4' value: section[int(nb_sections/2 - 1 ) ].current_concentration color: #red marker: false;\n\t\t\t\tdata 'Section 5' value: section[int(nb_sections/2)].current_concentration color: #green marker: false;\n\t\t\t\tdata 'Section 6' value: section[6].current_concentration color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 7' value: section[7].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 8' value: section[8].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 9' value: section[9].current_concentration color: #gray marker: false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdisplay Flows  type: 2d {\n\t\t\t    chart \"Flows\" type: series  {\n\t\t\t\tdata 'Section 0' value: section[0].current_flow color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 1' value: section[1].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 2' value: section[2].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 3' value: section[3].current_flow color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 4' value: section[int(nb_sections/2 - 1)].current_flow color: #red marker: false;\n\t\t\t\tdata 'Section 5' value: section[int(nb_sections/2)].current_flow color: #green marker: false;\n\t\t\t\tdata 'Section 6' value: section[6].current_flow color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 7' value: section[7].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 8' value: section[8].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 9' value: section[9].current_flow color: #gray marker: false;\n\t\t\t\t}\n\t\t\t}\n\t}\n}"}
{"prompt": "Create a Netlogo model that simulates traffic flow on two roads with different acceleration and deceleration rates, allowing for comparison of congestion levels between the two scenarios.", "gaml_code": "/***\n* Name: NetlogoTrafficmodel2\n* Author: Benoit Gaudou\n* Description: This model is a variation of the \"Netlogo - Traffic model - 1 road.gaml\" in order to be able \n*     to visualise the impacts of parameters on the congestion and compare 2 scenarios of acceleration-deceleration. \n*     It is based on the Netlogo model \"Traffic model\".\n*     Wilensky, U. (1997). NetLogo Traffic Basic model. http://ccl.northwestern.edu/netlogo/models/TrafficBasic. \n*     Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\n*  It has been implemented with the Netlogo platform:\n*     Wilensky, U. (1999). NetLogo. http://ccl.northwestern.edu/netlogo/. \n*     Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\n* Tags: traffic, transport, congestion, netlogo\n***/\n\nmodel NetlogoTrafficmodel\n\nglobal torus: true {\n\tint pavement_width <- 50;\n\tint pavement_height <- 14;\n\t\n\tgeometry shape <- rectangle(pavement_width * 2, pavement_height * 2);\t\n\timage_file voit_image_file <- image_file(\"../includes/voit.png\");\n\timage_file voit_red_image_file <- image_file(\"../includes/voit_red.png\");\n\timage_file voit_blue_image_file <- image_file(\"../includes/voit_blue.png\");\n\n\tint y_road1 <- 4;\n\tint y_road2 <- 10;\n\tlist<car> cars_on_road1;\n\tlist<car> cars_on_road2;\n\tcar sample_car1;\n\tcar sample_car2;\t\n\tlist<pavement> road1;\n\tlist<pavement> road2;\n\t\n\tint nb_cars <- 25;\n\tfloat acceleration1 <- 0.0045 min: 0.0 max: 0.01;\n\tfloat deceleration1 <- 0.026 min: 0.0 max: 0.1;\t\n\tfloat acceleration2 <- 0.0025 min: 0.0 max: 0.01;\n\tfloat deceleration2 <- 0.013 min: 0.0 max: 0.1;\t\n\n\tfloat max_speed <- 50.0;\n\t\n\tinit {\n\t\troad1 <- pavement where(each.grid_y = y_road1);\n\t\tcars_on_road1 <- create_cars_on_road(1, road1,1);\n\t\tsample_car1 <- pick_sample(cars_on_road1, #red, voit_red_image_file);\n\t\t\n\t\troad2 <- pavement where(each.grid_y = y_road2);\t\t\n\t\tcars_on_road2 <- create_cars_on_road(1, road2,2);\n\t\tsample_car2 <- pick_sample(cars_on_road2, #blue, voit_blue_image_file);\t\t\n\t}\n\t\n\treflex create_cars when: (length(car) < nb_cars * 2) and every(10 #cycles) {\n\t\tdo create_cars_on_road(1, road1, 1);\n\t\tdo create_cars_on_road(1, road2, 2);\t\t\n\t}\n\t\n\tlist<car> create_cars_on_road(int num_cars, list<pavement> road, int t){\n\t\tcreate car number: num_cars returns: cars_on_road {\n\t\t\tpavement free_pavement <- one_of(road where(empty(car inside self)));\n\t\t\tif(free_pavement != nil) {\n\t\t\t\tmy_pavement <- free_pavement;\n\t\t\t\tlocation <- my_pavement.location;\n\t\t\t\ttype <- t;\n\t\t\t} else {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\theading <- 0.0;\n\t\t}\n\t\t\n\t\treturn cars_on_road;\t\t\n\t}\n\t\n\tcar pick_sample(list<car> cars, rgb col, image_file _icon) {\n\t\tcar a_car <- one_of(cars);\n\t\task a_car {\n\t\t\tcolor <- col;\n\t\t\ticon <- _icon;\n\t\t}\t\n\t\treturn a_car;\t\n\t}\n\n}\n\ngrid pavement height: pavement_height width: pavement_width {\n\tinit {\n\t\tif( (grid_y >= y_road1 - 1) and (grid_y <= y_road1 + 1) ) or \n\t\t  ( (grid_y >= y_road2 - 1) and (grid_y <= y_road2 + 1)) {\n\t\t\tcolor <- #white;\n\t\t} else {\n\t\t\tcolor <- #black;\n\t\t}\n\t}\n}\n\nspecies car skills: [moving] {\n\tfloat speed_limit;\n\tfloat speed_min;\n\tfloat acceleration;\n\tfloat deceleration;\n\trgb color;\n\timage_file icon;\n\tpavement my_pavement;\n\tint type;\n\t\n\tinit {\n\t\tcolor <- #blue;\n\t\ticon <- voit_image_file;\n\t\tspeed <- 0.1 +rnd(0.9);\n\t\tspeed_limit <- 1.0;\n\t\tspeed_min <- 0.0;\n\t}\n\t\n\treflex patch_ahead {\n\t\tmy_pavement <- pavement first_with(each overlaps self);\n\t\tpavement next_pavement <- pavement first_with( \n\t\t\t\t\t\t\t\t\t\t(each.grid_y = my_pavement.grid_y) and \n\t\t\t\t\t\t\t\t\t\t(each.grid_x = (my_pavement.grid_x + signum(cos(heading))) mod pavement_width)\n\t\t);\n\t\tcar car_ahead <- first(car inside next_pavement);\n\t\tif(car_ahead != nil) {\n\t\t\tdo slow_down(car_ahead);\n\t\t} else {\n\t\t\tdo speed_up;\n\t\t}\n\t\t\n\t\tdo move heading: heading;\n\t}\n\n\taction slow_down(car car_ahead) {\n\t\tspeed <- max(speed_min, car_ahead.speed - ((type=1)?deceleration1:deceleration2)) ;\n\t}\n\t\n\taction speed_up {\n\t\tspeed <- min(speed + ((type=1)?acceleration1:acceleration2), speed_limit);\n\t}\n\n\taspect rect {\n\t\tdraw rectangle(1.5,1) rotated_by heading color: color border: #black;\n\t}\n\t\n\taspect icon {\n\t\tdraw icon at: location size: 3 rotate: heading ;\n\t}\t\n}\n\nexperiment NetlogoTrafficmodel type: gui {\n\t\n\tparameter \"Acceleration 1\" var:acceleration1;\n\tparameter \"Deceleration 1\" var:deceleration1;\n\tparameter \"Acceleration 2\" var:acceleration2;\n\tparameter \"Deceleration 2\" var:deceleration2;\n\tfloat minimum_cycle_duration <- 0.01;\n\t\n\toutput {\n\t\tlayout #vertical;\n\t\tdisplay road type:2d antialias:false{\n\t\t\tgrid pavement /*border: #black*/;\n\t\t\tspecies car aspect: icon;\n\t\t\t\n\t\t}\n\n\t\tdisplay sp  type: 2d {\n\t\t\tchart \"speed\" type: series {\n\t\t\t\tdata \"red car\" value: sample_car1.speed * max_speed color: sample_car1.color;\n\t\t\t\tdata \"blue car\" value: sample_car2.speed * max_speed color: sample_car2.color;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a hydrological model that simulates flooding and water flow in a city with dykes and buildings, using GIS data to represent terrain elevation and obstacles.", "gaml_code": "/**\n* Name: Hydrological Model\n* Author: Patrick Taillandier\n* Description: A model showing how to represent a flooding system with dykes and buildings. It uses \n* \ta grid to discretize space, and has a 3D display. The water can flow from one cell to another considering \n* \tthe height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them \n* \tin the display.\n* Tags: shapefile, gis, grid, 3d, gui, hydrology\n*/\n\nmodel hydro\n\nglobal {\n\t\n   //Shapefile for the river\n   file river_shapefile <- file(\"../includes/RedRiver.shp\");\n   //Shapefile for the dykes\n   file dykes_shapefile <- file(\"../includes/Dykes.shp\");\n   //Shapefile for the buildings\n   file buildings_shapefile <- file(\"../includes/Building.shp\");\n   \n   //Data elevation file\n   file dem_file <- file(\"../includes/mnt50.asc\");  \n   //Diffusion rate\n   float diffusion_rate <- 0.6;\n   //Height of the dykes\n   float dyke_height <- 15.0;\n   //Width of the dyke\n   float dyke_width <- 15.0;\n    \n   //Shape of the environment using the dem file\n   geometry shape <- envelope(dykes_shapefile);\n   \n   //List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1#h;\n   \n   init {\n   \t //Initialization of the cells\n      do init_cells;\n     //Initialization of the water cells\n      do init_water;\n     //Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     //Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     //Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      //Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell  {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   //action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river  {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   //initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke  {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n      \talready <- false;\n         do flow;\n      }\n   }\n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell  {\n         do update_color;\n      }\n   }\n   //Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n//Species which represent the obstacle\n   species obstacle  {\n   \t  //height of the obstacle\n      float height min: 0.0;\n      //Color of the obstacle\n      rgb color;\n      //Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      //List of cells concerned\n      list<cell> cells_concerned ;\n      //List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      //Action to compute the water pressure\n      float compute_water_pressure {\n      \t//If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t//The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            //Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level / height]);\n         } \n      }\n      \n      //Action to update the cells\n      action update_cells {\n      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t//Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         //Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         //The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t//We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   //Species buildings which is derivated from obstacle\n   species buildings parent: obstacle schedules: [] {\n   \t //The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   //Species dyke which is derivated from obstacle\n   species dyke parent: obstacle {\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      //Action to represent the break of the dyke\n       action break{\n         ask cells_concerned  {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      //Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      //user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   //Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false schedules: []  {\n      //Altitude of the cell\n      float altitude;\n      //Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      //Height of the cell\n      float height;\n      //List of the neighbour cells\n      list<cell> neighbour_cells ;\n      //Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      //Boolean to know if it is a river cell\n      bool is_river <- false;\n      //List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      //Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      //Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      //action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment Run type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n   //layout vertical([0::5000,1::5000]) tabs:false editors: false;\n      display map type: 3d {\n         grid cell triangulation: true;\n         species buildings aspect: geometry refresh: false;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24#cycles)  type: 2d  { \n         chart \"Pressure on Dykes\" type: series legend_font: font(\"Helvetica\", 18)  label_font: font(\"Helvetica\", 20, #bold)  title_font: font(\"Helvetica\", 24, #bold){\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta  ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}"}
{"prompt": "Create a GAML model that simulates k-means clustering with interactive user input for selecting points and centroids, allowing users to visualize the impact of different cluster numbers on the algorithm's convergence.", "gaml_code": "/***\n* Name: MASKmeansInteractive\n* Author: Jean-Daniel Zucker\n* Description: Model which shows how to use the event layer to place points and initial centroids\n* to see the impact of choosing. \n* CHOOSE the experiment SelectPoints2Cluster\n* Click on the dot on the right palette to then click on the left display\n* so as to position points. Then click on the cross on the right palette (to position centroids). Then\n* drop a few centroids. Their number is the number of clusters searched for.\n* Then start to iterate on the simulation one at a time ak-means and see the kmeans algorithm.\n***/\n\nmodel MASKmeansInteractive\nimport \"Mas KMeans.gaml\"\n\nglobal {\n\n\t//current action type\n\tint action_type <- -1;\t\n\tlist<point> clicks <- [];\n\t\n\t//images used for the buttons\n\tlist<file> images <- [\n\t\tfile(\"../images/dot.jpg\"),\n\t\tfile(\"../images/cross.png\"),\n\t\tfile(\"../images/eraser.jpg\"),\n\t\tfile(\"../images/empty.png\")\n\t]; \n\t\n\n\t\n\treflex pauseAtConvergence when: converged { }\n\t\n\taction activate_act {\n\t\tbutton selected_but <- first(button overlapping (circle(1) at_location #user_location));\n\t\tif(selected_but != nil) {\n\t\t\task selected_but {\n\t\t\t\task button {bord_col<-#black;}\n\t\t\t\tif (action_type != id) {\n\t\t\t\t\taction_type<-id;\n\t\t\t\t\tbord_col<-#red;\n\t\t\t\t} else {\n\t\t\t\t\taction_type<- -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// We register the clicks asynchronously (when the user presses the mouse button)\n\t// No need to register the type of action as the simulation is supposed to run fast, so that \n\t// the user doesnt have the time, in one step, to click two times and change the action type in-between.\n\t// See issue #3626 on GAMA platform Github\n\taction register_click {\n\t\tclicks << #user_location;\n\t}\n\t\n\t// .. and we manage the points synchronously, in the normal scheduling of the model. The worst that can happen is \n\t// to miss one click if the user clicks very fast. \n\treflex manage_clicks {\n\t\tloop p over: clicks {\n\t\t\tdo cell_management(p);\n\t\t}\n\t\tclicks <- [];\n\t}\n\t\n\taction cell_management(point the_location) {\n\t\t//write agents;\n\t\tswitch action_type {\n\t\t\tmatch 0 {\n\t\t\t\tcreate datapoints with:(location : the_location);\n\t\t\t}\n\t\t\t\n\t\t\tmatch 1 {\n\t\t\t\tcreate centroids with:(location : the_location);\n\t\t\t\tint K <- length(centroids);\n\t\t  \t\tloop i from:0 to: K-1 { ask centroids[i] { color_kmeans  <- hsb(i/K,1,1); }}\n\t\t   }\n\t\t\t\t\n\t\t\tmatch 2 {\n\t\t\t\tlist<agent> close_ag <- (datapoints+centroids) overlapping (circle(5) at_location the_location);\n\t\t\t\tif not empty(close_ag) {\n\t\t\t\t\task close_ag closest_to the_location {\n\t\t\t\t\t\tif (self is datapoints ) {\n\t\t\t\t\t\t\tcentroids c <- datapoints(self).mycenter;\n\t\t\t\t\t\t\tif (c != nil) {\n\t\t\t\t\t\t\t\tc.mypoints >> self;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\task centroids(self).mypoints {\n\t\t\t\t\t\t\t\tmycenter <- nil;\n\t\t\t\t\t\t\t\tcolor_kmeans <- rgb(225,225,225) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdo die;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\t\n\t\t\t\n\t\t}\n\t}\n\n}\n\n\ngrid button width:2 height:2 \n{\n\tint id <- int(self);\n\trgb bord_col<-#black;\n\taspect normal {\n\t\tdraw rectangle(shape.width * 0.8,shape.height * 0.8).contour + (shape.height * 0.01) color: bord_col;\n\t\tdraw image_file(images[id]) size:{shape.width * 0.5,shape.height * 0.5} ;\n\t}\n}\n\n// To avoid displaying experiments coming from the inherited model MAS_KMEANS\nexperiment clustering2D type: gui virtual: true;\nexperiment clustering3D type: gui virtual: true;\n\nexperiment SelectPoints2Cluster2D type: gui autorun: true{\n\toutput {\n\t\tlayout horizontal([0.0::8000,1::2000]) tabs:true;\n\t\t\n\t\tdisplay map type:2d {\n\t\t\tevent #mouse_down {ask simulation {do register_click;}}\n\t\t\tspecies datapoints aspect: kmeans_aspect2D transparency:0.5;\n\t\t\tspecies centroids aspect: kmeans_aspect2D;\n\t\t\tgraphics \"Full target\"\n\t\t\t{\n\t\t\tif ! (globalIntraDistance = 0) {\n\t\t\t\t\t\tdraw \"Current sum of cluster intra-distance \" + globalIntraDistance with_precision(1)  at:{ 12, 4 } font: regular color: # black;\n\t\t\t\t\t\t}\n\t\t\t\n\t\t\tif converged {draw \"Algorithm has converged !\" + \" at cycle \"+ cycle at: { 60, 4 } font: regular color: # red; }\n\t\t\t}\n\t\t}\n\t\t//display the action buttons\n\t\tdisplay action_buton background:#white name:\"Tools panel\" type:2d\t{\n\t\t\tspecies button aspect:normal ;\n\t\t\tevent #mouse_down {ask simulation {do activate_act;}}   \n\t\t}\n\n\t}\n}"}
{"prompt": "Implement a K-means clustering algorithm with visualization for 2D and 3D data points, allowing users to adjust cluster count and point number.", "gaml_code": "/**\n* Name: Agent Based Clustering\n* Author: Jean-Danie Zucker with Patrick Taillandier's and Arnaud Grignard's Help\n* Description: This model displays the step to stpe algorithm of k-means\n* See for  https://en.wikipedia.org/wiki/K-means_clustering ...\n* Clustering\n* The k-medoid could be added\n* To be added stop the simulation when convergence is reached\n* To be added an overlay\n* To be added position the points at the begining usug user interaction model...\n*/\nmodel MASKMEANS\n\n\nglobal\n{\n// the number of classes to create (kmeans)\n// It corresponds to the centroids\n\tint k ;\n\t// the number of points\n\tint N ;\n\t//number of dimensions\n\tint dimensions <- 2;\n\tfloat globalIntraDistance <- 0.0;\n\tbool converged <- false;\n\tfont regular <- font(\"Helvetica\", 12, # bold);\n\tinit\n\t{\n\t\t//create datapoints agents\n\t\tcreate datapoints number: N\n\t\t{\n\t\t\tif (dimensions = 3)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t\tif (dimensions = 2)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t}\n\t\t//create centroid agents\n\t\tcreate centroids number: k\n\t\t{\n\t\t\tif (dimensions = 3)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t\tif (dimensions = 2)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t}\n\t\tint K <- length(centroids);\n\t\tif (K > 0) {loop i from:0 to: K-1 { ask centroids[i] { color_kmeans  <- hsb(i/K,1,1); }}}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t//give a random color to each centroid (i.e. to each datapoints agents of the group)\n\t\t\t//\t\tloop c over: centroids { rgb col <- rnd_color(255); ask c { color_kmeans <- col;}}\n\t\t\n\t\n\t}\n\t\n\treflex pauseAtConvergence when: converged { do pause;\n\t\t\n\t}\n\treflex assign_points_to_centroid when: even(cycle)\n\t{\n\t    // The \"assignment\" step is also referred to as expectation step,\n\t\task centroids\n\t\t{\n\t\t\tmypoints <- list<datapoints> ([]);\n\t\t}\n\n\t\tloop pt over: datapoints\n\t\t{\n\t\t\task pt\n\t\t\t{\n\t\t\t\tif not empty(centroids) {\n\t\t\t\t\tmycenter <- centroids closest_to self;\n\t\t\t\t\tcolor_kmeans <- mycenter.color_kmeans;\n\t\t\t\t\tadd self to: mycenter.mypoints;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treflex update_centroids when: not even(cycle)\n\t{\n\t// the \"update step\" as maximization step,\n\t// making this algorithm a variant of the generalized expectation-maximization algorithm.\n\n\t//We give a random color to each group (i.e. to each datapoints agents of the group)\n\t\task centroids where (not empty(each.mypoints))\n\t\t{\n\t\t\tlocation <- mean(mypoints collect each.location);\n\t\t\tfloat oldist <- myIntraDistance;\n\t\t\tmyIntraDistance <- mypoints sum_of (each distance_to self);\n\t\t\tconverged <- (oldist-myIntraDistance) with_precision(2) = 0;\n\t\t}\n\t\t\n\t\tglobalIntraDistance <- centroids sum_of (each.myIntraDistance);\n\t}\n\n}\n\nspecies datapoints\n{\n\trgb color_kmeans <- rgb(225,225,225) \t;\n\tcentroids mycenter;\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw circle(2) color: color_kmeans border:color_kmeans-25;\n\t}\n\n\taspect kmeans_aspect3D\n\t{\n\t\tdraw sphere(2) color: color_kmeans ;\n\t}\n\n}\n\nspecies centroids\n{\n\trgb color_kmeans <-  rgb(225,225,225);\n\tlist<datapoints> mypoints;\n\tfloat myIntraDistance <- 0.0;\n\taspect kmeans_aspect2D\n\t{\n\t\t// explicitly loops over a copy of the points to avoid concurrency issues with the simulation\n\t\tloop pt over: copy(mypoints)\n\t\t{\n\t\t\tdraw line([location, pt]) + 0.1 color: color_kmeans;\n\t\t}\n\t\tdraw cross(3, 0.5) color: color_kmeans border:color_kmeans-25;\n\t}\n\n\taspect kmeans_aspect3D\n\t{\n\t\tloop pt over: mypoints\n\t\t{\n\t\t\tdraw line([location, pt], 0.2) color: color_kmeans;\n\t\t}\n\t\tdraw cube(5) color: color_kmeans border: # black;\n\t\t\n\t}\n\n}\n\nexperiment clustering2D type: gui\n{\n\tparameter \"Number of clusters to split the data into\" var: k init:4 category: \"KMEANS\";\n\tparameter \"Number of points to be clustered\" var: N init: 500;\n\t\n\t\t\n\tpoint target <- { 20, 95 };\n\toutput\n\t{\n\t\t\n\t\tdisplay map_kmeans type:3d axes:false{\n\n\t\t\tspecies datapoints aspect: kmeans_aspect2D transparency:0.4;\n\t\t\tspecies centroids aspect: kmeans_aspect2D;\n\t\t\t\n\t\t\tgraphics \"Full target\"\n\t\t\t{\n\t\t\t\tdraw rectangle(100, 5) color: # yellow  at: { 50, 2.5 };\n\t\t\t\tdraw rectangle(100, 4) color: # yellow at: { 50, target.y + 3 };\n\t\t\t\tif (not even(cycle))\n\t\t\t\t{\n\t\t\t\t// the \"update step\" as maximization step, (a mean is done to recenter)\n\t\t\t\t\tif ! (globalIntraDistance = 0) {\n\t\t\t\t\t\tdraw \"Current step was an estimation Step (each point is assigned the color of his nearest centroid\" at:{ 8, 2 } font: regular color: # green;\n\t\t\t\t\t\tdraw \"Current sum of cluster intra-distance \" + globalIntraDistance with_precision(1)  at:{ 8, 4 } font: regular color: # black;\n\t\t\t\t\t\t}\n\t\t\t\t\tif converged {draw \"Algorithm has converged !\" + \" cycle \"+ cycle at:{ 58, 4 } font: regular color: # red;}\n\t\t\t\t\tdraw \"Next step is a maximisation step the centroid will move to the center of its  associated points\" at: target + { -10, 3.5 } font: regular color: # red;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif ! (globalIntraDistance = 0) {\n\t\t\t\t\t\tdraw \"Current step was a maximisation step the centroid moved to the center of its associated points\" at: { 8, 2 } font: regular color: # red;\n\t\t\t\t\t\tdraw \"Current sum of cluster intra-distance \" + globalIntraDistance with_precision(1)  at:{ 8, 4 } font: regular color: # black;\n\t\t\t\t\t\t}\n\t\t\t\t\tif converged {draw \"Algorithm has converged !\"  at:{ 60, 3.5 } font: regular color: # red;}\n\t\t\t\t\tdraw \"Next step is an estimation Step (each point is assigned the color of his nearest centroid\" at: target + { -10, 3.5 } font: regular color: # green;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nexperiment clustering3D type: gui \n{\n\tparameter \"Number of clusters to split the data into\" var: k init:4 min: 0 max: 10 category: \"KMEANS\";\n\tparameter \"Number of points to be clustered\" var: N init:1000 ;\n\tparameter \"Number of dimensions (2D or 3D)\" var: dimensions init: 3 min: 2 max: 3;\n\tfont regular <- font(\"Helvetica\", 14, # bold);\n\tpoint target <- { 20, 95 };\n\t\n\t// The display is explicitly synchronized to avoid concurrency issues (if the points are changed in the simulation while being displayed)\n\toutput synchronized: true\n\t{\n\t\tdisplay map_kmeans type: 3d\n\t\t{\n\t\t\tspecies datapoints aspect: kmeans_aspect3D transparency:0.4;\n\t\t\tspecies centroids aspect: kmeans_aspect3D;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Simulate a simple hydrological model of water flow through a river using a graph-based approach, incorporating GIS data and visualizing the results in a GUI.", "gaml_code": "/***\n* Name: Water flow in a river graph, using water units\n* Author: Benoit Gaudou\n* Description: In this model, the flow of water is simulated through the move of water units from a source point toward the outlet point.\n* \tEvery step a source point is chosen to create a water unit, that will then flow toward the outlet point.\n* Tags: shapefile, gis, graph, gui, hydrology, water flow\n***/\n\nmodel Waterflowriverwaterunit\n\nglobal {\n\tfile river_shape_file <- shape_file(\"../includes/rivers.shp\");\n\tfile poi_file <- shape_file(\"../includes/poi.shp\");\n\n\tgeometry shape <- envelope(river_shape_file) + 500;\n\t\n\tgraph the_river;\n\n\tinit {\n\t\tcreate river from: river_shape_file;\n\t\tcreate poi from: poi_file;\n\t\t\n\t\tthe_river <- as_edge_graph(river);\n\t}\n\t\n\treflex c_water {\n\t\tcreate water {\n\t\t\tlocation <- one_of(poi where (each.type = \"source\")).location;\n\t\t\ttarget <- one_of(poi where (each.type = \"outlet\")) ;\n\t\t}\n\t}\n}\n\nspecies poi {\n\tstring type;\n\t\n\taspect default {\n\t\tdraw circle(500) color: (type=\"source\") ? #green : #red border: #black;\t\t\n\t}\t\n}\n\nspecies river {\n\taspect default {\n\t\tdraw shape + 30 color: #blue;\t\t\n\t}\n}\n\nspecies water skills: [moving] {\n\tpoi target ;\n\n\treflex move {\n\t\tdo goto target: target on: the_river speed: 100.0;\n\t}\t\n\t\n\taspect default {\n\t\tdraw circle(500) color: #blue border: #black;\n\t}\n}\n\nexperiment flow type: gui {\n\toutput {\n\t \tdisplay \"Water Unit\" type:2d{ \n\t\t\tspecies river ; \n\t\t\tspecies water;\t\n\t\t\tspecies poi;\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a hydrological model of water flow in a grid-based environment using a Digital Elevation Model (DEM) file, where water flows from source cells to drain cells based on elevation and diffusion rate.", "gaml_code": "/***\n* Name: Waterflowgridelevation\n* Author: ben\n* Description: \n* Tags: water, dem, grid\n***/\n\n/***\n* Name: Water flow in a river represented by a set of cells, depending on the elevation\n* Author: Benoit Gaudou\n* Description: In this model, the space is discretised using a grid. Thus the river is a set of cells, each of them with an elevation.\n* \tThe data comes from a DEM (Digital Elevation Model) file.\n* \tThe upstream cells (i.e. the source cells) and the downstrem cells (i.e. the drain cells) are chosen by the modeler.\n* \tAt each step, the cells transmits a part of their water to their neighbor cells that are lower (their height is computed taken into account their elevation and height of water. \n* Tags: grid, gui, hydrology, water flow, DEM\n***/\n\nmodel Waterflowgridelevation\n\nglobal {\n\tfile dem_file <- file(\"../includes/DEM_100m_PP.asc\");\n\tfile river_file <- file(\"../includes/river.shp\");\n \n  \t //Shape of the environment using the dem file\n  \t geometry shape <- envelope(dem_file);\n\t\n\t//Diffusion rate\n\tfloat diffusion_rate <- 0.8;\n\t\n\tlist<cell> drain_cells;\n\tlist<cell> source_cells;\n\t\n\tfloat input_water;\n\t\n\tinit {\n\t\tcreate river from: river_file;\n\t\tdo init_cells;\n\t\tdo init_water;\n   \t  \t//Initialization of the drain cells\n\t\tdrain_cells <- cell where (each.is_drain);\n\t\tsource_cells <- cell where(each.is_source);\n\t\task cell {do update_color;}\n\t}\t\n\t\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\t\n   \n   action init_water {\n      ask cell overlapping first(river) {\n         //water_height <- 3.0;\n         is_source <- grid_y = 0;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }   \n\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- input_water;\n      ask source_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   \n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask cell {already <- false;}\n      ask (cell sort_by ((each.altitude + each.water_height))) {\n         do flow;\n      }\n   }\n   \n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell {\n         do update_color;\n      }\n   }\n   \n   //Reflex for the drain cells to drain water\n   reflex draining when: false{\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }   \n\t\n//\treflex d {\n//\t\twrite \"min  \" + cell min_of(each.grid_value);\n//\t\twrite \"max  \" + cell max_of(each.grid_value);\t\t\n//\t}\n}\n\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {\n\tfloat altitude;\n\tfloat water_height;\n\tfloat height;\n\tlist<cell> neighbour_cells;\n\tbool is_drain;\n\tbool is_source;\n\tbool already;\n\n     //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height ;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n}\n\nspecies river {\n\taspect default {\n\t\tdraw shape color: #red;\n\t}\n}\n\nexperiment hydro type: gui {\n\tparameter \"input water\" var: input_water <- 1.0;\n\toutput {\n\t\tdisplay d type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\t//species river;\n\t\t}\n\t}\n}"}
{"prompt": "Create a grid-based model for simulating water flow in a river using a Digital Elevation Model (DEM) and incorporating features such as source cells, drain cells, and diffusion rate.", "gaml_code": "/***\n* Name: Waterflowgridelevation\n* Author: ben\n* Description: \n* Tags: water, dem, grid\n***/\n\n/***\n* Name: Water flow in a river represented by two fields (one for the terrain, one for the flow)\n* Author: Benoit Gaudou & Alexis Drogoul\n* Description: In this model, the space is discretised using two fields, the 'river' being a set of cells, each of them with an elevation.\n* \tThe data comes from a DEM (Digital Elevation Model) file.\n* \tThe upstream cells (i.e. the source cells) and the downstream cells (i.e. the drain cells) are determined automatically ('up' and 'down' of the cells with an altitude < 0)\n* \tAt each step, the cells in the flow field transmits a part of their water to their neighbor cells that are lower (their height is computed taken into account their elevation and height of water. \n* Tags: grid, gui, hydrology, water flow, DEM\n***/\nmodel WaterOnFields\n\n\nglobal {\n\tgrid_file dem_file <- file(\"../includes/DEM_100m_PP.asc\");\n\tfield terrain <- field(dem_file) ;\n\tfield flow <- field(terrain.columns,terrain.rows);\n\t//Shape of the environment using the dem file\n\tgeometry shape <- envelope(dem_file);\n\tbool fill <- false;\n\n\t//Diffusion rate\n\tfloat diffusion_rate <- 0.8;\n\tint frequence_input <- 3;\n\tlist<point> drain_cells <- [];\n\tlist<point> source_cells <- [];\n\tmap<point, float> heights <- [];\n\tlist<point> points <- flow points_in shape;\n\tmap<point, list<point>> neighbors <- points as_map (each::(flow neighbors_of each));\n\tmap<point, bool> done <- points as_map (each::false);\n\tmap<point, float> h <- points as_map (each::terrain[each]);\n\tfloat input_water;\n\tinit {\n\t\tgeometry river_g <- first( file(\"../includes/river.shp\"));\n\t\tfloat c_h <- shape.height/flow.rows;\n\t\tlist<point>  rivers_pt <- points where ((each overlaps river_g) and (terrain[each] < 100.0)) ;\n\t\tif (fill) {\n\t\t\tloop pt over: rivers_pt  {\n\t\t\t\tflow[pt] <- 1.0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tloop pt over: rivers_pt  {\n\t\t\tif (pt.y <  (c_h)) {\n\t\t\t\tsource_cells <<pt;\n\t\t\t}\n\t\t}\t\n\t\tloop pt over: rivers_pt  {\n\t\t\tif (pt.y > (shape.height - (c_h) )) {\n\t\t\t\tdrain_cells <<pt;\n\t\t\t}\n\t\t}\t\n\t\t\n\t}\n\n\t//Reflex to add water among the water cells\n\treflex adding_input_water when: every(frequence_input#cycle){\n\t\tloop p over: source_cells {\n\t\t\tflow[p] <- flow[p] + input_water;\n\t\t}\n\t}\n\n\t//Reflex for the drain cells to drain water\n\treflex draining  {\n\t\tloop p over: drain_cells {\n\t\t\tflow[p] <- 0.0;\n\t\t}\n\t}\n\n\n\tfloat height (point c) {\n\t\treturn h[c] + flow[c];\n\t}\n\n\t//Reflex to flow the water according to the altitude and the obstacle\n\treflex flowing {\n\t\tdone[] <- false;\n\t\theights <- points as_map (each::height(each));\n\t\tlist<point> water <- points where (flow[each] > 0) sort_by (heights[each]);\n\t\tloop p over: points - water {\n\t\t\tdone[p] <- true;\n\t\t}\n\t\tloop p over: water {\n\t\t\tfloat height <- height(p);\n\t\t\tloop flow_cell over: (neighbors[p] where (done[each] and height > heights[each])) sort_by heights[each]  {\n\t\t\t\tfloat water_flowing <- max(0.0, min((height - heights[flow_cell]), flow[p] * diffusion_rate));\n\t\t\t\tflow[p] <- flow[p] - water_flowing;\n\t\t\t\tflow[flow_cell] <- flow[flow_cell] + water_flowing;\n\t\t\t\theights[p] <- height(p) ;\n\t\t\t\theights[flow_cell] <- height(flow_cell) ;\n\t\t\t}\n\t\t\tdone[p] <- true;\n\t\t}\n\t}\n}\n\n\nexperiment hydro type: gui {\n\tparameter \"Input water at source\" var: input_water <- 1.0 min: 0.0 max: 3.0 step: 0.1;\n\tparameter \"Fill the river\" var: fill <- true;\n\toutput {\n\t\tdisplay d type: 3d {\n\t\t\tcamera 'default' location: {7071.9529,10484.5136,5477.0823} target: {3450.0,3220.0,0.0};\n\t\t\tmesh terrain scale: 10 triangulation: true  color: palette([#burlywood, #saddlebrown, #darkgreen, #green]) refresh: false smooth: true;\n\t\t\tmesh flow scale: 10 triangulation: true color: palette(reverse(brewer_colors(\"Blues\"))) transparency: 0.5 no_data:0.0 ;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Design a grid-based model to simulate water flow in a river using a raster image as input data, where cells are assigned an order based on their neighborhood and water is transferred between downstream cells.", "gaml_code": "/***\n* Name: Water flow in a river represented by a set of cells\n* Author: Benoit Gaudou and Patrick Taillandier\n* Description: In this model, the space is discretised using a grid. Thus the river is a set of cells. \n* \tThe data comes from a raster image.\n* \tThe upstream cells (i.e. the source cells) are chosen by the modeler.\n* \tInitialy, an order is computed by neighborhood to make the water flows from the source cells, all over the river.\n* \tAt each step, the cells transmits a part of their water to their downstream cells (the neighbor cells with a greater order number).\n* Tags: grid, gui, hydrology, water flow\n***/\n\nmodel Waterflowgridneighborhood\n\nglobal {\n\tint image_size <- 20;\n\tfile image_river_file <- image_file('../includes/river_image.png') ;\n\t\n\tlist<cell> river;\n\t\n\tfloat entrance_water <- 255.0;\n\t\n\t\n\tinit {\n\t\task cell {\t\n\t\t\tcolor <- rgb( (image_river_file) at {grid_x,grid_y}) ;\n\t\t\tif(color = rgb(0,61,245)) {\n\t\t\t\tis_river_cell <- true;\n\t\t\t\torder <- image_size - 1 - grid_x;\n\t\t\t\tsource <- order = 0;\t\t\t\n\t\t\t}\n\t\t}\n\t\triver <- cell where(each.is_river_cell);\n\t\t\n    }\t\n    \n    \n}\n\ngrid cell  width: image_size height: image_size schedules: reverse(river sort_by(each.order)){\n\tbool is_river_cell <- false;\n\tbool source <- false;\n\tint order <- -1;\n\t\n\tfloat water_volume;\n\n\treflex water_flow {\n\t\task neighbors where(each.order > self.order) {\n\t\t\twater_volume <- water_volume + 0.9*myself.water_volume;\n\t\t}\n\t\twater_volume <- 0.1*water_volume;\n\t}\n\t\n\treflex water_source when: source and every(20 #cycle) {\n\t\twater_volume <- water_volume + entrance_water;\n\t}\n\t\t\n\t\n\taspect default {\n\t\tdraw shape color: is_river_cell? rgb(0,0,2 * water_volume) : #lightgreen border: #grey;\n\t}\n}\n\nexperiment Waterflowgridneighborhood type: gui {\n\toutput synchronized: true{\n\t\tdisplay flow type:2d{\n\t\t\tspecies cell;\n\t\t}\t\t\n\t}\n}"}
{"prompt": "Create a model that simulates water flow in a river graph using shapefiles and GIS data, where water flows from source points to outlet points, and visualize the simulation using a GUI.", "gaml_code": "/***\n* Name: Water flow in a river graph, using water flow in rivers\n* Author: Benoit Gaudou and Patrick Taillandier\n* Description: In this model, the flow of water is modeled through the exchange of water between elements of rivers.\n* \tThe only water input comes (every 20 steps) from the source points. Then the water flows toward the outlet point.\n* Tags: shapefile, gis, graph, gui, hydrology, water flow\n***/\n\nmodel Waterflowrivergraph\n\nglobal {\n\tfile river_shape_file <- shape_file(\"../includes/rivers.shp\");\n\tfile poi_file <- shape_file(\"../includes/poi.shp\");\n\n\tgeometry shape <- envelope(river_shape_file) + 500;\n\t\n\tgraph the_river;\n\tpoi outlet;\n\n\tinit {\n\t\tcreate river from: river_shape_file;\n\t\tcreate poi from: poi_file;\n\t\toutlet <- poi first_with(each.type = \"outlet\");\n\t\tthe_river <- as_edge_graph(river);\n\t\n\t\task poi - outlet{\n\t\t\tclosest_river <- river closest_to self;\n\t\t\tpath path_to_outlet <- path_between(the_river,self,outlet);\n\t\t\tloop i from: 0 to: length(path_to_outlet.edges) - 2 {\n\t\t\t\triver(path_to_outlet.edges[i]).next_river <- river(path_to_outlet.edges[i+1]);\n\t\t\t}\n\t\t} \n\t}\n\t\n\treflex water_flow {\n\t\t// Every 20 simulation steps, the source points provide water to the closest river.\n\t\tif (every(10#cycles)) {\n\t\t\task poi - outlet {\n\t\t\t\tdo give_water;\n\t\t\t}\t\n\t\t//  For a visualisation purpose, the water flow is not executed when the sources provide water.\n\t\t} else {\t\t\n\t\t\task river {\n\t\t\t\tdo water_flow;\n\t\t\t}\n\t\t\task river {\n\t\t\t\tdo update_water_level;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\nspecies poi {\n\tstring type;\n\triver closest_river ;\n\t\n\taction give_water {\n\t\tclosest_river.water_volume <- 200.0;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(500) color: (type=\"source\") ? #green : #red border: #black;\t\t\n\t}\t\n}\n\nspecies river {\n\triver next_river ;\n\tfloat water_volume;\n\tfloat water_volume_from_other;\n\t\n\taction water_flow {\n\t\tif (next_river != nil) {\n\t\t\tnext_river.water_volume_from_other <- next_river.water_volume_from_other + 0.9 * water_volume;\n\t\t}\n\t}\n\t\n\taction update_water_level {\n\t\twater_volume <- 0.1 * water_volume + water_volume_from_other;\n\t\twater_volume_from_other <- 0.0;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: #blue;\t\n\t\tdraw shape + water_volume color: #blue;\n\t\t\n\t\t\t\n\t}\n}\n\nexperiment flow type: gui {\n\toutput {\n\t \tdisplay \"Water Unit\" type:2d { \n\t\t\tspecies river ; \n\t\t\tspecies poi;\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a model of water flow through a watershed using sub-watersheds, incorporating rain input and upstream water volume, with visualization capabilities.", "gaml_code": "/***\n* Name: Water flow with watershed\n* Author: Benoit Gaudou\n* Description: A model inspired by the SWAT model to make flow the water in a water basin using sub watershed.\n* \tThe water flows from the upstream watersheds to the downstream watershed. The water basin gets water only from the rain.\n* \tTo better vizualise the water flow, rain is uniform on the basin and occurs only every 20 steps.\n* \tDuring the other steps, there is no water input in the basin.\n* Tags: shapefile, gis, gui, hydrology, water flow\n***/\n\n\nmodel Waterflowwatershed\n\nglobal {\t\n\tfile watershed_shape_file <- shape_file(\"../includes/ZH2.shp\");\n\tgeometry shape <- envelope(watershed_shape_file);\n\n\tfloat rain <- rnd(10.0) update: every(20#cycle) ? rnd(10.0) : 0.0;\n\t\n\tinit {\n\t\tcreate watershed from: watershed_shape_file with: [id_watershed::int(read(\"ID_ZH\")), id_watershed_outlet::int(read(\"ID_ND_EXUT\")),order::int(read(\"order\"))];\n\t\t\n\t\task watershed {\n\t\t\tdo init_watershed;\n\t\t\twrite \"\" + int(self) + \" \" + length(shape.points) + \" points\";\n\t\t}\n\t}\n\t\n\treflex water_floaw {\n\t\task reverse(watershed sort_by(each.order)) {\n\t\t\tdo model_hydro;\n\t\t}\n\t}\n}\n\nspecies watershed schedules: [] {\n\tint id_watershed;\n\tint id_watershed_outlet;\n\tint order;\n\t\n\tlist<watershed> watershed_upstream;\n\n\tfloat volume_watershed ;\n\n\taction init_watershed {\n\t\t// Find ZH in the upstream \n\t\twatershed_upstream <- watershed where(each.id_watershed_outlet = id_watershed);\n\t}\n\t\t\n\taction model_hydro {\t\n\t\tvolume_watershed <- 0.7 * rain * self.shape.area  + (watershed_upstream sum_of(each.volume_watershed));\t\n\t}\t\n\n\taspect blueFlow {\n\t\tdraw shape border: #white color:rgb(0,0,255*volume_watershed/100000000);\n\t}\n}\n\nexperiment waterFlow type: gui {\n\toutput {\n\t \tdisplay \"My display Abs\" type:2d{ \n\t\t\tspecies watershed aspect: blueFlow;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation where cubes are colored based on their position and sorted using bubble sort algorithm.", "gaml_code": "/**\n* Name: Creating color and sort cubes by color\n* Author:  Arnaud Grignard\n* Description: A model to show how to create color by using the rgb operator, the color depending on the position of cube in the xyz space. \n* \tThe cubes are randomly mixed to finally be sorted according to the color of each vertix of the whole big cube, using the bubble sort \n*        algorithm (https://en.wikipedia.org/wiki/Bubble_sort). \n* Tags: color, 3d\n*/\n\nmodel bubblesort3D\n\n\nglobal {\n\n//Number of cubes by faces of the whole big cube\nint nb_cells<-15;\n\ngeometry shape <- cube(nb_cells) ;\n\n\nbool change <- true;\n\ninit {\n\t//We create nb_cells^3 cubes and we define their color depending on their position in XYZ\n\tloop i from:0 to:nb_cells-1{\n\t\tloop j from:0 to: nb_cells-1{\n\t\t\tloop k from:0 to:nb_cells-1{\n\t\t\t  create cells{\n\t\t\t\tlocation <-{i mod nb_cells,j mod nb_cells, k mod nb_cells};\n\t\t\t\t\n\t\t\t\t//The canal RGB limit color to 255 by canal\n\t\t\t\tred <- float((i mod nb_cells)* int(255 / nb_cells));\n\t\t\t\tgreen <- float((j mod nb_cells) * int(255 / nb_cells));\n\t\t\t\tblue <- float((k mod nb_cells) * int(255 / nb_cells));\n\t\t\t\t\n\t\t\t\t//We create the color according to the value of the red, green and blue canals\n\t\t\t\tcolor <- rgb(red,green,blue);\n\t\t\t  }\t\n\t\t\t}\t\n\t    }\n\t}\n\t\n\t//We mix all the cubes randomly by permuting two randomly chosen cubes\n\tloop times: 10000 {\n\t\t\task one_of(cells) {\n\t\t\t\tcells one_cells <- one_of(cells);\n\t\t\t\tif (self != one_cells) {\n\t\t\t\t\tpoint loc <- copy(location);\n\t\t\t\t\tlocation <- one_cells.location;\n\t\t\t\t\tone_cells.location <- loc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t\n\n}\n\n//Reflex to finish the execution of the model when nothing has changed during the cycle\nreflex end {\n\tif (not change) {\n\t\tdo pause;\t\n\t} \n\tchange <- false;\n\t}\n}\n\n\nspecies cells{\n\n\trgb color;\n\tfloat red;\n\tfloat green;\n\tfloat blue;\n\tlist<cells> neigbhours update: cells at_distance (1.1);\n\t\n\t//Update of the neighbours cubes at each cycle of the simulation according to their location\n\tcells upper_cell_y update: neigbhours first_with (shape.location.y > each.shape.location.y);\n\tcells upper_cell_x update: neigbhours first_with (shape.location.x > each.shape.location.x);\n\tcells upper_cell_z update: neigbhours first_with (shape.location.z > each.shape.location.z);\n\t\n\t//We permute the cube agent with its neighbour if its intensity is greater according to the canal related to its axis (z for canal blue, y for green and x for red)\n\treflex swap_z when: upper_cell_z != nil and blue < upper_cell_z.blue{ \n\t\tpoint tmp1Loc <-location;\n\t\tlocation <- upper_cell_z.location;  \n    \tupper_cell_z.location<-tmp1Loc; \t\n\t    change <- true;\t\n    }\n\t\n\treflex swap_y when: upper_cell_y != nil and green < upper_cell_y.green{ \n\t\tpoint tmp1Loc <-location;\n\t\tlocation <- upper_cell_y.location;  \n    \tupper_cell_y.location<-tmp1Loc; \t\n\t    change <- true;\t\n    }\n    \n    reflex swap_x when: upper_cell_x != nil and red < upper_cell_x.red{ \n\t\tpoint tmp1Loc <-location;\n\t\tlocation <- upper_cell_x.location;  \n    \tupper_cell_x.location<-tmp1Loc; \t\n\t    change <- true;\t\n    }\n\n\taspect default {\n\t\tdraw cube(1) color:color border:color at:location;\n\t}\t\n}\n\n\nexperiment Display type: gui autorun:true{\n\toutput {\n\t\tdisplay View1 type:3d axes:false background:#black {\n\t\t\tcamera 'default' location: {26.889,23.7693,37.0687} target: {2.2036,3.0558,0.0};\n\t\t\tspecies cells transparency:0.1;\n\t\t\tgraphics \"di\"{\n\t\t\t draw \"black(0,0,0)\" at:{0,0,0} color:#black perspective:false;\n\t\t\t draw \"red(1,0,0)\" at:{world.shape.width,0,0} color:#red perspective:false;\n\t\t\t draw \"green(0,1,0)\" at:{0,world.shape.height,0} color:#green perspective:false;\n\t\t\t draw \"blue(0,0,1)\" at:{0,0,world.shape.width} color:#blue perspective:false;\n\t\t\t draw \"yellow(1,1,0)\" at:{world.shape.width,world.shape.height,0} color:#yellow perspective:false;\n\t\t\t draw \"magenta(1,0,1)\" at:{world.shape.width,0,world.shape.depth} color:#magenta perspective:false;\n\t\t\t draw \"cyan(0,1,1)\" at:{0,world.shape.height,world.shape.depth} color:#cyan perspective:false;\n\t\t\t draw \"white(1,1,1)\" at:{world.shape.width,world.shape.height,world.shape.depth} color:#white perspective:false;\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of a flocking behavior using 300 boids, where they can create flocks and follow a goal, while avoiding obstacles and displaying various statistics.", "gaml_code": "/**\n* Name: Boids With Flocks\n* Author: \n* Description: This model shows the movement of boids following a goal and creating a flock . \n* Tags: gui, skill, 3d, multi_level, clustering\n*/\nmodel boids_flock\n//Import the boids model\nimport \"Boids.gaml\"\nglobal {\n\t//Size of the boids\n\tfloat boids_size <- float(3);\n\t//Shape of the boids\n\tgeometry boids_shape <- circle(boids_size);\n\t//Separation between boids\n\tfloat boids_separation <- 4 * boids_size;\n\t//Distance to allow creation of the flock \n\tint flock_creation_distance <- int(boids_separation + 1);\n\t//Minimum number of member among a flock\n\tint min_group_member <- 3;\n\t//Frequency of update for the flock\n\tint update_frequency <- 10;\n\t//Frequency of merge for the flock\n\tint merge_frequency <- 10;\n\t//Allow the creation of flock\n\tbool create_flocks <- false;\n\t//Perception range of the boids\n\tint base_perception_range <- int(xmax / 100) min: 1;\n\t\n\tinit {\n\t\t//Creation of the different agents viewer\n\t\tcreate boids_agents_viewer;\n\t\tcreate flock_agents_viewer;\n\t\tcreate boids_in_flock_viewer;\n\t}\n\t//Reflex to create the flocks if it is available\n\treflex create_flocks when: create_flocks {\n\t\t\n\t\tif (length(boids) > 1) {\n\t\t\t//Clustering by distance of the boids to determine the satisfying boids groups\n\t\t\tlist<list<boids>> satisfying_boids_groups <- (boids.population simple_clustering_by_distance flock_creation_distance) where ((length(each)) > min_group_member);\n\t\t\tloop one_group over: satisfying_boids_groups {\n\t\t\t\t\n\t\t\t\tgeometry potential_flock_polygon <- convex_hull(solid(polygon(one_group collect boids(each).location)) + (base_perception_range + 5));\n\t\t\t\t//If there is no obstacle between the boids of a potential flock, then the flock is created and all the boids become boids in flock\n\t\t\t\tif (empty(obstacle overlapping potential_flock_polygon)) {\n\t\t\t\t\tcreate flock {\n\t\t\t\t\t\tcapture one_group as: boids_in_flock;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} \n\n}\n\n//Species flock which represent the flock of boids, using the skill moving\nspecies flock skills: [moving] {\n\trgb color <- rgb(rnd(255), rnd(255), rnd(255));\n\tgeometry shape <- any_point_in(host);\n\t//Range of perception of the flock\n\tfloat perception_range <- float(base_perception_range + (rnd(5)));\n\t//Speed of the flock\n\tfloat speed update: mean(boids_in_flock collect each.speed);\n\t//Reflex to disaggregate the flock if there is a obstacle in the flock\n\treflex disaggregate {\n\t\tgeometry buffered_shape <- shape + perception_range;\n\t\tif !(empty(obstacle overlapping buffered_shape)) {\n\t\t\trelease list<agent>(members) as: boids in: world;\n\t\t\tdo die;\n\t\t}\n\n\t}\n\t//Reflex to capture the boids nearby in the range of perception with an update_frequency\n\treflex capture_nearby_boids when: ((cycle mod update_frequency) = 0) {\n\t\tgeometry buffered_shape <- shape + perception_range;\n\t\tlist<boids> nearby_boids <- (boids overlapping buffered_shape);\n\t\tif (!(empty(nearby_boids))) {\n\t\t\tgeometry new_polygon <- convex_hull(solid(shape + polygon(nearby_boids collect (each.location))));\n\t\t\tif (empty(obstacle overlapping new_polygon)) {\n\t\t\t\tcapture nearby_boids as: boids_in_flock;\n\t\t\t}\n\n\t\t}\n\n\t}\n\t//Reflex to merge the intersecting flocks\n\treflex merge_nearby_flocks when: ((cycle mod merge_frequency) = 0) \n\t{\n\t\tloop f over: (flock) {\n\t\t\tif (f != self and (shape intersects f.shape)) {\n\t\t\t\tgeometry new_shape <- convex_hull(polygon(shape.points + f.shape.points));\n\t\t\t\tif empty(obstacle overlapping new_shape) {\n\t\t\t\t\tlist<boids> released_boids;\n\t\t\t\t\task f {\n\t\t\t\t\t\trelease list<agent>(members) as: boids in: world returns: released_coms;\n\t\t\t\t\t\treleased_boids <- released_coms;\n\t\t\t\t\t\tdo die;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!empty(released_boids)) {\n\t\t\t\t\t\tcapture released_boids as: boids_in_flock;\n\t\t\t\t\t}\n\n\t\t\t\t\tshape <- convex_hull(polygon(members collect (boids_in_flock(each).location)));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\t//Reflex to make the flock follow the goal\n\treflex chase_goal {\n\t\tfloat direction_to_nearest_ball <- (self towards (first(boids_goal)));\n\t\tfloat step_distance <- speed * step;\n\t\tfloat dx <- step_distance * (cos(direction_to_nearest_ball));\n\t\tfloat dy <- step_distance * (sin(direction_to_nearest_ball));\n\t\tgeometry envelope <- shape.envelope;\n\t\tfloat min_y <- (envelope.points with_min_of (each.y)).y;\n\t\tfloat min_x <- (envelope.points with_min_of (each.x)).x;\n\t\tfloat max_x <- (envelope.points with_max_of (each.x)).x;\n\t\tfloat max_y <- (envelope.points with_max_of (each.y)).y;\n\t\tif (((dx + min_x) < xmin) and min_x > xmin) or (((dx + max_x) > xmax) and max_x < xmax) {\n\t\t\tdx <- 0.0;\n\t\t}\n\t\tif (((dy + min_y) < ymin) and min_y > ymin) or (((dy + max_y) > ymax) and max_y < ymax) {\n\t\t\tdy <- 0.0;\n\t\t}\n\t\t\n\t\tloop com over: boids_in_flock {\n\t\t\tcom.location <- com.location + { dx, dy };\n\t\t}\n\n\t\tshape <- convex_hull(polygon(list(boids_in_flock) collect (each.location)));\n\t}\n\n\taspect default {\n\t\tdraw shape color: color;\n\t}\n\t//Species boids_in_flock which represents the boids agents captured by the flock\n\tspecies boids_in_flock parent: boids {\n\t\tfloat my_age <- 1.0 update: my_age + 0.01;\n\t\treflex separation when: apply_separation {\n\t\t}\n\n\t\treflex alignment when: apply_alignment {\n\t\t}\n\n\t\treflex cohesion when: apply_cohesion {\n\t\t}\n\n\t\treflex avoid when: apply_avoid {\n\t\t}\n\n\t\treflex follow_goal  {\n\t\t}\n\n\t\treflex wind when: apply_wind {\n\t\t}\n\n\t\taction do_move {\n\t\t}\n\n\t\treflex movement {\n\t\t\tdo do_move;\n\t\t}\n\n\t\taspect default {\n\t\t\tdraw circle(my_age) color: (host.color).darker;\n\t\t}\n\n\t}\n\n}\n//Species flock agents viewer which draw the flock information\nspecies flock_agents_viewer {\n\taspect default {\n\t\tdraw \"Flocks: \" + (string(length(list(flock)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 5 } color: #blue size: 80 ;\n\t}\n\n}\n//Species boids agents viewer which draw the boids information\nspecies boids_agents_viewer {\n\taspect default {\n\t\tdraw \"Boids: \" + (string(length(list(boids)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 165 } color: #blue size: 80 ;\n\t}\n\n}\n\n//Species boids_in_flock_viewer which draw the boids in flock information\nspecies boids_in_flock_viewer {\n\taspect default {\n\t\tdraw \"Boids in flocks: \" + (string(number_of_agents - (length(list(boids))))) at: { width_and_height_of_environment - 810, width_and_height_of_environment - 85 } color:\n\t\t#blue size: 80 ;\n\t}\n\n}\n\n\nexperiment boids_flocks type: gui {\n\tparameter \"Create flock?\" var: create_flocks <- true;\n\tparameter \"Number of boids\" var: number_of_agents <- 300;\n\tparameter \"Environment size\" var: width_and_height_of_environment <- 1600;\n\tparameter \"Moving obstacles?\" var: moving_obstacles <- true;\n\tparameter \"Number of obstacles\" var: number_of_obstacles <- 5;\n\toutput {\n\t\tdisplay default_display {\n\t\t\tspecies boids_goal;\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies obstacle;\n\t\t\tspecies flock aspect: default transparency: 0.5 {\n\t\t\t\tspecies boids_in_flock aspect: default;\n\t\t\t}\n\n\t\t\tspecies flock_agents_viewer;\n\t\t\tspecies boids_agents_viewer;\n\t\t\tspecies boids_in_flock_viewer;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of a flock of birds (boids) following a goal agent, with adjustable parameters for cohesion, alignment, separation, and wind effects.", "gaml_code": "/**\n* Name: Boids 3D Motion\n* Author: \n* Description: This model shows the movement of boids following a goal, and creating a flock .  \n*\tThe goal agent and the boids will move within the 3D space.\n* Tags: gui, skill, 3d\n*/\nmodel boids_3D \nglobal torus: torus_environment{ \n\t//Number of boids to create\n\tint number_of_agents <- 100 min: 1 max: 500;\n\t//Number of obstacles to create\n\tint number_of_obstacles <- 0 min: 0;\n\t//Size of the boids\n\tint boids_size <- 50 min: 1;\n\t//Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Factor for the boids flock\n\tint cohesion_factor <- 100; \n\tint alignment_factor <- 100; \n\tfloat minimal_distance <- 10.0; \n\t//MAximal angle of turn for the boids\n\tint maximal_turn <- 90 min: 0 max: 359; \n\t//environment parameters\n\tint width_and_height_of_environment <- 800;  \n\tint z_max <- 400;  \n\tbool torus_environment <- false; \n\t//Experiment parameter\n\tbool apply_cohesion <- true;\n\tbool apply_alignment <- true;   \n\tbool apply_separation <- true;   \n\tbool apply_goal <- true; \n\tbool apply_wind <- true;     \n\t//Wind variable\n\tpoint wind_vector <- {0,0,0};   \n\t//Duration of the goal\n\tint goal_duration <- 30 update: (goal_duration - 1); \n\t//Location of the goal\n\tpoint goal <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 ,(rnd(z_max - 2) + 1)}; \n\tgif_file bird0_gif_file <- gif_file(\"../images/bird.gif\");\n\n\tgeometry shape <- cube(width_and_height_of_environment);\n\tinit {\n\t\t//Creation of the boids agents that will be placed randomly within the environment\n\t\tcreate boids number: number_of_agents { \n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 , (rnd(z_max - 2) + 1)};\n\t\t} \n\t\t//Creation of the goal\n\t\tcreate boids_goal {\n\t\t\tlocation <- goal;\n\t\t}\n\t}\n}\n\n//Species boids_goal that will represent the goal agent, using the skill moving\nspecies boids_goal skills: [moving3D] {\n\tfloat range init: 20.0;\n\t\n\t//Reflex to make the goal agent wander in a certain amplitude and a certain speed, \n\t//Respecting the minimal and maximal z values\n\treflex wander { \n\t\tdo  wander amplitude: 45.0 speed: 20.0; \n\t\tif (location.z) < 0 {\n\t\t\tlocation <- {location.x,location.y,0};\n\t\t} else if (location.z) > z_max {\n\t\t\tlocation <- {location.x,location.y,z_max};\n\t\t}\n\t\tgoal <- location;\n\t}\n\t\n\taspect default { \n\t\tdraw sphere(10) color: #red ;\n\t}\n} \n\n//Species boids that will represent the boids agents, using the skill moving\nspecies boids skills: [moving3D] {\n\t//Attribute for the speed of the boids\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range of sensing of the boids\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0, 0} ;\n\t\n\t//List of the others boids in the range distance of the agent\n\tlist<boids> others update: ((boids at_distance range)  - self);\n\t//Mass center of the \"flock\" represented as the other boids in the sensing range\n\tpoint mass_center update:  (length(others) > 0) ? (mean (others collect (each.location)) )  : location;\n\t\n\t//Reflex to apply separation\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0,0};\n\t\tloop boid over: (boids at_distance (minimal_distance))  {\n\t\t\tacc <- acc - ((location of boid) - location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to apply alignment\n\treflex alignment when: apply_alignment {\n\t\tpoint acc <- (length(others) > 0) ? (mean (others collect (each.velocity))) : {0.0,0.0,0.0};\n\t\tacc <- acc - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t//Reflex to apply cohesion\n\treflex cohesion when: apply_cohesion {\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor;\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Action to make the agent location within the environment\n\taction bounding {\n\t\tif (location.z) < 0 {\n\t\t\tlocation <- {location.x,location.y,0};\n\t\t} else if (location.z) > z_max {\n\t\t\tlocation <- {location.x,location.y,z_max};\n\t\t}\n\t}\n\t//Reflex to make the agent follow the goal\n\treflex follow_goal when: apply_goal {\n\t\tvelocity <- velocity + ((goal - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind by using the vector of wind\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t//Action to make the agent moving\n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) and (((velocity.z) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2,  ((rnd(4)) - 2)} ; \n\t\t}\n\t\tpoint old_location <- location;\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t//Reflex to move the agent, calling both bounding and do_move action\n\treflex movement {\n\t\tdo bounding;\n\t\tdo do_move;\n\t}\n\t\n\taspect sphere {\n\t\tdraw sphere(10) color: #green;\n\t}\n\t\n\taspect image {\n\t\tdraw bird0_gif_file size: boids_size rotate: heading::(location - boids_goal[0].location) color: #black ;      \n\t}\n}\n\n\nexperiment \"3D\" type: gui {\n\t\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var:number_of_obstacles;\n\tparameter 'Boids size' var:boids_size;\n\tparameter 'Maximal speed' var:maximal_speed;\n\tparameter 'Cohesion Factor' var:cohesion_factor;\n\tparameter 'Alignment Factor' var:alignment_factor;\n\tparameter 'Minimal Distance' var:minimal_distance;\n\tparameter 'Maximal Turn' var:maximal_turn;\n\tparameter 'Width/Height of the Environment' var:width_and_height_of_environment;\n\tparameter 'Z max of the Environment' var:z_max;\n\tparameter 'Toroidal Environment ?' var:torus_environment;\n\t\n\tparameter 'Apply Cohesion ?' var: apply_cohesion;\n\tparameter 'Apply Alignment ?' var: apply_alignment;   \n\tparameter 'Apply Separation ?' var: apply_separation;  \n\tparameter 'Apply Wind ?' var: apply_wind ;    \n\tparameter 'Follow Goal ?' var:apply_goal;\n\tparameter 'Direction of the wind' var:wind_vector;\n\t\n\tfloat minimum_cycle_duration <- 0.05#s;\n\t\n\toutput synchronized: true {\n\t\t\n\t\tdisplay Sky1 type:3d {\n\t\t\tcamera 'default' location: {555.5176,1479.257,750.4308} target: {442.2293,184.3665,0.0};\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies boids_goal;\t\n\t\t}\n\t\t\n\n\t}\n}"}
{"prompt": "Create a 3D simulation of boids following a goal and interacting with obstacles, allowing for user control over parameters such as cohesion, alignment, and wind.", "gaml_code": "/**\n* Name: Boids\n* Author: \n* Description: This model shows the movement of boids following a goal, and creating a flock. \n* The experiment the boids in 3D and allows users to move the goal.\n* Tags: gui, skill\n*/\n\nmodel boids \nglobal { \n\t//Number of boids that will be created\n\tint number_of_agents <- 50 min: 1 max: 500;\n\t//Number of obstacles for the boids movement to represent\n\tint number_of_obstacles <- 0 min: 0;\n\t//Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Factors for the group of boids\n\tint cohesion_factor <- 200;\n\tint alignment_factor <- 100; \n\t//Variables for the movement of the boids\n\tfloat minimal_distance <- 30.0; \n\t\n\tint width_and_height_of_environment <- 1000;  \n\tbool apply_cohesion <- true ;\n\tbool apply_alignment <- true ;\n\tbool apply_separation <- true;\n\tbool apply_avoid <- true;  \n\tbool apply_wind <- true;   \n\tbool moving_obstacles <- false;   \n\tint bounds <- int(width_and_height_of_environment / 20); \n\t//Vector for the wind\n\tpoint wind_vector <- {0,0}; \n\tlist<image_file> images  <- [image_file('../images/bird1.png'),image_file('../images/bird2.png'),image_file('../images/bird3.png')]; \n\tint xmin <- bounds;   \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);     \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\t\n\t//Action to move the goal to the mouse location\n\taction move_goal {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: #user_location speed: 30.0;\n\t\t}\n\t}\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\n\tinit { \n\t\t//Create the boids agents\n\t\tcreate boids number: number_of_agents { \n\t\t\t location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t//Create the obstacles agents\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t//Create the goal that boids will follow\n\t\tcreate  boids_goal;\t\n\t}\t\n}\n\n//Species boids goal which represents the goal that will be followed by boids agents using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range  <- 20.0;\n\t\n\t//If the mouse is not used, then the goal just wander\n\treflex wander {  \n\t\tdo  wander amplitude: 45.0 speed: 20.0;  \n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: #red ;\n\t\tdraw circle(40) color: #orange wireframe: true;\n\t}\n} \n//Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving\nspecies boids skills: [moving] {\n\t//Speed of the boids agents\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range used to consider the group of the agent\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0};\n\t\t\n\t//Reflex used when the separation is applied to change the velocity of the boid\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0};\n\t\task (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location) - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t//Reflex to align the boid with the other boids in the range\n\treflex alignment when: apply_alignment {\n\t\tlist<boids> others  <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t \n\t//Reflex to apply the cohesion of the boids group in the range of the agent\n\treflex cohesion when: apply_cohesion {\n\t\tlist<boids> others <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;\n\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor; \n\t\tvelocity <- velocity + acc;   \n\t}\n\t\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t\n\t//action to represent the bounding of the environment considering the velocity of the boid\n\taction bounding {\n\t\tif  (location.x) < xmin {\n\t\t\tvelocity <- velocity + {bounds,0};\n\t\t} else if (location.x) > xmax {\n\t\t\tvelocity <- velocity - {bounds,0};\n\t\t}\n\t\t\n\t\tif (location.y) < ymin {\n\t\t\tvelocity <- velocity + {0,bounds};\n\t\t} else if (location.y) > ymax {\n\t\t\tvelocity <- velocity - {0,bounds};\n\t\t}\t\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal {\n\t\tvelocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector on the velocity\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t\n\t//Action to move the agent  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2};\n\t\t}\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t\n\t//Reflex to apply the movement by calling the do_move action\n\treflex movement {\n\t\tdo do_move;\n\t\tdo bounding;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \n\t}\n\taspect circle { \n\t\tdraw circle(15)  color: #red;\n\t}\n\t\n\taspect default { \n\t\tdraw circle(20) color: #lightblue wireframe: true;\n\t}\n} \n\n//Species obstacle that represents the obstacles avoided by the boids agents using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 2.0;\n\n\tinit {\n\t\tshape <- triangle(15);\n\t}\t\n\t//Reflex to move the obstacles if it is available\n\treflex move_obstacles when: moving_obstacles {\n\t\t//Will make the agent go to a boid with a 50% probability\n\t\tif flip(0.5)  \n\t\t{ \n\t\t\tdo goto target: one_of(boids);\n\t\t} \n\t\telse{ \n\t\t\tdo wander amplitude: 360.0;   \n\t\t}\n\t}\n\taspect default {\n\t\tdraw  triangle(20) color: #black ;\n\t}\n\n}\n\n\nexperiment \"Basic\" type: gui {\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput synchronized: true {\n\t\tdisplay Sky type: 3d axes:false{ \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t}\n\n\t}\n}\n\n\nexperiment \"Interactive\" type: gui autorun: true{\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\tbool previous_state <- gama.pref_synchronize_quadtree;\n\t\n\tinit {\n\t\t// The preference is explicitly set so as to avoid concurrency problems \n\t\tgama.pref_synchronize_quadtree <- true;\n\t}\n\t\n\tabort {\n\t\tgama.pref_synchronize_quadtree <- previous_state;\n\t}\n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput synchronized: true {\n\t\tdisplay Sky  background: #blue type: 3d fullscreen: 0 toolbar: false axes:false{ \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image trace: 10 fading: true ;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\n\t\t\tevent #mouse_move {ask simulation {do move_goal;}}\n\t\t}\n\n\t}\n}"}
{"prompt": "**This is a simulation of Boid behavior using NetLogo. The code defines various species (Boids, obstacles, and a goal) and experiments to visualize their behavior.**", "gaml_code": "/**\n* Name: Boids 3D Analysis\n* Author: \n* Description:  This model shows the movement of boids following a goal and creating a flock. \n* Four experiments are proposed : Simple is the 3D display of the boids like a real world, \n* Trajectory Analysis is about the analysis of the trajectories of the boids, Space Time Cube adds two \n* \tdisplays to see the movement of the boids using the time as the z-axis, and the last one represents the \n* \tdifferents cameras available in GAMA.\n* Tags: gui, skill, 3d, camera, multi_level\n*/\nmodel boids\n\nglobal torus: torus_environment {\n//Number of boids to represent\n\tint number_of_agents <- 10 min: 1 max: 500;\n\t//Number of obstacles to represent\n\tint number_of_obstacles <- 4 min: 0;\n\t//Size of the boids\n\tint boids_size <- 20 min: 1;\n\t//Maximal speed allowed for the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Speed radius\n\tfloat radius_speed <- 0.5 min: 0.1;\n\t//Cohesion factor of the boid group  in the range of a boid agent\n\tint cohesion_factor <- 200;\n\t//Alignment factor used for the boid group in the range of a boid agent\n\tint alignment_factor <- 100;\n\t//Minimal distance to move\n\tfloat minimal_distance <- 30.0;\n\t//Maximal turn done by the boids\n\tint maximal_turn <- 45 min: 0 max: 359;\n\n\t//Parameters of the environment and the simulations\n\tint width_and_height_of_environment <- 800;\n\tbool torus_environment <- false;\n\tbool apply_cohesion <- true;\n\tbool apply_alignment <- true;\n\tbool apply_separation <- true;\n\tbool apply_goal <- true;\n\tbool apply_avoid <- true;\n\tbool apply_wind <- true;\n\tbool moving_obstacles <- false;\n\tint bounds <- int(width_and_height_of_environment / 20);\n\t//Wind vector \n\tpoint wind_vector <- {0, 0};\n\tint goal_duration <- 30 update: (goal_duration - 1);\n\t//Goal location\n\tpoint goal <- {rnd(width_and_height_of_environment - 2) + 1, rnd(width_and_height_of_environment - 2) + 1};\n\tlist images of: image_file <- [file('../images/bird1.png'), file('../images/bird2.png'), file('../images/bird3.png')];\n\tstring file_path_to_ocean <- '../images/ocean.jpg';\n\tint xmin <- bounds;\n\tint ymin <- bounds;\n\tint xmax <- (width_and_height_of_environment - bounds);\n\tint ymax <- (width_and_height_of_environment - bounds);\n\tgeometry shape <- square(width_and_height_of_environment);\n\n\t// flock's parameter \n\tfloat two_boids_distance const: true init: 30.0;\n\tint merging_distance const: true init: 30;\n\tbool create_flock init: false;\n\n\tinit {\n\t//Create the boids and place them randomlly\n\t\tcreate boids number: number_of_agents {\n\t\t\tlocation <- {rnd(width_and_height_of_environment - 2) + 1, rnd(width_and_height_of_environment - 2) + 1};\n\t\t}\n\n\t\t//Create an obstacle and place it randomly\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd(width_and_height_of_environment - 2) + 1, rnd(width_and_height_of_environment - 2) + 1};\n\t\t}\n\t\t//Create a goal and place it at the goal location\n\t\tcreate boids_goal number: 1 {\n\t\t\tlocation <- goal;\n\t\t}\n\n\t\tcreate aggregatedboids;\n\t}\n\n\t//Reflex to create flock of boids considering the neighbours of each boids \n\treflex create_flocks {\n\t\tif create_flock {\n\t\t//Create a map using a boid agent as a key and the list of all its neighbours as the value for the key\n\t\t\tmap<boids, list<boids>> potentialBoidsNeighboursMap;\n\n\t\t\t//Search all the boids within the two boids distance from a boid agent and put them in the map\n\t\t\tloop one_boids over: boids {\n\t\t\t\tlist<boids> free_neighbours <- boids overlapping (one_boids.shape + (two_boids_distance));\n\t\t\t\tremove one_boids from: free_neighbours;\n\t\t\t\tif !(empty(free_neighbours)) {\n\t\t\t\t\tadd (one_boids::free_neighbours) to: potentialBoidsNeighboursMap;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//Sorting of all the boids considered as key in the map by the length of their neighbours\n\t\t\tlist<boids> sorted_free_boids <- (potentialBoidsNeighboursMap.keys) sort_by (length(potentialBoidsNeighboursMap at each));\n\t\t\t//Removing of all the boids which has been considered as a key of the map, but  which are already included in a bigger list of neighbours by one of them neighbours\n\t\t\tloop one_boids over: sorted_free_boids {\n\t\t\t\tlist<boids> one_boids_neighbours <- potentialBoidsNeighboursMap at one_boids;\n\t\t\t\tif (one_boids_neighbours != nil) {\n\t\t\t\t\tloop one_neighbour over: one_boids_neighbours {\n\t\t\t\t\t\tremove one_neighbour from: potentialBoidsNeighboursMap;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//Remove all the duplicates key of potentialBoidsNeighboursMap\n\t\t\tlist<boids> boids_neighbours <- (potentialBoidsNeighboursMap.keys);\n\t\t\tloop one_key over: boids_neighbours {\n\t\t\t\tput (remove_duplicates((potentialBoidsNeighboursMap at (one_key)) + one_key)) at: one_key in: potentialBoidsNeighboursMap;\n\t\t\t}\n\n\t\t\t//Create a flock of boids considering the key of potentialBoidsNeighboursMap\n\t\t\tloop one_key over: (potentialBoidsNeighboursMap.keys) {\n\t\t\t\tlist<boids> micro_agents <- potentialBoidsNeighboursMap at one_key;\n\t\t\t\tif ((length(micro_agents)) > 1) {\n\t\t\t\t\tcreate flock number: 1 with: [color::rgb([rnd(255), rnd(255), rnd(255)])] {\n\t\t\t\t\t\tcapture micro_agents as: boids_delegation;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n//Species boids_goal which represents the goal followed by the boids agent, using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range const: true init: 20.0;\n\tint radius <- 3;\n\n\t//Reflex to make the goal move in circle\n\treflex wander_in_circle {\n\t\tlocation <- {world.shape.width / 2 + world.shape.width / 2 * cos(time * radius_speed), world.shape.width / 2 + world.shape.width / 2 * sin(time * radius_speed)};\n\t\tgoal <- location;\n\t}\n\n\taspect default {\n\t\tdraw circle(10) color: rgb('red');\n\t\tdraw circle(40) color: rgb('orange') wireframe: true;\n\t}\n\n}\n\n//Species flock which represents the flock of boids agents, managing the boids agents captured\nspecies flock {\n//Represent the cohesion index of the flock\n\tfloat cohesionIndex <- two_boids_distance update: (two_boids_distance + (length(members)));\n\trgb color <- rgb([64, 64, 64]);\n\tgeometry shape update: !(empty(members)) ? ((polygon(members collect\n\t(boids_delegation(each)).location)) + 2.0) : (polygon([{rnd(width_and_height_of_environment), rnd(width_and_height_of_environment)}]));\n\n\t//Species that will represent the boids agents captured or inside a flock\n\tspecies boids_delegation parent: boids topology: topology(world.shape) {\n\t\tlist<boids> others -> ((boids_delegation overlapping (shape + range))) - self;\n\n\t\t//Action to compute the mass center of the flock\n\t\taction compute_mass_center type: point {\n\t\t\tloop o over: others {\n\t\t\t\tif dead(o) {\n\t\t\t\t\twrite 'in ' + name + ' agent with others contains death agents';\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn (length(others) > 0) ? (mean(others collect (each.location))) : location;\n\t\t}\n\n\t\treflex separation when: apply_separation {\n\t\t}\n\n\t\treflex alignment when: apply_alignment {\n\t\t}\n\t\t//Reflex to apply the cohesion on the boids agents\n\t\treflex cohesion when: apply_cohesion {\n\t\t\tpoint acc <- compute_mass_center() - location;\n\t\t\tacc <- acc / cohesion_factor;\n\t\t\tvelocity <- velocity + acc;\n\t\t}\n\n\t\treflex avoid when: apply_avoid {\n\t\t}\n\n\t}\n\t//Reflex to capture boids agents and release captured boids agents\n\treflex capture_release_boids {\n\t\tlist<boids_delegation> removed_components <- boids_delegation where ((each distance_to location) > cohesionIndex);\n\t\tif !(empty(removed_components)) {\n\t\t\trelease removed_components;\n\t\t}\n\n\t\tlist<boids> added_components <- boids where ((each distance_to location) < cohesionIndex);\n\t\tif !(empty(added_components)) {\n\t\t\tcapture added_components as: boids_delegation;\n\t\t}\n\n\t}\n\t//Reflexe to kill the flock if the boids agents contained is lower than 2\n\treflex dispose when: ((length(members)) < 2) {\n\t\trelease list<agent>(members);\n\t\tdo die;\n\t}\n\t//Reflex to merge the flocks too close from each other\n\treflex merge_nearby_flocks {\n\t\tlist<flock> nearby_flocks <- (flock overlapping (shape + merging_distance));\n\t\tif !(empty(nearby_flocks)) {\n\t\t\tnearby_flocks <- nearby_flocks sort_by (length(each.members));\n\t\t\tflock largest_flock <- nearby_flocks at ((length(nearby_flocks)) - 1);\n\t\t\tremove largest_flock from: nearby_flocks;\n\t\t\tlist<boids> added_components;\n\t\t\tloop one_flock over: nearby_flocks {\n\t\t\t\trelease list<agent>(one_flock.members) returns: released_boids;\n\t\t\t\tloop rb over: released_boids {\n\t\t\t\t\tadd boids(rb) to: added_components;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif !(empty(added_components)) {\n\t\t\t\task largest_flock {\n\t\t\t\t\tcapture added_components as: boids_delegation;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taspect default {\n\t\tdraw shape color: color;\n\t}\n\n}\n\n//Species to represent the boids aggregated\nspecies aggregatedboids {\n\n\treflex updateLocation {\n\t\tlocation <- mean(boids collect (each.location));\n\t}\n\n\taspect base {\n\t\tdraw circle(10) color: #white;\n\t}\n\n}\n//Species to represent the boids agent using the skill moving\nspecies boids skills: [moving] {\n//Speed of the agent\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range of movement for the neighbours\n\tfloat range <- minimal_distance * 2;\n\t//Velocity of the agent\n\tpoint velocity <- {0, 0};\n\tfloat hue <- rnd(360) / 360;\n\n\t//List of the neighbours boids\n\tlist<boids> others update: ((boids overlapping (circle(range))) - self);\n\n\t//Point of the mass center of the \"flock\" considered as the neighbours agents\n\tpoint mass_center update: (length(others) > 0) ? (mean(others collect (each.location))) : location;\n\n\t//Reflex to do the separation of the agents with the other boids in the minimal distance\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0, 0};\n\t\tloop boid over: (boids at_distance minimal_distance) {\n\t\t\tacc <- acc - ((boid.location) - location);\n\t\t}\n\n\t\tvelocity <- velocity + acc;\n\t}\n\n\t//Reflex to do the alignement of the boids\n\treflex alignment when: apply_alignment {\n\t\tpoint acc <- mean(others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\n\t//Reflex to apply the cohesion using the mass center of the \"flock\"\n\treflex cohesion when: apply_cohesion {\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor;\n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid {\n\t\tpoint acc <- {0, 0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle(range)));\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\n\t\tvelocity <- velocity + acc;\n\t}\n\t//action to represent the bounding of the movement of the boids\n\taction bounding {\n\t\tif !(torus_environment) {\n\t\t\tif (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds, 0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds, 0};\n\t\t\t}\n\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0, bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0, bounds};\n\t\t\t}\n\n\t\t}\n\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal when: apply_goal {\n\t\tvelocity <- velocity + ((goal - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t//action to move  \n\taction do_move {\n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) - 2, (rnd(4)) - 2};\n\t\t}\n\n\t\tpoint old_location <- location;\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\n\t//Reflex to do the movement, calling both bounding and do_move actions\n\treflex movement {\n\t\tdo bounding;\n\t\tdo do_move;\n\t}\n\n\taspect basic {\n\t\tdraw triangle(boids_size) color: rgb('black');\n\t}\n\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: boids_size rotate: heading color: rgb('black');\n\t}\n\n\taspect dynamicColor {\n\t\trgb cc <- hsb(float(heading) / 360.0, 1.0, 1.0);\n\t\tdraw triangle(20) size: 15 rotate: 90 + heading color: cc border: cc depth: 5;\n\t}\n\n}\n\n//Species which represents the obstacles using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 0.1;\n\n\taspect default {\n\t\tdraw triangle(20) color: rgb('yellow') depth: 5;\n\t}\n\n}\n\nexperiment base virtual:true{\n\t\n\tparameter 'Number of agents'  var:number_of_agents;\n\tparameter 'Number of obstacles' var:number_of_obstacles;\n\tparameter 'Boids size' var:boids_size;\n\tparameter 'Maximal speed' var:maximal_speed;\n\tparameter 'radius speed' var:radius_speed;\n\tparameter 'Cohesion Factor' var:cohesion_factor;\n\tparameter 'Alignment Factor' var:alignment_factor;\n\tparameter 'Minimal Distance' var:minimal_distance;\n\tparameter 'Maximal Turn' var:maximal_turn;\n\tparameter 'Width/Height of the Environment' var:width_and_height_of_environment;\n\tparameter 'Direction of the wind' var:wind_vector;\n\tparameter 'Toroidal Environment ?' var:torus_environment;\n\tparameter 'Apply Cohesion ?' var:apply_cohesion;\n\tparameter 'Apply Alignment ?' var:apply_alignment;\n\tparameter 'Apply Separation ?' var:apply_separation;\n\tparameter 'Follow Goal ?' var:apply_goal;\n\tparameter 'Apply Avoidance ?' var:apply_avoid;\n\tparameter 'Apply Wind ?' var:apply_wind;\n\tparameter 'Moving Obstacles ?' var:moving_obstacles;\n\t\n}\n\nexperiment \"Simple\" type: gui parent:base{\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tdisplay RealBoids type: 3d {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies boids aspect: dynamicColor position: {0, 0, 0.1} trace: 30;\n\t\t\tspecies boids_goal transparency: 0.2 position: {0, 0, 0.1};\n\t\t\tspecies obstacle position: {0, 0, 0.1};\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Trajectory Analysis\" type: gui parent:base{\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tlayout #split;\n\t\tdisplay RealBoids type: 3d {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies boids aspect: dynamicColor transparency: 0.5 position: {0, 0, 0.1};\n\t\t\tspecies boids_goal transparency: 0.2 position: {0, 0, 0.1};\n\t\t\tspecies obstacle position: {0, 0, 0.1};\n\t\t}\n\n\t\tdisplay AggregatedBoidsTrajectory type: 3d {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies aggregatedboids aspect: base trace: 100 fading: true;\n\t\t\tspecies boids_goal aspect: default;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Space & Time Cube\" type: gui parent:base{\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tlayout #split;\n\t\tdisplay RealBoids type: 3d {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies boids aspect: dynamicColor transparency: 0.5 position: {0, 0, 0.1};\n\t\t\tspecies boids_goal transparency: 0.2 position: {0, 0, 0.1};\n\t\t\tspecies obstacle position: {0, 0, 0.1};\n\t\t}\n\n\t\tdisplay SpaceTimeCubeAll type: 3d camera: #from_up_front {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies boids trace: 100 {\n\t\t\t\tdraw triangle(20) size: 15 rotate: heading color: hsb(float(heading) / 360.0, 1.0, 1.0) border: hsb(float(heading) / 360.0, 1.0, 1.0) depth: 5 at:\n\t\t\t\t{location.x, location.y, location.z + time};\n\t\t\t}\n\n\t\t\tspecies boids_goal trace: 100 {\n\t\t\t\tdraw sphere(10) color: rgb('yellow') at: {location.x, location.y, location.z + time};\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay SpaceTimeCubeAggregated type: 3d camera: #from_up_front {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies aggregatedboids trace: 500 {\n\t\t\t\tdraw sphere(10) color: rgb('red') at: {location.x, location.y, location.z + time};\n\t\t\t}\n\n\t\t\tspecies boids_goal trace: 500 {\n\t\t\t\tdraw sphere(10) color: rgb('yellow') at: {location.x, location.y, location.z + time};\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Multiple views\" type: gui parent:base{\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput synchronized: true {\n\t\tlayout #split;\n\t\tdisplay RealBoids type: 2d antialias: false {\n\t\t\timage file_path_to_ocean refresh: false;\n\t\t\tspecies boids aspect: dynamicColor transparency: 0.5 position: {0, 0, 0.1};\n\t\t\tspecies boids_goal transparency: 0.2 position: {0, 0, 0.25};\n\t\t\tspecies obstacle;\n\t\t\tspecies boids aspect: dynamicColor transparency: 0.2 position: {0, 0, 0.24};\n\t\t}\n\n\t\tdisplay ThirdPerson type: 3d antialias: false {\n\t\t\tcamera \"default\" dynamic: true location: {int(first(boids).location.x), int(first(boids).location.y), 500} target:\n\t\t\t{int(first(boids).location.x), int(first(boids).location.y), 0};\n\t\t\toverlay position: {5, 5} size: {width_and_height_of_environment/3,width_and_height_of_environment/3} transparency: 0.2 rounded: false {\n\t\t\t \task boids {\n\t\t\t\t\tdraw triangle(20) size: 15 rotate: 90 + heading color: int(self)=0 ? #red: #gray depth: 5 at: location/3;\n\t\t\t \t}\n\t\t\t}\n\t\t\timage file_path_to_ocean;\n\t\t\tspecies obstacle;\n\t\t\tspecies boids aspect: dynamicColor transparency: 0.2;\n\t\t\tspecies boids_goal transparency: 0.2;\n\t\t}\n\n\t\tdisplay FirstPerson type: 3d antialias: false {\n\t\t\tcamera \"default\" dynamic: true location: {int(first(boids).location.x), int(first(boids).location.y), 10} target:\n\t\t\t{cos(first(boids).heading) * first(boids).speed + int(first(boids).location.x), sin(first(boids).heading) * first(boids).speed + int(first(boids).location.y), 5};\n\t\t\timage file_path_to_ocean;\n\t\t\tspecies obstacle;\n\t\t\tspecies boids aspect: dynamicColor transparency: 0.2;\n\t\t\tspecies boids_goal transparency: 0.2;\n\t\t\toverlay position: {5, 5} size: {width_and_height_of_environment/3,width_and_height_of_environment/3} transparency: 0.2 rounded: false {\n\t\t\t \task boids {\n\t\t\t\t\tdraw triangle(20) size: 15 rotate: 90 + heading color: int(self)=0 ? #red: #gray depth: 5 at: location/3;\n\t\t\t \t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates the K-Nearest Neighbors algorithm. The user should be able to interact with the model by clicking on locations, and the color of each point should be determined by the colors of its k-nearest neighbors.", "gaml_code": "/**\n* Name: K Nearest Neighbors\n* Description: This model represents how the K Nearest Neighbors Algorithm work. Whenever the user click on any location, a point will\n* be generated and its color will be based on the colors of its k-nearest points. The user can also let the point generated dynamically and \n* the colors of these points will also based on the colors of their k-nearest points\n* Author: Minh Nguyen Dich Nhat\n* Tags: \n*/\n\n/**\n * There will be four parameters\n * The first one is \"Number of group\", it will specify the number of group in our model. Different groups have different colors.\n * The second one is \"Radius\", this parameter is the radius of the circles which contain the groups. \n * The third one is \"Initial number of point for each group\". \n * And the final one is \"Number of neighbors\", this will specify the number of neighbors that we want to use for our \"k_nearest_neighbors\" operator,\n * the \"k_nearest_neighbors\" have one parameter called k, this parameter specify the number of agents we want to compare with our agent. The \n * \"Number of neighbours\" parameter is the parameter k in the \"k_nearest_neighbors\" operator.\n */\n\n\nmodel KNearestNeighbors\n\n\nglobal {\n\n\tmap<unknown, unknown> store;\n\tlist<rgb> colour <- [#red, #blue, #green, #yellow, #purple, #orange, #pink, #magenta, #cyan];\n    int init_amount <- 10;\n    int nb_group <- 2;\n    float radius <- 10.0;\n    int k <- 10;\n\tinit {\n\t\tloop i from: 0 to: nb_group - 1{\n\t\t\tspecial_point center;\n\t\t\tcreate special_point{\n\t\t\t\tcolor <- colour[i];\n\t\t\t\tcenter <- self;\n\t\t\t}\n\t\t\tgeometry around <- circle(radius, center.location) intersection world.shape;\n\t\t\tcreate special_point number: init_amount - 1{\n\t\t\t\tlocation <- any_location_in(around);\n\t\t\t\tcolor <- center.color;\n\t\t\t}\n\t\t}\n\t\tstore <- world.special_point as_map (each::each.color);\n\t}\n\n\taction createAgent{\n\t    create special_point{\n\t    \tlocation <- #user_location;\n\t    \tcolor <- self k_nearest_neighbors (store, k);\n\t\t    store <+ (self::color);\n\t    }\n\t}\n\n\treflex auto{\n\t\tcreate special_point{\n\t   \t\tcolor <- self k_nearest_neighbors (store, k);\n\t   \t\tstore <+ self::color;\n\t   \t}\n\t}\n}\n\nspecies special_point {\n\tfloat size <- 0.5;\n\trgb color;\n\taspect base{\n\t\tdraw circle(size) color:color;\n\t}\n\t\n}\n\nexperiment demo {\n\tparameter \"Number of groups: \" var:nb_group min: 2 max: 9;\n\tparameter \"Radius: \" var: radius min:10.0 max:30.0;\n\tparameter \"Initial numbers of agent for each group: \" var:init_amount min:1 max:50;\n\tparameter \"Number of neighbours considered (K)\" var:k min:1;\n\toutput {\n\t\tdisplay main type:2d{\n\t\t\tspecies special_point aspect: base;\n\t\t\tevent #mouse_down {ask simulation {do createAgent;}} \n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of people evacuating from an area to an exit location while avoiding walls, using a grid-based space and agent movement.", "gaml_code": "/**\n* Name: evacuationgoto\n* Author: Patrick Taillandier\n* Description: A 3D model with walls and exit, and people agents trying to evacuate \n* \tfrom the area to a exit location, avoiding the walls with a discretized space by a grid\n* Tags: 3d, shapefile, gis, agent_movement, skill, grid\n*/\n\nmodel evacuationgoto\n\nglobal {\n\t//Shapefile of the walls\n\tfile wall_shapefile <- shape_file(\"../includes/walls.shp\");\n\t//Shapefile of the exit\n\tfile exit_shapefile <- shape_file(\"../includes/exit.shp\");\n\t//DImension of the grid agent\n\tint nb_cols <- 50;\n\tint nb_rows <- 50;\n\t\n\t//Shape of the world initialized as the bounding box around the walls\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tinit {\n\t\t//Creation of the wall and initialization of the cell is_wall attribute\n\t\tcreate wall from: wall_shapefile {\n\t\t\task cell overlapping self {\n\t\t\t\tis_wall <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the exit and initialization of the cell is_exit attribute\n\t\tcreate exit from: exit_shapefile {\n\t\t\task (cell overlapping self) where not each.is_wall{\n\t\t\t\tis_exit <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the people agent\n\t\tcreate people number: 50{\n\t\t\t//People agent are placed randomly among cells which aren't wall\n\t\t\tlocation <- one_of(cell where not each.is_wall).location;\n\t\t\t//Target of the people agent is one of the possible exits\n\t\t\ttarget <- one_of(cell where each.is_exit).location;\n\t\t}\n\t}\n}\n//Grid species to discretize space\ngrid cell width: nb_cols height: nb_rows neighbors: 8 {\n\tbool is_wall <- false;\n\tbool is_exit <- false;\n\trgb color <- #white;\t\n}\n//Species exit which represent the exit\nspecies exit {\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n//Species which represent the wall\nspecies wall {\n\taspect default {\n\t\tdraw shape color: #black depth: 10;\n\t}\n}\n//Species which represent the people moving from their location to an exit using the skill moving\nspecies people skills: [moving]{\n\t//Evacuation point\n\tpoint target;\n\trgb color <- rnd_color(255);\n\t\n\t//Reflex to move the agent \n\treflex move {\n\t\t//Make the agent move only on cell without walls\n\t\tdo goto target: target speed: 1.0 on: (cell where not each.is_wall) recompute_path: false;\n\t\t//If the agent is close enough to the exit, it dies\n\t\tif (self distance_to target) < 2.0 {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw pyramid(2.5) color: color;\n\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\n\t}\n}\nexperiment evacuationgoto type: gui {\n\tfloat minimum_cycle_duration <- 0.04; \n\toutput {\n\t\tdisplay map type: 3d axes:false{\n\t\t\timage \"../images/floor.jpg\";\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies exit refresh: false;\n\t\t\tspecies people;\n\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of an evacuation system where agents (people) move towards a target point while avoiding obstacles and maintaining cohesion, using NetLogo-like modeling language.", "gaml_code": "/**\n* Name: continuous_move\n* Author: Patrick Taillandier\n* Description: A 3D model which show how to represent an evacuation system with \n* \tobstacles, cohesion factor and velocity. The people are placed randomly and have \n* \tto escape by going to a target point\n* Tags: 3d, shapefile, gis, agent_movement, skill\n*/\nmodel continuous_move \nglobal { \n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(building_shapefile);\n\tint maximal_turn <- 90; //in degree\n\tint cohesion_factor <- 10;\n\t//Size of the people\n\tfloat people_size <- 2.0;\n\t//Space without buildings\n\tgeometry free_space;\n\t//Number of people agent\n\tint nb_people <- 500;\n\t//Point to evacuate\n\tpoint target_point <- {shape.width, 0};\n\tinit { \n\t\t\n\t\tfree_space <- copy(shape);\n\t\t//Creation of the buildinds\n\t\tcreate building from: building_shapefile {\n\t\t\t//Creation of the free space by removing the shape of the different buildings existing\n\t\t\tfree_space <- free_space - (shape + people_size);\n\t\t}\n\t\t//Simplification of the free_space to remove sharp edges\n\t\tfree_space <- free_space simplification(1.0);\n\t\t//Creation of the people agents\n\t\tcreate people number: nb_people {\n\t\t\t//People agents are placed randomly among the free space\n\t\t\tlocation <- any_location_in(free_space);\n\t\t\ttarget_loc <-  target_point;\n\t\t} \t\t \t\n\t}\t\n}\n//Species which represent the building \nspecies building {\n\t//Height of the buildings\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species people which move to the evacuation point using the skill moving\nspecies people skills:[moving]{\n\t//Target point to evacuate\n\tpoint target_loc;\n\t//Speed of the agent\n\tfloat speed <- 0.5 + rnd(1000) / 1000;\n\t//Velocity of the agent\n\tpoint velocity <- {0,0};\n\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\n\tfloat heading max: heading + maximal_turn min: heading - maximal_turn;\n\t\n\t//Size of the agent\n\tfloat size <- people_size; \n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\n\t//Reflex to kill the agent when it has evacuated the area\n\treflex end when: location distance_to target_loc <= 2 * people_size{\n\t\twrite name + \" is arrived\";\n\t\tdo die;\n\t}\n\t//Reflex to compute the velocity of the agent considering the cohesion factor\n\treflex follow_goal  {\n\t\tvelocity <- velocity + ((target_loc - location) / cohesion_factor);\n\t}\n\t//Reflex to apply separation when people are too close from each other\n\treflex separation {\n\t\tpoint acc <- {0,0};\n\t\task (people at_distance size)  {\n\t\t\tacc <- acc - (location - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to avoid the different obstacles\n\treflex avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<building> nearby_obstacles <- (building at_distance people_size);\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - (obs.location - location); \n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Reflex to move the agent considering its location, target and velocity\n\treflex move {\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity ;\n\t\tif not(self overlaps free_space ) {\n\t\t\tlocation <- ((location closest_points_with free_space)[1]);\n\t\t}\n\t\tvelocity <- location - old_location;\n\t}\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size*0.75} color: color;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\tfloat minimum_cycle_duration <- 0.04; \n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a simulation model for an evacuation scenario where people need to escape from a flooding city using different alert communication strategies.", "gaml_code": "/***\n* Name: CityEscape\n* Author: kevinchapuis\n* Description: An evacuation model of a theoretical city with different alert communication strategies. Hazard is a very simple flood\n* and we make the hypothesis that people die when they are in the flood (e.g. Tsunami). The flooding start x time after the beginning\n* of the simulation. People escape when they perceive the flood or when they are alerted. There are 3 communication strategies: \n* - 'EVERYONE' = to alert everyone at the start of the simulation\n* - 'STAGED' = to alert nb_people/nb_stages random people every (time_of_hazard-buffer_time)/nb_stages minutes\n* - 'SPATIAL' = to alert nb_people/nb_stages closest people to exits every (time_of_hazard-buffer_time)/nb_stages minutes\n* Where (time_of_hazard-buffer_time)/nb_stages correspond to the time between stages computed using the three parameters:\n* - Time before hazard = time_of_hazard\n* - Time alert buffer before hazard = buffer_time\n* - Number of stages = nb_stages\n* Tags: evacuation, traffic, hazard, gis, water\n***/\nmodel CityEscape\n\nglobal {\n\t\n\t// Starting date of the simulation\n\tdate starting_date <- #now;\n\t\n\t// Time step to represent very short term movement (for congestion)\n\tfloat step <- 10#sec;\n\t\n\tint nb_of_people;\n\t\n\t// To initialize perception distance of inhabitant\n\tfloat min_perception_distance <- 10.0;\n\tfloat max_perception_distance <- 30.0;\n\t\n\t// Represents the capacity of a road indicated as: number of inhabitant per #m of road\n\tfloat road_density;\n\t\n\t// Parameters of the strategy\n\tint time_after_last_stage;\n\tstring the_alert_strategy;\n\tint nb_stages;\n\t\n\t// Parameters of hazard\n\tint time_before_hazard;\n\tfloat flood_front_speed;\n\t\n\tfile road_file <- file(\"../includes/city_environment/road_environment.shp\");\n\tfile buildings <- file(\"../includes/city_environment/building_environment.shp\");\n\tfile evac_points <- file(\"../includes/city_environment/evacuation_environment.shp\");\n\tfile water_body <- file(\"../includes/city_environment/sea_environment.shp\");\n\tgeometry shape <- envelope(envelope(road_file)+envelope(water_body));\n\t\n\t// Graph road\n\tgraph<geometry, geometry> road_network;\n\tmap<road,float> road_weights;\n\t\n\t// Output the number of casualties\n\tint casualties;\n\t\n\tinit {\n\t\t\t\t\n\t\tcreate road from:road_file;\n\t\tcreate building from:buildings;\n\t\tcreate evacuation_point from:evac_points;\n\t\tcreate hazard from: water_body;\n\t\t\n\t\tcreate inhabitant number:nb_of_people {\n\t\t\tlocation <- any_location_in(one_of(building));\n\t\t\tsafety_point <- any(evacuation_point);\n\t\t\tperception_distance <- rnd(min_perception_distance, max_perception_distance);\n\t\t}\n\t\t\n\t\tcreate crisis_manager;\n\t\t\n\t\troad_network <- as_edge_graph(road);\n\t\troad_weights <- road as_map (each::each.shape.perimeter);\n\t\n\t}\n\t\n\t// Stop the simulation when everyone is either saved :) or dead :(\n\treflex stop_simu when:inhabitant all_match (each.saved or each.drowned) {\n\t\tdo pause;\n\t}\n\t\n}\n\n/*\n * Agent responsible of the communication strategy\n */\nspecies crisis_manager {\n\t\n\t/*\n\t * Time between each alert stage (#s)\n\t */\n\tfloat alert_range;\n\t\n\t/*\n\t * The number of people to alert every stage\n\t */\n\tint nb_per_stage;\n\t\n\t/*\n\t * Parameter to compute spatial area of each stage in the SPATIAL strategy\n\t */\n\tgeometry buffer;\n\tfloat distance_buffer;\n\t\n\tinit {\n\t\t// For stage strategy\n\t\tint modulo_stage <- length(inhabitant) mod nb_stages; \n\t\tnb_per_stage <- int(length(inhabitant) / nb_stages) + (modulo_stage = 0 ? 0 : 1);\n\t\t\n\t\t// For spatial strategy\n\t\tbuffer <- geometry(evacuation_point collect (each.shape buffer 1#m));\n\t\tdistance_buffer <- world.shape.height / nb_stages;\n\t\t\n\t\talert_range <- (time_before_hazard#mn - time_after_last_stage#mn) / nb_stages;\n\t}\n\t\n\t/*\n\t * If the crisis manager should send an alert\n\t */\n\treflex send_alert when: alert_conditional() {\n\t\task alert_target() { self.alerted <- true; }\n\t}\n\t\n\t/*\n\t * The conditions to send an alert : return true at cycle = 0 and then every(alert_range)\n\t * depending on the strategy used\n\t */\n\tbool alert_conditional {\n\t\tif(the_alert_strategy = \"STAGED\" or the_alert_strategy = \"SPATIAL\"){\n\t\t\treturn every(alert_range);\n\t\t} else {\n\t\t\tif(cycle = 0){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * Who to send the alert to: return a list of inhabitant according to the strategy used\n\t */\n\tlist<inhabitant> alert_target {\n\t\tswitch the_alert_strategy {\n\t\t\tmatch \"STAGED\" {\n\t\t\t\treturn nb_per_stage among (inhabitant where (each.alerted = false));\n\t\t\t}\n\t\t\tmatch \"SPATIAL\" {\n\t\t\t\tbuffer <- buffer buffer distance_buffer;\n\t\t\t\treturn inhabitant overlapping buffer;\n\t\t\t}\n\t\t\tmatch \"EVERYONE\" {\n\t\t\t\treturn list(inhabitant);\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n/*\n * Represent the water body. When attribute triggered is turn to true, inhabitant\n * start to see water as a potential danger, and try to escape\n */\nspecies hazard {\n\t\n\t// The date of the hazard\n\tdate catastrophe_date;\n\t\n\t// Is it a tsunami ? (or just a little regular wave)\n\tbool triggered;\n\t\n\tinit {\n\t\tcatastrophe_date <- current_date + time_before_hazard#mn;\n\t}\n\t\n\t/*\n\t * The shape the represent the water expend every cycle to mimic a (big) wave\n\t */\n\treflex expand when:catastrophe_date < current_date {\n\t\tif(not(triggered)) {triggered <- true;}\n\t\tshape <- shape buffer (flood_front_speed#m/#mn * step) intersection world;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color:#blue;\n\t}\n\t\n}\n\n/*\n * Represent the inhabitant of the area. They move at foot. They can pereive the hazard or be alerted\n * and then will try to reach the one randomly choose exit point\n */\nspecies inhabitant skills:[moving] {\n\t\n\t// The state of the agent\n\tbool alerted <- false;\n\tbool drowned <- false;\n\tbool saved <- false;\n\t\n\t// How far (#m) they can perceive\n\tfloat perception_distance;\n\t\n\t// The exit point they choose to reach\n\tevacuation_point safety_point;\n\t// How fast inhabitant can run\n\tfloat speed <- 10#km/#h;\n\t\n\t/*\n\t * Am I drowning ?\n\t */\n\treflex drown when:not(drowned or saved) {\n\t\tif(first(hazard) covers self){\n\t\t\tdrowned <- true;\n\t\t\tcasualties <- casualties + 1; \n\t\t}\n\t}\n\t\n\t/*\n\t * Is there any danger around ?\n\t */\n\treflex perceive when: not(alerted or drowned) and first(hazard).triggered {\n\t\tif self.location distance_to first(hazard).shape < perception_distance {\n\t\t\talerted <- true;\n\t\t}\n\t}\n\t\n\t/*\n\t * When alerted people will try to go to the choosen exit point\n\t */\n\treflex evacuate when:alerted and not(drowned or saved) {\n\t\tdo goto target:safety_point on: road_network move_weights:road_weights;\n\t\tif(current_edge != nil){\n\t\t\troad the_current_road <- road(current_edge);  \n\t\t\tthe_current_road.users <- the_current_road.users + 1;\n\t\t}\n\t}\n\t\n\t/*\n\t * Am I safe ?\n\t */\n\treflex escape when: not(saved) and location distance_to safety_point < 2#m{\n\t\tsaved <- true;\n\t\talerted <- false;\n\t}\n\t\n\taspect default {\n\t\tdraw  sphere(1#m) color:drowned ? #black : (alerted ? #red : #green);\n\t}\n\t\n}\n\n/*\n * The point of evacuation\n */\nspecies evacuation_point {\n\t\n\tint count_exit <- 0 update: length((inhabitant where each.saved) at_distance 2#m);\n\t\t\n\taspect default {\n\t\tdraw circle(1#m+49#m*count_exit/nb_of_people) color:#green;\n\t}\n\t\n}\n\n/*\n * The roads inhabitant will use to evacuate. Roads compute the congestion of road segment\n * accordin to the Underwood function.\n */\nspecies road {\n\t\n\t// Number of user on the road section\n\tint users;\n\t// The capacity of the road section\n\tint capacity <- int(shape.perimeter*road_density);\n\t// The Underwood coefficient of congestion\n\tfloat speed_coeff <- 1.0;\n\t\n\t// Update weights on road to compute shortest path and impact inhabitant movement\n\treflex update_weights {\n\t\tspeed_coeff <- max(0.05,exp(-users/capacity));\n\t\troad_weights[self] <- shape.perimeter / speed_coeff;\n\t\tusers <- 0;\n\t}\n\t\n\t// Cut the road when flooded so people cannot use it anymore\n\treflex flood_road {\n\t\tif(hazard first_with (each covers self) != nil){\n\t\t\troad_network >- self; \n\t\t\tdo die;\n\t\t}\n\t}\n\t\n\taspect default{\n\t\tdraw shape width: 4#m-(3*speed_coeff)#m color:rgb(55+200*users/capacity,0,0);\n\t}\t\n\t\n}\n\n/*\n * People are located in building at the start of the simulation\n */\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray border: #black depth: 1;\n\t}\n}\n\nexperiment \"Run\" {\n\tfloat minimum_cycle_duration <- 0.1;\n\t\t\n\tparameter \"Alert Strategy\" var:the_alert_strategy init:\"STAGED\" among:[\"NONE\",\"STAGED\",\"SPATIAL\",\"EVERYONE\"] category:\"Alert\";\n\tparameter \"Number of stages\" var:nb_stages init:6 category:\"Alert\";\n\tparameter \"Time alert buffer before hazard\" var:time_after_last_stage init:5 unit:\"mn\" category:\"Alert\";\n\t\n\tparameter \"Road density index\" var:road_density init:6.0 min:0.1 max:10.0 category:\"Congestion\";\n\t\n\tparameter \"Speed of the flood front\" var:flood_front_speed init:5.0 min:1.0 max:30.0 unit:\"m/mn\" category:\"Hazard\";\n\tparameter \"Time before hazard\" var:time_before_hazard init:5 min:0 max:10 unit:\"mn\" category:\"Hazard\";\n\t\n\tparameter \"Number of people\" var:nb_of_people init:500 min:100 max:20000 category:\"Initialization\";\n\t\n\toutput {\n\t\tdisplay my_display type:3d axes:false{ \n\t\t\tspecies road;\n\t\t\tspecies evacuation_point;\n\t\t\tspecies building;\n\t\t\tspecies hazard ;\n\t\t\tspecies inhabitant;\n\t\t}\n\t\tmonitor \"Number of casualties\" value:casualties;\n\t}\t\n\t\n}"}
{"prompt": "Create a 3D simulation of an evacuation system with buildings and agents moving through a grid, avoiding obstacles and reaching a target point.", "gaml_code": "/**\n* Name: grid_move\n* Author: \n* Description: A 3D model which show how to represent an evacuation system with \n* \tobstacles, cohesion factor and velocity. The people are placed randomly and have \n* \tto escape by going to a target point, within a discretized space by a grid. The agents \n* \tdon't use the skill moving to move.\n* Tags: 3d, shapefile, gis, agent_movement, grid\n*/\nmodel grid_move\n\nglobal {\n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the world\n\tgeometry shape <- envelope(building_shapefile);\n\t//Maximum memory of the agent to avoid loop of the agents\n\tint max_memory <- 5;\n\t//Size of the people agents\n\tfloat people_size <- 2.0;\n\t//Number of people agents\n\tint nb_people <- 500;\n\t//Evacuation point for the people agents\n\tpoint target_point <- {shape.width, 0};\n\t\n\tinit {\n\t\t//Creation of the building agents using the shapefile\n\t\tcreate building from: building_shapefile\n\t\t{\n\t\t\t//Initialization of the cell is_obstacle attribute\n\t\t\task cell overlapping self {\n\t\t\t\tis_obstacle <- true;\n\t\t\t\tcolor <- #black;\n\t\t\t}\n\t\t}\n\n\t\tlist<cell> free_cell <- cell where not (each.is_obstacle);\n\t\tcell the_target_cell <- cell closest_to target_point;\n\t\t//Creation of the people agent\n\t\tcreate people number: nb_people {\n\t\t\t//People agent are placed randomly among the cells which haven't people or obstacle\n\t\t\tcurrent_cell <- one_of(free_cell);\n\t\t\tcurrent_cell.is_free <- false;\n\t\t\tremove current_cell from: free_cell;\n\t\t\tlocation <- current_cell.location;\n\t\t\ttarget_cell <- the_target_cell;\n\t\t\tmemory << current_cell;\n\t\t\t\n\t\t}\n\t}\n}\n//Species which represent the buildings\nspecies building {\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species which represent the people agent moving from one cell to its neighbours\nspecies people {\n\t//Current cell of the agent\n\tcell current_cell;\n\t//Evacuation cell of the agent\n\tcell target_cell;\n\t//List of the cells already passed by the agents and mesmorized\n\tlist<cell> memory;\n\t//Size of the agent\n\tfloat size <- people_size;\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\n\t\n\t//Reflex to kill the agent once it is close enough to an evacuation point\n\treflex end when: location distance_to target_cell.location <= 2 * people_size {\n\t\tcurrent_cell.is_free <- true;\n\t\tdo die;\n\t}\n\t//Reflex to move the agent\n\treflex move {\n\t\t//List of all the cells possible (which aren't obstacles, without people on it and on which the agent hasn't already passed\n\t\tlist<cell> possible_cells <- current_cell.neighbors where (not (each.is_obstacle) and each.is_free and not (each in memory));\n\t\t//If there is possible cell, the agent move on the closest one to the evacuation point\n\t\tif not empty(possible_cells) {\n\t\t\tcurrent_cell.is_free <- true;\n\t\t\tcurrent_cell <- shuffle(possible_cells) with_min_of (each distance_to target_cell);\n\t\t\tlocation <- current_cell.location;\n\t\t\tcurrent_cell.is_free <- false;\n\t\t\t//Management of the memory of the agents\n\t\t\tmemory << current_cell; \n\t\t\tif (length(memory) > max_memory) {\n\t\t\t\tremove memory[0] from: memory;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size*0.75} color: color;\n\t}\n}\n//Grid species to discretize space\ngrid cell width: 150 height: 150  neighbors: 8 frequency: 0 {\n\tbool is_obstacle <- false;\n\tbool is_free <- true;\n\trgb color <- #white;\n}\n\nexperiment Run type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\tfloat minimum_cycle_duration <- 0.04; \n\toutput {\n\t\tdisplay map type: 3d    {\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Generate a simple agent-based model of 50 bugs with 5 classes, where each bug has an attribute that changes over time and is displayed as a colored sphere.", "gaml_code": "model Bug\n\nglobal {\n\tint nbClass <-5;\n\tint nbBugs <-50;\n    init {\n        create bug number: nbBugs{\n        \tattribute <- rnd(nbClass);\n        \tcolor <- hsb (attribute/nbClass,1.0,1.0);\n        }\n    }\n} \n\n\nspecies bug skills: [moving] {\n\t rgb color;\n     int attribute;\n\n\t reflex move{\n\t \tdo move;\n\t }\n\t \n\treflex update{\n\t\tattribute <- rnd(nbClass);\n\t} \n\t//Display the bug in red\n    aspect base {\n        draw sphere(1) color: #red;\n    }\n    \n    //Display the bug with a color that represent the value of the attribute\n    aspect attribute{\n      draw sphere(2) color: color;\n      color <- hsb(attribute/nbClass,1.0,1.0);\n    }\n}"}
{"prompt": "Create a 3D spatial graph model that mirrors the behavior of a bug species, using a distance-based graph algorithm to connect nodes and visualize the graph in a GUI.", "gaml_code": "/**\n* Name: SpatialGraph\n* Author: Arnaud Grignard\n* Description: From the reference model \"bug.gaml\" a spatial graph is created. \n*  We create a species node that mirrors the species bug and then a spatial graph is creating \n*  using as_distance_graph operator.\n* Tags: graph, mirror, 3d\n*/\n\nmodel SpatialGraph\n//Import the model Common Bug Species model\nimport '../includes/Common Bug Species.gaml'\n\n\nglobal { \n\t//Graph that will be computed at each step linking the bug agents according to their distance\n\tgraph myGraph;\n\t//Minimal distance to consider two nodes agents (ie the bug) as connected\n\tfloat distance min: 1.0 <- 10.0;\n\t\n\t//Reflex to update the graph when cycle is greater than 0. Important because the mirroring has one step late from\n\t//the original species, and at step 0, the mirroring species aren't created\n\treflex updateGraph when:(cycle>0){\n\t\t//Kill all the edge agent to create a new graph\n\t\task edge_agent {\n\t\t\tdo die;\n\t\t}\n\t\t//Create a new graph using the distance to compute the edges\n\t\tmyGraph <- as_distance_graph(node_agent, distance, edge_agent);\n\t}\n}\n//Species node_agent mirroring the bug species\nspecies node_agent mirrors: list(bug) {\n\t//Each location will be the one of the bug at the previous step\n\tpoint location <- target.location update: target.location;\n\taspect base {\n\t\tdraw sphere(1.1) color: #green; \n\t}\n}\n//Species to represent the edge of the graph\nspecies edge_agent {\n\taspect base {\n\t\tdraw shape color: #green;\n\t}\n}\n\nexperiment spatialGraph type: gui {\n\t\n\tparameter 'Distance' var:distance  min: 1.0 <- 10.0 category: 'Model';\n\t\n\tfloat minimum_cycle_duration <- 0.05#s;\n\t\n\toutput {\t\n\t\tdisplay graph_view type: 3d {\n\t\t\tcamera 'default' location: {-15.7912,153.2715,67.8712} target: {50.0,50.0,0.0};\n\t \t    species bug aspect:base;\n\t\t\tspecies node_agent aspect: base position:{0,0,0.1};\n\t\t\tspecies edge_agent aspect: base position:{0,0,0.1};\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D graph model that mirrors a species (bug) and visualizes relationships between nodes based on distance, with animation capabilities.", "gaml_code": "/**\n* Name: SpatialGraph3d\n* Author: Arnaud Grignard\n* Description: From the reference model \"bug.gaml\" a spatial graph is created. \n*  We create a species node that mirrors the species bug and then a spatial graph is creating \n*  using as_distance_graph operator. The species node should then \n*  define its own related_to method to decide wether or not a node is related to another one.\n* Tags: graph, mirror, 3d\n*/\n\n\nmodel Graph\n\n//Import the model Common Bug Species model\nimport '../includes/Common Bug Species.gaml'\n\nglobal {\n\t//Distance to link two bugs\n\tint distance min: 1 <- 25;\n\t//variable to start the animation of the model\n\tint startAnimation min: 1 <- 25;\n\t//Variable to save the time animation\n\tint timeAnim <- 0;\n\t//Reflex to update the time of animation\n\treflex updateAnimation \n\t{\n\t\tif (time > startAnimation) \n\t\t{\n\t\t\ttimeAnim <- int(time - startAnimation);\n\t\t}\n\t}\n}\n//Species node_agent mirroring the bug species, represented as graph node\nspecies node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {\n\t//Their location is the one of the target location\n\tpoint location <- target.location update: target.location;\n\t\n\t//Action to know if an agent is related to another agent considering their distance\n\tbool related_to (node_agent other) {\n\t\tusing topology(target) {\n\t\t\treturn (target.location distance_to other.target.location) < distance;\n\t\t}\n\n\t}\n\n\taspect base {\n\t\tdraw sphere(2) color: #green;\n\t}\n\n\taspect dynamic {\n\t\tint degree <- (my_graph) degree_of (self);\n\t\tdraw sphere(1 + (degree / 5.0)) color: #blue;\n\t}\n\n}\n//Species edge to represent the edges of the graph\nspecies edge_agent parent: base_edge {\n\trgb color;\n\taspect base {\n\t\tdraw shape color: #green;\n\t}\n\t\n\taspect dynamic {\n\t\tgeometry ss <- line([{ self.source.location.x, self.source.location.y, self.source.location.z }, { self.target.location.x, self.target.location.y, self.target.location.z }]);\n\t\tfloat val <- 255.0 * (ss.perimeter / distance);\n\t\trgb cc <- hsb(val, 1.0, 1.0);\n\t\tdraw ss + 0.1 color: cc border: cc;\n\t}\n\n}\n\nexperiment AdvancedView type: gui {\n\t\n\t\n\tparameter 'Distance' var:distance category: 'Model';\n\tparameter 'Start Animation ' var:startAnimation category: 'Animation View';\n\tfloat minimum_cycle_duration <- 0.05#s;\n\t\n\toutput {\n\t\tdisplay graph_plus_bug_layered type: 3d {\n\t\t\tcamera 'default' location: {-9.2599,157.3601,111.6399} target: {52.0223,44.4922,0.0}; \n\t\t\tspecies bug aspect: base;\n\t\t\tspecies node_agent aspect: base position: { 0, 0, 0.2 };\n\t\t\tspecies edge_agent aspect: base position: { 0, 0, 0.2 };\n\t\t\tspecies node_agent aspect: dynamic position: { 0, 0, 0.4 };\n\t\t\tspecies edge_agent aspect: dynamic position: { 0, 0, 0.4 };\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D graph visualization of a complex system with multiple interacting agents and classes, where nodes represent classes and edges represent interactions between them.", "gaml_code": "/**\n* Name: Modavi\n* Author: Arnaud Grignard\n* Description: From a reference model with node of a given class, a spatial graph is created \n*  (or a barabasi graph if spatialGraph is set to false) in the advanced view to \n*  represent the interaction in the reference model.\n*  An abstract view/controller is created to summarize the interaction in the advanced view\n*  in a macro graph and control the reference model by defining an action (user_command) \n*  for each macroNode and macroEdge.\n* Tags: 3d, graph, gui\n*/\n\nmodel modavi\n \nglobal {\n\t//Graph of the agents\n\tgraph<node_agent,edge_agent> my_graph ;\n\t\n\t//Number of agents to create\n\tint nbAgent min: 1 <- 100;\n\t//Number of value per class\n\tint nbValuePerClass min: 1 max:100 <- 15;\n\t//Boolean to know if we display a spatial graph or not\n\tbool spatialGraph <- true;\n\t//Distance to link two node agents\n\tfloat distance min: 1.0 <- 10.0;\n\t//Threshold\n\tint threshold min: 0 <- 0;\n\n\t//Size of a node agent\n\tint nodeSize min: 1 <- 1;\n\t//Size of a macro node agent\n\tint macroNodeSize min: 1 <- 2;\n\t\n\t//Number of type of class\n\tint nbTypeOfClass <-1;\n\t\n\t//Zoom factor\n\tint zoomFactor <- nbTypeOfClass;\n\n\t//List of the different interaction matrices\n\tlist<matrix<int>> interactionMatrix <-list_with(nbTypeOfClass,matrix([0]));\n\t//Number maximum of edges\n    int nbEdgeMax;\n    \n    //Reflex to update the interaction matrix list\n    reflex updateInteractionMatrix{\n    \t//Ask for each edge agent to update it sources and destination to create the matrix\n    \task edge_agent{\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tsrc <- my_graph source_of(self);\n\t\t\t\tdest <- my_graph target_of(self);\n\t\t\t\tint tmp <- (interactionMatrix[i]  at {(src.classVector[i]-1),(dest.classVector[i]-1)});\n\t\t\t\tinteractionMatrix[i][src.classVector[i]-1,dest.classVector[i]-1] <- (tmp+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Reflex to compute te maximum number of edges\n\treflex computeNbEdgeMax{\n\t\t//Number maximum of edges\n\t\tnbEdgeMax <-1;\n\t\t//Ask for each macro edge its aggregated link list number\n\t\task macroEdge{\n\t\t\tif(nbAggregatedLinkList[0] > nbEdgeMax){\n\t\t\t\tnbEdgeMax <-nbAggregatedLinkList[0];\n\t\t\t}\t\n\t\t}\n\t}\n\n\t//Initialization of the model\n\tinit {\n\t\t//Initialization of the matrix\n\t\tdo InitInteractionMatrix;\n\t\t//If we want a spatial graph in that case we create a graph according to their distance, else we create a barabasi albert graph\n\t\tif(spatialGraph){\n\t\t\tcreate node_agent number:nbAgent;\n\t\t\tmy_graph <- graph<node_agent, edge_agent>(as_distance_graph(node_agent, distance, edge_agent)); \n\t\t\t\n\t\t}\n        else{\n          my_graph <- graph<node_agent, edge_agent>(generate_barabasi_albert(nbAgent * 0.5,5,nbAgent,false,node_agent,edge_agent));\t\n        }\n        \n\t\t//For each node agent, we compute its class value\n\t\task node_agent as list{\n\t\t\tloop i from:0 to:nbTypeOfClass-1{\n\t\t\t\tclassVector[i] <- rnd(nbValuePerClass-1)+1;\n \t\t\t}\t\t\n\t\t}\n\n\t\tint i<-1;\n\t\t//Creation of the macronode according to the number of value per class\n\t\tcreate macroNode number: nbValuePerClass{\t \n\t\t\tclass <-i;\n\t\t\tlocation <- {(cos (((class-1)/nbValuePerClass)*360)*50 +50),(sin (((class-1)/nbValuePerClass)*360)*50+50),0};\n\t\t\tcolor <- hsb (i/nbValuePerClass,1.0,1.0);\n\t\t\tdo updatemyNodes;\n\t\t\ti<-i+1;\t\n\t\t}\n\t\t//We finally create the macroGraph\n\t\tcreate macroGraph;\n\t }\n\t //Action to initialize the interaction Matrix according to the number of type of classes\n\t action InitInteractionMatrix{\n\t\t loop i from:0 to:nbTypeOfClass-1{\n\t\t\t\tinteractionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});\n \t\t  }\t\n\t}\n}\n\n\n//Species to represent the node_agent\nspecies node_agent  {\n\t//Color of the node agent\n\trgb color;\n\t//List of the class\n\tlist<int> classVector <- list_with (nbTypeOfClass,0);\n\t//List of the position\n\tlist<point> posVector <- list_with (nbTypeOfClass,{0,0});\n\t//List of the color\n\tlist<rgb> colorList <- list_with (nbTypeOfClass, rgb(0,0,0));\n\t\t\t\t\t\t\t\n\t//Shuffle the classes of the node_agent\n\treflex shuffleClass{\n\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t\tclassVector[i] <- rnd(nbValuePerClass-1)+1;\n\t\t}\t\n\t}\n\t\n\taspect real {\t\t\t \n\t\tdraw sphere(nodeSize) color: colorList[0];\n\t} \n\t\t\t\t\t\t\t\n\taspect coloredByClass{\n\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t    colorList[i]<- hsb (classVector[i]/nbValuePerClass,1.0,1.0);\t\t\t\t\t\n\t\t    posVector[i] <- {(location.x+i*110)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};  \n\t\t    draw sphere(nodeSize/zoomFactor) color: colorList[i] at: posVector[i] ;   \n\t\t}\n\t}\n\n}\n\n//Species edge_agent to represent the edge of the graph\nspecies edge_agent { \n\trgb color;\n\t//Source of the edge\n\tnode_agent src;\n\t//Target of the edge\n\tnode_agent dest;\n\t\t \n\taspect base {\n\t\tdraw shape color: rgb(125,125,125);\n\t}\t\n\t\n\taspect edgeGenericSpatialized{\n\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t  if ((src != nil) and (dest !=nil) ){\n\t\t\tdraw line( [ (src.posVector[i]) , (dest.posVector[i])] ) color:rgb(125,125,125);\n\t\t  }\n\t\t}\n\t}\n}\n//Species representing the macro node agents\nspecies macroNode{\n\trgb color;\n\tint class;\n\t//List of all the aggregated nodes\n\tlist<int> nbAggregatedNodes <- list_with(nbTypeOfClass,0);\n\t//List of all the position\n\tlist<point> posVector <-list_with(nbTypeOfClass,{0,0});\n\t \n\t//Update the nodes of the agents\n\treflex update{\n\t\tdo updatemyNodes;\n\t}\n\t//For each classes, find all the nodes with the same classes\n\taction updatemyNodes{\n\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\n\t\t\tnbAggregatedNodes[i]<-0;\n\t\t\task node_agent as list{\n\t\t\t  if\t(classVector[i] = myself.class) {\n\t\t\t\tmyself.nbAggregatedNodes[i] <- myself.nbAggregatedNodes[i]+1;\n\t\t\t  }\t \n\t\t    }\n\t    }\t    \n\t} \n\t\n\taspect sphere{\n\t\tdraw sphere((nbAggregatedNodes[0]/10)*macroNodeSize) color: color at: point([location.x,location.y]) ;\n\t}\n\t\n\taspect Generic{\n\t\tloop i from:0 to: nbTypeOfClass-1\n\t\t{\n\t\tposVector[i] <- {(location.x+i*150)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};\t\n\t\tdraw sphere((nbAggregatedNodes[i]/10)*macroNodeSize*(1/zoomFactor)) color: color at: posVector[i] ;\n\t\t}\n\t}\n\t\n\t//This action only works when having nbTypeOfClass=1\n\taction removeMicroNode{\n\t\task node_agent as list{\n\t\t\t  if\t(classVector[0] = myself.class) {\n\t\t\t      do die;\n\t\t\t  }\t \n         }\n\t}\n\t\n\tuser_command \"Remove all micro node\" action: removeMicroNode;\n}\n\n//Species macroEdge representing the macro edges agents\nspecies macroEdge  { \n\trgb color <- #black;\n\t//Source of the macroedge\n\tmacroNode src;\n\t//Destination of the macroedge\n\tmacroNode dest;\n\t//List of all the aggregated links\n\tlist<int> nbAggregatedLinkList <- list_with(nbTypeOfClass,0);\n\t\n\taspect base {\n\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t\tif(nbAggregatedLinkList[i]>threshold){\n\t\t\tdraw (line([src.posVector[i],dest.posVector[i]]) buffer ((nbAggregatedLinkList[i])/((length(edge_agent)))*nbEdgeMax)) color: rgb(125,125,125) border:rgb(125,125,125); \t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Action to remove a micro edge\n\taction removeMicroEdge{\n\t\task edge_agent as list{\n\t\t\t  if\t((self.src.classVector[0] =  myself.src.class) and (self.dest.classVector[0] =  myself.dest.class)) {\n\t\t\t      do die;\n\t\t\t  }\t \n         }\n\t}\n\t\n\tuser_command \"Remove all micro edge\" action: removeMicroEdge;\t\n}\n\n//Species macroGraph representing the macro graph composed of macroNode and macroEdge\nspecies macroGraph {\n\t\n\n//Reflex to update the graph by killing all the previous edges first \n   reflex updateAllMacroEdge {\t\n\t \task macroEdge as list{\n\t \t\tdo die;\n\t \t}\n\t \t\n\t \tloop h from:0 to: nbTypeOfClass-1{\n\t\t \tloop i from: 0 to: nbValuePerClass-1{\n\t\t      loop j from: 0 to: nbValuePerClass-1{\n\t\t        int tmp <- interactionMatrix[h] at {i,j}; \n\n\t\t        if(i!=j){\n\t\t            create macroEdge{\n\t\t              nbAggregatedLinkList[h] <- tmp;\n\t\t              src <- macroNode[i];\n\t\t\t\t      dest <- macroNode[j];\n\t\t            }\t  \n\t\t        }      \n\t\t      }\n\t\t    }\n\t    }\n  \t}\n  \t//Reflex to initialize the matrix\nreflex initMatrix{\n\tloop i from:0 to:nbTypeOfClass-1{\n\t  interactionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});\t\n\t}\t\n  }\t\n}\n\n\n\nexperiment MODAVI type: gui {\n\t\n\tparameter 'Number of Agents' var:nbAgent category: 'Model';\n\tparameter 'Number of value per class' var:nbValuePerClass category: 'Model';\n\tparameter 'Spatial Graph' var:spatialGraph  category: 'Model';\n\tparameter 'Distance' var:distance category: 'Model';\n\tparameter 'Threshold' var:threshold category: 'Model';\n\tparameter 'Node size' var:nodeSize category: 'Aspect';\n\tparameter 'Macro Node size' var:macroNodeSize category: 'Aspect';\n\t\n\tfloat minimum_cycle_duration <- 0.2#s;\n\t\n\t\n\toutput synchronized: true {\t\t\t\n\t\tdisplay MODAVI type:3d axes:false {\n//\t\t\tcamera #default location:{world.shape.width*1.5, world.shape.height,world.shape.width*4} target:{world.shape.width*1.5, world.shape.height,0};\n\t\t\tcamera 'default' location: {150.0,100,300} target: {150.0,100.0,0.0};\n\t\t\t\n\t\t\tgraphics 'ReferenceModel'{\n\t\t\t\tdraw \"Reference model\" at:{200,50,0} size:5 color: #black perspective:false;\n\t\t\t}\n\t\t\tspecies node_agent aspect: real position:{100,0,0.01} ;\n\t\t\t\n\t\t\tgraphics 'View1'{\n\t\t\t\tdraw \"Advanced view\" at:{50,210,0} size:5 color: #black perspective:false;\n\t\t\t}\n\t\t\tspecies node_agent aspect: coloredByClass position: {0,100,0.02};\n\t\t\tspecies edge_agent aspect: edgeGenericSpatialized position: {0,100,0.02};\n\t\t\t\n\t\t\tgraphics 'AbstractView'{\n\t\t\t\tdraw \"Abstract view/controller\" at:{250,210,0} size:5 color: #black perspective:false;\n\t\t\t}\n\t\t\tspecies macroNode aspect:Generic position: {200,100,0.01};\n\t\t\tspecies macroEdge aspect:base position: {200,100,0.01};\t\n\t\t}\n\t}\t\t\n}"}
{"prompt": "Implement a model for residential segregation using the Thomas Schelling model, allowing users to customize parameters such as color groups, number of groups, density of people, and desired percentage of similarity.", "gaml_code": "model segregation_base\n\nglobal {\n\t//Different colors for the group\n\trgb color_1 <- rgb (\"yellow\");\n\trgb color_2 <- rgb (\"red\");\n\trgb color_3 <- rgb (\"blue\");\n\trgb color_4 <- rgb (\"orange\");\n\trgb color_5 <- rgb (\"green\");\n\trgb color_6 <- rgb (\"pink\");   \n\trgb color_7 <- rgb (\"magenta\");\n\trgb color_8 <- rgb (\"cyan\");\n    list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\n\n\t\n\t//Number of groups\n\tint number_of_groups <- 2 max: 8;\n\t//Density of the people\n\tfloat density_of_people <- 0.7 min: 0.01 max: 0.99;\n\t//Percentage of similar wanted for segregation\n\tfloat percent_similar_wanted <- 0.5 min: float (0) max: float (1);\n\t//Dimension of the grid\n\tint dimensions <- 40 max: 200 min: 10;\n\t//Neighbours distance for the perception of the agents\n\tint neighbours_distance <- 2 max: 10 min: 1;\n\t//Number of people agents\n\tint number_of_people <- 0;\n\t//Number of happy people\n\tint sum_happy_people <- 0 update: all_people count (each.is_happy);\n\t//Number of similar neighbours\n\tint sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby);\n\t//Number of neighbours\n\tint sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1;\n\t//List of all the places\n\tlist<agent> all_places;\n\t//List of all the people\n\tlist<base> all_people;  \n\t\n\t//Action to write the description of the model in the console\n\taction description {\n\t\twrite \t\t\"Description. \\n\"\n\t\t\t\t+ \t\"Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\n\"\n\t\t\t\t+\t\"In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\n\"\n\t\t\t\t+ \t\"In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\n\t}\n\t//Initialization of the model\n\tinit {\n\t\t//Write the description of the model \n\t\tdo description;\n\t\t//Initialization of the places\n\t\tdo initialize_places;\n\t\t//Computation of the number of people according to the density of people\n\t\tnumber_of_people <- int( length (all_places) * density_of_people);\n\t\t//Initialization of the people\n\t\tdo initialize_people;\n\t}\n\t//Action to initialize places defined in the subclasses\n\taction initialize_places virtual: true;\n\t//Action to initialize people in the subclasses\n\taction initialize_people virtual: true;\n}\n\n//Species base representing the people agents\nspecies base {\n\trgb color;\n\t//List of all the neighbours agents\n\tlist<base> my_neighbours;\n\t//computation of the similar neighbours\n\tint similar_nearby -> \n\t\t(my_neighbours count (each.color = color))\n\t;\n\t//Computation of the total neighbours nearby\n\tint total_nearby -> \n\t\tlength (my_neighbours)\n\t;\n\t//Boolean to know if the agent is happy or not\n\tbool is_happy -> similar_nearby >= (percent_similar_wanted * total_nearby ) ;\n}\n\nexperiment base_exp virtual:true{\n\t\n\tparameter \"Color of group 1:\" category: \"User interface\" var:color_1;\n\tparameter \"Color of group 2:\" category: \"User interface\" var:color_2;\n\tparameter \"Color of group 3:\" category: \"User interface\" var:color_3;\n\tparameter \"Color of group 4:\" category: \"User interface\" var:color_4;\n\tparameter \"Color of group 5:\" category: \"User interface\" var:color_5;\n\tparameter \"Color of group 6:\" category: \"User interface\" var:color_6;\n\tparameter \"Color of group 7:\" category: \"User interface\" var:color_7;\n\tparameter \"Color of group 8:\" category: \"User interface\" var:color_8;\t\n\t\n\tparameter \"Number of groups:\" var:number_of_groups category: \"Population\";\n\tparameter \"Density of people:\" var:density_of_people category: \"Population\";\n\tparameter \"Desired percentage of similarity:\" var:percent_similar_wanted category: \"Population\";\n\tparameter \"Width and height of the environment:\" var:dimensions category: \"Environment\";\n\tparameter \"Distance of perception:\" var:neighbours_distance category: \"Population\";\n\n}"}
{"prompt": "Create a cellular automata model that simulates Schelling's Segregation model using GAML, where agents move to neighboring cells based on similarity and happiness.", "gaml_code": "/**\n* Name: segregationGrid\n* Author: \n*  Description: A model showing the segregation of the people just by putting a similarity wanted parameter using cells \n* \tto represent the individuals\n* Tags: grid\n*/\nmodel segregation\n\n//Importation of the Common Schelling Segregation model\nimport \"../includes/Common Schelling Segregation.gaml\"\n\n//Define the environment as torus\nglobal torus: true{\n\t//List of all the free places\n\tlist<space> free_places ;\n\t//List of all the places\n\tlist<space> all_places  ;\n\t//List of all the people\n\tlist<space> all_people;\n\t//Shape of the environment\n\tgeometry shape <- square(dimensions);\n\t\n\t//Action to initialize the places\n\taction initialize_places {\n\t\tall_places <- shuffle(space);\n\t\tfree_places <- shuffle(all_places);\n\t}\n\t//Action to initialize the people agents\n\taction initialize_people {\n\t\t//Place all the people agent in the cellular automata\n\t\tloop i from: 0 to: number_of_people - 1 {\n\t\t\tspace pp <- all_places at i;\n\t\t\tremove pp from: free_places;\n\t\t\tadd pp to: all_people;\n\t\t\tpp.color <- colors at (rnd(number_of_groups - 1));\n\t\t}\n\n\t}\n\t//Reflex to migrate all the people agents\n\treflex migrate {\n\t\task copy(all_people) {\n\t\t\tdo migrate;\n\t\t}\n\n\t}\n\n}\n\n//Grid species representing the places and the people in each cell\ngrid space parent: base width: dimensions height: dimensions neighbors: 8  {\n\trgb color <- #black;\n\t//List of the neighbours of the places\n\tlist<space> my_neighbours <- self neighbors_at neighbours_distance;\n\t//Action to migrate the agent in another cell if it is not happy\n\taction migrate {\n\t\tif !is_happy {\n\t\t\t//Change the space of the agent to a free space\n\t\t\tspace pp <- any(my_neighbours where (each.color = #black));\n\t\t\tif (pp != nil) {\n\t\t\t\tfree_places <+ self;\n\t\t\t\tfree_places >- pp;\n\t\t\t\tall_people >- self;\n\t\t\t\tall_people << pp;\n\t\t\t\tpp.color <- color;\n\t\t\t\tcolor <- #black;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nexperiment schelling type: gui parent:base_exp{\n\toutput {\n\t\tdisplay Segregation type:2d antialias:false{\n\t\t\tgrid space;\n\t\t}\n\n\t\tdisplay Charts  type: 2d {\n\t\t\tchart \"Proportion of happiness\" type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\n\t\t\t}\n\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 }  x_range: 50{\n\t\t\t\tdata \"happy\" color: #blue value: (sum_happy_people / number_of_people) * 100 style: spline;\n\t\t\t\tdata \"similarity\" color: #red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: step;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a model that simulates Schelling's Segregation model using agents to represent individuals and a grid to discretize space. The model should use colors from an image file to determine possible spaces for segregation. Include charts to display the proportion of happy agents and global happiness and similarity metrics.", "gaml_code": "/**\n* Name: segregationGoogleMap\n* Author: \n* Description: A model showing the segregation of the people just by putting a similarity wanted parameter using agents \n* \tto represent the individuals and a grid to discretize space. Use the colors of the image to know if it is a possible space or not\n* Tags: grid\n*/\nmodel segregation\n\n//Import the model Common Schelling Segregation\nimport \"../includes/Common Schelling Segregation.gaml\"    \n\nglobal {\n\t//List of all the free places\n\tlist<space> free_places ; \n\t//List of all the places\n\tlist<space> all_places;\n\t//Shape of the environment\n\tgeometry shape <- square(dimensions);\n\t//Percentage of similarity wanted by an agent\n\tfloat percent_similar_wanted <- 0.6;\n\t//Distance of perception of the neighbours\n\tint neighbours_distance <- 4; \n\t//Number of groups of people\n\tint number_of_groups <- 3;\n\tlist google_buildings  <- [rgb(\"#EBE6DC\"), rgb(\"#D1D0CD\"), rgb(\"#F2EFE9\"), rgb(\"#EEEBE1\"), rgb(\"#F9EFE8\")] ;\n\t//List of all the available places\n\tlist<space> available_places ;\n\t//Image file to load\n\timage_file bitmap_file_name <- image_file(\"../images/hanoi.png\");\n\tmatrix<int> map_colors;\n \n \t//Action to initialize the people agents\n\taction initialize_people {\n\t\tcreate people number: number_of_people ;  \n\t\tall_people <- people as list ;  \n\t}\n\t//Action to initialize the places using the color in the image\n\taction initialize_places { \n\t\tmap_colors <- (bitmap_file_name) as_matrix {dimensions,dimensions} ;\n\t\task space as list {\n\t\t\tcolor <- rgb(map_colors at {grid_x,grid_y}) ;\n\t\t}\n\t\tall_places <- shuffle (space where (each.color in google_buildings)) ;\n\t\tfree_places <- copy(all_places);\n\t}  \n}\n//Grid to discretize the space\ngrid space width: dimensions height: dimensions neighbors: 8 use_individual_shapes: false use_regular_agents: false frequency: 0 ; \n \n//Species people representing the people agent\nspecies people parent: base  {\n\trgb color <- colors at (rnd (number_of_groups - 1));\n\t//List of all the neighbours\n\tlist<people> my_neighbours -> (self neighbors_at neighbours_distance) of_species people;\n\t\n\t//Launched at the initialization of the agent\n\tinit {\n\t\t//Set the place of the agent as one of the free place\n\t\tlocation <- (one_of(free_places)).location; \n\t\tremove location as space from: free_places;\n\t} \n\t//Reflex to migrate the agent when it's not happy\n\treflex migrate when: !is_happy { \n\t\tadd location as space to: free_places;\n\t\tlocation <- any(free_places).location;\n\t\tremove location as space from: free_places;\n\t}\n\taspect geom {\n\t\tdraw square(1) color: color  ;\n\t}\n\taspect default {\n\t\tdraw  square(2) color: #black ;\n\t}\n}\n\n\nexperiment schelling type: gui parent:base_exp{\n\t\n\t\t\n\t parameter \"Name of image file to load:\" var:bitmap_file_name category: \"Environment\";\n\t\n\toutput {\n\t\tdisplay Segregation type:2d{\n\t\t\timage bitmap_file_name.path ;\n\t\t\tspecies people transparency: 0.5 aspect: geom;\n\t\t}\t\n\t\tdisplay Charts  type: 2d {\n\t\t\tchart \"Proportion of happiness\" type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\n\t\t\t}\n\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 } x_range: 20 y_range: 20 {\n\t\t\t\tdata \"happy\" color: #blue value: (sum_happy_people / number_of_people) * 100 style: spline fill: false;\n\t\t\t\tdata \"similarity\" color: #red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: line fill: true ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates Schelling's Segregation Model using agents to represent individuals, allowing users to adjust similarity parameters and visualize the segregation process through GUI charts.", "gaml_code": "/**\n* Name: segregationAgents\n* Author: \n* Description: A model showing the segregation of the people just by putting a similarity wanted parameter using agents \n* \tto represent the individuals\n* Tags: grid\n*/\n\nmodel segregation\n\n//import the Common Schelling Segregation model\nimport \"../includes/Common Schelling Segregation.gaml\"\n\nglobal {\n\t//List of all the free places\n\tlist<space> free_places ;\n\t//List of all the places\n\tlist<space> all_places ;\n\t//Shape of the world\n\tgeometry shape <- square(dimensions);\n\t\n\t//Action to initialize the people agents\n\taction initialize_people { \n\t\tcreate people number: number_of_people; \n\t\tall_people <- people as list ;  \n\t} \n\t//Action to initialize the places\n\taction initialize_places { \n\t\tall_places <- shuffle (space);\n\t\tfree_places <- all_places;  \n\t} \n}\n//Grid to discretize space, each cell representing a free space for the people agents\ngrid space width: dimensions height: dimensions neighbors: 8 use_regular_agents: false frequency: 0{\n\trgb color  <- #black;\n}\n\n//Species representing the people agents\nspecies people parent: base  {\n\t//Color of the people agent\n\trgb color <- colors at (rnd (number_of_groups - 1));\n\t//List of all the neighbours of the agent\n\tlist<people> my_neighbours -> people at_distance neighbours_distance ;\n\t//Cell representing the place of the agent\n\tspace my_place;\n\tinit {\n\t\t//The agent will be located on one of the free places\n\t\tmy_place <- one_of(free_places);\n\t\tlocation <- my_place.location; \n\t\t//As one agent is in the place, the place is removed from the free places\n\t\tfree_places >> my_place;\n\t} \n\t//Reflex to migrate the people agent when it is not happy \n\treflex migrate when: !is_happy {\n\t\t//Add the place to the free places as it will move to another place\n\t\tfree_places << my_place;\n\t\t//Change the place of the agent\n\t\tmy_place <- one_of(free_places);\n\t\tlocation <- my_place.location; \n\t\t//Remove the new place from the free places\n\t\tfree_places >> my_place;\n\t}\n\t\n\taspect default{ \n\t\tdraw circle (0.5) color: color; \n\t}\n}\n\n\n\nexperiment schelling type: gui parent:base_exp{\t\n\toutput {\n\t\tdisplay Segregation {\n\t\t\tspecies people;\n\t\t}\t\n\t\tdisplay Charts  type: 2d {\n\t\t\tchart \"Proportion of happiness\" type: pie background: #gray style: exploded position: {0,0} size: {1.0,0.5}{\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\n\t\t\t}\n\t\t\tchart \"Global happiness and similarity\" type: series background: #gray axes: #white position: {0,0.5} size: {1.0,0.5} {\n\t\t\t\tdata \"happy\" color: #blue value:  (sum_happy_people / number_of_people) * 100 style: spline ;\n\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of urban segregation using agents and GIS data to model people's movement and happiness based on similarity and spatial proximity.", "gaml_code": "/**\n* Name: segregationGIS\n* Author: \n* Description: A model showing the segregation of the people just by putting a similarity wanted parameter using agents \n* \tto represent the individuals and GIS file for the places\n* Tags: gis, shapefile\n*/\nmodel segregation\n\n//Import the model Common Schelling Segregation\nimport \"../includes/Common Schelling Segregation.gaml\" \nglobal {\n\t//List of all the free places\n\tlist<space> free_places  ;  \n\t//List of all the places\n\tlist<space> all_places ;\n\t//Neighbours distance for the perception of an agent\n\tint neighbours_distance <- 50 min: 1 max: 1000;\n\t//Shapefile to load\n\tfile shape_file_name <- file(\"../gis/nha2.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(shape_file_name);\n\t//Square meters per people in m2\n\tint square_meters_per_people <- 200;\n\t\n\t//Action to initialize people agents\n\taction initialize_people { \n\t\t//Create all the places with a surface given within the shapefile\n\t\tcreate space from: shape_file_name with: [surface :: float(read(\"AREA\"))];\n\t\tall_places  <- shuffle(space);\n\t\t//Compute the number of people to create considering the density of people\n\t\tnumber_of_people <- int( density_of_people * sum (all_places collect (each.capacity))); \n\t\tcreate people number: number_of_people;  \n\t    all_people <- people as list ; \n\t    //Move all the people to a new place\n\t\task people  {  \n\t\t\tdo move_to_new_place;       \n\t\t}   \n\t}      \n\t//Action to initialize the places\n\taction initialize_places {}   \n\t\n} \n\n//Species people representing the people\nspecies people parent: base { \n\t//Size of the people agent\n\tfloat size const: true <- 2.0;\n\t//Color of the people agent  \n\trgb color const: true <- colors at (rnd (number_of_groups - 1)); \n\tint red const: true <- (color as list) at 0; \n\tint green const: true <- (color as list) at 1;  \n\tint blue const: true <- (color as list) at 2;  \n\t//Building in which the agent lives\n\tspace current_building <- nil;\n\t//List of all the neighbour people agents\n\tlist<people> my_neighbours -> people at_distance neighbours_distance; \n\t\n\t//Action to move to a new place\n\taction move_to_new_place {  \n\t\tcurrent_building <- (shuffle(all_places) first_with (((each).capacity) > 0));\n\t\task current_building {\n\t\t\tdo accept one_people: myself;   \n\t\t}\n\t}\n\t//Reflex to migrate to another place if the agent isn't happy\n\treflex migrate when: !is_happy {\n\t\tif current_building != nil {\n\t\t\task current_building { \n\t\t\t\tdo remove_one one_people: myself;\n\t\t\t}\n\t\t} \n\t\tdo move_to_new_place;\n\t}\n\n\taspect simple {\n\t\tdraw circle(5) color: color border: #black;\n\t}\n}\n\n//Species space representing a space for a people agent to live in\nspecies space {\t\n\t//List of all the people agents living within\n\tlist<people> insiders;\n\trgb color <- rgb(255, 255, 255); \n\t//Surface of the place\n\tfloat surface;\n\t//Capacity of the place\n\tint capacity  <- 1 + int(surface / square_meters_per_people);\n\t\n\t//Action to accept a people agent  \n\taction accept (people one_people) {\n\t\tadd one_people to: insiders;\n\t\tlocation of one_people <- any_location_in(shape);\n\t\tcapacity <- capacity - 1;\n\t}\n\t//Action to remove a people agent\n\taction remove_one (people one_people){\n\t\tremove one_people from: insiders;\n\t\tcapacity <- capacity + 1;\n\t}\n\taspect simple {\n\t\tcolor <- empty(insiders) ? #white : rgb ([mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw  square(40) color: color;\n\t}\n\taspect gis {\n\t\tcolor <- empty(insiders) ? #white : rgb( [mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw shape color: color border: #black;\n\t} \n\taspect highlighted {\n\t\tcolor <- #blue;\n\t\tdraw shape+10 color: color;\n\t}\n}\n\n\nexperiment schelling type: gui parent:base_exp{\t\n\t\n\tparameter \"Shapefile to load:\" var:shape_file_name category: \"GIS specific\";\n\tparameter \"Occupancy of people (in m2):\" var:square_meters_per_people category: \"GIS specific\";\n\t\n\toutput {\n\t\tdisplay Town_display type:2d  {\n\t\t\tspecies space aspect: gis;\n\t\t\tspecies people  aspect: simple;\n\t\t}\n\t\tdisplay Charts  type: 2d {\n\t\t\tchart \"Proportion of happiness\" type: histogram background: #lightgray gap:0.05 position: {0,0} size: {1.0,0.5}{\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow ;\n\t\t\t}\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: {0,0.5} size: {1.0,0.5} {\n\t\t\t\tdata \"happy\" color: #blue value:  ((sum_happy_people * 100) / number_of_people)  style: spline ;\n\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a hybrid simulation model that combines the Predator-Prey and Sugarscape models in a single environment. The model should consist of two types of agents: Preydator (Predator-Prey) and Sugar (Sugarscape), each with their own micro-models, grids, and visualization output.", "gaml_code": "/**\n* Name: Comodel of Predator Prey and the SugarScape\n* Author: HUYNH Quang Nghi\n* Description: Co-model example : The Predator Prey and SugarScape are mixed into a common environment.\n* Tags: comodel\n */\n model prey_sugarscaptor\n\nimport \"Adapters/Predator Prey Adapter.gaml\" as Preydator \nimport \"Adapters/Sugarscape Adapter.gaml\" as Sugar\n\nglobal\n{  \n\tgeometry shape <- square(200);\n\tint grid_size_Preydator<-2;\n\tint grid_size_Sugar<-4;\n\tlist<point> offset_Preydator <- [{ 0, 0 }, { 0, 100 }, { 100, 0 }, { 100, 100 }];\n\t\n\tlist<point> offset_Sugar <- [\n\t\t\t\t\t\t\t\t\t\t{ 0, 0 }, \t\t\t{ 0, 50 }, \t\t{ 0, 100 }, \t\t\t{ 0, 150 }, \n\t\t\t\t\t\t\t\t\t\t{ 50, 0 }, \t\t{ 50, 50 }, \t\t{ 50, 100 }, \t\t{ 50, 150 }, \n\t\t\t\t\t\t\t\t\t\t{ 100, 0 }, \t\t{ 100, 50 }, \t{ 100, 100 }, \t\t{ 100, 150 }, \n\t\t\t\t\t\t\t\t\t\t{ 150, 0 }, \t\t{ 150, 50 }, \t{ 150, 100 }, \t\t{ 150, 150 }\n\t];\n\n\t\n\t\n\t\n\tlist<agent> micro_models_Preydator<-[];\n\tlist<agent> micro_models_Sugar<-[];\n\tinit\n\t{  \n\t\tint i <- -1;\n\t\tcreate Preydator.Adapter2 number: grid_size_Preydator*grid_size_Preydator;\n\t\task Preydator.Adapter2{\n\t\t\tseed<-float(rnd(1111));\n\t\t\ti<-i+1;\n\t\t\tcentroid <- myself.offset_Preydator[i];\n\t\t\tdo transform_environment;\n\t\t}\n\t\t\n\t\t i <- -1;\n\t\tcreate Sugar.Adapter number: grid_size_Sugar*grid_size_Sugar  with:[shape::envelope(100)];\n\t\task Sugar.Adapter{\n\t\t\tseed<-float(rnd(1111));\n\t\t\ti<-i+1;\n\t\t\tcentroid <- myself.offset_Sugar[i]; \n\t\t\tdo transform_environment;\n\t\t} \n\t\t\n\t\tmicro_models_Preydator<- Preydator.Adapter2 collect each.simulation;\n\t\tmicro_models_Sugar<- Sugar.Adapter collect each.simulation;\n\n\t}\n\treflex ss{\n\t\t\n\t\task micro_models_Sugar\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tlist<agent> veg_cells;\n\tlist<agent> sug_cells;\n\tlist<prey> all_preys;\n\tlist<agent> all_animals;\n\n\n\treflex update {\n\t\tveg_cells <- Preydator.Adapter2 accumulate each.simulation.vegetation_cell;\n\t\tsug_cells <- Sugar.Adapter accumulate each.simulation.sugar_cell;\n\t\tall_preys <- Preydator.Adapter2 accumulate each.simulation.prey;\n\t\tall_animals <- Sugar.Adapter accumulate each.simulation.animal;\n\t}\n}\n\ngrid G width: grid_size_Preydator height: grid_size_Preydator\n{\n\treflex a\n\t{\n\t\task micro_models_Preydator[int(self)]\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t}\n\n}\n\nexperiment main type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tdisplay \"Co-display\" type:2d antialias:false\n\t\t{\n\n\t\t\t\tgrid G border: # red transparency:0.2;\t\t\t\t\n\t\t\t\t\n\t\t\t\tagents \"vegetation_cell\" value: veg_cells ;\n\t\t\t\t\n\t\t\t\tagents \"sugar_cell\" value: sug_cells transparency:0.7;\n\n\t\t\t\tagents \"prey\" value: all_preys aspect:base;\n\t\t\t\t\t\t\n\t\t\t\tagents \"animal\" value: all_animals;\n\t\t\t\t\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Couple two models of weather and plant growth to simulate their interaction, specifically focusing on how rainfall affects water availability for plants.", "gaml_code": "/**\n* Name: Comodel0 \n* Author: Benoit Gaudou & Damien Philippon\n* Description: Couple two models: weather and plant growth\n* - create interaction between models entities: water on rain will full the water reserve\n* Tags: comodel\n*/\n\nmodel coModel\n\nimport \"Weather.gaml\" as weather\nimport \"Plant Growth.gaml\" as plantGrow\n\n\nglobal {\n\t\n\tweather weather_simu ;\n\tplantGrow plantGrow_simu;\n\t\t\n\tinit {\n\t\tcreate weather.\"Weather Co-Modeling\" with: [grid_size::20,write_in_console_step::false];\n\t\tweather_simu <- first(weather.\"Weather Co-Modeling\").simulation; \n\t\t\n\t\tcreate plantGrow.\"Plant Growth Co-Modeling\" with: [grid_size::40];\n\t\tplantGrow_simu <- first(plantGrow.\"Plant Growth Co-Modeling\").simulation; \t\t\n\t}\n\n\treflex simulate_micro_models_weather {\n\t\task weather_simu\n\t\t{\n\t\t\tdo _step_;\n\t\t}\t\n\t}\n\t\n\treflex coupling {\n\t\t\n\t\task weather_simu.plotWeather {\n\t\t\tlist<plotGrow> overlapped_plots <- plantGrow_simu.plotGrow where (each.shape.location overlaps self);\n\t\t\t\t\t\t\n\t\t\task overlapped_plots {\n\t\t\t\tavailable_water <- available_water + myself.rain;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex simulate_micro_models_plantGrow {\n\t\task plantGrow_simu\n\t\t{\n\t\t\tdo _step_;\n\t\t}\t\t\n\t}\n}\n\nexperiment \"CoModel\" type: gui {\n\toutput {\n\t\tdisplay w type:2d antialias:false{\n\t\t\tagents \"weather\" value: weather_simu.plotWeather ;\n\t\t}\n\t\tdisplay pG type:2d antialias:false{\n\t\t\tagents \"plantGrowth\" value: plantGrow_simu.plotGrow ;\n\t\t}\t\t\n\t\t\n\t\tdisplay data  type: 2d  {\n\t\t\tchart \"rain\" type: series {\n\t\t\t\tdata \"rainfall\" value: sum(weather_simu.plotWeather accumulate (each.rain));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"}
{"prompt": "Create a simple 2D grid-based model to visualize and simulate weather patterns using GAML, including a GUI for interactive exploration.", "gaml_code": "model weather\n\nglobal {\n\tfloat env_size <- 100 #m;\n\tgeometry shape <- square(env_size);\n\tint grid_size <- 20;\n\t\n\tbool write_in_console_step <- false;\n\t\n\tinit {\n\t\twrite \"[WEATHER model] Initialization\";\n\t}\n\t\n\treflex write_one_step {\n\t\tif(write_in_console_step) {\n\t\t\twrite \"[WEATHER model] One step\";\n\t\t}\n\t}\n}\n\ngrid plotWeather height: grid_size width: grid_size {\n\tfloat rain <- grid_x*grid_y*rnd(10)/10 update: grid_x*grid_y*rnd(10)/10;\n\trgb color <- rgb(0,0,rain) update: rgb(0,0,rain);\n}\n\nexperiment \"Weather\" type: gui {\n\toutput {\n\t\tdisplay d type:2d antialias:false{\n\t\t\tgrid plotWeather border: #black;\n\t\t}\n\t}\n}\n\nexperiment \"Weather Co-Modeling\" type:gui {\n\tparameter \"check execution step\" var: write_in_console_step <- true;\n}"}
{"prompt": "Create a GAML model that simulates weather patterns using a co-modeling approach, instantiating a sub-model and computing indicators on its agents.", "gaml_code": "/**\n* Name: Comodel0 \n* Author: Benoit Gaudou & Damien Philippon\n* Description: Second co-Model\n*  - instanciate a sub-model in a model\n*  - step it\n*  - display its agents\n*  - compute indicators on it \n* Tags: comodel\n*/\n\nmodel coModel\n\nimport \"Weather.gaml\" as weather\n\n\nglobal {\n\t\n\tweather weather_simu ;\n\t\t\n\tinit {\n\t\tcreate weather.\"Weather Co-Modeling\" with: [grid_size::30,write_in_console_step::false];\n\t\tweather_simu <- first(weather.\"Weather Co-Modeling\").simulation; \n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\task weather_simu\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t}\n}\n\nexperiment \"CoModel\" type: gui {\n\toutput {\n\t\tdisplay d type:2d antialias:false{\n\t\t\tagents \"weather\" value: weather_simu.plotWeather ;\n\t\t}\n\t\t\n\t\tdisplay data  type: 2d {\n\t\t\tchart \"rain\" type: series {\n\t\t\t\tdata \"rainfall\" value: sum(weather_simu.plotWeather accumulate (each.rain));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"}
{"prompt": "Create a simple model of plant growth using a grid-based system, where plants grow and respond to available water resources, and display the results in a GUI.", "gaml_code": "/**\n* Name: plantGrow\n* Author: Benoit Gaudou\n* Description: A simple model of plant growth\n* Tags: ecology, \n*/\n\nmodel plantGrow\n\nglobal {\n\tint grid_size <- 20;\n\tfloat env_size <- 100 #m;\n\tgeometry shape <- square(env_size);\n\t\t\n\tfloat CARRYING_CAPACITY <- 50.0;\n\tfloat RESERVE_CAPACITY <- 50.0;\n\t\n\tinit {\n\t\twrite \"[PLANT GROWTH] Initialization\";\t\t\n\t}\n}\n\ngrid plotGrow height: grid_size width: grid_size neighbors: 8 {\n\tfloat biomass <- rnd(CARRYING_CAPACITY) max: CARRYING_CAPACITY ;\n\tfloat available_water <- rnd(RESERVE_CAPACITY) max: RESERVE_CAPACITY ;\n\t\n\trgb color <- rgb(0,255*biomass/CARRYING_CAPACITY,0)\n\t\t\t\tupdate: rgb(0,255*biomass/CARRYING_CAPACITY,0);\t\t\n\t\n\treflex grow {\n\t\tif( available_water >0 ) {\n\t\t\tbiomass <- min([CARRYING_CAPACITY, biomass + 1]);\n\t\t\tavailable_water <- max([0, available_water - 1]);\n\t\t} else {\n\t\t\tbiomass <- max([0, biomass - 1]);\n\t\t}\n\t}\n\n}\n\nexperiment \"Plant Growth\" type: gui {\n\toutput {\n\t\tdisplay d type:2d antialias:false{\n\t\t\tgrid plotGrow border: #black;\n\t\t}\n\t\tdisplay biomass  type: 2d {\n\t\t\tchart \"levels\" type: series {\n\t\t\t\tdata \"water\" value: sum(plotGrow collect(each.available_water)) color: #blue;\n\t\t\t\tdata \"biomass\" value: sum(plotGrow collect(each.biomass)) color: #green;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nexperiment \"Plant Growth Co-Modeling\" type: gui {\n}"}
{"prompt": "Create a coupled model that integrates urban growth and traffic simulation, where urbanization affects traffic speed and road development.", "gaml_code": "/**\n* Name: urbanization_and_traffic_comodeling\n* Author: HUYNH Quang Nghi\n* Description: Co-model example : coupling urban growth model with the traffic model. \n* The speed of people on the road will be effected by the urbanization, more people in the region, the lower speed they move.\n* And the greater urbanization the faster developping of roads.\n* Tags: comodel\n */\nmodel urbanization_and_traffic_comodeling\n\nimport \"Adapters/Traffic Adapter.gaml\" as Traffic\nimport \"Adapters/Urban Adapter.gaml\" as Urbanization\n\n\nglobal\n{\n//set the bound of the world\n//\tgeometry shape <- envelope(shape_file(\"../../../Toy Models/Traffic/includes/roads.shp\"));\n\tgeometry shape<-envelope(grid_file(\"../../../../Toy Models/Urban Growth/includes/cantho_1999_v6.asc\"));\n\tfloat step<-#day;\n\tfloat road_develop_speed <- 1.1;\n\tint threshold_number_people<-50;\n\n\tinit\n\t{\n\t\t//create Traffic micro-model's experiment\n\t\tcreate Traffic.\"Adapter of Traffice\"{\n\t\t\tdo transform;\n\t\t}\n\t\t//create Urban micro-model;s experiment\n\t\tcreate Urbanization.\"Adapter\" ;\n\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t//ask simulation of micro-model step one\n\t\task Traffic.\"Adapter of Traffice\" collect each.simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t// tell the urban to evolve and interract with the traffic every 30 step = 1 month\n\t\tif(cycle mod 10 = 0 ){\t\t\t\n//\t\t\t// tell the urban to grow up \n\t\t\task Urbanization.\"Adapter\" collect each.simulation\n\t\t\t{\n\t\t\t\tdo _step_;\n\t\t\t}\n\t\t\tloop r over: Traffic.\"Adapter of Traffice\"[0].simulation.road\n\t\t\t{\n\t\t\t\t// compute the cell overlaps the road, which means the size of population\n\t\t\t\tlist l <- Urbanization.\"Adapter\"[0].simulation.plot where (each.grid_value = 1.0 and each overlaps r);\n\t\t\t\tif (length(l) > 0)\n\t\t\t\t{\n\t\t\t\t\t// adding the population to the variable of the road. It will be recompute the speed in the next step\n\t\t\t\t\tr.nb_people <- r.nb_people + length(l);\n\t\t\t\t\tif (r.nb_people > threshold_number_people)\n\t\t\t\t\t{\n\t\t\t\t\t\t//we build a random road with hoping to solve the traffic jam\n\t\t\t\t\t\tdo build_a_new_road;\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\n\t}\n\t\n\taction build_a_new_road\n\t{\n\t\troad r1 <- any(Traffic.\"Adapter of Traffice\"[0].simulation.road);\n\t\troad r2 <- any(Traffic.\"Adapter of Traffice\"[0].simulation.road);\n\t\tpoint p1 <- any_point_in(r1.shape);\n\t\tpoint p2 <- any_point_in(r2.shape);\n\t\tgeometry newroad <- line([p1, p2]);\n\t\tlist<geometry> nr <- [];\n\t\tlist<point> i1 <- [p1, p2];\n\t\tlist<road> rrr <- (Traffic.\"Adapter of Traffice\"[0].simulation.road) sort_by (each distance_to p1);\n\t\tloop i from: 0 to: length(rrr) - 1\n\t\t{\n\t\t\tif (newroad intersects rrr[i])\n\t\t\t{\n\t\t\t\tpoint t <- (newroad intersection rrr[i]).location;\n\t\t\t\tif (t != nil)\n\t\t\t\t{\n\t\t\t\t\ti1 <+ t;\n\t\t\t\t\tlist s <- rrr[i].shape split_at t;\n\t\t\t\t\tif (length(s) > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\trrr[i].shape <- s[0];\n\t\t\t\t\t\task Traffic.\"Adapter of Traffice\"[0].simulation\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcreate road from: list(s[1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ti1 <- i1 sort_by (each distance_to p1);\n\t\tloop i from: 0 to: length(i1) - 2\n\t\t{\n\t\t\tnr <+ line([i1[i], i1[i + 1]]);\n\t\t\task Traffic.\"Adapter of Traffice\"[0].simulation\n\t\t\t{\n\t\t\t\troad_network << edge(i1[i], i1[i + 1]);\n\t\t\t}\n\n\t\t}\n\n\t\tloop ee over: nr\n\t\t{\n\t\t\tif(ee!=nil){\n\t\t\t\t\n\t\t\task Traffic.\"Adapter of Traffice\"[0].simulation\n\t\t\t{\n\t\t\t\tcreate road from: list(ee)\n\t\t\t\t{\n\t\t\t\t\tbuffer<-100;\n\t\t\t\t\tshape <- ee; //scaled_by 0.7;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n}\n\nexperiment main type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tdisplay \"Comodel Display\" type:2d antialias:false\n\t\t{\n\t\t\tagents \"cell\" value: (Urbanization.\"Adapter\"[0]).get_plot() transparency:0.75;\n\n\t\t\tagents \"road\" \t\tvalue: Traffic.\"Adapter of Traffice\"[0].get_road();\n\t\t\tagents \"building\" \tvalue: Traffic.\"Adapter of Traffice\"[0].get_building();\n\t\t\tagents \"people\" \tvalue: Traffic.\"Adapter of Traffice\"[0].get_people() aspect:default;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a co-model that simulates both flood and evacuation scenarios in a urban environment, where people can evacuate to designated exits while avoiding flooded areas. The model should track casualties and display the simulation results in 3D.", "gaml_code": "/**\n* Name: Comodel of Flood and Evacuation model\n* Author: HUYNH Quang Nghi\n* Description: Co-model example : couple the evacuation model with the flood model. Water win or human win?\n* Tags: comodel\n */\nmodel flood_evacuation_comodeling\n \nimport \"Adapters/Flood Adapter.gaml\" as Flooding \nimport \"Adapters/Evacuation Adapter.gaml\" as Evacuation\n\n\nglobal\n{\n\t//set the bound of the environment\n\tgeometry shape <- envelope(file(\"../../../Toy Models/Flood Simulation/includes/mnt50.asc\"));\n\tgeometry the_free_shape<-copy(shape);\n\t//counter for casualties\n\tint casualty <- 0;\n\t\n\tlist<point> offset <- [{ 50, 1700 }, { 800, 3400 }, { 2900, 0 }, { 4200, 2900 }, { 5100, 1300 }];\n\tlist<point> exits <- [{250, 1600 }, { 400, 4400 }, { 4100, 1900 }, { 6100, 2900 }, { 5700, 900 }];\n\t\n\tinit\n\t{\n\t\t//create experiment from micro-model myFlood with corresponding parameters\n\t\tcreate Flooding.\"Adapter\";\n\t\n\t\t//create the Evacuation micro-model's experiment\n\t\tcreate Evacuation.\"Adapter of Evacuation\" number:length(offset);// with:[nb_people::1];\n\t\task Evacuation.\"Adapter of Evacuation\"\n\t\t{\n\t\t\tcentroid <- myself.offset[int(self)];\n\t\t\ttarget_point <- myself.exits[int(self)];\n\t\t\t//transform the environment and the agents to new location (near the river)\n\t\t\tdo transform_environment;\n\t\t\tloop t over: list(building)\n\t\t\t{\n\t\t\t\tthe_free_shape <- myself.the_free_shape - (t.shape+ people_size);\n\t\t\t}\n\t\t\t\n\t\t\tfree_space<-copy(myself.the_free_shape);\t\t\t\n\t\t\tfree_space <- free_space simplification(1.0);\n\t\t}\n\n\t}\n\n\treflex doing_cosimulation\n\t{\n\t\t//do a step of Flooding\n\t\task Flooding.\"Adapter\" collect each.simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//evacuate people\n\t\task Evacuation.\"Adapter of Evacuation\" collect each.simulation\n\t\t{\n\t\t\t//depending on the real plan of evacuation, we can test the speed of the evacuation with the flooding speed by doing more or less simulation steps \n\t\t\tdo _step_;\n\t\t}\n\t\t\n\t\t//loop over the population\n\t\tloop thePeople over: Evacuation.\"Adapter of Evacuation\"  accumulate each.get_people()\n\t\t{\n\t\t\t//get the cell at people's location \n\t\t\tcell theWater <- cell(first(Flooding.\"Adapter\").get_cell_at(thePeople));\n\t\t\t//if the water level is higher than 8 meters and the cell overlaps people, kill the people\n\t\t\tif (theWater.grid_value > 8.0)\n\t\t\t{\n\t\t\t\task thePeople\n\t\t\t\t{\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\t//increase the counting variable\n\t\t\t\tcasualty <- casualty + 1;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment simple type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tdisplay \"Comodel Display\"  type:3d\n\t\t{\n\t\t\tagents \"building\" value: Evacuation.\"Adapter of Evacuation\"  accumulate each.get_building();\n\t\t\tagents \"people\" value:  Evacuation.\"Adapter of Evacuation\"  accumulate each.get_people();\n\t\t\tgraphics \"exits\" refresh:false{\n\t\t\t\tloop e over: exits\n\t\t\t\t{\n\t\t\t\t\tdraw sphere(100) at: e color: # green;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tagents \"cell\" value: first(Flooding.\"Adapter\").get_cell();\n\t\t\tagents \"cell\" value: first(Flooding.\"Adapter\").get_buildings()  aspect: geometry;\n\t\t\tagents \"dyke\" value: first(Flooding.\"Adapter\").get_dyke() aspect: geometry ;\n\t\t\tgraphics 'CasualtyView' \n\t\t\t{\n\t\t\t\tdraw ('Casualty: ' + casualty +\"/\"+sum(Evacuation.\"Adapter of Evacuation\"  accumulate (each.simulation.nb_people))) at: { 1000, 5200 } font: font(\"Arial\", 24, # bold) color: # red;\n\t\t\t}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Develop a comodel that dynamically switches between an EBM and an ABM to simulate the SIR model based on population density thresholds.", "gaml_code": "/**\n* Name: Comodel SIR Switch\n* Author: HUYNH Quang Nghi\n* Description: This is a comodel that implement the dynamic of SIR_switch: it will use the EBM when the density of population is big and ABM when \n* the density of population is low. It demonstrate the capability of using dynamically the legacy models.\n* \n* SIR_ABM_coupling is the coupling that manipulates the elements inside SIR_ABM model and proposes the function would be used from outside. SIR_ABM is a simple example of SIR that use the agents to represent the spreading of disease..\n* \n* SIR_EBM_coupling is the coupling that manipulates the elements inside SIR_EBM model and proposes the function would be used from outside. SIR_EBM is a simple example of ODE use into agents with the example of the SIR equation system.\n* Tags: comodel, math, equation\n*/\nmodel Comodel_SIR_Switch\n\nimport \"Legacy_models/EBM Adapter.gaml\" as SIR_1\nimport \"Legacy_models/ABM Adapter.gaml\" as SIR_2\n\n\nglobal\n{\n\tgeometry shape <- envelope(square(100));\n\tint switch_threshold <- 120; // threshold for switching models\n\tint threshold_to_IBM <- 220; // threshold under which the model swith to IBM\n\tint threshold_to_Maths <- 20;\n\tinit\n\t{\n\t\tcreate SIR_1.\"Adapter\";\n\t\tcreate SIR_2.\"Adapter\";\n\t\tcreate Switch;\n\t} \n\n}\n\nspecies Switch\n{\n\tint S <- 495;\n\tint I <- 50;\n\tint R <- 0;\n\treflex request_from_micro_model\n\t{\n\t\t//if the size of S population and I population are bigger than a threshold, use the EBM\n\t\tif (S > threshold_to_Maths and I > threshold_to_Maths)\n\t\t{\n\t\t\t\tif(first(SIR_1.\"Adapter\")!=nil){\t\t\t\t\t\n\t\t\t\t\tunknown call;\n\t\t\t\t\tcall <- first(SIR_1.\"Adapter\").set_num_S_I_R(S, I, R);\n\t\t\t\t\task first(SIR_1.\"Adapter\").simulation\n\t\t\t\t\t{\n\t\t\t\t\t\tloop times: 1\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdo _step_;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tS <- first(SIR_1.\"Adapter\").get_num_S();\n\t\t\t\t\tI <- first(SIR_1.\"Adapter\").get_num_I();\n\t\t\t\t\tR <- first(SIR_1.\"Adapter\").get_num_R();\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t//if the size of S population or  I population are smaller  than a threshold, use the ABM\n\t\tif (I < threshold_to_IBM or S < threshold_to_IBM)\n\t\t{\n\t\t\t\tunknown call;\n\t\t\t\tcall <- first(SIR_2.\"Adapter\").set_num_S_I_R(S, I, R);\n\t\t\t\task first(SIR_2.\"Adapter\").simulation\n\t\t\t\t{\n\t\t\t\t\tloop times: 10\n\t\t\t\t\t{\n\t\t\t\t\t\tdo _step_;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tS <- first(SIR_2.\"Adapter\").get_num_S();\n\t\t\t\tI <- first(SIR_2.\"Adapter\").get_num_I();\n\t\t\t\tR <- first(SIR_2.\"Adapter\").get_num_R();\n\t\t}\n\n\t}\n\n\taspect base\n\t{\n\t\tdraw square(100);\n\t}\n\n}\n\nexperiment Simple_exp type: gui\n{\n\toutput\n\t{\n\t \tlayout horizontal([0::5000,vertical([1::5000,2::5000])::5000]) tabs:true editors: false;\n\t\tdisplay \"Switch_SIR chart\" type: 2d \n\t\t{\n\t\t\tchart \"SIR_agent\" type: series background: # white\n\t\t\t{\n\t\t\t\tdata 'S' value: first(Switch).S color: # green;\n\t\t\t\tdata 'I' value: first(Switch).I color: # red;\n\t\t\t\tdata 'R' value: first(Switch).R color: # blue;\n\t\t\t}\n\n\t\t}\n\t\tdisplay \"EBM Disp\"  type: 2d {\t\t\t\n\t\t\tchart \"SIR_agent\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(first(SIR_1.\"Adapter\").simulation.agent_with_SIR_dynamic).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'I' value: first(first(SIR_1.\"Adapter\").simulation.agent_with_SIR_dynamic).I color: #red ;\n\t\t\t\tdata 'R' value: first(first(SIR_1.\"Adapter\").simulation.agent_with_SIR_dynamic).R color: #blue ;\n\t\t\t}\n\t\t}\n\t\tdisplay \"ABM Disp\" type:2d{\t\t\t\n\t\t\tagents \"Host\" value:first(SIR_2.\"Adapter\").simulation.Host aspect:base;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a co-model that simulates the interaction between boid flocking behavior and procedural city generation, where boids navigate through the city's buildings.", "gaml_code": "/**\n* Name: Comodel of Boids and the Procedural City\n* Author: HUYNH Quang Nghi\n* Description: Co-model example : The Boids are moving in the Procedural City.\n* Tags: comodel\n */\nmodel city_boids\nimport \"Adapters/Boids Adapter.gaml\" as Boids\nimport \"Adapters/Procedural City Adapter.gaml\" as City\n \n\nglobal\n{\n\tint width_and_height_of_environment<-500;\n\t// set the bound of the environment\n\tgeometry shape <- envelope(width_and_height_of_environment);\n\t\n\tinit\n\t{\t\n\t\t//create experiment from micro-model Boids\n\t\tcreate Boids.\"Adapter of Boids\" with: [\n\t\t\tshape::square(width_and_height_of_environment), \n\t\t\twidth_and_height_of_environment::width_and_height_of_environment, \n\t\t\tz_max::100,\n\t\t\tnumber_of_agents::50\n\t\t];\n\t\t//create experiment form micro-model Procedural City\n\t\tcreate City.\"Adapter\" \n\t\twith:[\n\t\t\t number_of_building::Boids.\"Adapter of Boids\"[0].simulation.number_of_agents*2,\n\t\t\twidth_and_height_of_environment::width_and_height_of_environment\n\t\t];\n\t}\n\n\treflex simulate_micro_models\n\t{\n \n\t\t\n\t\t//loop over the population\n\t\tloop theBoid over: (Boids.\"Adapter of Boids\"[0]).get_boids()\n\t\t{\n\t\t\tBuilding theBuilding <- Building((City.\"Adapter\"[0]).get_building_at(theBoid)); \n\t\t\tif(theBuilding != nil){\t\t\t\t\n\t\t\t\tif (theBoid distance_to theBuilding < theBuilding.width)\n\t\t\t\t{\n\t\t\t\t\task theBoid\n\t\t\t\t\t{\n\t\t\t\t\t\tlocation<- location + ((theBoid.location-theBuilding.location));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//tell the Boids to step a cycle\n\t\task (Boids.\"Adapter of Boids\" collect each.simulation){ do _step_;}\n\t\t\n\t\t//tell the City to step one per 100 cycle\n\t\tif(cycle mod 100=0){\t\t\t\n\t\t\task (City.\"Adapter\" collect each.simulation){ do _step_;}\n\t\t}\n\t}\n\n}\n \nexperiment main type: gui\n{   float minimum_cycle_duration <- 0.05;\n\toutput synchronized: true\n\t{\n\t\tdisplay \"Comodel Display\" camera:#isometric type:3d background:rgb(10,40,55)\n\t\t{\n\t\t\tagents \"Building\" value: (City.\"Adapter\" accumulate each.get_building()) aspect:textured;\t\t\n\t\t\t\n\t\t\tagents \"boids_goal\" value: (Boids.\"Adapter of Boids\" accumulate each.get_boids_goal()) ;\n\t\t\t\n\t\t\tagents \"boids\" value: (Boids.\"Adapter of Boids\" accumulate each.get_boids())  aspect: image;\n\t\t\t\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a co-model that combines Boids and Voronoi models to simulate the behavior of boids in a Voronoi diagram, using two micro-models with shared parameters.", "gaml_code": "/**\n* Name: Comodel of Boids and Voronoi\n* Author: HUYNH Quang Nghi\n* Description: Co-model example : The Boids is applied in Voronoi presentation . https://www.youtube.com/watch?v=I9hBeJQUFYg\n* Tags: comodel\n */\nmodel Voroboids\nimport \"Adapters/Boids Adapter.gaml\" as Boids\nimport \"Adapters/Voronoi Adapter.gaml\" as Voronoi\n\n\nglobal\n{\n\tint width_and_height_of_environment<-200;\n\t// set the bound of the environment\n\tgeometry shape <- envelope(width_and_height_of_environment);\n\t\n\tinit\n\t{\t\n\t\t//create experiment from micro-model Boids\n\t\tcreate Boids.\"Adapter\" with: [\n\t\t\tshape::square(width_and_height_of_environment), \n\t\t\twidth_and_height_of_environment::width_and_height_of_environment, \n\t\t\tnumber_of_agents::10\n\t\t];\n\t\t//create experiment form micro-model Voronoi\n\t\tcreate Voronoi.\"Adapter 2\" with:[\n\t\t\tnum_points::Boids.\"Adapter\"[0].simulation.number_of_agents, \n\t\t\tenv_width::width_and_height_of_environment, \n\t\t\tenv_height::width_and_height_of_environment\n\t\t];\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t//tell myBoids to step a cycle\n\t\task (Boids.\"Adapter\" collect each.simulation){ do _step_;}\n\t\t//get all boids's location into a list\n\t\tlist<point> theLocations<-(Boids.\"Adapter\" accumulate each.get_boids()) collect each.location;\n\t\t//myVoronoi do a step with the location of their agent from the location list above \n\t\task (Voronoi.\"Adapter 2\" collect each.simulation){ ask center{location<-theLocations at (int(self)); }do _step_;}\n\t}\n\n}\n \nexperiment main type: gui\n{\n\tfloat minimum_cycle_duration <- 0.05#s;\n\toutput synchronized: true\n\t{\n\t\tdisplay \"Comodel Display\"  type:2d\n\t\t{\n\t\t\tagents \"cell\" value: (Voronoi.\"Adapter 2\" accumulate each.get_cell()) transparency:0.5;\n\t\t\t\n\t\t\tagents \"boids_goal\" value: (Boids.\"Adapter\" accumulate each.get_boids_goal()) aspect:default;\n\t\t\t\n\t\t\tagents \"boids\" value: (Boids.\"Adapter\" accumulate each.get_boids())  aspect:default;\n\t\t\t\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that adapts the Predator Prey model to work as an interface for the 'Prey Sugarscaptor' simulation, using GUI and coupling the original model.", "gaml_code": "/**\n* Name: predator_prey_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Predator Prey model. It is used in the \"Prey Sugarscaptor\" as an interface. \n* Tags: comodel\n*/\nmodel predator_prey_adapter\n\nimport \"../../../../Tutorials/Predator Prey/models/Model 06.gaml\"\n\nexperiment Adapter2 type: gui\n{\n\tpoint centroid <- { 0, 100 };\n \n\taction transform_environment\n\t{\n\t\tloop t over: list(prey)\n\t\t{\n\t\t\task t\n\t\t\t{\n\t\t\t\tshape <- shape translated_by myself.centroid;\n\t\t\t}\n\t\t}\n\t\t\n\t\tloop t over: vegetation_cell\n\t\t{\n\t\t\task t\n\t\t\t{\n\t\t\t\tshape <- shape translated_by myself.centroid;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "Create a GAML model that adapts the SugarScape model to serve as an interface for the 'Prey Sugarscaptor' simulation, allowing agents to move towards a centroid point.", "gaml_code": "/**\n* Name: sugarscape_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of SugarScape model. It is used in the \"Prey Sugarscaptor\" as an interface. \n* Tags: comodel\n*/\nmodel sugarscape_adapter\n\nimport \"../../../../Toy Models/Sugarscape/models/Sugarscape.gaml\"\n\nexperiment Adapter type: gui\n{\n\tpoint centroid <- { 0, 100 }; \n\n\taction transform_environment\n\t{\n//\t\twrite centroid;\n\t\t\n\t\tloop t over: sugar_cell\n\t\t{\n\t\t\task t\n\t\t\t{\n\t\t\t\tshape <- shape translated_by myself.centroid;\n\t\t\t\tlocation <- location + myself.centroid;\n\t\t\t}\n\n\t\t}\n\n\t\tloop t over: animal\n\t\t{\n\t\t\task t \n\t\t\t{\n\t\t\t\tshape <- shape translated_by myself.centroid;\n\t\t\t\tplace <- one_of(sugar_cell);\n\t\t\t\tlocation <- place.location;\n\t\t\t}\n\t\t}\n\t}\n\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "Create a traffic simulation model that interfaces with existing 'Urban and Traffic' models, scaling up objects by 20x and adjusting their locations to a central point.", "gaml_code": "/**\n* Name: traffic_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Traffic  model. It is used in the \"Urban and Traffic\" as an interface. \n* Tags: comodel\n*/\nmodel traffic_adapter\n\nimport \"../../../../Toy Models/Traffic/models/Traffic and Pollution.gaml\"\nexperiment \"Adapter of Traffice\" type: gui\n{\n\tpoint centroid <- { 15200, 1580 };\n\taction transform{\t\t\n\t\tloop t over:list(road){\t\t\t\n\t\t\tt.shape <- (t.shape * 20 );\n\t\t\tt.location <- (t.location * 20) + centroid;\n\t\t\tt.buffer<-100;\n\t\t}\n\t\tloop t over: list(building)\n\t\t{\n\t\t\tt.shape <- t.shape * 20;\n\t\t\tt.location <- (t.location * 20) + centroid;\n\t\t}\n\n\t\tloop t over: list(people)\n\t\t{\n\t\t\tt.speed <- t.speed / 50;\n\t\t\tt.shape <- t.shape * 40;\n\t\t\tt.location <- any_location_in(one_of(building));\n\t\t\tt.target <- any_location_in(one_of(building));\n\t\t}\n\t\t\n\t}\n\tlist<building> get_building\n\t{\n\t\treturn list(building);\n\t}\n\n\tlist<people> get_people\n\t{\n\t\treturn list(people);\n\t}\n\n\tlist<road> get_road\n\t{\n\t\treturn list(road);\n\t}\n\n}"}
{"prompt": "Create a GUI interface for urban growth modeling that adapts and transforms input data from another model.", "gaml_code": "/**\n* Name: urban_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Urban model. It is used in the \"Urban and Traffic\" as an interface. \n* Tags: comodel\n*/\nmodel urban_adapter\n\nimport \"../../../../Toy Models/Urban Growth/models/Raster Urban Growth.gaml\"\nexperiment \"Adapter\" type: gui \n{\n\taction transform{\n\t\task plot{\n\t\t\tlocation<-{location.x*0.037 , location.y*0.053};\n\t\t}\n\t}\n\t\n\tlist<plot> get_plot\n\t{\n\t\treturn list(plot);\n\t}\n\n}"}
{"prompt": "Create a Gamelab model that interfaces with an existing Evacuation model to simulate flood and evacuation scenarios, with adjustable scaling factors for buildings and people.", "gaml_code": "/**\n* Name: evacuation_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Evacuation model. It is used in the \"Flood and Evacuation\" as an interface. \n* Tags: comodel\n*/\nmodel evacuation_adapter\n\nimport \"../../../../Toy Models/Evacuation/models/Continuous Move.gaml\"\nexperiment \"Adapter of Evacuation\" type: gui\n{\n\tpoint centroid <- { 200, 580 };\n\tlist<building> get_building\n\t{\n\t\treturn list(building);\n\t}\n\n\taction transform_environment\n\t{\n\t\tpeople_size <- people_size * 10;\n\t\tloop t over: list(building)\n\t\t{\n\t\t\tt.shape <- t.shape * 20;\n\t\t\tt.location <- (t.location * 10) + centroid;\n\t\t}\n\n\t\tloop t over: list(people)\n\t\t{\n\t\t\tt.speed <- t.speed * 10;\n\t\t\tt.size <- t.size * 10;\n\t\t\tt.location <- (t.location * 10) + centroid;\n\t\t\tt.shape<-(square(1) at_location t.location); \n\t\t\tt.target_loc <- target_point;\n\t\t}\n\n\t}\n\n\tlist<people> get_people\n\t{\n\t\treturn list(people);\n\t}\n\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "Create a GAML model that integrates the Flood simulation model as an interface for the 'Flood and Evacuation' scenario, with specific GUI features and functionality.", "gaml_code": "/**\n* Name: flood_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Flood model. It is used in the \"Flood and Evacuation\" as an interface. \n* Tags: comodel\n*/\nmodel flood_adapter\n\nimport \"../../../../Toy Models/Flood Simulation/models/Hydrological Model.gaml\"\nexperiment \"Adapter\" type: gui\n{\n\tpoint newSize <- { 0.07, 0.07 };\n\tcell get_cell_at (agent p)\n\t{\t \n\t\tusing topology(cell) {\n\t\t\treturn first(cell overlapping p);\n\t\t} \n\t}\n\n\tlist<cell> get_cell\n\t{\n\t\treturn list(cell) where (each.grid_value > 8.0);\n\t}\n\n\tlist<buildings> get_buildings\n\t{\n\t\treturn list(buildings);\n\t}\n\n\tlist<dyke> get_dyke\n\t{\n\t\treturn list(dyke);\n\t}\n\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "Create a NetLogo model that simulates the spread of an infectious disease among a population of 500 hosts, using SIR compartmental modeling and visualizing the infection status of each host on a GUI display.", "gaml_code": "model SIR_ABM \n\nglobal{\n\tgeometry shape<-envelope(square(100));\n\tlist<rgb> the_color<-[#green, #red, #yellow];\n\tfloat beta <- 0.8 ; \t \n\tfloat alpha <- 0.06;\n\tinit{\n\t\tcreate Host number:495 ;\n\t\tcreate Host number:5{state<-1;}\n\t\t\n\t}\n}\n\nspecies Host skills:[moving]{\n\tint state<-0;\n\treflex moving{\n\t\tdo wander;\n\t}\n\n\n    \n    reflex become_infected when: state=1 {\n    \tlist n<- self neighbors_at(1);\n    \task n{    \t\t\n\t    \tif (flip(beta)) {\n\t\t\t\tstate<-1;    \n\t        }\n    \t}\n    }\n    \n    reflex become_immune when: (state=1 and flip(alpha)) {\n    \tstate<-2;\n    }\n    \n            \n\taspect base{\n\t\tif(!dead(self)){\t\t\t\n\t\t\tdraw circle(1) color: the_color[state];\n\t\t}\n\t}\n}\nexperiment SIR_ABM_exp type:gui{\n\toutput {\n\t\tdisplay \"HostDisp\" {\n\t\t\tspecies Host aspect:base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates an SIR (Susceptible-Infected-Recovered) epidemic model using agent-based modeling, and provide actions to set the number of susceptible, infected, and recovered individuals at each time step.", "gaml_code": "model SIR_ABM_coupling\n\nimport \"SIR_ABM.gaml\"\nexperiment \"Adapter\" type: gui\n{\n\tint get_num_S\n\t{\n\t\treturn length(Host where (each.state = 0));\n\t}\n\n\tint get_num_I\n\t{\n\t\treturn length(Host where (each.state = 1));\n\t}\n\n\tint get_num_R\n\t{\n\t\treturn length(Host where (each.state = 2));\n\t}\n\n\taction set_num_S_I_R (int numS, int numI, int numR)\n\t{\n\t\tunknown call;\n\t\tcall <- set_num_S(numS);\n\t\tcall <- set_num_I(numI);\n\t\tcall <- set_num_R(numR);\n\t}\n\n\taction set_num_S (int num)\n\t{\n\t\task (Host where (each.state = 0))\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tcreate Host number: num\n\t\t{\n\t\t\tstate <- 0;\n\t\t}\n\n\t}\n\n\taction set_num_I (int num)\n\t{\t\t\n\t\task (Host where (each.state = 1))\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tcreate Host number: num\n\t\t{\n\t\t\tstate <- 1;\n\t\t}\n\n\t}\n\n\taction set_num_R (int num)\n\t{\t\t\n\t\task (Host where (each.state = 2))\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tcreate Host number: num\n\t\t{\n\t\t\tstate <- 2;\n\t\t}\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates an SIR (Susceptible-Infected-Recovered) epidemiological model coupled with an EBM (Epidemiological Balance Model), allowing for dynamic population updates and visualization through a GUI interface.", "gaml_code": "model SIR_EBM_coupling\n\nimport \"SIR_EBM.gaml\"\nexperiment \"Adapter\" type: gui\n{\n\tint get_num_S\n\t{\n\t\treturn int(first(agent_with_SIR_dynamic).S);\n\t}\n\n\tint get_num_I\n\t{\n\t\treturn int(first(agent_with_SIR_dynamic).I);\n\t}\n\n\tint get_num_R\n\t{\n\t\treturn int(first(agent_with_SIR_dynamic).R);\n\t}\n\n\taction set_num_S_I_R (int numS, int numI, int numR)\n\t{\n\t\tunknown call;\n\t\tcall <- set_num_S(numS);\n\t\tcall <- set_num_I(numI);\n\t\tcall <- set_num_R(numR);\n\t}\n\n\taction set_num_S (int num)\n\t{\n\t\tfirst(agent_with_SIR_dynamic).S <- float(num);\n\t}\n\n\taction set_num_I (int num)\n\t{\n\t\tfirst(agent_with_SIR_dynamic).I <- float(num);\n\t}\n\n\taction set_num_R (int num)\n\t{\n\t\tfirst(agent_with_SIR_dynamic).R <- float(num);\n\t}\n}"}
{"prompt": "Simulate a simple SIR model (Susceptible-Infected-Recovered) for 495 agents with initial conditions of 5 infected and 490 susceptible individuals, using the Euler method to solve the differential equations.", "gaml_code": "model SIR_EBM\n\nglobal {\n\tinit{\n\t\tcreate agent_with_SIR_dynamic;\n\t} \n}\n\n\nspecies agent_with_SIR_dynamic {\n\tint N <- 495 ;\n\tint iInit <- 5;\t\t\n\n    float t;  \n\tfloat S <- N - float(iInit); \t      \n\tfloat I <- float(iInit); \n\tfloat R <- 0.0; \n\t\n\tfloat alpha <- 0.2;\n\tfloat beta <- 0.8; \n\n\tfloat h <- 0.01;\n   \n\tequation SIR{ \n\t\tdiff(S,t) = (- beta *   S * I / N);\n\t\tdiff(I,t) = (  beta*  S * I / N) - (alpha * I)  ;\n\t\tdiff(R,t) = (  alpha  *  I) ;\n\t}\n                \n    reflex solving {\n//    \twrite S;\n    \tsolve SIR method: \"rk4\" step_size: h;\n    }    \n}\n\n\nexperiment SIR_EBM_exp type: gui {\n\toutput { \n\t\tdisplay display_charts  type: 2d  {\n\t\t\tchart \"SIR_agent\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(agent_with_SIR_dynamic).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'I' value: first(agent_with_SIR_dynamic).I color: #red ;\n\t\t\t\tdata 'R' value: first(agent_with_SIR_dynamic).R color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that serves as an interface for the Boids 3D Motion model, allowing users to interact with it through a GUI.", "gaml_code": "/**\n* Name: boids_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Boids model. It is used in the \"City Boids\" as an interface. \n* Tags: comodel\n*/\nmodel boids_adapter\n\nimport \"../../../../Toy Models/Boids/models/Boids 3D Motion.gaml\"\n\n\nexperiment \"Adapter of Boids\" type:gui  {\n\t\n\tlist<boids_goal> get_boids_goal{\n\t\treturn list(boids_goal);\n\t}\n\t\n\tlist<boids> get_boids{\n\t\treturn list(boids);\n\t}\n\t\n\toutput{\n\t}\n}"}
{"prompt": "Create a GUI-based adapter model that interfaces with the Procedural City model to retrieve building information from a 3D visualization.", "gaml_code": "/**\n* Name: city_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Procedural City model. It is used in the \"City Boids\" as an interface. \n* Tags: comodel\n*/\nmodel city_adapter\n\nimport \"../../../../Visualization and User Interaction/Visualization/3D Visualization/models/Procedural City.gaml\"\n\nexperiment \"Adapter\" type:gui  {\n\t\n\n\t\n\tBuilding get_building_at (geometry p)\n\t{\n\t\task simulation\n\t\t{\n\t\t\treturn Building closest_to p;\n\t\t}\n\n\t}\n\t\n\tlist<Building> get_building{\n\t\treturn list(Building);\n\t}\t\n\t\n\toutput{\n\t}\n}"}
{"prompt": "Create a GAML model that interfaces with the Boids model and provides access to its goals and agents as lists.", "gaml_code": "/**\n* Name: boids_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Boids model. It is used in the \"Boid and Voronoi\" as an interface. \n* Tags: comodel\n*/\nmodel boids_adapter\n\nimport \"../../../../Toy Models/Boids/models/Boids.gaml\"\n\n\nexperiment \"Adapter\" type:gui  {\n\t\n\tlist<boids_goal> get_boids_goal{\n\t\treturn list(boids_goal);\n\t}\n\t\n\tlist<boids> get_boids{\n\t\treturn list(boids);\n\t}\n\t\n\toutput{\n\t}\n}"}
{"prompt": "Create a GAML model that integrates Voronoi and Boid models as an interface for a GUI experiment.", "gaml_code": "/**\n* Name: boids_adapter\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Voronoi model. It is used in the \"Boid and Voronoi\" as an interface. \n* Tags: comodel\n*/\nmodel voronoi_adapter\n\nimport \"../../../../Toy Models/Art/Voronoi/Voronoi.gaml\"\n\n\nexperiment \"Adapter 2\" type:gui  {\n\t\n\tlist<center> get_center{\n\t\treturn list(center);\n\t}\n\t\n\tlist<cell> get_cell{\n\t\treturn list(cell);\n\t}\t\n\t\n\toutput{\n\t}\n}"}
{"prompt": "**The provided code is a simulation of a soccer match using the NetLogo programming language. It includes various species such as players, ball, and goals, and allows for customization of parameters like player speed and collective play ability. The experiment also displays statistics about the game, including ball possession and number of passes made by each team.**", "gaml_code": "/**\n* Name: Soccer Game\n* Author: Julien\n* Description: This model shows how can we make an easy simulation of collective games, such as soccer. \n* \n* Each player have an offensive and a defensive position, and a behavior associated. Each player of the defensive team \n* can either search to catch the ball or mark an other player (offensive player) according to his defensive position.\n* \n* Each player of the offensive team can either run to its offensive place (when he does not have the ball), run with the balloon / \n* pass the ball / try to score a goal (when he has the ball). By changing the different parameters, you can see the concequences \n* in real time. \n* Tags: sport\n*/\n\nmodel soccer\n\nglobal {\n\tgeometry shape <- rectangle(120#m,90#m);\n\tfloat red_players_speed <- 1.0;\n\tfloat blue_players_speed <- 1.0;\n\tfloat red_size_play_area <- 30.0 min:1.0 max:100.0;\n\tfloat blue_size_play_area <- 30.0 min: 1.0 max:100.0;\n\tfloat previous_red_size_play_area <- red_size_play_area; // just to check if the parameter value has been changed\n\tfloat previous_blue_size_play_area <- blue_size_play_area; // just to check if the parameter value has been changed\n\tfloat red_collective_play <- 0.5 min:0.0 max:1.0;\n\tfloat blue_collective_play <- 0.5 min:0.0 max:1.0;\n\tfloat red_recuperation_ability <- 0.5 min:0.0 max:1.0;\n\tfloat blue_recuperation_ability <- 0.5 min:0.0 max:1.0;\n\t\n\tint red_score <- 0;\n\tint red_possession <- 0;\n\tint nb_red_pass <- 0;\n\tint nb_red_pass_succeed <- 0;\n\tint nb_red_interception <- 0;\n\tint blue_score <- 0;\n\tint blue_possession <- 0;\n\tint nb_blue_pass <- 0;\n\tint nb_blue_pass_succeed <- 0;\n\tint nb_blue_interception <- 0;\n\t\n\tbool show_status <- false;\n\tbool show_area <- false;\n\tbool show_marked_player <- false;\n\tbool show_ball_indicator <- false;\n\t\n\tbool play_with_offside <- true;\n\t\n\tlist<point> bluePlayerPosition <- [{8,10}, {8,80}, {10,30}, {10,60},\n\t\t{30,25}, {28,45}, {30,65},\n\t\t{50,25}, {50,65}, {55,45}\n\t];\n\t\n\tlist<point> redPlayerPosition <- [{120-8,10}, {120-8,80}, {120-10,30}, {120-10,60},\n\t\t{120-30,25}, {120-28,45}, {120-30,65},\n\t\t{120-50,25}, {120-50,65}, {120-55,45}\n\t];\n\t\n\tball ball_agent;\n\tplayer closest_red_player_from_the_ball;\n\tplayer closest_blue_player_from_the_ball;\n\tplayer called_player;\n\tstring team_possession <- \"\";\n\tfloat blue_offside_pos <- 120.0;\n\tfloat red_offside_pos <- 0.0;\n\t\n\tinit {\n\t\tloop pos over:redPlayerPosition {\n\t\t\tcreate player with:[team::\"red\", location::pos];\n\t\t}\n\t\tloop pos over:bluePlayerPosition {\n\t\t\tcreate player with:[team::\"blue\", location::pos];\n\t\t}\n\t\tcreate ball with:[location::location] returns:ball_agt;\n\t\tball_agent<-ball_agt at 0;\n\t\tcreate goal with:[location::{0,location.y}, team::\"blue\"];\n\t\tcreate goal with:[location::{120,location.y}, team::\"red\"];\n\t}\n\t\n\treflex update {\n\t\tfloat shortest_distance <- 100.0;\n\t\tfloat offside_pos <- 0.0;\n\t\task player where (each.team = \"red\") {\n\t\t\tif (distance_to_ball < shortest_distance and inactivity_time=0) {\n\t\t\t\tclosest_red_player_from_the_ball <- self;\n\t\t\t\tshortest_distance <- distance_to_ball;\n\t\t\t}\n\t\t\tif (location.x > offside_pos) {\n\t\t\t\toffside_pos <- location.x;\n\t\t\t\tred_offside_pos <- offside_pos;\n\t\t\t}\n\t\t}\n\t\tif (not play_with_offside) {\n\t\t\tred_offside_pos <- 120.0;\n\t\t}\n\t\t\n\t\tshortest_distance <- 100.0;\n\t\toffside_pos <- 100.0;\n\t\task player where (each.team = \"blue\") {\n\t\t\tif (distance_to_ball < shortest_distance and inactivity_time=0) {\n\t\t\t\tclosest_blue_player_from_the_ball <- self;\n\t\t\t\tshortest_distance <- distance_to_ball;\n\t\t\t}\n\t\t\tif (location.x < offside_pos) {\n\t\t\t\toffside_pos <- location.x;\n\t\t\t\tblue_offside_pos <- offside_pos;\n\t\t\t}\n\t\t}\n\t\tif (not play_with_offside) {\n\t\t\tblue_offside_pos <- 0.0;\n\t\t}\n\t\t\n\t\tif (previous_red_size_play_area != red_size_play_area) {\n\t\t\task area where (each.team = \"red\") {\n\t\t\t\tdo update_size;\n\t\t\t}\n\t\t\tprevious_red_size_play_area <- red_size_play_area;\n\t\t}\n\t\tif (previous_blue_size_play_area != blue_size_play_area) {\n\t\t\task area where (each.team = \"blue\") {\n\t\t\t\tdo update_size;\n\t\t\t}\n\t\t\tprevious_blue_size_play_area <- blue_size_play_area;\n\t\t}\n\t\tif (team_possession = \"blue\") {\n\t\t\tblue_possession <- blue_possession + 1;\n\t\t}\n\t\tif (team_possession = \"red\") {\n\t\t\tred_possession <- red_possession + 1;\n\t\t}\n\t}\n\t\n\taction reinit_phase {\n\t\task player {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball_agent.location <- location;\n\t\tball_agent.speed <- 0.0;\n\t}\n}\n\nspecies player skills:[moving] {\n\tstring team <- \"\"; // value : \"blue\" (left side) or \"red\" (right side)\n\tbool possess_ball <- false;\n\tint inactivity_time <- 0 update:(inactivity_time<=0) ? 0 : inactivity_time-1;\n\tint seed <- rnd(100);\n\tpoint init_pos;\n\tpoint previous_pos;\n\t\n\t// strategy\n\tarea defensive_pos;\n\tarea offensive_pos;\n\tplayer marked_player;\n\tfloat collective_mark <- 0.5 update:(team=\"red\") ? red_collective_play : blue_collective_play;\n\tfloat recuperation_mark <- 0.5 update:(team=\"red\") ? red_recuperation_ability : blue_recuperation_ability;\n\t\n\tstring status <- \"\";\n\t\n\t// moving attributes\n\tfloat running_speed_without_ball <- 0.8 update:(team=\"red\") ? red_players_speed*0.8 : blue_players_speed*0.8;\n\tfloat running_speed_with_ball <- 0.6 update:(team=\"red\") ? red_players_speed*0.5 : blue_players_speed*0.5;\n\tfloat speed <- 0.0 max:1.2;\n\tpoint velocity <- {0,0};\n\t\n\tfloat distance_to_closest_ennemy <- 100.0;\n\tfloat distance_to_ennemy_goal <- 100.0 update:self distance_to ( (goal where (each.team != team)) at 0);\n\tfloat distance_to_ball <- 100.0 update:self distance_to ball_agent;\n\t\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tcreate area with:[location::init_pos, team::self.team, position::init_pos] returns:def_pos;\n\t\tdefensive_pos <- def_pos at 0;\n\t\tpoint offensivePos <- {(team=\"red\") ? init_pos.x-60 : init_pos.x+60,init_pos.y};\n\t\tcreate area with:[location::offensivePos, team::self.team, position::offensivePos] returns:off_pos;\n\t\toffensive_pos <- off_pos at 0;\n\t}\n\t\n\treflex update_status {\n\t\tdistance_to_closest_ennemy <- 100.0;\n\t\tloop pl over:player where (each.team != team) {\n\t\t\tfloat distance_to_ennemy <- self distance_to pl;\n\t\t\tif (distance_to_ennemy < distance_to_closest_ennemy) {\n\t\t\t\tdistance_to_closest_ennemy <- distance_to_ennemy;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex defensive_behavior when:team_possession != team {\n\t\t// the ball is not possessed by the team.\n\t\tdo apply_inertia;\n\t\tif (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball) {\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_move;\n\t\t}\n\t}\n\t\n\treflex offensive_behavior when:team_possession = team {\n\t\tdo apply_inertia;\n\t\tif (possess_ball) {\n\t\t\tdo run_with_ball;\n\t\t\tif (distance_to_ennemy_goal < 30 and flip(1/(distance_to_ennemy_goal*distance_to_ennemy_goal/10+1))) {\n\t\t\t\t// shoot !\n\t\t\t\tdo kick_ball_to_goal;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// pass !\n\t\t\t\tif (distance_to_closest_ennemy < 5) {\n\t\t\t\t\tif (flip(collective_mark)) {\n\t\t\t\t\t\tdo pass_the_ball;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if flip(collective_mark/50) {\n\t\t\t\t\tdo pass_the_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ball_agent.belong_to_team = \"\" and\n\t\t\t(self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball\n\t\t\tor self = called_player)\n\t\t) {\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\tdo offensive_move;\n\t\t}\n\t}\n\t\n\treflex choose_player_to_mark when:(cycle mod 20=seed or cycle=0) {\n\t\tif ( not empty(player where(each.offensive_pos intersects defensive_pos)) ) {\n\t\t\tmarked_player <- 1 among (player where((each.offensive_pos intersects defensive_pos) and (each.team != team))) at 0;\n\t\t}\n\t}\n\t\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.8,(location.y-previous_pos.y)*0.8};\n\t\tfloat max_inertia <- running_speed_without_ball;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball_agent.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball_agent.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball_agent.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo goto with:[target::targetPos, speed::running_speed_without_ball];\n\t\t\n\t\tstatus <- \"run to the ball\";\n\t\t\n\t\t// if close enough, catch the ball\n\t\tif (location distance_to ball_agent.location < 1.5#m) {\n\t\t\tif (self = called_player) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\telse if (ball_agent.belong_to_team = \"\") {\n\t\t\t\tif flip(1/(ball_agent.speed*recuperation_mark+1)) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (team_possession = team) {\n\t\t\t\t\t// result of a long pass for instance\n\t\t\t\t\tif (flip(recuperation_mark*1.5)) {\n\t\t\t\t\t\tdo take_ball;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// interception of the ball\n\t\t\t\t\tif (flip(recuperation_mark*0.8)) {\n\t\t\t\t\t\tdo take_ball;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction run_with_ball {\n\t\tstatus <- \"run with the ball\";\n\t\tpoint goal_pos;\n\t\task goal {\n\t\t\tif (self.team != myself.team) {\n\t\t\t\tgoal_pos <- location;\n\t\t\t}\n\t\t}\n\t\tdo goto with:[target::goal_pos, speed::running_speed_with_ball];\n\t\tball_agent.location <- location;\n\t}\n\t\n\taction offensive_move {\n\t\t// try to reach an offensive postion\n\t\tpoint target_location;\n\t\tgeometry possible_pos <- (team=\"red\") ? world inter (rectangle({blue_offside_pos,0},{120,90}))\n\t\t: world inter (rectangle({0,0},{red_offside_pos,90}));\n\t\t\n\t\t\n\t\t// check if the player is in the field\n\t\tif (location.y < 0) {\n\t\t\ttarget_location <- {location.x,90};\n\t\t}\n\t\telse if (location.y > 90) {\n\t\t\ttarget_location <- {location.x,0};\n\t\t}\n\t\t// check if the player is in offside position\n\t\telse if ( (location.x > red_offside_pos and team = \"blue\") or (location.x < blue_offside_pos and team = \"red\")) {\n\t\t\ttarget_location <- (team=\"red\") ? {120,location.y} : {0,location.y};\n\t\t\tstatus <- \"run to a non offside position\";\n\t\t}\n\t\telse {\n\t\t\tstatus <- \"run to a offensive place\";\n\t\t\tif (not (possible_pos intersects offensive_pos)) {\n\t\t\t\ttarget_location <- (team=\"red\") ? {blue_offside_pos,location.y} : {red_offside_pos,location.y};\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttarget_location <- any_location_in(offensive_pos inter possible_pos);\n\t\t\t}\n\t\t}\n\t\tdo goto target:target_location speed:running_speed_without_ball;\n\t}\n\t\n\taction defensive_move {\n\t\t// try to mark an ennemy player\n\t\tstatus <- \"mark ennemy player\";\n\t\tif (not (marked_player = nil)) {\n\t\t\tdo goto with:[target::marked_player.location+((team=\"red\")?{2+rnd(5.0),rnd(2.0)-1} : {-2-rnd(5.0),rnd(2.0)-1}), speed::running_speed_without_ball];\n\t\t}\n\t}\n\t\n\taction kick_ball_to_goal {\n\t\tdo loose_ball;\n\t\task ball_agent {\n\t\t\tdo shooted speed_atr:4.0 target_position:((goal where (each.team != myself.team)) at 0).location;\n\t\t}\n\t\tinactivity_time <- 20;\n\t}\n\t\n\taction pass_the_ball {\n\t\tfloat wisest_choice_mark <- -100.0;\n\t\tplayer wisest_target;\n\t\task player  where(each.team = team and each != self and (self distance_to each > 15)) {\n\t\t\tint number_of_ennemies_on_range <- length(player at_distance 5 where (each.team != myself.team));\n\t\t\tfloat wise_choice_mark <- 100-distance_to_ball+number_of_ennemies_on_range*10-2*distance_to_ennemy_goal;\n\t\t\tif (wise_choice_mark > wisest_choice_mark) {\n\t\t\t\twisest_target <- self;\n\t\t\t\twisest_choice_mark <- wise_choice_mark;\n\t\t\t}\n\t\t}\n\t\tif (wisest_choice_mark > -100.0) {\n\t\t\t// a target has been found\n\t\t\tdo loose_ball;\n\t\t\task ball_agent {\n\t\t\t\tdo shooted target_position:wisest_target.location speed_atr:wisest_target.distance_to_ball/8;\n\t\t\t}\n\t\t\tcalled_player <- wisest_target;\n\t\t\tinactivity_time <- 20;\n\t\t\tif (team = \"red\") {nb_red_pass <- nb_red_pass+1;}\n\t\t\telse {nb_blue_pass <- nb_blue_pass+1;}\n\t\t}\n\t}\n\t\n\taction take_ball {\n\t\tif (ball_agent.belong_to_team != \"\" and ball_agent.belong_to_team != team) {\n\t\t\task ball_agent.belong_to_player {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tteam_possession <- team;\n\t\tpossess_ball <- true;\n\t\tball_agent.belong_to_team <- team;\n\t\tball_agent.belong_to_player <- self;\n\t\tball_agent.speed <- 0.0;\n\t\tif (self = called_player) {\n\t\t\tif (team = \"red\") {nb_red_pass_succeed <- nb_red_pass_succeed+1;}\n\t\t\telse {nb_blue_pass_succeed <- nb_blue_pass_succeed+1;}\n\t\t}\n\t\telse {\n\t\t\tif (team = \"red\") {nb_red_interception <- nb_red_interception+1;}\n\t\t\telse {nb_blue_interception <- nb_blue_interception+1;}\n\t\t}\n\t\tcalled_player <- nil;\n\t}\n\t\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tball_agent.belong_to_team <- \"\";\n\t}\n\t\n\taspect base {\n\t\tdraw circle(1) color:(team=\"red\") ? #red : #blue;\n\t\tif (show_status) {\n\t\t\tdraw string(status);\n\t\t\tif (marked_player != nil) {\n\t\t\t\tdraw polyline([location,marked_player.location]);\n\t\t\t}\n\t\t}\n\t\tif (marked_player != nil and show_marked_player) {\n\t\t\tdraw polyline([location,marked_player.location]) end_arrow:1 color:#chartreuse;\n\t\t}\n\t}\n}\n\nspecies area {\n\tstring team <- \"\";\n\tpoint position;\n\t\n\tinit {\n\t\tshape <- ((team=\"red\") ? square(red_size_play_area) : square(blue_size_play_area)) inter world;\n\t}\n\t\n\taction update_size {\n\t\tlocation <- position;\n\t\tshape <- ((team=\"red\") ? square(red_size_play_area) : square(blue_size_play_area)) inter world;\n\t}\n\t\n\taspect base {\n\t\tif (show_area) {\n\t\t\tdraw shape color:rgb(128,128,128,50) border:(team=\"red\") ? rgb(256,0.0,0.0,100) : rgb(0.0,0.0,256.0,100);\n\t\t}\n\t}\n}\n\nspecies ball skills:[moving]{\n\tstring belong_to_team <- \"\";\n\tplayer belong_to_player;\n\tfloat speed <- 0.0 update:speed*0.9;\n\tlist<point> nextPlace;\n\tgeometry ball_direction;\n\treflex update {\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tif ((location.x+cos(heading)*speed) > 120) {\n\t\t\tblue_score <- blue_score + 1;\n\t\t\task world {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.x+cos(heading)*speed) < 0) {\n\t\t\tred_score <- red_score + 1;\n\t\t\task world {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tdo wander amplitude:1.0;\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\taspect base {\n\t\tdraw circle(0.5) color:#white border:#black;\n\t\tif (show_ball_indicator) {\n\t\t\tdraw ball_direction end_arrow:1 color:#chartreuse;\n\t\t\tif (team_possession=\"red\") {\n\t\t\t\tdraw circle(0.5) color:#darkred border:#black;\n\t\t\t}\n\t\t\telse if (team_possession=\"blue\") {\n\t\t\t\tdraw circle(0.5) color:#darkblue border:#black;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies goal {\n\tstring team <- \"\";\n\taspect base {\n\t\tdraw rectangle(0.1,7.32) color:#black;\n\t}\n}\n\n\nexperiment match type:gui {\n\tparameter \"blue running speed\" var:blue_players_speed category:\"Blue Team\";\n\tparameter \"red running speed\" var:red_players_speed category:\"Red Team\";\n\t// speed of players when they run. Note that a player which have the ball will run at 50% of his max capacity, and he will run at 80% of his max capacity if he does not have the ball.\n\t\n\tparameter \"blue collective play\" var:blue_collective_play category:\"Blue Team\";\n\tparameter \"red collective play\" var:red_collective_play category:\"Red Team\";\n\t// propention of giving the ball to an other player of the team. If the value is 0, the player will never pass the ball.\n\t\n\tparameter \"blue recuperation ability\" var:blue_recuperation_ability category:\"Blue Team\";\n\tparameter \"red recuperation ability\" var:red_recuperation_ability category:\"Red Team\";\n\t// ability to catch the ball when no player has it and when a player of the other team has it. 1 for very good hability, 0 for very poor hability.\n\t\n\tparameter \"blue play area size\" var:blue_size_play_area category:\"Blue Team\";\n\tparameter \"red play area size\" var:red_size_play_area category:\"Red Team\";\n\t// change the size of the area of each player. The bigger this area is, the less players will maintains their position.\n\t\n\tparameter \"display status\" var:show_status category:\"Display\";\n\t// displays or not the current status of the player (his intentions)\n\t\n\tparameter \"display play area\" var:show_area category:\"Display\";\n\t// displays or not the offensive and defensive area of each player. The bigger this area is, the less players will maintains their position.\n\t\n\tparameter \"display marked player\" var:show_marked_player category:\"Display\";\n\t// displays or not an arrow between the player that are marked each other.\n\t\n\tparameter \"display ball indicators\" var:show_ball_indicator category:\"Display\";\n\t// changes the color of the ball if the ball is possessed by the blue or the red team. Display also the direction of the ball when it has been shooted.\n\t\n\tparameter \"play with offside position\" var:play_with_offside category:\"Rules\";\n\t// play with or without the \"offside\" rule.\n\t\n\toutput {\n\t\tdisplay \"soccer_field\" type:2d{\n\t\t\t// display the field.\n\t\t\timage \"../images/soccer_field.png\";\n\t\t\tspecies player aspect:base;\n\t\t\tspecies ball aspect:base;\n\t\t\tspecies goal aspect:base;\n\t\t\tspecies area aspect:base;\n\t\t\tgraphics \"score_display\" {\n\t\t\t\tdraw \"Blue side - \"+string(blue_score) color:#blue at: {10,5} font: font(\"Helvetica\", 18 * #zoom, #bold) perspective:true;\n\t\t\t\tdraw string(red_score)+\" - Red side\" color:#red at: {90,5} font: font(\"Helvetica\", 18 * #zoom, #bold) perspective:true;\n\t\t\t\tif (show_status) {\n\t\t\t\t\tdraw line([{red_offside_pos,0},{red_offside_pos,90}]) color:#red;\n\t\t\t\t\tdraw line([{blue_offside_pos,0},{blue_offside_pos,90}]) color:#blue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay \"match_stats\"  type: 2d {\n\t\t\t// display some statistics about the game\n\t\t\tchart \"ball_possession\" type:pie position:{0,0} size:{0.5,0.5} {\n\t\t\t\tdata \"Red possession\" value:red_possession color:#red;\n\t\t\t\tdata \"Blue possession\" value:blue_possession color:#blue;\n\t\t\t}\n\t\t\tchart \"red pass\" type:pie position:{0,0.5} size:{0.5,0.5} {\n\t\t\t\t// note that a pass is said \"successful\" if the player that has the ball was the player called initially. A \"failed pass\" does not necessary means that the team have lost the ball.\n\t\t\t\t\tdata \"Red pass succeed\" value:(nb_red_pass = 0) ? 0 : float(nb_red_pass_succeed)/float(nb_red_pass) color:#red;\n\t\t\t\t\tdata \"Red pass failed\" value:(nb_red_pass = 0) ? 0 : 1-float(nb_red_pass_succeed)/float(nb_red_pass) color:#darkred;\n\t\t\t}\n\t\t\tchart \"blue pass\" type:pie position:{0.5,0.5} size:{0.5,0.5} {\n\t\t\t\t// note that a pass is said \"successful\" if the player that has the ball was the player called initially. A \"failed pass\" does not necessary means that the team have lost the ball.\n\t\t\t\tdata \"Blue pass succeed\" value:(nb_blue_pass = 0) ? 0 : float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#blue;\n\t\t\t\tdata \"Blue pass failed\" value:(nb_blue_pass = 0) ? 0 : 1-float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#darkblue;\n\t\t\t}\n\t\t\tchart \"number pass\" type:series position:{0.5,0} size:{0.5,0.5} {\n\t\t\t\tdata \"Number pass red\" value:nb_red_pass color:#red;\n\t\t\t\tdata \"Number pass blue\" value:nb_blue_pass color:#blue;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a soccer game simulation model using GAML, including player and team behaviors, ball movement, and goal scoring.", "gaml_code": "/**\n* Name: _soccerbase\n* Author: Julien\n* Description: This model contains the parent classes of the model\n* Tags:\n*/\n\nmodel soccerbase\n\nspecies soccer_game {\n\t// contains the global informations of the game\n\trgb back_color_team;\n\trgb front_color_team;\n\t\n\tball_sp ball; // the ball agent\n\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\n\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\n\tlist<base_team> teams; // contains the 2 teams\n\tlist<base_player> players; // contains all the players of the game\n\t\n\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\n\t\n\tinit {\n\t\t// create the entities ball and the 2 goals\n\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\n\t\tball <- first(var_ball);\n\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\n\t\tfront_goal <- first(var_goal1);\n\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\n\t\tback_goal <- first(var_goal2);\n\t}\n\t\n\taction reinit_phase {\n\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\n\t\task players {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball.location <- world.location;\n\t\tball.speed <- 0.0;\n\t}\n}\n\nspecies base_player skills:[moving] {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\n\tfloat speed_without_ball;\n\tfloat speed_with_ball;\n\tpoint previous_pos; // used to apply inertia\n\tbool displacement_effectued<-false update:false; // we can apply only one displacement by step !\n\t\n\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tbase_team team;\n\tsoccer_game game;\n\tbase_team ennemy_team <- nil update:first(game.teams where (each.position != team.position));\n\tball_sp ball <- nil update:first(ball_sp);\n\tgoal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position));\n\tgoal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position));\n\t// ratio of avancement of the ball (from the point of view of the current team)\n\tfloat ball_advancement <- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\n\t\n\tbool possess_ball;\n\tpoint init_pos;\n\tpoint init_pos_in_percent;\n\tfloat distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player;\n\t// the number of ennemy players in a range of 15 meters\n\tint number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\n\tfloat distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\n\tfloat distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\n\t// the closest player of this team\n\tbase_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the closest ennemy player\n\tbase_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the player of this team wich has the best \"position_mark\"\n\tbase_player best_position_player <- nil update:first((team.players where (each != self)) \n\t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\n\t);\n\tfloat current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\n\tfloat position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \n\t// By default, this mark is equal to -distance_to_goal.\n\tstring status <- \"\"; // the current status of the player (can be useful to build the model)\n\tgeometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\n\t\n\t// CONSTRUCTOR /////////////////////////////////////////////\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tpossess_ball <- false;\n\t\tspeed_with_ball <- 0.4;\n\t\tspeed_without_ball <- 0.5;\n\t}\n\t\n\t// ACTIONS ////////////////////////////////////////////////////\n\t\n\t// ACTIONS TO CALL FROM THE STRATEGY FILE\n\t// action to run to a particular position\n\taction run_to(point target) {\n\t\tif (!displacement_effectued) {\n\t\t\t\tdo goto target:target speed:current_speed;\n\t\t\tif (possess_ball) {\n\t\t\t\tball.location <- location;\n\t\t\t}\n\t\t\tdisplacement_effectued <- true;\n\t\t}\n\t\telse {\n\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\n\t\t}\n\t}\n\t\n\t// action to run to the ball\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo run_to(targetPos);\n\t}\n\t\n\t// action to run to the ennemy goal\n\taction run_to_ennemy_goal {\n\t\tdo run_to( ennemy_goal.location );\n\t}\n\t\n\t// action to run to its own goal\n\taction run_to_own_goal {\n\t\tdo run_to( own_goal.location );\n\t}\n\t\n\t// action to mark a player\n\taction mark_player (base_player player) {\n\t\tfloat rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.\n\t\tpoint pos <- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\n\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\n\t}\n\t\n\t// action ot shoot the ball to the ennemy goal\n\taction shoot {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\n\t\t}\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball (base_player target_player) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tfloat offset <- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\n\t\t\tpoint target_point <- {target_player.location.x,target_player.location.y+offset};\n\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\n\t// try to take the ball if it is close enough\n\taction try_to_take_ball {\n\t\t// if no player has the ball\n\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\n\t\t\t// if the player is the one called (result of a pass)\n\t\t\tif (team.called_player = self) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\n\t\t\telse {\n\t\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the ball is possessed by the ennemy team\n\t\telse if (ennemy_team.possess_ball) {\n\t\t\t// try to catch the ball from the other player\n\t\t\tif flip(recuperation_ability) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// action of taking the ball\n\taction take_ball {\n\t\tif (ennemy_team.possess_ball) {\n\t\t\task ennemy_team.player_with_ball {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tpossess_ball <- true;\n\t\tball.speed <- 0.0;\n\t\tteam.called_player <- nil;\n\t\tteam.player_with_ball <- self;\n\t\tteam.possess_ball <- true;\n\t\tgame.team_possession <- team;\n\t}\n\t\n\t// action of loosing the ball\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tteam.player_with_ball <- nil;\n\t\tteam.possess_ball <- false;\n\t}\n\t\n\t// apply the inertia\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\n\t\tfloat max_inertia <- current_speed;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\t// useful functions\n\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\n\tfloat getXPos(float x_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- 90-x_ratio*90;\n\t\t}\n\t\telse {\n\t\t\tresult <- x_ratio*90;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\n\tfloat getYPos(float y_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- y_ratio*120;\n\t\t}\n\t\telse {\n\t\t\tresult <- 120-y_ratio*120;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t///////////////////////////////////////////////////////\n\t\n\t// The update function, calls the adequate behavior\n\treflex update when:cycle>1 {\n\t\tdo apply_inertia;\n\t\t// verify if it is a non-offside position\n\t\tif ( (((team.position = \"back\") and (location.y > team.offside_pos))\n\t\t\tor ((team.position = \"front\") and (location.y < team.offside_pos))) \n\t\t\tand (!possess_ball) and (self != team.called_player)\n\t\t) {\n\t\t\t// offside position, go back to a correct position\n\t\t\tpoint target_pos <- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\n\t\t\tdo run_to(target_pos);\n\t\t\tstatus <- \"offside position !\";\n\t\t}\n\t\telse if ((distance_to_ball < 2) and !possess_ball) {\n\t\t\tdo try_to_take_ball;\n\t\t}\n\t\telse if (game.team_possession = team) {\n\t\t\tdo offensive_behavior;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_behavior;\n\t\t}\n\t}\n\t\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of the ennemy team\n\taction defensive_behavior virtual:true {\n\t\t\n\t}\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of this team\n\taction offensive_behavior virtual:true {\n\t\t\n\t}\n\t\n\t\n\t// ASPECT ////////////////////////////////////////////////////////\n\taspect player {\n\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\n\t\tif (possess_ball) {\n\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t\telse {\n\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t}\n}\n\n\n\nspecies base_team {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat offside_pos <- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\n\t\t: min((game.players where (each.team != self)) collect (each.location.y));\n\t\n\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tstring position; // can be \"front\" or \"back\".\n\tlist<base_player> players; // all the players of the team.\n\tsoccer_game game;\n\t\n\tbase_player closest_player_to_ball <- first(players) update: first( players with_min_of (each.distance_to_ball ) );\n\tbase_player called_player;\n\tbool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) );\n\tbase_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\n\tlist<point> player_init_position;\n}\n\nspecies ball_sp skills:[moving] {\n\t// The ball agent.\n\tfloat speed <- 0.0;\n\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\n\treflex update {\n\t\tspeed <- speed*0.95;\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tdo wander amplitude:1.0;\n\t\t\n\t\t// anticipation of the ball position to detect a goal\n\t\tif ((location.y+sin(heading)*speed) > 120) {\n\t\t\twrite \"back team scores a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.y+sin(heading)*speed) < 0) {\n\t\t\twrite \"front team scores a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\t// action called when a player shoots the ball\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\t\n\taspect ball {\n\t\tdraw circle(0.5) color:#white;\n\t}\n}\n\nspecies goal_sp {\n\tstring position; // can be \"front\" or \"back\".\n\t\n\tinit {\n\t\tcreate goal_keeper with:[position::position];\n\t}\n\t\n\taspect goal {\n\t\tdraw rectangle(7.32,1.0) color:#black;\n\t}\n}\n\nspecies goal_keeper {\n\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \n\tstring position; // can be \"front\" or \"back\".\n\tball_sp ball <- nil update:first(ball_sp);\n\t\n\treflex update when:cycle>0 {\n\t\tlocation <- {ball.location.x/90*12+(90-12)/2,location.y};\n\t\tif (ball distance_to self < 2) {\n\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\tfirst(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));\n\t\t\t\task ball {\n\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinit {\n\t\tlocation <- {45,(position=\"front\") ? 117 : 3};\n\t}\n\t\n\taction offensive_behavior {\n\t}\n\t\n\taction defensive_behavior {\n\t}\n\t\n\taspect goal_keeper {\n\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\n\t}\n}"}
{"prompt": "Design a soccer team strategy model that assigns roles and positions to players based on their location on the field, taking into account factors such as ball possession, distance to goal, and player safety.", "gaml_code": "/**\n* Name: _team1strategy\n* Author: Julien\n* Description: This model contains one of the 2 team strategy. \n* This strategy is quite advanced, attributing role for each player, with a custom influence_area and a custom position_mark.\n* Tags:\n*/\n\nmodel team1strategy\n\nimport \"Soccer Base.gaml\"\n\nspecies player_intelligentTeam parent:base_player {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game\n\t//closest_player_to_ball\n\t// called_player : the player called for a pass\n\t// possess_ball : true or false\n\t// player_with_ball : player currently with the ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// position_mark\n\t// status : the current status of the player (can be useful to build the model)\n\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\t\n\tfloat position_mark <- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;\t\n\tstring role; // a value between \"defense\", \"mid\" and \"attack\".\n\tstring wing; // a value between \"left\", \"center\" and \"right\".\n\tgeometry influence_area <- circle(15,init_pos);\n\t\n\tfloat defense_mid_pos <- 30.0; // the y percent chosed to separate the defense from the mid position.\n\tfloat mid_attack_pos <- 60.0; // the y percent chosen to separate the mid from the attack position.\n\t\n\tinit {\n\t\t// set the role of the player (between \"defense\", \"mid\" and \"attack\").\n\t\tif ( init_pos_in_percent.y < defense_mid_pos ) {\n\t\t\trole <- \"defense\";\n\t\t}\n\t\telse if ( (init_pos_in_percent.y > mid_attack_pos ) ) {\n\t\t\trole <- \"attack\";\n\t\t}\n\t\telse {\n\t\t\trole <- \"mid\";\n\t\t}\n\t\t// set the wing of the player (between \"left\", \"center\" and \"right\")\n\t\tif ( init_pos_in_percent.x < 40 ) {\n\t\t\twing <- \"left\";\n\t\t}\n\t\telse if ( init_pos_in_percent.x > 60 ) {\n\t\t\twing <- \"right\";\n\t\t}\n\t\telse {\n\t\t\twing <- \"center\";\n\t\t}\n\t}\n\t\n\taction update_influence_area {\n\t\tstatus <- wing + \" \" + role;\n\t\tfloat y_ratio;\n\t\tif (role = \"defense\") { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.7 * ball_advancement;\n\t\t}\n\t\tif (role = \"mid\") { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.15 + 0.7 * ball_advancement;\n\t\t}\n\t\tif (role = \"attack\") { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.3 + 0.7 * ball_advancement;\n\t\t}\n\t\tfloat x_ratio;\n\t\tif (wing = \"center\") {\n\t\t\tx_ratio <- 0.5;\n\t\t}\n\t\telse if (wing = \"left\") {\n\t\t\tx_ratio <- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the \"side\" wings are more marked if the player is in the center of the field.\n\t\t}\n\t\telse {\n\t\t\tx_ratio <- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );\n\t\t}\n\t\tinfluence_area <- circle(15,{getXPos(x_ratio),getYPos(y_ratio)});\n\t}\n\t\n\taction defensive_behavior {\t\n\t\tdo update_influence_area;\n\t\t// advanced defensive behavior\n\t\t// run to the ball if the player is the closest player from the ball.\n\t\tif ((self = team.closest_player_to_ball) or (self distance_to ball < 5)) {\n\t\t\tstatus <- getStatus(\"run to ball\");\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\t// if there is an ennemy player in the influence area, mark the player.\n\t\t\tif ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {\n\t\t\t\tbase_player marked_player <- first(1 among (self.ennemy_team.players where (each intersects influence_area)));\n\t\t\t\tstatus <- getStatus(\"mark player \"+marked_player);\n\t\t\t\tdo mark_player( marked_player );\n\t\t\t}\n\t\t\t// if there is no ennemy player in the influence area, stay in influence area.\n\t\t\telse {\n\t\t\t\tstatus <- getStatus(\"run to influence area\");\n\t\t\t\tdo run_to(influence_area.location);\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction offensive_behavior {\t\n\t\tdo update_influence_area;\n\t\t// advanced offensive behavior\n\t\tif (possess_ball) {\n\t\t\t// if the player has the ball and is close enough to the ennemy goal, shoot.\n\t\t\tif (distance_to_goal < 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {\n\t\t\t\tstatus <- getStatus(\"shoot the ball\");\n\t\t\t\tdo shoot;\n\t\t\t}\n\t\t\t// if the player has the ball and is in a safe position, run to the ennemy goal.\n\t\t\telse if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player > 2) )\n\t\t\t{\n\t\t\t\tstatus <- getStatus(\"run to ennemy goal\");\n\t\t\t\tdo run_to_ennemy_goal;\n\t\t\t}\n\t\t\t// if the player has the ball but is in a dangerous situation, pass the ball to another player.\n\t\t\telse {\n\t\t\t\tbase_player target_player <- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );\n\t\t\t\tstatus <- getStatus(\"pass the ball to \"+target_player);\n\t\t\t\tdo pass_the_ball_ahead ( target_player,10.0 );\n\t\t\t}\n\t\t}\n\t\t// if the player has not the ball but is the called player, run to the ball.\n\t\telse if (self = team.called_player) {\n\t\t\tstatus <- getStatus(\"run to ball\");\n\t\t\tdo run_to_ball;\n\t\t\tstatus <- \"called player\";\n\t\t}\n\t\t// else, run to influence area.\n\t\telse {\n\t\t\tstatus <- getStatus(\"run to influence area\");\n\t\t\tdo run_to(influence_area.location);\n\t\t}\n\t}\n\t\n\tstring getStatus(string str) {\n\t\treturn wing + \" \" + role + \"| action : \" + str;\n\t}\n\t\n}\n\nspecies intelligentTeam parent:base_team {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game.\n\t// closest_player_to_ball.\n\t// called_player : the player called for a pass.\n\t// possess_ball : true when a player of the team possess the ball.\n\t// player_with_ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// player_init_position\n\t\n\t// initial position of the player in percentage : for each point,\n\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\n\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\n\tlist<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];\n}"}
{"prompt": "Create a simple soccer team strategy model that implements two basic behaviors for players: defensive behavior (run to the ball) and offensive behavior (run to enemy goal or shoot when close).", "gaml_code": "/**\n* Name: _team2strategy\n* Author: Julien\n* Description: This model contains one of the 2 team strategy. \n* This strategy is very stupid : when you have the ball, run to the ennemy goal, else run to the ball\n* Tags: \n*/\n\nmodel team2strategy\n\nimport \"Soccer Base.gaml\"\n\nspecies player_stupidTeam parent:base_player {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game\n\t//closest_player_to_ball\n\t// called_player : the player called for a pass\n\t// possess_ball : true or false\n\t// player_with_ball : player currently with the ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// position_mark\n\t// status : the current status of the player (can be useful to build the model)\n\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\n\t\n\taction defensive_behavior {\t\n\t\t// very basic defensive behavior : run to the ball\n\t\tdo run_to_ball;\n\t}\n\t\n\taction offensive_behavior {\t\n\t\t// very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.\n\t\tif ((possess_ball) and (distance_to_goal < 30)) {\n\t\t\tdo shoot;\n\t\t}\n\t\telse {\n\t\t\tdo run_to_ennemy_goal;\n\t\t}\n\t}\n\t\n}\n\nspecies stupidTeam parent:base_team {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game.\n\t// closest_player_to_ball.\n\t// called_player : the player called for a pass.\n\t// possess_ball : true when a player of the team possess the ball.\n\t// player_with_ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// player_init_position\n\t\n\t// initial position of the player in percentage : for each point,\n\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\n\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\n\tlist<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];\n}"}
{"prompt": "Create a soccer game simulation with two teams, one using a basic strategy and the other using an intelligent strategy, allowing for visualization of player information.", "gaml_code": "/**\n* Name: Soccer game (Various strategies)\n* Author: Julien\n* Description: This model shows a game between two teams, with the same of with different strategies :\n* \n* * The \"stupidTeam\" has a very basic strategy : when a player has the ball, he runs to the ennemy goal, he runs to the ball otherwise.\n* \n* * The \"intelligentTeam\" is composed of players that each one have a strategical place wich they are able to keep. They also do pass when \n* they are in dangerous position, to the \"safer\" player.\n* \n* This model is designed to show how, with the same set of rules and some predefined actions, we can build a strategy of a team. You are free to change \n* the imported files \"team1_strategy.gaml\" and \"team2_strategy.gaml\", using the read-only and the read-write attributes of the mother species.\n* Tags: sport, inheritence\n*/\n\nmodel soccerexpe\n\n// import the 2 strategies\nimport \"Team1 Strategy.gaml\"\nimport \"Team2 Strategy.gaml\"\n\nglobal {\n\t// set the size of the environment\n\tgeometry shape <- rectangle(90#m,120#m);\n\t\n\tbool show_info <- false;\n\t\n\trgb back_color_team <- #blue;\n\trgb front_color_team <- #red;\n}\n\nspecies info_player1 mirrors:player_intelligentTeam {\n\t// mirror species that shows additionnal information about the player\n\tpoint location <- target.location update:target.location;\n\tstring status <- target.status update:target.status;\n\tfloat speed <- target.speed update:target.speed;\n\tgeometry influence_area <- target.influence_area update:target.influence_area;\n\taspect info {\n\t\tif (show_info) {\n\t\t\tdraw status color:#black;\n\t\t\tdraw influence_area color:rgb(200,200,255,0) border:rgb(200,200,255,255);\n\t\t}\n\t}\n}\n\nspecies info_player2 mirrors:player_stupidTeam {\n\t// mirror species that shows additionnal information about the player\n\tpoint location <- target.location update:target.location;\n\tstring status <- target.status update:target.status;\n\tfloat speed <- target.speed update:target.speed;\n\tgeometry influence_area <- target.influence_area update:target.influence_area;\n\taspect info {\n\t\tif (show_info) {\n\t\t\tdraw status color:#black;\n\t\t\tdraw influence_area color:rgb(255,200,200,0) border:rgb(255,200,200,255);\n\t\t}\n\t}\n}\n\nexperiment intelligentTeam_vs_stupidTeam type:gui {\n\tinit {\n\t\t// instantialization of the game (contains global information about the game)\n\t\tcreate soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;\n\t\t// instantialization of the teams\n\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"back\");\n\t\tcreate stupidTeam with:(game:first(soccerGame),position:\"front\");\n\t\tadd first(intelligentTeam) to:first(soccerGame).teams;\n\t\tadd first(stupidTeam) to:first(soccerGame).teams;\n\t\t// create players of the team1\n\t\tlist<player_intelligentTeam> player_list1;\n\t\tloop pos over:first(intelligentTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(intelligentTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_intelligentTeam with:(team:first(intelligentTeam),game:first(intelligentTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list1;\n\t\t}\n\t\tfirst(intelligentTeam).players <- player_list1;\n\t\t// create players of the team2\n\t\tlist<player_stupidTeam> player_list2;\n\t\tloop pos over:first(stupidTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(stupidTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_stupidTeam with:(team:first(stupidTeam),game:first(stupidTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list2;\n\t\t}\n\t\tfirst(stupidTeam).players <- player_list2;\n\t\tfirst(soccerGame).players <- player_list1+player_list2;\n\t}\n\tparameter \"show player info\" var:show_info;\n\toutput {\n\t\tdisplay \"soccer_field\" type:2d  {\n\t\t\t// display the field.\n\t\t\timage \"../images/soccer_field2.png\";\n\t\t\t// display the species with their correct aspect\n\t\t\tspecies player_intelligentTeam aspect:player;\n\t\t\tspecies player_stupidTeam aspect:player;\n\t\t\tspecies ball_sp aspect:ball;\n\t\t\tspecies goal_sp aspect:goal;\n\t\t\tspecies goal_keeper aspect:goal_keeper;\n\t\t\tspecies info_player1 aspect:info;\n\t\t\tspecies info_player2 aspect:info;\n\t\t}\n\t}\n}\n\nexperiment intelligentTeam_vs_intelligentTeam type:gui {\n\tinit {\n\t\t// instantialization of the game (contains global information about the game)\n\t\tcreate soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;\n\t\t// instantialization of the teams\n\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"back\") returns:backTeam;\n\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"front\") returns:frontTeam;\n\t\t\n\t\tadd first(backTeam) to:first(soccerGame).teams;\n\t\tadd first(frontTeam) to:first(soccerGame).teams;\n\t\t// create players of the team1\n\t\tlist<player_intelligentTeam> player_list1;\n\t\tloop pos over:first(backTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(backTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_intelligentTeam with:(team:first(backTeam),game:first(backTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list1;\n\t\t}\n\t\tfirst(backTeam).players <- player_list1;\n\t\t// create players of the team2\n\t\tlist<player_intelligentTeam> player_list2;\n\t\tloop pos over:first(frontTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(frontTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_intelligentTeam with:(team:first(frontTeam),game:first(frontTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list2;\n\t\t}\n\t\tfirst(frontTeam).players <- player_list2;\n\t\tfirst(soccerGame).players <- player_list1+player_list2;\n\t}\n\tparameter \"show player info\" var:show_info;\n\toutput {\n\t\tdisplay \"soccer_field\"  type:2d{\n\t\t\t// display the field.\n\t\t\timage \"../images/soccer_field2.png\";\n\t\t\t// display the species with their correct aspect\n\t\t\tspecies player_intelligentTeam aspect:player;\n\t\t\tspecies ball_sp aspect:ball;\n\t\t\tspecies goal_sp aspect:goal;\n\t\t\tspecies goal_keeper aspect:goal_keeper;\n\t\t\tspecies info_player1 aspect:info;\n\t\t\tspecies info_player2 aspect:info;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates predator-prey dynamics between sheep and wolves, allowing users to adjust parameters such as initial population sizes, energy consumption, and reproduction rates.", "gaml_code": "/**\n* Name: Agent display (aspect)\n* Author:\n* Description: 7th part of the tutorial: Predator Prey\n* Tags: display\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- one_of(my_cell.neighbors2);\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:3d antialias:false{\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:3d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Design a multi-agent system for simulating predator-prey dynamics using NetLogo, including species inheritance and interactions with a grid-based environment.", "gaml_code": "/**\n* Name: Predator agents (parent species)\n* Author:\n* Description: 5th part of the tutorial : Predator Prey\n* Tags: inheritance\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tvegetation_cell my_cell <- one_of (vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\t\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- one_of(my_cell.neighbors2);\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t} \n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\t\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\t\t\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\t\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\t\t\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));\n\tlist<vegetation_cell> neighbors2  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: base;\n\t\t\tspecies predator aspect: base;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Create a predator-prey simulation model with two species (prey and predator) that interact through eating and reproduction, using NetLogo-like agent-based modeling language.", "gaml_code": "/**\n* Name: Complex behaviors for the preys and predators\n* Author:\n* Description: 8th part of the tutorial: Predator Prey\n* Tags: inheritance, iterator, container\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- choose_cell();\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty(prey inside (each))));\n\t\tif my_cell_tmp != nil {\n\t\t\treturn my_cell_tmp;\n\t\t} else {\n\t\t\treturn one_of(my_cell.neighbors2);\n\t\t}\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:2d antialias:false{\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Design a predator-prey model with 2 species (prey and predator) that interact through energy transfer, reproduction, and death. Include charts to display population dynamics and energy distribution.", "gaml_code": "/**\n* Name: Definition of charts\n* Author:\n* Description: 10th part of the tutorial: Predator Prey\n* Tags: chart\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo pause;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- choose_cell();\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty(prey inside (each))));\n\t\tif my_cell_tmp != nil {\n\t\t\treturn my_cell_tmp;\n\t\t} else {\n\t\t\treturn one_of(my_cell.neighbors2);\n\t\t}\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tdisplay Population_information refresh: every(5#cycles)  type: 2d {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Create a predator-prey simulation model using GAML, including species definitions for prey and predators, grid and experiment setup, and parameters for user input.", "gaml_code": "/**\n* Name: Adding of a stopping condition\n* Author:\n* Description: 9th part of the tutorial: Predator Prey\n* Tags: pause\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo pause;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- choose_cell();\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty(prey inside (each))));\n\t\tif my_cell_tmp != nil {\n\t\t\treturn my_cell_tmp;\n\t\t} else {\n\t\t\treturn one_of(my_cell.neighbors2);\n\t\t}\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Create a NetLogo model simulating predator-prey dynamics with agent-based modeling, including species inheritance and parameterizable variables for energy consumption, reproduction, and predation.", "gaml_code": "/**\n* Name: Breeding of prey and predator agents\n* Author:\n* Description: 6th part of the tutorial : Predator Prey\n* Tags: reproduce, myself, self\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- one_of(my_cell.neighbors2);\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: base;\n\t\t\tspecies predator aspect: base;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Create a predator-prey simulation model using GAML, where prey and predators interact on a 2D grid, with parameters for initial population sizes, energy levels, reproduction rates, and food consumption. Visualize the simulation using GUI displays to show species evolution, energy distribution, and monitor population counts.", "gaml_code": "/**\n* Name: Image loading (raster data)\n* Author:\n* Description: 12th part of the tutorial: Predator Prey\n* Tags: file, raster\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tfile map_init <- image_file(\"../includes/data/raster_map.png\");\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t\task vegetation_cell {\n\t\t\tcolor <-  rgb(map_init at {grid_x,grid_y});\n\t\t\tfood <- 1 - (((color as list) at 0) / 255);\n\t\t\tfood_prod <- food / 100; \n\t\t}\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + (prey min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + (prey max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + (predator min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + (predator max_of each.energy)) \n\t   \t\tto: \"results.txt\" rewrite: (cycle = 0) ? true : false;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo pause;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- choose_cell();\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty(prey inside (each))));\n\t\tif my_cell_tmp != nil {\n\t\t\treturn my_cell_tmp;\n\t\t} else {\n\t\t\treturn one_of(my_cell.neighbors2);\n\t\t}\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:2d antialias:false{\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tdisplay Population_information refresh: every(5#cycles)  type: 2d {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Create a simple predator-prey model using GAML, with 200 initial preys and a GUI display to visualize their behavior.", "gaml_code": "/**\n* Name: Basic model (prey agents)\n* Author:\n* Description: First part of the tutorial : Predator Prey\n* Tags:\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0;\n\trgb color <- #blue;\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n} \n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n\toutput {\n\t\tdisplay main_display {\n\t\t\tspecies prey aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Design a predator-prey simulation model using GAML, exploring the impact of different parameters on population dynamics and energy transfer between species.", "gaml_code": "/**\n* Name: Exploration (batch)\n* Author:\n* Description: 13th part of the tutorial: Predator Prey\n* Tags: batch\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tfile map_init <- image_file(\"../includes/data/raster_map.png\");\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\tbool is_batch <- false;\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t\task vegetation_cell {\n\t\t\tcolor <- rgb (map_init at {grid_x,grid_y});\n\t\t\tfood <- 1 - (((color as list) at 0) / 255);\n\t\t\tfood_prod <- food / 100; \n\t\t}\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + (prey min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + (prey max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + (predator min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + (predator max_of each.energy)) \n\t   \t\tto: \"results.txt\" rewrite: (cycle = 0) ? true : false;\n\t}\n\t\n\treflex stop_simulation when: ((nb_preys = 0) or (nb_predators = 0)) and !is_batch {\n\t\tdo pause;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- choose_cell();\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty(prey inside (each))));\n\t\tif my_cell_tmp != nil {\n\t\t\treturn my_cell_tmp;\n\t\t} else {\n\t\t\treturn one_of(my_cell.neighbors2);\n\t\t}\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tdisplay Population_information refresh: every(5#cycles)  type: 2d {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n\nexperiment Optimization type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {\n\tparameter \"Prey max transfer:\" var: prey_max_transfer min: 0.05 max: 0.5 step: 0.05;\n\tparameter \"Prey energy reproduce:\" var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05;\n\tparameter \"Predator energy transfer:\" var: predator_energy_transfer min: 0.1 max: 1.0 step: 0.1;\n\tparameter \"Predator energy reproduce:\" var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;\n\tparameter \"Batch mode:\" var: is_batch <- true;\n\t\n\tmethod tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3;\n\t\n\t\n\treflex save_results_explo {\n\t\task simulations {\n\t\t\tsave [int(self),prey_max_transfer,prey_energy_reproduce,predator_energy_transfer,predator_energy_reproduce,self.nb_predators,self.nb_preys] \n\t\t   \t\tto: \"results.csv\" format:\"csv\" rewrite: (int(self) = 0) ? true : false header: true;\n\t\t}\t\t\n\t}\n}"}
{"prompt": "Create a simple predator-prey simulation using NetLogo, where 200 preys are initialized on a grid of vegetation cells, and each prey has basic movement and eating behaviors.", "gaml_code": "/**\n* Name: Behavior of the prey agent\n* Author:\n* Description: Third part of the tutorial : Predator Prey\n* Tags:\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0;\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\t\t\n\tvegetation_cell my_cell <- one_of (vegetation_cell); \n\tfloat energy <- rnd(max_energy)  update: energy - energy_consum max: max_energy;\n\t\t\n\tinit { \n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- one_of(my_cell.neighbors2);\n\t\tlocation <- my_cell.location;\n\t}\n\treflex eat when: my_cell.food > 0 { \n\t\tfloat energy_transfer <- min([max_transfer, my_cell.food]);\n\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\tenergy <- energy + energy_transfer;\n\t}\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\";\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Design a predator-prey simulation model using NetLogo, including species and grid definitions, with adjustable parameters for initial prey population, prey energy levels, and transfer rates.", "gaml_code": "/**\n* Name: Use of Inspectors/monitors\n* Author:\n* Description: 4th part of the tutorial : Predator Prey\n* Tags: inspector, monitor\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tint nb_preys -> {length (prey)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0;\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\t\t\n\tvegetation_cell my_cell <- one_of(vegetation_cell); \n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\t\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- one_of(my_cell.neighbors2);\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat when: my_cell.food > 0 {\n\t\tfloat energy_transfer <- min([max_transfer, my_cell.food]);\n\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\tenergy <- energy + energy_transfer;\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\";\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: base;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates a predator-prey ecosystem on a grid, where preys are initially distributed randomly and have a dynamic color based on the available food.", "gaml_code": "/**\n* Name: Dynamic of the vegetation (grid)\n* Author:\n* Description: Second part of the tutorial : Predator Prey\n* Tags: grid\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0;\n\trgb color <- #blue;\n\tvegetation_cell my_cell <- one_of (vegetation_cell);\n\t\t\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a predator-prey simulation model using GAML, where prey and predators interact through energy transfer and reproduction, and display population dynamics and energy distribution charts.", "gaml_code": "/**\n* Name: Writing files\n* Author:\n* Description: 11th part of the tutorial: Predator Prey\n* Tags: file\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + (prey min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + (prey max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + (predator min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + (predator max_of each.energy)) \n\t   \t\tto: \"results.txt\" rewrite: (cycle = 0) ? true : false;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo pause;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- choose_cell();\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\t\t\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n\n\taspect icon {\n\t\tdraw my_icon size: 2 * size;\n\t}\n\n\taspect info {\n\t\tdraw square(size) color: color;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/sheep.png\");\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\timage_file my_icon <- image_file(\"../includes/data/wolf.png\");\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty(prey inside (each))));\n\t\tif my_cell_tmp != nil {\n\t\t\treturn my_cell_tmp;\n\t\t} else {\n\t\t\treturn one_of(my_cell.neighbors2);\n\t\t}\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: icon;\n\t\t\tspecies predator aspect: icon;\n\t\t}\n\n\t\tdisplay info_display type:2d antialias:false {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: info;\n\t\t\tspecies predator aspect: info;\n\t\t}\n\n\t\tdisplay Population_information refresh: every(5#cycles)  type: 2d {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}"}
{"prompt": "Create a GAML model that simulates the spread of an infectious disease through a population of 500 people in a city, allowing users to adjust parameters such as infection distance and probability of infection, and displaying the number of susceptible and infected individuals over time using a GUI.", "gaml_code": "/**\n* Name: Charts\n* Author: GAMA team\n* Description: Second part of the tutorial : Incremental Model\n* Tags: chart, tutorial\n*/\nmodel SI_city\n\nglobal {\n\tint nb_people <- 500;\n    float agent_speed <- 5.0 #km/#h;\t\t\n\tfloat step <- 1 #minutes;\n\tgeometry shape <- envelope(square(500 #m));\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected / nb_people;\n\n\tinit {\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif (flip(proba_infection)) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type: gui {\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_date.hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies people;\n\t\t}\n\n\t\tdisplay chart refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series style: spline {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green marker: false;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple simulation model of a city where people can move and infect each other, with adjustable parameters for infection distance, probability of infection, and initial number of infected individuals.", "gaml_code": "/**\n* Name: Simple SI Model\n* Author: GAMA team\n* Description: First part of the tutorial : Incremental Model\n* Tags: tutorial, gis\n*/\nmodel SI_city\n\nglobal {\n\tint nb_people <- 500;\n    float agent_speed <- 5.0 #km/#h;\t\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #minutes;\n\tgeometry shape <- envelope(square(500 #m));\n\n\tinit {\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\n\t}\n\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif (flip(proba_infection)) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type: gui {\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init;\n\t\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies people; // 'default' aspect is used automatically\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Simulate a population of 500 people in a city with roads and buildings, where some people are initially infected with a disease. Model the spread of the disease using a system of differential equations (SIR model) and visualize the results on a 3D map and a chart.", "gaml_code": "/**\n* Name: Differential Equation\n* Author: GAMA Team\n* Description: 7th part of the tutorial : Incremental Model\n* Tags: tutorial, chart, graph, 3d, light, multi-Level, equation\n*/\nmodel model7\n\nglobal {\n\tint nb_people <- 500;\n\tfloat agent_speed <- 5.0 #km / #h;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));\n\tfloat beta <- 0.01;\n\tfloat h <- 0.1;\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_in_building);\n\tint nb_people_infected <- nb_infected_init update: (people + list_people_in_buildings) count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_date.hour < 7 or current_date.hour > 20;\n\tfloat infected_rate update: nb_people_infected / nb_people;\n\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\n\treflex move when: target != nil {\n\t\tdo goto target: target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in(one_of(building));\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t}\n\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect circle {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n\n\taspect sphere3D {\n\t\tdraw sphere(3) at: {location.x, location.y, location.z + 3} color: is_infected ? #red : #green;\n\t}\n\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\n\taspect default {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tint nb_infected <- 0 update: self.people_in_building count each.is_infected;\n\tint nb_total <- 0 update: length(self.people_in_building);\n\tfloat height <- rnd(10 #m, 20 #m);\n\tfloat I;\n\tfloat S;\n\tfloat T;\n\tfloat t;\n\tfloat I_to1;\n\t\n\tspecies people_in_building parent: people schedules: [] { }\n\n\treflex let_people_leave {\n\t\task self.people_in_building {\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\n\t\trelease people_in_building where (flip((each).staying_counter / staying_coeff)) as: people in: world {\n\t\t\ttarget <- any_location_in(one_of(building));\n\t\t}\n\t}\n\n\treflex let_people_enter {\n\t\tcapture (people inside self) where (each.target = nil) as: people_in_building;\n\t}\n\n\tequation SI {\n\t\tdiff(S, t) = (-beta * S * I / T);\n\t\tdiff(I, t) = (beta * S * I / T);\n\t}\n\n\treflex epidemic when: nb_total > 0 {\n\t\tT <- float(nb_total);\n\t\tS <- float(nb_total - nb_infected);\n\t\tI <- T - S;\n\t\tfloat I0 <- I;\n\t\tif (I > 0 and S > 0) {\n\t\t\tsolve SI method: #rk4 step_size: h;\n\t\t\tI_to1 <- I_to1 + (I - I0);\n\t\t\tint I_int <- min([int(S), int(I_to1)]);\n\t\t\tI_to1 <- I_to1 - I_int;\n\t\t\task (I_int among (people_in_building where (!each.is_infected))) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw shape color: nb_total = 0 ? #gray : (float(nb_infected) / nb_total > 0.5 ? #red : #green) border: #black depth: height;\n\t}\n}\n\nexperiment main_experiment type: gui {\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_date.hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: 3d {\n\t\t\tlight #ambient intensity: 20;\n\t\t\tlight #default intensity:(is_night ? 127 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road;\n\t\t\tspecies people aspect: sphere3D;\n\t\t\tspecies building transparency: 0.5;\n\t\t}\n\n\t\tdisplay chart refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green marker: false;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a disease spreading model, where people move around and infect each other based on probability, with visualizations of infected and susceptible populations over time.", "gaml_code": "/**\n* Name: 3D visualization\n* Author: GAMA team\n* Description: 5th part of the tutorial : Incremental Model\n* Tags: tutorial, chart, graph, 3d, light\n*/\n\nmodel model5 \n \nglobal {\n\tint nb_people <- 500;\n    float agent_speed <- 5.0 #km/#h;\t\t\t\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_date.hour < 7 or current_date.hour > 20;\t\n\tfloat infected_rate update: nb_people_infected / nb_people;\n\t\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t\tlocation <- any_location_in(one_of(building));\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\treflex stay when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect default{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect default {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tfloat height <- rnd(10#m, 20#m) ;\n\t\n\taspect default {\n\t\tdraw shape color: #gray border: #black depth: height;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_date.hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: 3d {\n\t\t\tlight #ambient intensity: 20;\n\t\t\tlight #default intensity:(is_night ? 127 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road ;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building  transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh: every(10#cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series style: spline {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green marker: false;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a multi-level model of a population dynamics simulation where people move around and interact with each other and their environment, including buildings and roads. The simulation should track the spread of an infectious disease and display the results in 3D and 2D visualizations.", "gaml_code": "/**\n* Name: Multi-level\n* Author: GAMA team\n* Description: 6th part of the tutorial : Incremental Model\n* Tags: tutorial, chart, graph, 3d, light, multi-Level\n*/\nmodel model6\n\nglobal {\n\tint nb_people <- 500;\n\tfloat agent_speed <- 5.0 #km / #h;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_in_building);\n\tint nb_people_infected <- nb_infected_init update: (people + list_people_in_buildings) count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_date.hour < 7 or current_date.hour > 20;\n\tfloat infected_rate update: nb_people_infected / nb_people;\n\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t\tlocation <- any_location_in(one_of(building));\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\n\t}\n\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\n\treflex move when: target != nil {\n\t\tdo goto target: target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in(one_of(building));\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t}\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n\n\taspect sphere3D {\n\t\tdraw sphere(3) at: {location.x, location.y, location.z + 3} color: is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\n\taspect default {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tint nb_infected <- 0 update: self.people_in_building count each.is_infected;\n\tint nb_total <- 0 update: length(self.people_in_building);\n\tfloat height <- rnd(10 #m, 20 #m);\n\t\n\tspecies people_in_building parent: people schedules: [] {\n\t}\n\n\treflex let_people_leave {\n\t\task people_in_building {\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\n\t\trelease people_in_building where (flip(each.staying_counter / staying_coeff)) as: people in: world {\n\t\t\ttarget <- any_location_in(one_of(building));\n\t\t}\n\n\t}\n\n\treflex let_people_enter {\n\t\tcapture (people inside self where (each.target = nil)) as: people_in_building;\n\t}\n\n\taspect default {\n\t\tdraw shape color: nb_total = 0 ? #gray : (float(nb_infected) / nb_total > 0.5 ? #red : #green) border: #black depth: height;\n\t}\n}\n\nexperiment main_experiment type: gui {\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_date.hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: 3d {\n\t\t\tlight #ambient intensity: 20;\n\t\t\tlight #default intensity:(is_night ? 127 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road;\n\t\t\tspecies people aspect: sphere3D;\n\t\t\tspecies building transparency: 0.5;\n\t\t}\n\n\t\tdisplay chart refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green marker: false;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a model that simulates the spread of an infectious disease on a graph-based map, where people move around and can infect each other, and display the simulation results in real-time using a GUI interface.", "gaml_code": "/**\n* Name: Movement on Graph\n* Author: GAMA team\n* Description: 4th part of the tutorial : Incremental Model\n* Tags: tutorial, chart, graph, gis\n*/\n \nmodel model4 \n \nglobal {\n\tint nb_people <- 500;\n    float agent_speed <- 5.0 #km/#h;\t\t\t\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m; \n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected / nb_people;\n\t\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile; \n\t\tcreate people number:nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t\tlocation <- any_location_in(one_of(building));\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}  \n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\t\n\treflex staying when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect default{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_date.hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies road ;\n\t\t\tspecies building ;\n\t\t\tspecies people ;\t\t\t\n\t\t}\n\t\tdisplay chart refresh: every(10#cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series style: spline{\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green marker: false;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates the spread of an infectious disease through a population of people moving within a geographic area defined by roads and buildings.", "gaml_code": "/**\n* Name: Integration of GIS Data\n* Author:\n* Description: third part of the tutorial : Incremental Model\n* Tags: gis, chart, tutorial\n*/\nmodel model3\n\nglobal {\n\tint nb_people <- 500;\n\tfloat agent_speed <- 5.0 #km / #h;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected / nb_people;\n\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t\tlocation <- any_location_in(one_of(building));\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\n\nexperiment main_experiment type: gui {\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_date.hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies road;\n\t\t\tspecies building;\n\t\t\tspecies people;\n\t\t}\n\n\t\tdisplay chart refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series style: spline {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green marker: false;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red marker: false;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates road traffic and repair, including buildings, roads, people agents, and graphical displays for 3D city view and 2D charts.", "gaml_code": "/**\n* Name: Automatic repair of roads\n* Author:\n* Description: 7th part of the tutorial: Road Traffic\n* Tags: transport\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tdate starting_date <- date(\"2019-09-01-00-00-00\");\t\n\tint nb_people <- 100;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tint repair_time <- 2 ;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building> industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- rnd(min_speed, max_speed);\n\t\t\tstart_work <- rnd (min_work_start, max_work_start);\n\t\t\tend_work <- rnd(min_work_end, max_work_end);\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n\treflex repair_road when: every(repair_time #hour ) {\n\t\troad the_road_to_repair <- road with_max_of (each.destruction_coeff) ;\n\t\task the_road_to_repair {\n\t\t\tdestruction_coeff <- 1.0 ;\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- rnd(1.0,2.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_date.hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_date.hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- goto(target:the_target, on:the_graph, return_path: true);\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\tparameter \"Number of hours between two road repairs\" var: repair_time category: \"Road\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t\tdisplay chart_display refresh: every(10#cycles)  type: 2d { \n\t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates traffic flow and road damage in a city, including buildings, roads, and pedestrians, with adjustable parameters for number of people, work hours, speed, and destruction coefficient.", "gaml_code": "/**\n* Name: Dynamic update of the road network\n* Author:\n* Description: 5th part of the tutorial: Road Traffic\n* Tags: graph\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tdate starting_date <- date(\"2019-09-01-00-00-00\");\t\n\tint nb_people <- 10;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tgraph the_graph;\n\t\n\tinit { \n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building> industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- rnd(min_speed, max_speed);\n\t\t\tstart_work <- rnd (min_work_start, max_work_start);\n\t\t\tend_work <- rnd(min_work_end, max_work_end);\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{ \n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- rnd(1.0,2.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_date.hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_date.hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- goto(target: the_target, on:the_graph, return_path: true);\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates road traffic in a city, including buildings, roads, and people agents, with parameters for number of people, work hours, speed, and destruction coefficient, and display charts to show mean and max road destruction and people objectives.", "gaml_code": "/**\n* Name: Definition of a chart display\n* Author:\n* Description: 6th part of the tutorial: Road Traffic\n* Tags: chart\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tdate starting_date <- date(\"2019-09-01-00-00-00\");\t\n\tint nb_people <- 100;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building> industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- rnd(min_speed, max_speed);\n\t\t\tstart_work <- rnd (min_work_start, max_work_start);\n\t\t\tend_work <- rnd(min_work_end, max_work_end);\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- rnd(1.0,2.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_date.hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_date.hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- goto(target: the_target, on: the_graph, return_path: true);\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t\tdisplay chart_display refresh: every(10#cycles)  type: 2d { \n\t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a city's traffic system using GIS data from shapefiles, including buildings and roads.", "gaml_code": "/**\n* Name: Loading of GIS data (buildings and roads)\n* Author:\n* Description: first part of the tutorial: Road Traffic\n* Tags: gis\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\t\t\n\toutput {\n\t\tdisplay city_display type:3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of a city's traffic system using a GIS-based model, where agents (people) move between residential and industrial areas based on their work schedules, with adjustable parameters for population size, working hours, speed limits, and display settings.", "gaml_code": "/**\n* Name: Movement of the people agents\n* Author:\n* Description: third part of the tutorial: Road Traffic\n* Tags: agent_movement\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tdate starting_date <- date(\"2019-09-01-00-00-00\");\n\tint nb_people <- 100;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tthe_graph <- as_edge_graph(road);\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building> industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- rnd(min_speed, max_speed);\n\t\t\tstart_work <- rnd (min_work_start, max_work_start);\n\t\t\tend_work <- rnd(min_work_end, max_work_end);\n\t\t\tliving_place <- one_of(residential_buildings);\n\t\t\tworking_place <- one_of(industrial_buildings);\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n}\n\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_date.hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_date.hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tdo goto target: the_target on: the_graph ; \n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\t\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\t\n\toutput {\n\t\tdisplay city_display type: 3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates traffic flow in a city with buildings and roads, where agents (people) move between their living and working places based on their schedules.", "gaml_code": "/**\n* Name: Definition of weight for the road network\n* Author:\n* Description: 4th part of the tutorial: Road Traffic\n* Tags: graph\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tdate starting_date <- date(\"2019-09-01-00-00-00\");\t\n\tint nb_people <- 100;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building> industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- rnd(min_speed, max_speed);\n\t\t\tstart_work <- rnd (min_work_start, max_work_start);\n\t\t\tend_work <- rnd(min_work_end, max_work_end);\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- rnd(1.0,2.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_date.hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_date.hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tdo goto target: the_target on: the_graph ; \n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\t\n\toutput {\n\t\tdisplay city_display type:3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a city with buildings, roads, and pedestrians using GIS data.", "gaml_code": "/**\n* Name: Definition of people agents\n* Author:\n* Description: second part of the tutorial: Road Traffic\n* Tags: gis\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tcreate people number: nb_people {\n\t\t\tlocation <- any_location_in (one_of (residential_buildings));\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people {\n\trgb color <- #yellow ;\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:3d {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple 3D simulation model using GAML, including a GUI interface and basic visualization of cells in a 100x100x100 grid.", "gaml_code": "/**\n* Name: Basic model\n* Author: Arnaud Grignard\n* Description: First part of the tutorial : Tuto3D\n* Tags:\n*/\n\nmodel Tuto3D\n\nglobal {\n  int nb_cells <- 100;\t\n  init { \n    create cell number: nb_cells { \n      location <- {rnd(100), rnd(100), rnd(100)};       \n    } \n  }  \n} \n  \nspecies cell {                      \n  aspect default {\n    draw sphere(1) color: #blue;   \n  }\n}\n\nexperiment Tuto3D  type: gui {\n  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;\t\n  output {\n    display View1 type: 3d {\n\tcamera 'default' location: {-89.9704,145.5689,125.2091} target: {117.2908,13.529,0.0};\n      species cell;\n    }\n  }\n}"}
{"prompt": "Create a 3D simulation of cells moving on a grid, with each cell displaying its neighbors and interacting with them.", "gaml_code": "/**\n* Name: Moving cells with neighbors\n* Author: Arnaud Grignard\n* Description: Third part of the tutorial : Tuto3D\n* Tags: 3d, light, grid, neighbors\n*/\n\nmodel Tuto3D\n\nglobal {\n\tint nb_cells <- 100;\n\tint environment_size <- 100;\n\tgeometry shape <- cube(environment_size);\n\n\tinit {\n\t\tcreate cell number: nb_cells {\n\t\t\tlocation <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\t\t}\n\t}\n}\n\nspecies cell skills: [moving3D] {\n\trgb color;\n\tlist<cell> neighbors;\n\tint offset;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex compute_neighbors {\n\t\tneighbors <- cell select ((each distance_to self) < 10);\n\t}\n\n\taspect default {\n\t\tdraw sphere(environment_size * 0.01) color: #orange;\n\t\tloop pp over: neighbors {\n\t\t\tdraw line([self.location, pp.location]);\n\t\t}\n\t}\n}\n\nexperiment Tuto3D type: gui {\n\tparameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\";\n\toutput {\n\t\tdisplay View1 type: 3d background: rgb(10, 40, 55) {\n\t\t\tcamera 'default' location: {-89.9704,145.5689,125.2091} target: {117.2908,13.529,0.0};\n\t\t\tgraphics \"env\" {\n\t\t\t\tdraw cube(environment_size) color: #black wireframe: true;\n\t\t\t}\n\t\t\tspecies cell;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a grid environment with moving cells, using NetLogo or similar agent-based modeling framework.", "gaml_code": "/**\n* Name: Moving cells\n* Author: Arnaud Grignard\n* Description: Second part of the tutorial : Tuto3D\n* Tags: grid, agent_movement\n*/\nmodel Tuto3D   \n\nglobal {\n\tint nb_cells <- 100;\n\tint environment_size <- 100;\n\tgeometry shape <- cube(environment_size);\n\n\tinit {\n\t\tcreate cell number: nb_cells {\n\t\t\tlocation <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\t\t}\n\t}\n}\n\nspecies cell skills: [moving3D] {\n\treflex move {\n\t\tdo move;\n\t}\n\n\taspect default {\n\t\tdraw sphere(environment_size * 0.01) color: #blue;\n\t}\n}\n\nexperiment Tuto3D type: gui {\n\tparameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\";\n\toutput {\n\t\tdisplay View1 type: 3d {\n\t\t\tcamera 'default' location: {-89.9704,145.5689,125.2091} target: {117.2908,13.529,0.0};\n\t\t\tgraphics \"env\" {\n\t\t\t\tdraw cube(environment_size) color: #black wireframe: true;\n\t\t\t}\n\t\t\tspecies cell;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a city with spreading disease, where people move and infect each other, using NetLogo-like modeling language.", "gaml_code": "/**\n* Name: Luneray's flu 5\n* Author: Patrick Taillandier\n* Description: Define a 3D display\n* Tags: 3D, obj, 3d, tutorial\n*/\n\nmodel model5\n\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 5 #mn;\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\t\n\tgraph road_network;\n\t\n\t\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\t\t\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tlocation <- any_location_in(one_of(building));\t\t\t\t\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\tpoint target;\n\t\n\treflex stay when: target = nil {\n\t\tif flip(0.05) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t} \n\t}\n\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect circle {\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n\t\n\taspect geom3D {\n\t\tif target != nil {\n\t\t\tdraw obj_file(\"../includes/people.obj\", 90::{-1,0,0}) size: 5\n\t\t\tat: location + {0,0,7} rotate: heading - 90 color: is_infected ? #red : #green;\n\t\t}\n\t}\n\t\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n\taspect geom3D {\n\t\tdraw line(shape.points, 2.0) color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n\taspect geom3D {\n\t\tdraw shape depth: 20 #m border: #black texture:[\"../includes/roof_top.jpg\",\"../includes/texture.jpg\"];\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tdisplay chart_display refresh: every(10 #cycles)  type: 2d  {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay view3D type: 3d antialias: false {\n\t\t\tlight #ambient intensity: 80;\n\t\t\timage \"../includes/luneray.jpg\" refresh: false; \n\t\t\tspecies building aspect: geom3D refresh: false;\n\t\t\tspecies road aspect: geom3D refresh: false;\n\t\t\tspecies people aspect: geom3D; \n\t\t}\n\t}\n}"}
{"prompt": "Simulate a simple SIR model (Susceptible-Infected-Recovered) of disease spreading in a population of 2147 people, where some are initially infected and the rest are susceptible, with optional parameters to control the initial number of infected individuals.", "gaml_code": "/**\n* Name: Luneray's flu 2\n* Author: Patrick Taillandier\n* Description: Additions of a chart, monitor and end condition\n* Tags: chart, monitor, pause, tutorial\n*/\n\nmodel model2\n\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 5 #mn;\n\tgeometry shape<-square(1500 #m);\n\t\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\tinit{\n\t\tcreate people number:nb_people;\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n    reflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n    }\t\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\t\n\treflex move{\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect circle {\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\n\t\t}\n\t\t\n\t\tdisplay chart_display refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates the spread of a disease through a population of people moving on a road network, using a graph to constrain their movements.", "gaml_code": "/**\n* Name: Luneray's flu 4\n* Author: Patrick Taillandier\n* Description: Use of a graph to constraint the movements of people\n* Tags: graph, moving, tutorial\n*/\n\nmodel model4\n\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 5 #mn;\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\t\n\tgraph road_network;\n\t\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\t\t\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tlocation <- any_location_in(one_of(building));\t\t\t\t\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\n    reflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n    }\t\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\tpoint target;\n\t\n\treflex stay when: target = nil {\n\t\tif flip(0.05) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target: target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t} \n\t}\n\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect circle {\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t\n\t\tdisplay chart_display refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple epidemiological model using GAML to simulate the spread of an infectious disease among a population of 2147 people.", "gaml_code": "/**\n* Name: Luneray's flu 1\n* Author: Patrick Taillandier\n* Description: Describe here the model and its experiments\n* Tags: species, global, experiment, skill, moving, tutorial\n*/\n\nmodel model1\n\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 5 #mn;\n\tgeometry shape<-square(1500 #m);\n\t\n\tinit{\n\t\tcreate people number:nb_people;\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\t\n\treflex move{\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect circle {\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\n\t\t}\n\t}\n}"}
{"prompt": "Design a spatially explicit epidemiological model to simulate the spread of an infectious disease among a population of people moving through a road network and interacting with buildings, exploring the effects of various parameters on disease transmission.", "gaml_code": "/**\n* Name: Luneray's flu 6\n* Author: Patrick Taillandier\n* Description: Exploration of the model\n* Tags: batch, genetic, save, tutorial\n*/\n\nmodel model6\n\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 5 #mn;\n\t\n\tfloat proba_leave <- 0.05;\n\t\n\tfloat infection_distance <- 5 #m;\n\tfloat proba_infection <- 0.05;\n\t\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\t\n\tgraph road_network;\n\t\n\t\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\t\t\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tlocation <- any_location_in(one_of(building));\t\t\t\t\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\tpoint target;\n\t\n\treflex stay when: target = nil {\n\t\tif flip(proba_leave) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t} \n\t}\n\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect circle {\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n\t\n\taspect geom3D {\n\t\tif target != nil {\n\t\t\tdraw obj_file(\"../includes/people.obj\", 90::{-1,0,0}) size: 5\n\t\t\tat: location + {0,0,7} rotate: heading - 90 color: is_infected ? #red : #green;\n\t\t}\n\t}\n\t\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n\taspect geom3D {\n\t\tdraw line(shape.points, 2.0) color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n\taspect geom3D {\n\t\tdraw shape depth: 20 #m border: #black texture:[\"../includes/roof_top.jpg\",\"../includes/texture.jpg\"];\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\n\toutput {\n\t\t\n\t\tlayout #split ;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\n\t\tdisplay chart_display type: 2d refresh: every(10 #cycles) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay view3D type: 3d antialias: false {\n\t\t\tlight #ambient intensity: 80;\n\t\t\timage \"../includes/luneray.jpg\" refresh:false; \n\t\t\tspecies building aspect:geom3D refresh: false;\n\t\t\tspecies road aspect: geom3D refresh: false;\n\t\t\tspecies people aspect: geom3D ; \n\t\t}\n\t}\n}\n\nexperiment test_robustness type: batch until: time > 2#h repeat: 10 {\n\treflex information {\n\t\tlist<float> vals <- simulations collect each.infected_rate;\n\t\twrite \"mean: \" + mean(vals) + \" standard deviation: \" + standard_deviation(vals);\t\n\t}\n}\n\nexperiment explore_model type: batch until: time > 2#h repeat: 2 {\n\tparameter \"proba_leave\" var: proba_leave among: [0, 0.01, 0.05, 0.1, 1.0];\n\t\n\treflex save_results {\n\t\t\n\t\task simulations {\n\t\t\twrite \"proba_leave: \" + proba_leave + \" infected_rate: \" + self.infected_rate;\n\t\t\tsave [proba_leave, infected_rate] to:\"results.csv\" rewrite: (int(self) = 0) ? true : false header: true ;\n\t\t}\n\t}\n}\n\nexperiment calibration_model type: batch until: time > 2#h repeat: 3 {\n\tparameter \"infection distance\" var: infection_distance min: 1.0 max: 20.0 step: 1;\n\tparameter \"proba infection\" var: proba_infection min: 0.01 max: 1.0 step: 0.01;\n\t\n\tmethod genetic pop_dim: 3 max_gen: 5 minimize: abs(infected_rate - 0.5);\n}"}
{"prompt": "Create a NetLogo model that simulates the spread of an infectious disease through a population of people moving within a geographic area, using GIS data to define the environment.", "gaml_code": "/**\n* Name: Luneray's flu 3\n* Author: Patrick Taillandier\n* Description: Importation of GIS data\n* Tags: gis, tutorial\n*/\n\nmodel model3\n\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 5 #mn;\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\t\n\t\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number: nb_people {\n\t\t\tlocation <- any_location_in(one_of(building));\t\t\t\t\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\n    reflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n    }\t\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect circle {\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map {\n\t\t\tspecies road aspect: geom;\n\t\t\tspecies building aspect: geom;\n\t\t\tspecies people aspect: circle;\t\t\t\n\t\t}\n\t\t\n\t\tdisplay chart_display refresh: every(10 #cycles)  type: 2d {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a SIR model to optimize infection rate and mortality probability for minimizing the number of infected people using various optimization algorithms (PSO, GA, Hill Climbing, Tabu Search, Reactive Tabu Search, Simulated Annealing) in batch mode.", "gaml_code": "/**\n* Name:  Model using Batch mode\n* Author:  Patrick Taillandier\n* Description: A model showing how to use batch experiments to find the best combination of parameters to minimize the numbers of infected people \n*      in a SIR infection model where agents infect others and become immune after a certain time and has a probability to die. The batch mode uses seven different methods: Hill climbing\n*      GA, PSO, Tabu Search, Reactive Tabu Search, Simulated Annealing, and Explicit exploration. The model proposes five experiments : one simple with a User Interface, one running 10 experiments and saving the data, and one \n*      for each strategy. \n* Tags: batch, algorithm, save_file\n*/\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- gama.machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\tparameter 'Probability of dying:' var: dying_proba;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n// This experiment explores two parameters with a PSO strategy,\n// repeating each simulation five times (the aggregated fitness correspond to the mean fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment PSO type: batch keep_seed: true repeat: 5 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod pso num_particles: 5 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5  iter_max: 5 aggregation:\"avr\"  minimize: num_dead  ; \n}\n\n// This experiment explores two parameters with a GA strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the min fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 improve_sol: true stochastic_sel: false\n\tnb_prelim_gen: 1 max_gen: 5  minimize: num_dead  aggregation: \"min\";\n}\n\n\n// This experiment explores two parameters with a Hill Climbing strategy from an explicit init solution (if no solution is given, start from a random sol),\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Hill_Climbing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.1;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod hill_climbing init_solution:map([\"infection_rate\"::0.2, \"dying_proba\":: 0.05])  minimize: num_dead aggregation: \"max\";\n}\n\n\n// This experiment explores two parameters with a Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod tabu iter_max: 5 tabu_list_size: 5 minimize: num_dead aggregation: \"max\";\n}\n\n// This experiment explores two parameters with a Reactive Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Reactive_Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod reactive_tabu iter_max: 10 cycle_size_max: 10 cycle_size_min: 3 tabu_list_size_init: 5 minimize: num_dead aggregation: \"max\";\n}\n\n// This experiment explores two parameters with a Simulated annealing strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Simulated_annealing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod annealing  minimize: num_dead temp_decrease: 0.5 temp_end: 10.0 temp_init: 50;\n}"}
{"prompt": "Design a batch experiment to explore the behavior of a predator-prey model under various parameter settings and sampling methods, including exhaustive exploration, Latin Hypercube Sampling, Factorial design, Sobol analysis, Morris analysis, and Beta distribution estimation.", "gaml_code": "/**\n* Name: Exploration\n* Based on the internal empty template. \n* Author: kevinchapuis\n* Tags: batch\n*/\n\n\nmodel Exploration\n\nimport \"../../Tutorials/Predator Prey/models/Model 13.gaml\"\n\n/*\n * Change a little bit the behavior of the world agent to fit exploration requirements\n */\nglobal {\n\tint end_cycle <- 500;\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){ } // Overload method so we do not have any saved output\n\tbool stop_sim { return (nb_preys = 0) or (nb_predators = 0); } \n}\n\n/* \n * Model used to expose simulation exploration capabilities of Gama batch experiments\n * ----\n * See Predator Prey in tutorial in the Model Library\n * \n */\n \nexperiment batch_abstract type:batch virtual:true until:(time > end_cycle) {\n\tinit {is_batch <- true;}\n\tparameter \"Prey max transfer:\" var: prey_max_transfer min: 0.05 max: 0.5 step: 0.05;\n\tparameter \"Prey energy reproduce:\" var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05;\n\tparameter \"Predator energy transfer:\" var: predator_energy_transfer min: 0.1 max: 1.0 step: 0.1;\n\tparameter \"Predator energy reproduce:\" var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;\n}\n\n// This experiment runs the full factorial experiment (each combination of parameter) 5 times, that is 14k simulations :) see exhaustive_exploration experiment\n// At the end of each simulation (replicated 5 times), the people agents are saved in a shapefile\nexperiment 'Run 5 simulations' parent: batch_abstract type: batch repeat: 5 keep_seed: true until: world.stop_sim() or (time > end_cycle){\n\t\n\t// the reflex will be activated at the end of each run; in this experiment a run consists of the execution of 5 simulations (repeat: 5)\n\treflex end_of_runs\n\t{\n\t\tint cpt <- 0;\n\t\t// each simulation of the run is an agent; it is possible to access to the list of these agents by using the variable \"simulations\" of the experiment. \n\t\t// Another way of accessing to the simulations consists in using the name of model + _model: here \"batch_example_model\"\n\t\t//in this example, we ask all the simulation agents of the run to save (at the end of the simulation) the people population in a shapefile with their is_infected and is_immune attributes \n\t\task simulations\n\t\t{\n\t\t\tsave [nb_preys,nb_predators] to: \"Results/preypredator.csv\" format:\"csv\" rewrite:false;\n\t\t}\n\t}\n}\n\n// This experiment extract the number of replicates that should be made according to two methods:\n// 1. How increasing the number of replicates dimish the standard error\n// 2. coefficient of variation \nexperiment replication_analysis parent: batch_abstract type: batch until: world.stop_sim() or ( time > end_cycle ) \n\trepeat:40 keep_simulations:false {\n\tmethod stochanalyse outputs:[\"nb_preys\", \"nb_predators\"] report:\"Results/stochanalysis.txt\" results:\"Results/stochanalysis_raw.csv\" sample:3;\n} \n\n// This experiment explores the four parameters with an exhaustive strategy (default sampling method for exploration),\n// repeating each simulation three times. The overall combination of parameter values is 14000 (times 3 replications).\n// This is what we call 'brut force' exploration - because obviously it is not smart, nor gentle in the exploration approach. \n// In order to diminish number of explored points, one can use 'factorial' facet (how many value per parameter) or diminish the step\n// facet of parameters each at a time. Another way is to rely on smarter strategy to sample from the parameter space using sampling methods.  \nexperiment exhaustive_exploration parent: batch_abstract type: batch repeat: 3 keep_seed: true until: world.stop_sim() or ( time > end_cycle ) {\n\tmethod exploration;\n\t\n\t//the permanent section allows to define a output section that will be kept during all the batch experiment\n\tpermanent {\n\t\tdisplay Comparison  type: 2d {\n\t\t\tchart \"Number of people infected\" type: series {\n\t\t\t\t//we can access to all the simulations of a run (here composed of 5 simulation -> repeat: 5) by the variable \"simulations\" of the experiment.\n\t\t\t\t//here we display for the 5 simulations, the mean, min and max values of the nb_infected variable.\n\t\t\t\tdata \"Mean\" value: mean(simulations collect each.nb_preys ) style: spline color: #blue ;\n\t\t\t\tdata \"Min\" value:  min(simulations collect each.nb_preys ) style: spline color: #darkgreen ;\n\t\t\t\tdata \"Max\" value:  max(simulations collect each.nb_preys ) style: spline color: #red ;\n\t\t\t}\n\t\t}\t\n\t}\n}\n\n// This experiment tests two explicit parameters sets,\n// repeating each simulation three times (the aggregated fitness correspond to the mean fitness), \nexperiment explicit_exploration parent: batch_abstract type: batch repeat: 3 keep_seed: true until: world.stop_sim() or ( time > end_cycle ) {\n\tmethod exploration with: [\n\t\t[\"prey_max_transfer\"::0.1, \"predator_energy_transfer\":: 0.01],\n\t\t[\"prey_max_transfer\"::0.5, \"predator_energy_transfer\":: 0.2],\n\t\t[\"prey_max_transfer\"::1.0, \"predator_energy_transfer\":: 0.05],\n\t\t[\"prey_max_transfer\"::0.5, \"predator_energy_transfer\":: 0.1]\n\t];\n}\n\n// This experiment iterate over point of the parameter space choosen following\n// Latin Hypercube Sampling\nexperiment exploration_with_sampling  parent: batch_abstract repeat:3 type: batch until:world.stop_sim() or time>end_cycle {\n\tmethod exploration sampling:\"latinhypercube\" sample:100;\n}\n\nexperiment exploration_with_factorial  parent: batch_abstract repeat:3 type: batch until:world.stop_sim() or time>end_cycle {\n\tmethod exploration sampling:\"factorial\" factorial:4 sample:100;\n}\n\n// This experiment iterate over 100 point randomly drawn from the parameter space\n// Then the model global variables \"nb_preys\" and \"nb_predators\" are saved un a csv for each simulation run (including potential replicates)\nexperiment exploration_with_sampling_and_outputs parent: batch_abstract repeat:3 type: batch until:world.stop_sim() or time>end_cycle {\n\tmethod exploration sampling:\"uniform\" sample:10 outputs:[\"nb_preys\",\"nb_predators\"] results:\"Results/exploration.csv\";\n}\n\n// This experiment samples from the parameter space (Saltelli methods) to establish\n// Sobol index, i.e. a contribution value of each parameters to \n// observed variance for outcomes of interest, \n// more on this see https://www.jasss.org/19/1/5.html and http://moeaframework.org for the API\nexperiment Sobol parent: batch_abstract type: batch until:( time > end_cycle ) {\n\tmethod sobol outputs:[\"nb_preys\",\"nb_predators\"] sample:10 report:\"Results/sobol.csv\" results:\"Results/sobol_raw.csv\";\n}\n\n// This experiment perform a Morris analysis (see Morris 1991, doi:10.1080/00401706.1991.10484804)\n// to screen and rank parameters based on elementary effect (changes on outputs due to a small modification of \n// one paameter value)\nexperiment Morris parent: batch_abstract type: batch until:( time > end_cycle ) {\n\tmethod morris outputs:[\"nb_preys\",\"nb_predators\"] sample:10 levels:4 report:\"Results/morris.csv\" results:\"Results/morris_raw.csv\";\n}\n\n// This experiment computed beta d kuiper statistics to estimate the impact of parameters\n// on the distribution of outputs. It has been retro-engineered based on the description in\n// Borgonovo et al. 2022 doi:10.1007/s10588-021-09358-5\n// ---------------\n// sample facet: number of sampled points\n// bootstrap facet: how many time a parameter value is duplicated in the final experiment plan, with bootstrap < sample\n// Hence, final sample size is 'sample + sample * bootstrap * |parameter|', with default sample and bootstrap, respectively 132 and 4\n// Sampled point should be high and at least 2 times higher than bootstrap\nexperiment Beta_distribution parent: batch_abstract type: batch until:( time > end_cycle ) {\n\tmethod betad outputs:[\"nb_preys\",\"nb_predators\"] sampling:\"uniform\" sample:10 bootstrap:4 report:\"Results/betad.csv\" results:\"Results/betad_raw.csv\";\n}"}
{"prompt": "Create a NetLogo model that demonstrates multi-simulation, allowing multiple runs of the same GUI experiment with different parameter sets.", "gaml_code": "/**\n* Name: Multi Simulation\n* Author: Patrick Taillandier\n* Description: Model to show how to use multi-simulation, i.e. to run several times the same GUI experiment with potentially different parameter sets \n* Tags: multi_simulation\n*/\n\nmodel multi_simulation\n\nglobal {\n\t//definition of three global variables of which the initial values will be used by the first simulation \n\tint nb_agents <- 10;\n\tfloat agent_speed <- 1.0;\n\trgb agent_color <- #green;\n\t\n\t\n\tinit {\n\t\tcreate dummy number: nb_agents;\n\t}\n}\n\n//definition a simple species that just move randomly at a given speed\nspecies dummy skills: [moving]{\n\trgb color <- #green;\n\treflex move {\n\t\tdo wander speed: agent_speed;\n\t}\n\taspect default {\n\t\tdraw circle(2) color: agent_color border: #black;\n\t}\n}\n\nexperiment main type: gui {\n\t//definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\t//we define a init block to create new simulations\n\tinit {\n\t\t//we create a second simulation (the first simulation is always created by default) with the following parameters\n\t\tcreate simulation with: [nb_agents:: 5, agent_speed:: 5.0, agent_color:: #red];\n\t\t\n\t}\n\toutput {\n\t\tlayout horizontal([0::5000,1::4000]) tabs:true editors: false;\n\t\tdisplay map {\n\t\t\t//we use an overlay to display the speed of the agents in the simulation\n\t\t\toverlay position: { 5, 5 } size: { 180 #px, 30 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n               draw \"agent_speed: \" + agent_speed color: # white font: font(\"SansSerif\", 20, #bold) at: { 10#px, 20#px };\n            }\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}"}
{"prompt": "Design a multi-agent simulation model that demonstrates various dynamics and behaviors in regular and batch experiments, including GUI, initialization, and reflexes, with the ability to create multiple simulations, access their attributes, and execute parallel or sequential execution.", "gaml_code": "/***\n* Name: Experiment species\n* Author: Benoit Gaudou\n* Description: The model shows the different dynamics of the experiment and its simulation(s).\n* \n* Tags: experiment, simulation, gui, batch\n***/\n\n// Create a model showing the different dynamics of the experiment and its simulation(s), \n// in regular and batch experiments & memorize\n// (i.e. when are the behaviors of the experiment executed, how does it access its simulations, etc.)\n\n\nmodel Experimentspecies\n\nglobal {\n\tint nb_people <- 5;\n\t\n\tinit {\n\t\twrite \"====== Init of \" + self;\n\t\twrite sample(seed) + \" - of \" + self.name;\t\t\t\t\n\t\tcreate people number: nb_people;\n\t}\n\t\n\treflex t {\n\t\twrite sample(cycle) + \" - reflex t of \" + self.name;\n\t}\t\n\t\n\tabort {\n\t\twrite \"====== Death of \" + self;\n\t}\n}\n\nspecies people {}\n\n// The basic GUI experiment behavior is:\n// - create a single simulation (initialization of the model)\n// - (at each step) call the behavior of the model (e.g. the reflexes in the global).\nexperiment basic_exp type: gui { }\n\n// The GUI experiment can be configured to add a behavior at the initialization of the experiment and before each step.\n// Note that a simulation is always created by default, and the execution of the simulation is managed by its own behaviors.\nexperiment exp_with_init_reflex type: gui {\n\n\tinit {\n\t\twrite \"====== Init of \" + self color: #green;\n\t\t\n\t\t// simulations field of experiment contain all the simulations\n\t\t// simulation filed contains the last created simulation.\n\t\twrite \"The experiment contains \" + length(simulations) + \" simulations.\" color: #green;\n\t\twrite \"The last created simulation is: \" + simulation color: #green;\t\n\t}\n\t\n\treflex t {\n\t\twrite sample(cycle) + \" - reflex t of \" + self color: #red;\n\t}\n}\n\n// The init of the experiment is the place to create the additional simulations to run.\n// The experiment can control the way these simulations are executed using:\n// - schedules: facet (list of simulation agents): that specifies which simulations are executed and in which order.\n// - parallel: facet (true/false): whether they are executed parallelly or sequenticially.\n//\n// The experiment can access to all the simulations.\n//\n// Note: the experiment and all the simulations have the same seed by default. To avoid that, the seed should be set at hand.\nexperiment exp_4_simulations type: gui schedules: shuffle(simulations) parallel: true  {\n\n\tinit {\n\t\twrite \"====== Init of \" + self color: #green;\n\t\twrite sample(seed) + \" - of \" + self.name color: #green;\t\t\t\t\t\t\t\t\n\t\t\n\t\tcreate simulation with:[name::\"Simu 1\",nb_people::rnd(10),seed::rnd(1.0)];\n\t\tcreate simulation with:[name::\"Simu 2\",nb_people::rnd(10),seed::rnd(1.0)];\n\t\tcreate simulation with:[name::\"Simu 3\",nb_people::rnd(10),seed::rnd(1.0)];\n\t\t\t\t\n\t\twrite \"The experiment contains \" + length(simulations) + \" simulations.\" color: #green;\n\t\twrite \"The last created simulation is: \" + simulation color: #green;\n\t}\n\t\n\treflex t {\n\t\twrite sample(cycle) + \" - reflex t of \" + self color: #red;\n\t\t// The experiment can access to all the simulations, but also all the agents of all the simulations\n\t\twrite sample(simulations with_max_of(each.nb_people)) color: #red;\n\t\twrite sample(sum(simulations accumulate(length(each.agents)))) color: #red;\n\t\t\n\t\tloop s over: simulations {\n\t\t\twrite sample(length(s.people)) + \" (\"+s.name+\")\" color: #red;\n\t\t}\n\t}\n}\n\n// The default behavior of the experiment (with init and reflexs) can also be modified by redefining 2 actions:\n// - _init_ : its default behavior is to create a simulation and run the init statement of the experiment\n// - _step_ : its default behavior is to execute the behavior of the experiment (its reflexes) and then to call the behavior of the simulations.\n// When they are redefined, the default behaviors are disabled :\n// - _init_ : no simulation created and init statement is not called, \n// - _step_ : the behavior of exepriment and simulations is not called.\nexperiment exp_no_simulation type: gui {\n\n\taction _init_ {\n\t\twrite \"_init_ of \" + self color: #green;\n\t\tcreate simulation with:[name::\"Simu 1\",nb_people::rnd(10)];\t\t\n\t}\n\n\tinit {\n\t\terror \"This will not be executed\";\n\t\twrite \"init of \" + self color: #green;\t\n\t}\n\t\n\taction _step_ {\n\t\twrite sample(cycle) + \"  _step_ of \" + self  color: #red;\n\t\twrite \"NOTHING more is executed in the step\" color: #red;\n\t}\n\t\n\treflex t {\n\t\terror \"This will not be executed\" ;\t\t\n\t\twrite \"reflex t of \" + self color: #red;\n\t}\n}\n\n// Note that the basic simulation defined as:\n//       experiment basic_exp type: gui { }\n// could be written, using _init_ and _step_ as follows\nexperiment basic_exp_init_step {\n\taction _init_ {\n\t\tcreate simulation;\n\t}\n\t\n\taction _step_ {\n\t\task simulations {\n\t\t\tdo _step_;\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////\n// When the experiment is a batch, the two init and reflex statements are executed as follows:\n// - init is executed as the initialization of the experiment design and thus before the creation of any simulation \n// - reflex is executed after each replications (i.e. after the execution of the N simulations corresponding to a replication,\n// N is specified in the repeat: statement.\nexperiment batch_4_simu type: batch autorun: true repeat: 4 until: (cycle > 2) parallel: true keep_simulations: true {\n\n\tparameter \"nb_people\" var: nb_people among: [0,5,10];\n\n\tinit {\n\t\twrite \"====== Init of \" + self color: #green;\n\t\twrite sample(seed) + \" - of \" + self.name color: #green;\t\t\t\t\t\t\t\t\n\t\twrite \"The experiment contains \" + length(simulations) + \" simulations.\" color: #green;\n\t\twrite \"The last created simulation is: \" + simulation color: #green;\t\t\n\t}\n\t\n\t// \n\treflex t {\n\t\twrite \"============================================\" color: #red;\n\t\twrite \"End of replicates\" color: #red;\n\t\twrite sample(cycle) + \" - reflex t of \" + self.name color: #red;\n\t\t\n\t\t// The experiment can access to all the simulations, but also all the agents of all the simulations\n\t\t// It can be classically used in batch to save results in a file.\n\t\twrite sample(simulations with_max_of(each.nb_people))  color: #red;\n\t\twrite sample(sum(simulations accumulate(length(each.agents)))) color: #red;\n\t\t\n\t\tloop s over: simulations {\n\t\t\twrite sample(length(s.people)) + \" (\"+s.name+\")\" color: #red;\n\t\t}\n\t\t// We get rid of the simulations manually as we memorize them with 'keep_simulations' (necessary for accessing their attributes)\n\t\task simulations {\n\t\t\tdo die;\n\t\t}\n\t}\n}\n\n////////////////////////////////////////////////////////////\n// When the experiment is recorded, the behavior is very similar to the gui experiment one's.\n// Note that when 1 step back is made, no behavior is executed\nexperiment mem_simu record: true {\n\n\tinit {\n\t\twrite \"====== Init of \" + self color: #green;\n\t\twrite \"The experiment contains \" + length(simulations) + \" simulations.\" color: #green;\n\t\twrite \"The last created simulation is: \" + simulation color: #green;\t\t\n\t}\n\t\n\t// \n\treflex t {\n\t\twrite \"============================================\" color: #red;\n\t\twrite sample(cycle) + \" - reflex t of \" + self.name color: #red;\n\t}\n}\n\n////////////////////////////////////////////////////////////\n// When the experiment is recorded, if several simulations are created, they are all stepped back.\nexperiment mem_2_simu record: true {\n\n\tinit {\n\t\twrite \"====== Init of \" + self color: #green;\n\t\tcreate simulation;\n\t\twrite \"The experiment contains \" + length(simulations) + \" simulations.\" color: #green;\n\t\twrite \"The last created simulation is: \" + simulation color: #green;\t\t\n\t}\n\t\n\t// \n\treflex t {\n\t\twrite \"============================================\" color: #red;\n\t\twrite sample(cycle) + \" - reflex t of \" + self.name color: #red;\n\t}\n}"}
{"prompt": "Create a simple GAML model that simulates agents with customizable parameters (number of agents, color, 2D/3D mode) and displays them on a GUI.", "gaml_code": "/**\n* Name: InitAction\n* Author: Alexis Drogoul\n* Description:  This simple example shows how to use the _init_ callback action to build a simulation with some parameters, without declaring them as parameters\n* Tags: GAML\n*/\n\nmodel InitAction\n\nglobal {\n\tint agent_number <- 100;\n\trgb agent_color <- #red;\n\tbool 2d <- false;\n\t\n\tinit {\n\t\tcreate my_agents number: agent_number;\n\t}\n}\n\nspecies my_agents {\n\t\n\tint elevation <- rnd(30);\n\t\n\t\n\taspect default {\n\t\tif (2d){\n\t\t\tdraw square(5) color: agent_color;\t\t\t\n\t\t}\n\t\telse {\n\t\t\tdraw sphere(5) color: agent_color at:{location.x, location.y, elevation};\t\t\t\n\t\t}\n\t}\n\t\n}\n\nexperiment InitAction type: gui {\n\t\n\taction _init_ {\n\t\tmap<string, unknown> params <- user_input_dialog([enter(\"Number of agents\",100), enter(\"Color\",#red), enter(\"2D\",true)]);\n\t\tcreate InitAction_model with: [agent_number::int(params[\"Number of agents\"]), agent_color::rgb(params[\"Color\"]), 2d::bool(params[\"2D\"])];\n\t}\n\t\n\toutput {\n\t\tdisplay Simple type:3d{\n\t\t\tspecies my_agents aspect:default;\t\t\t \n\t\t}\n\t}\n\t\n}"}
{"prompt": "Show several ways to use the switch ... match ... statement in a Rock-Paper-Scissors game, including equality matches, range matches, and default cases.", "gaml_code": "/***\n* Name: switchmatch\n* Author: kevinchapuis\n* Description: Show several way to use the switch ... match ... statement\n* Tags: switch, match, match_one\n* \n***/\n\nmodel switchmatch\n \nglobal {\n\tstring my_play; // parameter:true init:\"ROCK\" among:RPS;\n\tfile my_image;\n\tfile bot_image;\n\t\n\tstring the_result;\n\t\n\tint win_sign;\n\t\n\tinit {\n\t\tcreate rps_bot with:[strategy::[1,1,1]];\n\t}\n\t\n\t/*\n\t * The argument to match can be constructed from any instruction. Switch statement\n\t * accept 3 types of match: (1) match to test the equality (2) match_one for at least one equality\n\t * (2) match_between for a test on a range of numerical value\n\t */\n\treflex play {\n\t\task rps_bot {do bot_play;}\n\t\tswitch first(rps_bot).bp+\"vs\"+my_play {\n\t\t\tmatch_one [\"ROCKvsPAPER\", \"PAPERvsSCISSORS\", \"SCISSORSvsROCK\"] {\n\t\t\t\twin_sign <- 1;\n\t\t\t}\n\t\t\tmatch_one [\"ROCKvsSCISSORS\", \"PAPERvsROCK\", \"SCISSORSvsPAPER\"] {\n\t\t\t\twin_sign <- -1;\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\twin_sign <- 0;\n\t\t\t} \n\t\t}\n\t\tbot_image <- file(rps_image(first(rps_bot).bp));\n\t\tmy_image <- file(rps_image(my_play));\n\t\twrite rps_result(win_sign);\n\t}\n\t\n\t/*\n\t * Switch statement can be used with any type of data like int, string, agent. \n\t * The match will be tested using the main expression type (here is int)\n\t */\n\tstring rps_result(int res) {\n\t\tswitch res {\n\t\t\tmatch_between [-#infinity,-1] {\n\t\t\t\treturn \"You loose\";\n\t\t\t} \n\t\t\tmatch_one [1,2,3,4,5] {\n\t\t\t\treturn \"You win\";\n\t\t\t}\n\t\t\tmatch 0 {\n\t\t\t\treturn \"Draw\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstring rps_image(string play) {\n\t\tswitch play {\n\t\t\tmatch \"ROCK\" {\n\t\t\t\treturn \"img/rock.png\";\n\t\t\t}\n\t\t\tmatch \"PAPER\" {\n\t\t\t\treturn \"img/paper.png\";\n\t\t\t}\n\t\t\tmatch \"SCISSORS\" {\n\t\t\t\treturn \"img/scissors.png\";\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n \nspecies rps_bot {\n\t\n\tlist<float> strategy;\n\t\n\tstring bp;\n\t\n\taction bot_play {\n\t\tbp <- [\"ROCK\",\"PAPER\",\"SCISSORS\"][rnd_choice(strategy)];\n\t}\n\t\n}\n\nexperiment \"Rock Paper Scissors\" type:gui {\n\tparameter \"My play\" var:my_play among:[\"ROCK\",\"PAPER\",\"SCISSORS\"] init:any([\"ROCK\",\"PAPER\",\"SCISSORS\"]);\n\toutput {\n\t\tdisplay my_display type:3d{\n\t\t\timage my_image size:point(0.2) position:{10,40} refresh:true;\n\t\t\tgraphics res {\n\t\t\t\tdraw (win_sign = 0 ? \"=\" : (win_sign < 0 ? \"<\" : \">\")) at:{47,52} font:font(\"Digit\",50,#bold) color:#black;\n\t\t\t}\n\t\t\timage bot_image size:point(0.2) position:{70,40} refresh:true;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple finite state machine example to demonstrate how an agent can transition between states based on conditions and behaviors.", "gaml_code": "/***\n* Name: statetransition\n* Author: kevinchapuis\n* Description: simple finite state machine example to show how make a transition to one state to another\n* Tags: fsm, state, transition\n***/\n\nmodel statetransition\n\nglobal {\n\t\n\tint number_of_dummy init:10;\n\t\n\tinit {\n\t\tcreate dummy number:number_of_dummy;\n\t}\n\t\n}\n\n/**\n * \n * Finite State Machine control makes it possible to define several possible state of the agent. Each state is associated\n * to behavior and attribute define in the model that can lead to transition between states. \n * \n * statement enter : set of instructions to be executed before entering a state\n * \n * statement transition : [to: the state to transition to] [when: the condition to trigger the transition]\n * \n * statement exit : set of instructions to be executed after leaving a state\n * \n * WARNING: this is not a knowledgeable model - the purpose is to explictly state the syntax\n * \n */\nspecies dummy skills:[moving] control:fsm {\n\t\n\tfloat speed <- 10#m/#s;\n\t\n\tint scope <- 1;\n\tint score;\n\t\n\tdummy match;\n\t\n\trgb color <- #orange;\n\t\n\t/*\n\t * The definition of the state called 'in_seach' which is the initial state of agent:\n\t * when created (at the beginning of the simulation), agent will be granted this state\n\t * \n\t */\n\tstate in_search initial: true {\n\t\t/*\n\t\t * Code to be executed each step when the agent is in this state\n\t\t */\n\t\tdo wander; \n\t\tmatch <- (dummy-self) first_with (each distance_to self < scope);\n\t\t\n\t\tscope <- scope + 1;\n\t\t\n\t\t/*\n\t\t * Transition to 'settle_down' when a match have been found\n\t\t */\n\t\ttransition to:settle_down when:not(match=nil) {\n\t\t\tcolor <- #blue;\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * The definition of the state called 'settle_down' \n\t */\n\tstate settle_down {\n\t\t\n\t\tdo goto target: match;\n\t\tscore <- score - 1;\n\t\t\n\t\t/*\n\t\t * The set of instructions to be execute ONCE when agent enter this state\n\t\t */\n\t\tenter {\n\t\t\tscope <- 1;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Transition to 'break_up' state when the match agent respond positively to self agent call\n\t\t */\n\t\ttransition to:break_up when:match.hello(self){\n\t\t\tcolor <- #green;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Transition to 'in_seach' when score is under or equal to 0\n\t\t */\n\t\ttransition to:in_search when:score <= 0 { color <- #orange;}\n\t}\n\t\n\t/*\n\t * The definition of the state 'break_up'\n\t */\n\tstate break_up {\n\t\tscore <- score + 1;\n\t\t\n\t\t/**\n\t\t * triggered once when entering this state\n\t\t */\n\t\tenter {\n\t\t\tscore <- score * int(score/10);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Transition to the state 'in_search' when my score is higher the my match score\n\t\t */\n\t\ttransition to:in_search when:score > match.score;\n\t\t\n\t\t/**\n\t\t * Set of instructions to be executed ONCE when leaving the state \n\t\t */\n\t\texit { \n\t\t\tscore <- (dummy with_min_of each.score).score;\n\t\t\tcolor <- #orange;\n\t\t}\n\t}\n\t\n\tbool hello(dummy paire){\n\t\treturn score = paire.score ? flip(0.5) : score < paire.score; \n\t}\n\t\n\taspect default {\n\t\tdraw triangle(score) color:color;\n\t\tdraw circle(scope) color:rgb(color,0.2);\n\t}\n}\n\nexperiment dummy_xp {\n\tparameter var:number_of_dummy;\n\toutput {\n\t\tdisplay friendship {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that demonstrates various if-then-else statements and the ternary operator, including examples of conditional logic, bi-conditionals, or-conditionals, and nested conditionals.", "gaml_code": "/***\n* Name: IfthenelseNewModel\n* Author: ben\n* Description: gives several examples of if then else statements. Also show how to use tertiary operator: 'condition ? then : else'\n* Tags: if, else, ?\n***/\n\nmodel IfthenelseNewModel\n\n/* Insert your model definition here */\n\nglobal {\n\t\n\tbool condition1 init:true;\n\tbool condition2 init:true;\n\t\n\tinit {\n\t\t\n\t\tdo condional_hello_world;\n\t\t\n\t\tdo bi_conditional_hello_world;\n\t\t\n\t\tdo or_conditional_hello_world;\n\t\t\n\t\tdo if_then_hello_world_else_goodbye;\n\t\t\n\t\tdo if_then_tic_elseif_then_tac_else_toc;\n\t\t\n\t\tdo tertiary_hello_world;\n\t\t\n\t}\n\t\n\taction condional_hello_world {\n\t\twrite \"------------------------\";\n\t\twrite \"Test : if condition1 is true then print 'hello world'\";\n\t\tstring result;\n\t\tif(condition1){\n\t\t\tresult <- \"Hello world !\";\n\t\t}\n\t\twrite \"Result : \"+result;\n\t}\n\t\t\n\taction bi_conditional_hello_world {\n\t\twrite \"------------------------\";\n\t\twrite \"Test : if condition1 and condition2 are true then print 'hello world'\";\n\t\tstring result;\n\t\tif(condition1 and condition2){\n\t\t\tresult <- \"Hello world !\";\n\t\t}\n\t\twrite \"Result : \"+result;\n\t}\n\t\n\taction or_conditional_hello_world {\n\t\twrite \"------------------------\";\n\t\twrite \"Test : if condition1 or condition2 are true then print 'hello world'\";\n\t\tstring result;\n\t\tif(condition1 or condition2){\n\t\t\tresult <- \"Hello world !\";\n\t\t}\n\t\twrite \"Result : \"+result;\n\t}\n\t\n\taction if_then_hello_world_else_goodbye {\n\t\twrite \"------------------------\";\n\t\twrite \"Test : if condition1 is true then print 'hello world' else print 'Goodbye'\";\n\t\tstring result;\n\t\tif(condition1) {\n\t\t\tresult <- \"Hello world !\";\n\t\t} else {\n\t\t\tresult <- \"Goodbye\";\n\t\t}\n\t\twrite \"Result : \"+result;\n\t}\n\t\n\taction if_then_tic_elseif_then_tac_else_toc {\n\t\twrite \"------------------------\";\n\t\twrite \"Test : if condition1 is true then print 'tic !' else if condition2 is true then print 'tac !' else print 'toc !'\";\n\t\tstring result;\n\t\tif(condition1) {\n\t\t\tresult <- \"tic !\";\n\t\t} else if (condition2) {\n\t\t\tresult <- \"tac !\";\n\t\t} else {\n\t\t\tresult <- \"toc !\";\n\t\t}\n\t\twrite \"Result : \"+result;\n\t}\n\t\n\taction tertiary_hello_world {\n\t\twrite \"------------------------\";\n\t\twrite \"Test tertiary operator (condition ? then : else)\";\n\t\twrite \"If condition1 true print 'Hello world !'\";\n\t\tstring result1 <- condition1 ? \"Hello world !\" : \"\";\n\t\twrite \"Result : \"+result1;\n\t\twrite \"If condition1 and condition2 are true print 'Hello world !'\";\n\t\tstring result2 <- condition1 and condition2 ? \"Hello world !\" : \"\"; \n\t\twrite \"Result : \"+result2;\n\t\twrite \"If condition1 true print 'Hello world !' else print 'Goodbye'\";\n\t\tstring result3 <- condition1 ? \"Hello world !\" : \"Goodbye\"; \n\t\twrite \"Result : \"+result3;\n\t\twrite \"If condition1 true print 'tic !' else if condition2 is true print 'tac !' else print 'toc !'\";\n\t\tstring result4 <- condition1 ? \"tic !\" : (condition2 ? \"tac !\" : \"toc !\");\n\t\twrite \"Result : \"+result4;\n\t}\n\t\t\n}\n\nexperiment my_xp type:gui {\n\tparameter var:condition1;\n\tparameter var:condition2;\n\t\n\toutput {\n\t\t\n\t}\n}"}
{"prompt": "Explore and demonstrate various scenarios for triggering reflexes in a multi-agent system using different conditions and logical operators.", "gaml_code": "/***\n* Name: reflex_when\n* Author: kevinchapuis\n* Description: Gives few example on how to use when facets of reflex statement\n* Tags: reflex, when, condition\n***/\n\nmodel reflex_when\n\nglobal {\n\t\n\tint no_condition;\n\tint nb_simple_when;\n\tint nb_composed_when;\n\t\n\tgeometry cr2_area <- polygon([{0,0},{50,0},{50,50},{0,50}]);\n\t\n\tinit {\n\t\tcreate dummy;\n\t}\n\t\n\treflex r {\n\t\tno_condition <- no_condition+1;\n\t}\n\t\n\t/*\n\t * You can use any operator that return a boolean to trigger a reflex \n\t * \n\t * Result: Do the reflex when flip(0.5) is true\n\t */\n\treflex cr when:flip(0.5) {\n\t\tnb_simple_when <- nb_simple_when+1;\n\t\twrite \"this reflex is activated \"+round(nb_simple_when/(cycle+1)*100)+\"% of the time\";\n\t}\n\t\n\t/*\n\t * You can use a combination of conditions to build more complex reflex trigger\n\t * \n\t * Result: Do the reflex when flip(0.1) is true AND the first dummy agent is below coordinate {50,50}\n\t */\n\treflex cr2 when:flip(0.1) and first(dummy).location < {50,50} {\n\t\tnb_composed_when <- nb_composed_when + 1; \n\t\twrite \"You've been lucky \"+nb_composed_when+\" times\";\n\t}\n\t\n\t/*\n\t * You can use as many conditions as necessary and combine them using logical operator\n\t * like 'and' and 'or'. A reflex can be schedule in detailed and can be very unlikely\n\t *  \n\t */\n\treflex cr3 when:(flip(0.01) and every(100#cycle) and (nb_composed_when mod 7 = 0)) or every(#year) {\n\t\twrite \"Jackpot after \"+no_condition+\" cycles\";\n\t}\n\t\n}\n\nspecies dummy {\n\treflex move {location <- any_location_in(world);}\n\taspect default {draw circle(1) color:#crimson;}\n}\n\nexperiment my_xp {\n\toutput {\n\t\tdisplay my_display type:3d{\n\t\t\tgraphics area transparency:0.3{\n\t\t\t\tdraw cr2_area color:#darkblue;\n\t\t\t\tdraw string(nb_composed_when) at:{25,25} font:font(\"Helvetica\",60,#bold) color:#white;\n\t\t\t}\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}"}
{"prompt": "Create a model that demonstrates the difference between agents created without a scheduler and those created with a scheduler. The model should include two species of agents, one without a scheduler and one with a scheduler, and print messages to the console as each agent is created.", "gaml_code": "/**\n* Name: schedullingagents\n* Author: damienphilippon\n* Description: If the schedules facet is not given, it will have its default value which is using the list of the species.\n\t\t\tAs the list of the species is created the same way the agents are created, it should be ordered. So the console\n\t\t\twill be filled with messages with the agent with the number used to index them that should be ordered in a\n\t\t\tforward sort with without agent writing first\n* Tags: \n*/\n\nmodel schedullingagents\n\n/* Insert your model definition here */\nglobal\n{\n\tinit\n\t{\n\t\tint cpt <- 0;\n\t\tcreate without_scheduler number:10\n\t\t{\n\t\t\tcpt<-cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\tcpt<-0;\n\t\tcreate scheduler_species number:10\n\t\t{\n\t\t\tcpt<-cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\twrite \"If the scheduled facet is not given, it will have its default value which is using the list of the species.\\n\"\n\t\t\t+ \"As the list of the species is created the same way the agents are created, it should be ordered. So the console \\n\"\n\t\t\t+ \"will be filled with messages with the agent with the number used to index them that should be ordered in a\\n\"\n\t\t\t+ \"forward sort with without agent writing first\";\n\t}\n}\nspecies without_scheduler\n{\n\tint nb_generated;\n\treflex sayHello\n\t{\n\t\twrite \"hello, i'm without scheduler \" + nb_generated;\n\t}\n}\n\nspecies scheduler_species schedules:scheduler_species\n{\n\tint nb_generated;\n\treflex sayHello\n\t{\n\t\twrite \"hello, i'm scheduled \"+nb_generated;\n\t}\n}\nexperiment example_default_scheduler type:gui\n{\n\n}"}
{"prompt": "Create a simple agent-based model that demonstrates how scheduling affects execution. The model should have 10 agents with a reflex to print their generated number when triggered. If an empty list is provided for scheduling, the model should not execute and print a message explaining this.", "gaml_code": "/**\n* Name: schedullingagents\n* Author: damienphilippon\n* Description: With an empty list given inside the schedules facet of the species, it will not be executed \n\t\t\t\tso, nothing will be written inside the console\n* Tags: scheduling, execution \n*/\n\nmodel schedullingagents\n\nglobal\n{\n\tinit\n\t{\n\t\tint cpt <- 0;\n\t\tcreate no_scheduler number:10\n\t\t{\n\t\t\tcpt<-cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\twrite \"With an empty list given inside the schedules facet of the species, it will not be executed \\n\"\n\t\t\t+ \"so, nothing will be written inside the console\";\n\t}\n}\nspecies no_scheduler schedules:[]\n{\n\tint nb_generated;\n\treflex sayHello\n\t{\n\t\twrite \"hello, i'm \"+nb_generated;\n\t}\n}\n\nexperiment \"No Scheduling\" type:gui\n{\n\t\n}"}
{"prompt": "Design a multi-agent system where a manager species schedules and executes agents from two other species (A and B) without being executed itself. The system should demonstrate scheduling and execution of agents in a random order.", "gaml_code": "/**\n* Name: managerscheduler\n* Author: damienphilippon\n* Description: This model shows how a species can manage other species execution process. In the facet schedules of the \n\t\t\tmanager species, a shuffled list of the agents of the species B and A has been given. The agents of species B and A will be randomly executed once per step.\n\t\t\tAn important point is that the manager is not executed, since it is not scheduled anywhere, but it is still scheduling other species agents.\n\t\t\tThis is shown with the reflex write_new_step belonging to the manager species that is not executed, not writing its text to the console.\n* Tags: scheduling, execution\n*/\n\nmodel managerscheduler\n\n/* Insert your model definition here */\n\nglobal\n{\n\tinit\n\t{\n\t\tcreate manager;\n\t\tint cpt <- 0;\n\t\tcreate A number:10\n\t\t{\n\t\t\tcpt <- cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\tcpt<-0;\n\t\tcreate B number:10\n\t\t{\n\t\t\tcpt <- cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\t\n\t\twrite \"This model shows how a species can manage other species execution process. In the facet schedules of the\\n\"\n\t\t\t+ \"manager species, a shuffled list of the agents of the species B and A has been given. The agents of species B and A will be randomly executed once per step.\\n\"\n\t\t\t+ \"An important point is that the manager is not executed, since it is not scheduled anywhere, but it is still scheduling other species agents.\\n\"\n\t\t\t+ \"This is shown with the reflex write_new_step belonging to the manager species that is not executed, not writing its text to the console.\";\n\t}\n}\n\nspecies manager schedules:manager+shuffle(B+A)\n{\n\treflex write_new_step\n\t{\n\t\twrite \"-----NEW STEP BY MANAGER-----\";\n\t}\n}\n\nspecies A schedules:[]\n{\n\tint nb_generated;\n\treflex present_itself\n\t{\n\t\twrite \"I'm A \"+nb_generated;\n\t}\n}\nspecies B schedules:[]\n{\n\tint nb_generated;\n\treflex present_itself\n\t{\n\t\twrite \"I'm B \"+nb_generated;\n\t}\n\t\n}\nexperiment \"Schedule\" type:gui\n{\n\t\n}"}
{"prompt": "Create a NetLogo model that demonstrates random scheduling of agents within a species using the shuffle operator.", "gaml_code": "/**\n* Name: randomscheduler\n* Author: damienphilippon\n* Description: To randomize the way agents of a same species are executed, it is possible to use the operator shuffle in the schedules facet. In this case, agents\n\t\t\twill write their number, but they are executed in a random way\n* Tags: scheduling, execution, random\n*/\n\nmodel randomscheduler\n\n/* Insert your model definition here */\n\nglobal\n{\n\tinit\n\t{\n\t\tint cpt <- 0;\n\t\tcreate no_scheduler number:10\n\t\t{\n\t\t\tcpt<-cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\twrite \"To randomize the way agents of a same species are executed,\\n\" \n\t\t\t+ \"it is possible to use the operator shuffle in the schedules facet. \\n\"\n\t\t\t+ \"In this case, agents will write their number,\\n\"\n\t\t\t+ \"but they are executed in a random way\";\n\t}\n\t\n\treflex write_new_step\n\t{\n\t\twrite \"NEW STEP\";\n\t}\n}\nspecies no_scheduler schedules:shuffle(no_scheduler)\n{\n\tint nb_generated;\n\treflex sayHello\n\t{\n\t\twrite \"hello, i'm \"+nb_generated;\n\t}\n}\n\nexperiment \"Schedule\" type:gui\n{\n\t\n}"}
{"prompt": "Create a model that demonstrates scheduling and execution of species A and B by a manager species, highlighting the manager's ability to schedule other agents without being executed itself.", "gaml_code": "/**\n* Name: managerscheduler\n* Author: damienphilippon\n* Description: This model shows how a species can manage other species execution process. In the facet schedules of the \n\t\t\tmanager species, the list of the agents of the species B and A has been given. B agents will be executed first and then A agents.\n\t\t\tAn important point is that the manager is not executed, since it is not scheduled anywhere, but it is still scheduling other species agents.\n\t\t\tThis is shown with the reflex write_new_step belonging to the manager species that is not executed, not writing its text to the console.\n* Tags: scheduling, execution\n*/\n\nmodel managerscheduler\n\n/* Insert your model definition here */\n\nglobal\n{\n\tinit\n\t{\n\t\tcreate manager;\n\t\tint cpt <- 0;\n\t\tcreate A number:10\n\t\t{\n\t\t\tcpt <- cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\tcpt<-0;\n\t\tcreate B number:10\n\t\t{\n\t\t\tcpt <- cpt+1;\n\t\t\tnb_generated<-cpt;\n\t\t}\n\t\t\n\t\twrite \t\"This model shows how a species can manage other species execution process. In the facet schedules of the \\n\"\n\t\t\t+\t\"manager species, the list of the agents of the species B and A has been given. B agents will be executed first and then A agents.\\n\"\n\t\t\t+\t\"An important point is that the manager is not executed, since it is not scheduled anywhere, but it is still scheduling other species agents.\\n\"\n\t\t\t+\t\"This is shown with the reflex write_new_step belonging to the manager species that is not executed, not writing its text to the console.\";\n\t}\n}\n\nspecies manager schedules:(B+A)\n{\n\treflex write_new_step\n\t{\n\t\twrite \"-----NEW STEP BY MANAGER-----\";\n\t}\n}\n\nspecies A schedules:[]\n{\n\tint nb_generated;\n\treflex present_itself\n\t{\n\t\twrite \"I'm A \"+nb_generated;\n\t}\n}\nspecies B schedules:[]\n{\n\tint nb_generated;\n\treflex present_itself\n\t{\n\t\twrite \"I'm B \"+nb_generated;\n\t}\n\t\n}\nexperiment \"Schedule\" type:gui\n{\n\t\n}"}
{"prompt": "Design a model that simulates opinion dynamics between agents and their mirror counterparts, where agents interact based on a convergence speed and threshold, and display the mirrored agents in a 3D social space.", "gaml_code": "/***\n* Name: Advanced mirror\n* Author: Kevin Chapuis and Benoit Gaudou\n* Description: This model goes further in the use of mirror species, \n*   in particular by illustrating creation and death of mirrored agents during the simulation.\n*   In particular, the mirrored agents move, and interact with their neighbor agents \n*   following a opinion dynamics model. The model is very close to Deffuant et al. JASSS. \n*   In addition the mirror agents are displayed in a so-called social space of opinion:\n*   they are displayed vertically, depending on their opinion value.\n*   \n* Tags: mirror, display, opinion dynamics\n***/\n\nmodel Mirror\n\nglobal {\n\tpoint up_display_threeD <- {0,0,20};\n\tfloat threshold <- 0.4;\n\tfloat convergence_speed <- 0.4;\n\t\n\tbool with_respawn <- false;\n\tint nb_agent <- 20;\n\t\n\tinit {\n    \tcreate A number:1;    \n  \t}\n  \t\n  \t// At the creation of an agent A, a mirror agent B will also be created.\n  \treflex create_agents when: length(A) < nb_agent{\n  \t\tcreate A number: 2;\n  \t}\n  \t\n  \t// Similarly when an agent A is killed, the corresponding mirror agent is killed \n  \t// (this is done only at the end of the simulation step).\n  \treflex update_population when: (length(A) >= nb_agent) and with_respawn {\n  \t\task one_of(A) {do die;}\n  \t\tcreate A;  \t\t\n  \t}\n}\n\nspecies A skills:[moving]{\n\tfloat opinion <- rnd(1.0);\n\t\n    reflex move {\n        do wander;\n    }\n\n    reflex opinion_influence {\n  \t\tA neighbor <- (A - self) with_min_of (each distance_to self);\n\n\t\tif (neighbor != nil) and ((abs(neighbor.opinion - opinion)) < threshold) {\t\n\t\t\t// x = x + u* (x - x')\n\t\t\tfloat temp <- opinion;\n\t\t\topinion <- opinion + convergence_speed * (neighbor.opinion - opinion);\n\t\t\tneighbor.opinion <- neighbor.opinion + convergence_speed * (temp - neighbor.opinion);\t\n\t\t}  \t\n    }\n    \n    aspect base{\n        draw circle(1) color:  rgb(255*opinion,255,0) border: #black;\n    }\n}\n\n// Only the mirror agents for which the target is not dead will be scheluded.\nspecies B mirrors: A schedules: B where(!dead(each.target)){\n\t\n    aspect base {\n    \tif(!dead(target)) {\n\t\t\tdraw sphere(2) at: {-10, 100 * target.opinion, 10} color: rgb(255*target.opinion,255,0) ;\t\t\n    \t}\n    }\n}\n\nexperiment mirroExp type: gui {\n\tparameter \"Create new agents\" var: with_respawn;\n\tparameter \"Macimum number of agents\" var: nb_agent;\n\t\n    output {\n        display superposedView type: 3d{ \n          \tspecies A aspect: base ;\n          \tspecies B aspect: base ;\n          \n          \tgraphics g {\n          \t\tfont f <- font(\"Arial\", 15, #bold);\n          \t\tdraw \"Opinion\" at: {-8, -5, 10} color: #black anchor: #top_center font: f;\n          \t\tdraw \"0.0\" at: {-17, 0, 10} color: #black font: f;\n          \t\tdraw \"1.0\" at: {-17, 100, 10} color: #black font: f;\n          \t\t\n          \t}\n        }\n    }\n}"}
{"prompt": "Implement an example of inheritance in a simple object-oriented model using GAML.", "gaml_code": "/**\n* Name: Inheritance\n* Author: Alexis Drogoul\n* Description:  A simple abstract model to show the usage of inheritance\n* Tags: GAML\n*/\n\nmodel Inheritance\n\nglobal {\n\tinit {\n\t\tcreate child {\n\t\t\tdo init(10,10);\n\t\t}\n\t\task child {\n\t\t\tdo add;\n\t\t}\n\t}\n}\n\nspecies parent {\n\tint a; \n\tint b;\n\t\n\taction init (int va, int vb) {\n\t\tself.a <- va;\n\t\tself.b <- vb;\n\t}\n\n\tint add {\n\t\tdo do_nothing();\n\t\twrite do_something();\n\t\treturn a + b;\n\t}\n\t\n\taction do_nothing virtual: true; // do_nothing is abstract and cannot be called. In addition it makes parent an abstract species\n\taction do_something virtual: true type:bool;// do_nothing is abstract and cannot be called. In addition it makes parent an abstract species\n}\n\nspecies child parent: parent {\n\taction init(int va, int vb) {\n\t\tinvoke init(va + 20, vb+20); // we invoke the super implementation of init with the keyword invoke, if the action is not used as a function\n\t}\n\t\n\tint add {\n\t\tint result <- super.add(); // when the action is used as a function, we invoke the super implementation of add with the keyword super\n\t\twrite result;\n\t\twrite do_something();\n\t\treturn result;\n\t}\n\tbool do_something{return true;}\n\taction do_nothing {write \"nothing\";} // virtual actions inherited from the parent must be redeclared or the species will be considered as abstract\n}\n\nexperiment Run {}"}
{"prompt": "Create a simple GAMA model that simulates mirror species with agents displaying different views of each other in a 3D environment.", "gaml_code": "/***\n* Name: Mirrorsimple\n* Author: documentation GAMA\n* Description: This model simply illustrates mirror species used to provides \n*   a different display of the agents\n* Tags: mirror, display\n***/\n\nmodel Mirrorsimple\n\nglobal {\n\t\n\tint neigh_distance <- 10;\n\t\n  \tinit{\n    \tcreate A number:100;    \n  \t}\n}\n\nspecies A skills:[moving] {\n    reflex update{\n        do wander;\n    }\n    aspect base{\n        draw circle(1) color: #white border: #black;\n    }\n}\nspecies B mirrors: A {\n    point location <- target.location update: {target.location.x,target.location.y,target.location.z+5};    \n   \tlist<B> neigh <- [] update: B at_distance neigh_distance;\n   \t\n    aspect base {\n        draw sphere(2) color: #blue;\n        loop n over: neigh {\n        \tdraw line(location, n.location) color: #black;\n        }\n    }\n}\n\nexperiment mirroExp type: gui {\n    output {\n        display superposedView type: 3d{ \n          species A aspect: base;\n          species B aspect: base transparency:0.5;\n        }\n    }\n}"}
{"prompt": "Generate a GAML model that demonstrates various ways to access agents' attributes, including built-in and custom attributes, and how they can be initialized from shape files.", "gaml_code": "/***\n* Name: Attribute Access\n* Author: Benoit Gaudou\n* Description: Model on accessing agents' attributes and which attributes are present when loading shape files.\n* Built-in attibutes are also presented.\n* Tags: GAML, attribute, access\n***/\n\n\nmodel AttributeAccess\n\nglobal {\n\n\tshape_file buildings_simple0_shape_file <- shape_file(\"includes/buildings_simple.shp\");\n\n\tpeople my_people;\n\tpeople_moving my_moving_people;\n\t\t\n\tinit {\n\t\tcreate people returns: list_people;\n\t\tmy_people <- first(list_people);\n\t\t\n\t\tcreate people_moving returns: list_people_moving;\n\t\tmy_moving_people <- first(list_people_moving);\n\t\t\n\t\t// access_attribute the various ways to access to agents' attributes.\n\t\tdo access_attribute;\n\t\t\n\t\t// Agents have several built-in attributes\n\t\tdo built_in_attributes;\n\n\t\t// Agents with a skill have even more attributes \t\t\n\t\tdo built_in_attributes_with_species;\n\t\t\n\t\t// Agents attirbutes can get attributes value from a shapefile \t\t\t\n\t\tdo attributes_from_data;\n\t}\n\t\n\t// \n\taction access_attribute {\n\t\twrite \"============== ACCESS ATTRIBUTES ==============\";\t\t\n\t\t\n\t\t// The access to agents' attributes can be done in several ways\n\t\t// using the . (dot)\n\t\twrite sample(my_people.name);\n\t\t// or using brackets\n\t\t// (in this case the attribute is get through its name as a string\n\t\twrite sample(my_people[\"name\"]);\n\t\t// or the of operators\n\t\twrite sample(name of my_people);\n\t\t\n\t}\n\t\n\taction built_in_attributes {\n\t\twrite \"============== Built-in ATTRIBUTES ==============\";\t\t\n\t\t\n\t\t// Any species has some built-in attributes\n\t\twrite sample(people.attributes);\n\t\t\n\t\t// The attributes list can be used to get the value of each of these attributes.\n\t\tloop attr_name over: people.attributes {\n\t\t\twrite attr_name;\n\t\t\twrite \"    my_people['\"+attr_name+\"'] -: \" + my_people[attr_name] ; \n\t\t\twrite \"    type_of(my_people['\"+attr_name+\"']) -: \" + type_of(my_people[attr_name]);\n\t\t}\n\t}\n\t\n\taction attributes_from_data {\n\t\twrite \"============== ATTRIBUTES read from a shapefile ==============\";\t\t\n\t\t\n\t\t// Agents created from a shapefile can initialize attribute values from the shapefile attributes, \n\t\t// either explicity, using the with: facet\n\t\t// or implicitely, when the attribute has the same name as the shapefile attribute.\n\t\t// The shape of the agent is initialized from the geometry of the shapefile.\n\t\tcreate building_from_shapefile from: buildings_simple0_shape_file with: [building_nature::string(read(\"NATURE\"))];\n\t\t\t\n\t\task building_from_shapefile {\n\t\t\twrite sample(self.building_nature);\n\t\t\twrite sample(self.HEIGHT);\n\t\t\twrite sample(self.name);\n\t\t\twrite sample(self.shape);\n\t\t}\t\n\t}\n\t\n\taction built_in_attributes_with_species {\n\t\twrite \"============== Built-in ATTRIBUTES for a species with skills ==============\";\t\t\n\t\t\n\t\t// Any species has some built-in attributes\n\t\twrite sample(people_moving.attributes);\n\t\t\n\t\t// The attributes list can be used to get the value of each of these attributes.\n\t\tloop attr_name over: people_moving.attributes {\n\t\t\twrite attr_name;\n\t\t\twrite \"    my_people['\"+attr_name+\"'] -: \" + my_moving_people[attr_name] ; \n\t\t\twrite \"    type_of(my_people['\"+attr_name+\"']) -: \" + type_of(my_moving_people[attr_name]);\n\t\t}\n\t}\n\t\n}\n\nspecies people {\n\tstring name <- \"init_in_species\";\n}\n\nspecies building_from_shapefile {\n\tfloat HEIGHT;\n\tstring building_nature;\n}\n\nspecies people_moving skills: [moving] {\n}\n\nexperiment Attributeaccess type: gui { }"}
{"prompt": "Design a simple rule-based control architecture for a GAMA model, demonstrating basic decision-making and behavior.", "gaml_code": "/***\n* Name: RuleBasedBehaviors\n* Author: A. Drogoul\n* Description: This model demonstrates the use of the basic rule-based control architecture available in GAMA. For more complex definition, please take a look at the simple_bdi control.\n* Tags: rule, behavior, architecture\n***/\n\nmodel RuleBasedBehaviors\n\nglobal {\n\tinit {\n\t\tcreate simple_rules_statements;\n\t}\n}\n\n\n/**\n * In this species, two rules and one reflex are defined. \n * The rules are fired (executed) when their condition becomes true and in the order \n * defined by their decreasing priorities. \n */\nspecies simple_rules_statements control: rules {\n\t\n\tint priority_of_a <- 0 update: rnd(100);\n\tint priority_of_b <- 0 update: rnd(100);\n\t\n\treflex show_priorities {\n\t\twrite \" Priority of rule a = \" + priority_of_a + \", priority of rule b = \" + priority_of_b;\n\t}\n\n\tdo_rule a when: priority_of_a < 50 priority: priority_of_a {\n\t\twrite \"Rule a fired with priority: \" + priority_of_a;\n\t}\n\t\n\tdo_rule b when: priority_of_b > 25 priority: priority_of_b {\n\t\twrite \"Rule b fired with priority: \" + priority_of_b; \n\t}\n}\n\nexperiment \"Try it\";"}
{"prompt": "Explain how to use different types of loops (times, from-to, step, over, while) on a list and demonstrate their usage with examples.", "gaml_code": "/***\n* Name: Loops\n* Author: Benoit Gaudou\n* Description: This model illustrates the possible uses of the loop statement on a list (but everything can be applied to any kind of container).\n* Tags: loop, list, over, times, while\n***/\n\nmodel LoopsPossibleUses\n\nglobal {\n\tlist<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\n\t\n\tinit  {\n\t\t// The facet times: is used to repeat a fixed number of times a set of statements:\n\t\tloop times: 2 {\n\t\t\twrite \"======================================\";\n\t\t} \n\t\twrite \"= Various uses of the loop statement =\";\n\t\tloop times: 2 {\n\t\t\twrite \t\"======================================\";\n\t\t} \t\t\n\t\t\n\t\t// The facets from: and to: can be used to repeat a set of statements while an id iterates over a range of values with a fixed step of 1:\n\t\t// For example, to iterate over the list list_of_string\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop  from: to: \" ;\n\t\twrite \"----------------------------------\";\n\n\t\tloop id from: 0 to: length(list_of_string) - 1 {\n\t\t\twrite \"\" + id +\"th element of \" + list_of_string;\n\t\t\twrite sample(list_of_string[id]);\n\t\t}\n\t\t\n\t\t// The three facets from:, to: and step: can be used to set the loop step (notice that step can be negative).\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop  from: to: step:\" ;\n\t\twrite \"----------------------------------\";\n\n\t\tloop id from: 0 to: length(list_of_string) - 1 step: 2 {\n\t\t\twrite \"\" + id +\"th element of \" + list_of_string;\n\t\t\twrite \"  \" + sample(list_of_string[id]); \n\t\t}\n\n\t\t// When step: is negative,we can iterate over a list in the reverse order\n\t\tloop id from: length(list_of_string) - 1 to: 0 step: -1 {\n\t\t\twrite \"\" + id +\"th element of \" + list_of_string;\n\t\t\twrite \"  \" + sample(list_of_string[id]); \n\t\t}\t\t\n\n\t\t// The facet over: can be used to repeat a set of statements while iterating over a full container:\n\t\t// For example, to iterate over the list list_of_string (which is equivalent to iterating over the list with from: and to: facets).\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop  over: \" ;\n\t\twrite \"----------------------------------\";\n\n\t\tloop elt over: list_of_string {\n\t\t\twrite sample(elt);\n\t\t}\t\t\n\t\t\n\t\t// The facet while: is used to repeat a set of statements while a condition is true.\n\t\t// Be careful if the condition is always true, the loop will never end.\n\t\t\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop  while: \" ;\n\t\twrite \"----------------------------------\";\n\n\t\t// For example, while can be used to iterate over a list while a given word is not found.\n\t\tstring word_to_find <- \"of\";\n\t\tint id <- 0;\n\t\t\n\t\tloop while: ( (id < length(list_of_string)) and (list_of_string[id] != word_to_find )) {\n\t\t\twrite \"\" + id +\"th element of \" + list_of_string;\n\t\t\twrite \"  \" + sample(list_of_string[id]); \t\t\t\n\t\t\t// id should be incremented ... otherwise the loop while never end.\n\t\t\tid <- id + 1;\n\t\t}\t\t\t\t\t\n\t\tdo break_loop;\n\t}\n\t\n\t\n\t\n\t// You can interrupt a loop at any time by using the break statement.\t\n\t// The following loop will continue until \n\taction break_loop {\n\t\tint i <- 0;\n\t\tloop while: true {\n\t\t\twrite \"\" + i + \"th iteration!\" ;\n\t\t\tif(flip(0.01)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti <- i + 1;\n\t\t}\n\t}\n}\n\nexperiment name type: gui { }"}
{"prompt": "Explain how to loop over different types of containers (lists, maps, matrices, pairs, graphs, files, populations) and demonstrate examples for each.", "gaml_code": "/***\n* Name: Loops\n* Author: Benoit Gaudou\n* Description: This model illustrates the behavior of loop over many kinds of container.\n* Tags: loop, container, list, map, matrix, point, population\n***/\n\nmodel LoopsOverContainers\n\nglobal {\n\t// GAML contains several container types: they are data structures containing several elements. Containers can be:\n\t// list (of a given type of elements):\n\tlist<string> list_of_string <- [\"A\",\"B\",\"C\"];\n\t// map (a set of pairs key::value):\n\tmap<string,int> map_of_string_int <- [\"A\"::1,\"B\"::2,\"C\"::3];\t\n\t// matrix (a 2-dimensions vector of elements of a given type)\n\tmatrix<string> matrix_of_string <- matrix([[\"R1C1\",\"R2C1\"],[\"R1C2\",\"R2C2\"],[\"R1C3\",\"R2C3\"]]);\n\t// pair (a pair of 2 elements, that can be of different types)\n\tpair<string,int> pair_of_string_int <- \"B\"::2;\n\t// graph (a set of nodes and edges between these nodes)\n\tgraph<point,geometry> graph_of_points <- as_edge_graph([edge({10,5}, {20,3}), edge({10,5}, {30,30}),edge({30,30}, {80,35}),edge({80,35}, {40,60}),edge({80,35}, {10,5}), node ({50,50})]);\t\t\n\t// file\n\ttext_file file_of_text <- text_file(\"created_file\",[\"First line\",\"Second line\",\"last sentence\"]);\n\t// population (the list of all the agents of a given species).\t\n\t// point (2 or 3 float coordinates)\n\tpoint point_3D <- {12,45,2};\n\t\n\t\n\tinit {\n\t\tcreate dummy_species number: 10;\n\t\t\n\t\t// A very convenient way to loop over all the elements of a container is to use the over: facet of the loop.\n\t\tdo loop_over;\n\t\t// To be more precise on the loop over a structure we can need to loop using an index value.\n\t\tdo loop_using_indices;\n\t\t// Some specificities of the loop over maps.\n\t\tdo loop_map;\n\t\t// Some specificities of the loop over graphs.\t\t\n\t\tdo loop_graph;\n\t}\n\t\n\taction loop_over {\n\t\twrite \"==================================\";\n\t\twrite \"= Loop over containers and point =\";\n\t\twrite \"==================================\";\n\t\t\n\t\t// In the loop over a container, a local variable is used and updated with the current element of the container at each step of the loop.\n\t\t// The type of this variable can be different depending on the container.\n\t\n\t\t// When we loop over a list, the local variable elt_of_list has the type of the elments of the list.\t\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the list: \" + list_of_string;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_list over: list_of_string {\n\t\t\twrite sample(elt_of_list);\n\t\t\t// As elt_of_list is taken from a list of string, it is of type string and can be used in any string-related operator.\n\t\t\twrite \"  \" + sample(lower_case(elt_of_list));\n\t\t}\n\t\t\n\t\t// When we loop over a map, the loop is done over the values. \n\t\t// As a consequence the local variable elt_of_map has the type of the values, i.e. int in the following case.\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the map: \" + map_of_string_int;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_map over: map_of_string_int {\n\t\t\twrite sample(elt_of_map);\n\t\t\t// As the loop is made over the values of map_of_string_int, elt_of_map it is of type int.\n\t\t\twrite \"  \" + sample(type_of(elt_of_map));\n\t\t}\t\t\n\t\t\n\t\t// When we loop over a matrix, the loop is done over all the elements (row by row). \n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the matrix: \" + matrix_of_string;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_matrix over: matrix_of_string {\n\t\t\twrite sample(elt_of_matrix);\n\t\t\t// As the loop is made over a matrix of string, elt_of_matrix is of type string.\n\t\t\twrite \"  \" + sample(lower_case(elt_of_matrix));\n\t\t}\t\t\n\t\t\n\t\t// When we loop over a pair, the loop is only over the 2 elements of the pair. \n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the pair: \" + pair_of_string_int;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_pair over: pair_of_string_int {\n\t\t\twrite sample(elt_of_pair);\n\t\t\twrite \"  \" + sample(type_of(elt_of_pair));\n\t\t\t// In a pair, the 2 elements can be of the same type or of different types.\n\t\t\t// In the first case, the elt_of_pair will be of the type common to the 2 elements whereas in the second case, it will be of type unknown.\n\t\t\twrite sample(\"  \" + type_of(elt_of_pair));\n\t\t}\t\n\t\t\n\t\t// When we loop over a graph, the loop is done over all the edges of the graph\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the graph: \" + graph_of_points;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_graph over: graph_of_points {\n\t\t\twrite sample(elt_of_graph);\n\t\t\t// As the loop is made over a graph of point and geometries, elt_of_graph is of type geometry (type of edges).\n\t\t\t// We can thus ask them their source and target nodes.\t\t\t\n\t\t\twrite \"  \" + sample(graph_of_points source_of(elt_of_graph));\n\t\t\twrite \"  \" + sample(graph_of_points target_of(elt_of_graph));\n\t\t}\t\t\n\n\t\t// When we loop over a file, the loop is done over its content (which depends on the file type).\n\t\t// When the file is a text_file, the content is a list of string, each element being a line of the text_file\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the file: \\n\" + file_of_text;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_file over: file_of_text {\n\t\t\twrite sample(elt_of_file);\n\t\t\t// As the loop is made over a text_file, elt_of_file is of type string.\n\t\t\twrite \"  \" + sample(upper_case(elt_of_file));\n\t\t}\t\n\t\t\n\t\t// When we loop over a species/population, the loop is done over all the agents of this population.\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the population: \" + dummy_species;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_species over: dummy_species {\n\t\t\twrite sample(elt_of_species);\n\t\t\t// As the loop is made over a species/population, elt_of_species is of type agent.\n\t\t\t// We can thus ask them some specific agents attributes.\t\t\t\n\t\t\twrite \"  \" + sample(elt_of_species.name);\n\t\t\twrite \"  \" + sample(elt_of_species.location);\t\t\t\n\t\t}\n\t\t\t\t\n\t\t// When we loop over a point, the loop is done over the three coordinates of the point.\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the point: \" + point_3D;\n\t\twrite \"----------------------------------\";\n\t\tloop elt_of_point over: point_3D {\n\t\t\twrite sample(elt_of_point);\n\t\t\t// As the loop is made over a point, elt_of_point is of type float.\t\t\t\n\t\t\twrite sample(type_of(elt_of_point));\n\t\t}\t\t\t\n\t}\n\t\n\t\n\taction loop_using_indices {\n\t\twrite \"=======================\";\n\t\twrite \"= Loop using an index =\";\n\t\twrite \"=======================\";\n\t\t\n\t\t// The previous example loop over a container using the over: facet and thus it iterates over all the elements of the container, \n\t\t// but without any information on it location in the container.\n\t\t// When we need to know this information, we can loop over a container (in particular list or matrix) through an index value.\n\t\t// Reminder: in GAML, lists and matrices index starts at 0 and ends at (number of elements in the container) - 1.\n\t\twrite sample(matrix_of_string[2,1])\t;\n\t\t\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the list: \" + list_of_string;\n\t\twrite \"----------------------------------\";\t\t\t\n\t\t// The loop over a list using an index will be written as follows (it is equivalent to the loop elt_of_list over: list_of_string).\n\t\t// The local variable i is an integer.\n\t\tloop i from: 0 to: length(list_of_string) - 1 {\n\t\t\twrite \"The \"+i+\"th element of the list is: \" + list_of_string[i];\n\t\t}\n\t\t\n\t\twrite \"----------------------------------\";\n\t\twrite \"Loop over the matrix: \" + matrix_of_string;\n\t\twrite \"----------------------------------\";\n\t\t// As a matrix is a 2-dimension set, we need a double loop to loop over all the elements\n\t\tloop index_row from: 0 to: matrix_of_string.rows - 1 {\n\t\t\tloop index_column from: 0 to: matrix_of_string.columns - 1 {\n\t\t\t\twrite \"The element at row: \" + (index_row+1) + \" and column: \" + (index_column+1) + \" of the matrix is: \" + matrix_of_string[index_column,index_row];\t\t\t\t\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\t\t\t\t\n\t// When we loop over a map, the default behavior is to loop over the values (and we thus lose the key in the loop).\n\t// To keep it we can loop over the map either through the keys list, the values list or even the pairs key::value list.\n\taction loop_map {\n\t\twrite \"=======================\";\n\t\twrite \"= Loop over maps      =\";\n\t\twrite \"=======================\";\n\n\t\t// The field keys of map is the list of all the keys of the map.\n\t\tloop key over: map_of_string_int.keys {\n\t\t\twrite sample(key);\n\t\t\t// Given the key, we can also access to the associated value\n\t\t\twrite \"  Value associated to the key \" + key + \": \" + map_of_string_int[key];\n\t\t}\n\n\t\t// The field values of map is the list of all the values of the map.\t\n\t\t// The loop over map_of_string_int.values is thus equivalent to the loop over map_of_string_int.\n\t\tloop value over: map_of_string_int.values {\n\t\t\twrite sample(value);\t\n\t\t}\n\n\t\t// The field pairs of map is the list of all the keys of the map.\t\n\t\t// The local variable a_pair thus contains both key and value.\t\n\t\tloop a_pair over: map_of_string_int.pairs {\n\t\t\twrite sample(a_pair);\n\t\t\t// As the map is a map of string and int, each a_pair is of type pair<string,int>.\n\t\t\twrite sample(type_of(a_pair));\n\t\t\t// We can thus access directly to both key and value.\n\t\t\twrite \"  The key is: \" + a_pair.key;\n\t\t\twrite \"  The value is: \" + a_pair.value;\n\t\t}\n\t}\n\n\t// When we loop over a graph, the default behavior is to loop over the edges.\n\t// But we can also want to loop over the nodes.\n\taction loop_graph {\n\t\twrite \"=======================\";\n\t\twrite \"= Loop over graphs    =\";\n\t\twrite \"=======================\";\n\t\t\t\t\n\t\t// The field edges of graph is the list of all the edges of the graph. \n\t\t// The loop over the edges of the graph is thus equivalent to the loop over the graph itself.\n\t\tloop edge over: graph_of_points.edges {\n\t\t\twrite sample(edge);\n\t\t\t// Given the key, we can also access to the associated value\n\t\t\twrite \"  \" + sample(graph_of_points source_of(edge));\n\t\t\twrite \"  \" + sample(graph_of_points target_of(edge));\t\t\t\n\t\t}\n\t\t\n\t\t// The field vertices of graph is the list of all the nodes of the graph.\n\t\tloop node over: graph_of_points.vertices {\t\n\t\t\twrite sample(node);\n\t\t\t// Given the node, we can access to some other information as its neighbors, degree ...\n\t\t\twrite(\"Degree of the node: \" + graph_of_points degree_of(node));\n\t\t\twrite(\"Successors of the node: \" + graph_of_points successors_of(node));\t\t\t\n\t\t}\t\n\t}\n}\n\n\nspecies dummy_species {}\n\nexperiment exp type: gui {}"}
{"prompt": "Illustrate the difference between using 'ask' and 'loop' statements to iterate over a population of agents in NetLogo, including examples of using 'self' and 'myself' meta-variables.", "gaml_code": "/***\n* Name: Ask (as a loop over a population) and self and myself\n* Author: Benoit Gaudou\n* Description: This model illustrates the use of the ask statement to iterate over a population of agents.\n* It compares it with the loop statement and introduces self and myself meta-variables.\n* Tags: ask, loop, self, myself\n***/\n\nmodel Asktoloopoveragents\n\nglobal {\n\tinit {\n\t\tcreate dummy_species number: 5;\n\t\t\n\t\t// We want that each created agent to introduce itself.\n\t\t// We can thus loop over the population of agents using the loop statement.\n\t\t// We are in the  context of the world agent, and thus need to access attribute of each agent using: agt.name and int(agt) \n\t\twrite \"Introduction in a loop statement.\";\n\t\tloop agt over: dummy_species {\n\t\t\t// we are in the context of the world agent, we CANNOT use dummy_species actions directly.\t\t\t\n\t\t\twrite \"This is \" + agt.name + \" and its number is \" + int(agt);\t\t\t\n\t\t}\n\t\t\n\t\t// Ask statement allows to iterate over a population of agents, and to execute a set of statements in the contexte OF EACH AGENT.\n\t\twrite \"Introduction in an ask statement.\";\n\t\task dummy_species {\n\t\t\t// we are in the context of a dummy_species agent, we can thus use its actions.\n\t\t\tdo introduce_myself;\n\t\t} \n\t\t\n\t\t// Ask can be used with the whole species, but also a list of agents (or even a single agent).\n\t\t// For example, 2 among the dummy_species agents will kill another dummy_species agent.\n\t\t// Before dying the agent says the name of its killer.\n\t\task 2 among dummy_species {\n\t\t\task one_of(dummy_species - self) {\n\t\t\t\t// To display the name of the agent that kills it, the current agent (self) should use myself to refer to its killer.\n\t\t\t\twrite \"I, \" + self.name + \", have been killed by \" + myself.name ;\n\t\t\t\tdo die;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies dummy_species {\n\taction introduce_myself {\n\t\twrite \"Hello! I am \" + name + \" and my number is \" + int(self);\n\t}\n}\n\nexperiment name type: gui {}"}
{"prompt": "Create a GAML model that demonstrates the use of break and continue statements within various loops and other GAML statements.", "gaml_code": "/**\n* Name: break_and_continue\n* This model shows how (and where) to use break and continue inside loops and other GAML statements. \n* Author: A. Drogoul\n* Tags: loop, break, continue, ask\n*/\n\n\nmodel break_and_continue\n\n\nglobal {\n\tinit {\n\t \tdo continue_in_loop_demo();\n\t \tdo break_in_loop_demo();\n\t \tdo break_in_infinite_loop_demo();\n\t \tdo break_in_switch_demo();\n\t \tdo break_in_create_demo(); \n\t \tdo break_in_ask_demo();\n\t} \n\t\n\t\n\taction continue_in_loop_demo {\n\t\twrite \"Use continue to write every odd number from 1 to 100\"; \n\t\tloop i from: 1 to: 100 {\n\t\t\tif (even(i)){ continue;}\n\t\t\twrite \"This number \" + i + \" is odd\";\n\t\t}\n\t}\n\t\n\taction break_in_infinite_loop_demo {\n\t\tloop while: true {\n\t\t\twrite \"Infinite loop\";\n\t\t\tif (flip(0.01)) {break;}\n\t\t}\n\t}\n\t\n\taction break_in_loop_demo {\n\t\tlist<int> numbers <- list_with(20, rnd(100));\n\t\twrite \"Use break to write every number until one is even in \" + numbers;\n\n\t\tloop i over: numbers {\n\t\t\tif (even(i)) {break;}\n\t\t\twrite \"Odd number \" + i;\n\t\t}\n\t} \n\t\n\taction break_in_switch_demo {\n\t\twrite \"Break can be used in switch (but not continue) to stop the match making\";\n\t\tint i <- 100;\n\t\tswitch i { \n\t\t\tmatch 100 {\n\t\t\t\twrite \"match 100: equal to 100. Let's continue\";\n\t\t\t}\n\t\t\tmatch_one [0,10,100] {\n\t\t\t\twrite \"match_one [0,10,100] : This one is ok too, but the last one will be skipped because we break the switch just after\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatch_between [0,1000] {\n\t\t\t\twrite \"match_between [0,1000] : This one is ok too, but never displayed\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction break_in_create_demo {\n\t\twrite \"Break can be used in create (and also release, capture, generate) to stop initializing agents. \n\t\t\t\tWarning: it does not stop CREATING them, but stops INITIALIZING them after the first break\";\n\t\tint j <- 0;\n\t\tcreate dummy number: 200 {\n\t\t\twrite \"initializing agent \" + j;\n\t\t\tj <- j + 1;\n\t\t\tif (j > 10) {break;}\n\t\t\tinitialized <- true;\n\t\t}\n\t\twrite \"Number of agents created \" + length(dummy) + \" and initialized \" + length(dummy where each.initialized);\n\t}\n\t\n\taction break_in_ask_demo {\n\t\twrite \"Break can be used in ask statements, but it only works (obviously) if no parallel execution is involved\";\n\t\tint j <- 0;\n\t\task shuffle(dummy) {\n\t\t\twrite \"No parallelism: Ask #\" + j + \" to dummy #\" + int(self);\n\t\t\tj <- j + 1;\n\t\t\tif (j >= 5) {break;}\n\t\t}\n\t\tj <- 0;\n\t\task shuffle(dummy) parallel: true{\n\t\t\twrite \"Parallelism: Ask #\" + j + \" to dummy #\" + int(self);\n\t\t\tj <- j + 1;\n\t\t\t// In that case break is not taken into account\n\t\t\tif (j >= 5) {break;}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tspecies dummy {\n\t\tbool initialized <- false;\n\t}\n\t\n}\n\nexperiment \"Run me\";"}
{"prompt": "Compare and demonstrate the use of iterators versus loops for common computations in GAML, specifically focusing on finding maximum values, agents with maximum values, and filtering by value.", "gaml_code": "/***\n* Name: Iterators\n* Author: Benoit Gaudou\n* Description: The iterators are a way to make a computation by iterating over a container.\n* This model compare the use of iterators with the loop.\n* Tags: loop, iterator, max_of, where, with_max_of\n***/\n\nmodel Iterators\n\nglobal {\t\n\tinit {\n\t\t// Given a set of 10 dummy_species agents with an integer attribute.\t\n\t\tcreate dummy_species number: 10{\n\t\t\tval <- rnd(10);\n\t\t}\n\t\t\n\t\t// Given this population, we can need to:\n\t\t// 1. Get the maximum value of the attribute val,\t\t\n\t\t// 2. Get the agent with the maximum value of the attribute val,\n\t\t// 3. Filter only the agents with a val value greater than 5.\n\t\t// .... \n\t\n\t\t// All these computations requier to iterate over all the population.\n\t\t// This can be done using a loop.\n\t\t// But GAML also provides many iterators allowing to compute these values very easily.\n\t\t\n\t\t// 1. Get the biggest value of the attribute val\n\t\t// Using a loop\n\t\tint val_max <- int(#min_int);\n\t\t\n\t\tloop agt over: dummy_species {\n\t\t\tif(agt.val > val_max) {\n\t\t\t\tval_max <- agt.val;\n\t\t\t}\n\t\t}\n\t\twrite \"[Using loop] The maximum value of val is: \" + val_max;\n\t\t\n\t\t// Using an iterator\n\t\tint val_max_ite <- dummy_species max_of(each.val);\n\t\twrite \"[Using iterator]  The maximum value of val is: \" + val_max_ite; \n\t\t\n\t\t\n\t\t// 2. Get the agent with the maximum value of the attribute val\n\t\t// Using a loop\n\t\tdummy_species agt_with_max_val <- first(dummy_species);\n\t\tloop agt over: dummy_species {\n\t\t\tif(agt.val > agt_with_max_val.val) {\n\t\t\t\tagt_with_max_val <- agt;\n\t\t\t}\t\t\t\n\t\t}\n\t\twrite \"[Using loop]  The agent with the maximum value of val is: \" + agt_with_max_val; \n\t\t\n\t\t// Using an iterator\n\t\tdummy_species agt_with_max_val_ite <- dummy_species with_max_of(each.val);\n\t\twrite \"[Using iterator]  The agent with the maximum value of val is: \" + agt_with_max_val_ite; \n\t\t\n\t\t// 3. Filter only the ones with a val value greater than 5\n\t\t// Using a loop\n\t\tlist<dummy_species> list_agt_filtered <- [];\n\t\tloop agt over: dummy_species {\n\t\t\tif(agt.val > 5) {\n\t\t\t\tadd agt to: list_agt_filtered;\n\t\t\t}\t\t\t\n\t\t}\n\t\twrite \"[Using loop]  The agents with a value of val greater than 5: \" + list_agt_filtered; \n\t\t\n\t\t// Using an iterator\n\t\tlist<dummy_species> list_agt_filtered_ite <- dummy_species where(each.val > 5);\n\t\twrite \"[Using iterator]  The agents with a value of val greater than 5: \" + list_agt_filtered_ite; \n\t\t\n\t}\n\t\n\t// Here are some other operators which can be useful to manipulate lists:\n\t// sort, sort_by, shuffle, reverse, collect, accumulate, among. \n\t// Please read the GAML Reference if you want to know more about those operators.\n\t\t\n}\n\nspecies dummy_species {\n\tint val;\n}\n\nexperiment exp type: gui {}"}
{"prompt": "Get system properties and display them using GAML.", "gaml_code": "/**\n* Name: System\n* Author: A. Drogoul\n* Description: Describes the syntax used to get different system properties. These can be used to ensure, for instance, that a minimum memory is available, or that a minimum version of GAMA is used to run a model\n* Tags: system, platform\n*/\nmodel System\n\n\nglobal\n{\n\tinit\n\t{\n\t\t// The version of the current GAMA installation\n\t\twrite sample(gama.version);\n\t\t// The list of plugins loaded in the current GAMA installation\n\t\twrite gama.plugins;\n\t\t// The current time since epoch day (i.e. UNIX time)\n\t\twrite sample(gama.machine_time) + \" milliseconds since epoch day\";\n\t\t// The current path to the workspace\n\t\twrite gama.workspace_path;\n\t\t// The memory still available to be allocated to GAMA\n\t\twrite sample(gama.free_memory) + \" bytes\" ;\n\t\t// The maximum amount of memory GAMA can be allocated\n\t\twrite sample(gama.max_memory) + \" bytes\";\n\t\t// gama.info could be used to get a summary of the current computer configuration (hardware and software)\n\t\twrite gama.info;\n\t\t// gama.platform could be used to get the platform on which GAMA is currently running\n\t\twrite gama.platform;\n\t}\n\n}\n\nexperiment Run;"}
{"prompt": "Demonstrate GAML's error handling and warning mechanisms by creating a model that showcases various scenarios of throwing and catching errors.", "gaml_code": "/**\n* Name: Errors\n* Author: Alexis Drogoul\n* Description: A model that demonstrates basic features of error throwing / error handling in GAML\n* Tags: gaml, syntax, error\n*/\nmodel Errors\n\n/**\n * In this experiment, a warning is raised by the model itself and should not interrupt the flow of execution\n */\nexperiment \"Raise a normal warning\"\n{\n\tinit\n\t{\n\t\t// To be sure, the global preference to consider warnings as errors is set to false\n\t\tgama.pref_errors_warnings_errors <- false;\n\t\twarn \"This warning is reported but does not interrupt the execution\";\n\t\twrite \"so this message should be visible in console\";\n\t}\n\n}\n\nexperiment \"Raise a warning (turned to an error)\"\n{\n\tinit\n\t{\n\t\t// If the global preference is set to consider warnings as errors, this will stop execution\n\t\tgama.pref_errors_warnings_errors <- true;\n\t\twarn \"This warning is now considered as an error\";\n\t\twrite \"This should not be written\";\n\t}\n\n}\n\n\n/**\n * In this experiment, an error is raised by the model itself and should interrupt the flow of execution\n */\nexperiment \"Raise an error\"\n{\n\tinit\n\t{\n\t\terror \"This error is generated by the model itself\";\n\t\twrite \"If gama.pref_errors_stop is set to true, this will not be written\";\t\n\t}\n\n}\n/**\n * In this experiment, an error is raised by the model itself but it is caught and displayed in the console without being reported and stopping the execution. #current_error is a constant representing the text of the latest error thrown\n */\nexperiment \"Raise and catch an error\"\n{\n\tinit\n\t{\n\t\ttry {\n\t\t\terror \"This error is generated by the model itself\";\n\t\t} catch {\n\t\t\twrite #current_error + \" but is not reported\";\n\t\t}\n\n\t}\n \n}\n\n\n/**\n* In this experiment, an error is provoked by making a division by zero but it is caught and displayed in the console without being reported and stopping the execution\n */\nexperiment \"Provoke and catch an error\"\n{\n\tinit\n\t{\n\t\ttry {\n\t\t\tfloat error <- 1 / 0;\n\t\t} catch {\n\t\t\twrite \"A \" + #current_error + \" is caught\";\n\t\t}\n\n\t}\n\n}\n\n/**\n* In this experiment, an error is provoked by making a division by zero but the use of 'try' makes it silent (i.e. no 'catch' block) \n */\nexperiment \"Provoke a silent error\"\n{\n\tinit\n\t{\n\t\ttry {\n\t\t\tfloat error <- 1 / 0;\n\t\t} \n\t}\n}"}
{"prompt": "Compare the performance of buffered and non-buffered writing strategies for a large number of writes to a file.", "gaml_code": "/**\n* Name: Buffering\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n\n// This model presents the difference in terms of performance between writing many times directly in a file \n// or using a buffering strategy to have all the writing requests grouped into one big at the end of the cycle\n// this benchmarking is not using the \"benchmark\" statement as we also want to include the time it takes for the \n// engine to actually write the files at the end of the cycle.\nmodel BufferingPerformances\n\n\nglobal{\n\t\n\tint state <- 0;\n\tint nb_rep <- 10000;\n\tfloat start_time;\n\t\n\treflex write_duration_buffered when:state=3{\n\t\twrite \"Duration for buffered writing: \" + (gama.machine_time - start_time) + \"ms\";\n\t\tdo pause;\n\t}\n\n\treflex write_buffered when:state = 2 {\n\t\tstart_time <- gama.machine_time;\n\t\tloop times:nb_rep{\n\t\t\tsave \"some text\\n\" to:\"someotherfile.txt\" rewrite:false buffering:\"per_cycle\" format:\"txt\";\n\t\t}\n\t\tstate <- 3;\n\t}\n\t\n\treflex write_duration_direct when:state = 1 {\n\t\twrite \"Duration for direct writing: \" + (gama.machine_time - start_time) + \"ms\";\n\t\tstate <- 2;\n\t}\n\t\n\t\n\treflex write_directly when:state=0{\n\t\tstart_time <- gama.machine_time;\n\t\tloop times:nb_rep{\n\t\t\tsave \"some text\\n\" to:\"somefile.txt\" rewrite:false buffering:\"no_buffering\" format:\"txt\";\n\t\t}\n\t\tstate <- 1;\n\t}\n\t\t\n}\n\nexperiment compare;"}
{"prompt": "**Set default preferences for GAMA.**", "gaml_code": "// GAMA 0.0.0-SNAPSHOT Preferences saved on 2025-05-04T22:52:53.671264\nmodel preferences\n\nexperiment 'Display Preferences' type: gui {\n\n\tinit {\n\t//Append the name of simulations to their outputs\n\t\twrite sample(gama.pref_append_simulation_name);\n\n\t\t//Graphical resolution of the charts (from 0, small and fast, to 1, best but consuming lots of resources)\n\t\twrite sample(gama.pref_chart_quality);\n\n\t\t//Max. number of characters to keep when paused (-1 = unlimited)\n\t\twrite sample(gama.pref_console_buffer);\n\n\t\t//Max. number of characters to display (-1 = unlimited)\n\t\twrite sample(gama.pref_console_size);\n\n\t\t//Wrap long lines (can slow down output)\n\t\twrite sample(gama.pref_console_wrap);\n\n\t\t//Default separator for fields\n\t\twrite sample(gama.pref_csv_separator);\n\n\t\t//Default separator for strings\n\t\twrite sample(gama.pref_csv_string_qualifier);\n\n\t\t//Custom date pattern (https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns)\n\t\twrite sample(gama.pref_date_custom_formatter);\n\n\t\t//Default date pattern for writing dates (i.e. string(date1))\n\t\twrite sample(gama.pref_date_default_formatter);\n\n\t\t//Default starting date of models\n\t\twrite sample(gama.pref_date_starting_date);\n\n\t\t//Default time step of models\n\t\twrite sample(gama.pref_date_time_step);\n\n\t\t//Apply antialiasing\n\t\twrite sample(gama.pref_display_antialias);\n\n\t\t//Default background color ('background' facet of 'display')\n\t\twrite sample(gama.pref_display_background_color);\n\n\t\t//Default camera to use when none is specified\n\t\twrite sample(gama.pref_display_camera);\n\n\t\t//Limit the number of frames per second if you experience stuttering in the rendering\n\t\twrite sample(gama.pref_display_cap_fps);\n\n\t\t//Continue to draw displays when in Modeling perspective\n\t\twrite sample(gama.pref_display_continue_drawing);\n\n\t\t//Default rendering method\n\t\twrite sample(gama.pref_display_default2);\n\n\t\t//Default color of agents\n\t\twrite sample(gama.pref_display_default_color);\n\n\t\t//Default font to use in 'draw'\n\t\twrite sample(gama.pref_display_default_font);\n\n\t\t//Defaut shape of agents\n\t\twrite sample(gama.pref_display_default_shape);\n\n\t\t//Default size of agents\n\t\twrite sample(gama.pref_display_default_size);\n\n\t\t//Enable fast snapshots (uncomplete when the display is obscured by others but much faster)\n\t\twrite sample(gama.pref_display_fast_snapshot);\n\n\t\t//Default highlight color\n\t\twrite sample(gama.pref_display_highlight_color);\n\n\t\t//Set the sensitivity of the keyboard movements  (0 for slow, 1 for fast)\n\t\twrite sample(gama.pref_display_keyboard_factor);\n\n\t\t//Set the default intensity of the lights (from 0, dark, to 255, light)\n\t\twrite sample(gama.pref_display_light_intensity);\n\n\t\t//Default line width (facet 'width' of 'draw'). Note that this attribute is not supported by all OpenGL implementations\n\t\twrite sample(gama.pref_display_line_width);\n\n\t\t//Max. number of frames per second\n\t\twrite sample(gama.pref_display_max_fps);\n\n\t\t//Keep chart values in memory (to save them as CSV) or not (to lower memory usage)\n\t\twrite sample(gama.pref_display_memorize_charts);\n\n\t\t//Set the sensitivity of the mouse/trackpad movements  (0 for slow, 1 fast)\n\t\twrite sample(gama.pref_display_mouse_factor);\n\n\t\t//Disable acceleration for Java2D (necessary on some configurations)\n\t\twrite sample(gama.pref_display_no_java2d_acceleration);\n\n\t\t//Use Numeric Keypad (2,4,6,8) for camera interaction\n\t\twrite sample(gama.pref_display_numkeyscam);\n\n\t\t//Show errors thrown in displays and outputs\n\t\twrite sample(gama.pref_display_show_errors);\n\n\t\t//Number of slices of circular geometries in OpenGL (the higher the more resources consuming)\n\t\twrite sample(gama.pref_display_slice_number);\n\n\t\t//Synchronize outputs with the simulation\n\t\twrite sample(gama.pref_display_synchronized);\n\n\t\t//Use GAMA image cache when building textures in OpenGL (potentially faster when running several simulations, but uses more memory)\n\t\twrite sample(gama.pref_display_use_cache);\n\n\t\t//Default layout of display views\n\t\twrite sample(gama.pref_display_view_layout);\n\n\t\t//Only display visible agents in OpenGL (faster, may create visual oddities)\n\t\twrite sample(gama.pref_display_visible_agents);\n\n\t\t//Draw only the 'external' faces of objects in OpenGL\n\t\twrite sample(gama.pref_display_visible_faces);\n\n\t\t//Set the zoom factor (0 for slow, 1 fast)\n\t\twrite sample(gama.pref_display_zoom_factor);\n\n\t\t//Enable GAMA Server mode\n\t\twrite sample(gama.pref_enable_server);\n\n\t\t//Show execution errors\n\t\twrite sample(gama.pref_errors_display);\n\n\t\t//Show errors in editors\n\t\twrite sample(gama.pref_errors_in_editor);\n\n\t\t//Number of errors to display\n\t\twrite sample(gama.pref_errors_number);\n\n\t\t//Stop simulation at first error\n\t\twrite sample(gama.pref_errors_stop);\n\n\t\t//Treat warnings as errors\n\t\twrite sample(gama.pref_errors_warnings_errors);\n\n\t\t//Ask to close the previous experiment when launching a new one\n\t\twrite sample(gama.pref_experiment_ask_closing);\n\n\t\t//Auto-run experiments when they are launched\n\t\twrite sample(gama.pref_experiment_auto_run);\n\n\t\t//Automatically expand the parameters categories\n\t\twrite sample(gama.pref_experiment_expand_params);\n\n\t\t//Incrementation of the step duration slider\n\t\twrite sample(gama.pref_experiment_type_slider);\n\n\t\t//Only display failed and aborted tests\n\t\twrite sample(gama.pref_failed_tests);\n\n\t\t//Let GAMA find which CRS to use to project GIS data\n\t\twrite sample(gama.pref_gis_auto_crs);\n\n\t\t//...or use the following EPSG code (the one that will also be used if no projection information is found)\n\t\twrite sample(gama.pref_gis_default_crs);\n\n\t\t//...or use the following CRS (EPSG code)\n\t\twrite sample(gama.pref_gis_initial_crs);\n\n\t\t//... or use this following CRS (EPSG code)\n\t\twrite sample(gama.pref_gis_output_crs);\n\n\t\t//When no .prj file or CRS is supplied, consider GIS data to be already projected in this CRS\n\t\twrite sample(gama.pref_gis_same_crs);\n\n\t\t//When no CRS is provided, save the GIS data with the current CRS\n\t\twrite sample(gama.pref_gis_save_crs);\n\n\t\t//Connection timeout (in ms)\n\t\twrite sample(gama.pref_http_connect_timeout);\n\n\t\t//Empty the local cache of files downloaded from the web\n\t\twrite sample(gama.pref_http_empty_cache);\n\n\t\t//Read timeout (in ms)\n\t\twrite sample(gama.pref_http_read_timeout);\n\n\t\t//Number of times to retry if connection cannot be established\n\t\twrite sample(gama.pref_http_retry_number);\n\n\t\t//When running out of memory in an experiment, GAMA should\n\t\twrite sample(gama.pref_memory_action);\n\n\t\t//Interval (in seconds) at which memory should be monitored\n\t\twrite sample(gama.pref_memory_frequency);\n\n\t\t//Emit a warning when the percentage of available memory is under\n\t\twrite sample(gama.pref_memory_threshold);\n\n\t\t//Display monitors in the parameters view\n\t\twrite sample(gama.pref_monitors_in_parameters);\n\n\t\t//Increment factor (from 0, none, to 1, max)\n\t\twrite sample(gama.pref_opengl_z_factor);\n\n\t\t//In OpenGL, add a small increment to the z ordinate of objects and layers to fight visual artefacts\n\t\twrite sample(gama.pref_opengl_z_fighting);\n\n\t\t//Optimize the 'at_distance' operator\n\t\twrite sample(gama.pref_optimize_at_distance);\n\n\t\t//Optimize the path computation operators and goto action (but with possible 'jump' issues)\n\t\twrite sample(gama.pref_optimize_path_computation);\n\n\t\t//Optimize spatial queries: add agents only when necessary in the quadtree (still experimental)\n\t\twrite sample(gama.pref_optimize_quadtree);\n\n\t\t//Allow grids to schedule their agents in parallel (prevents the reproducibility of simulations)\n\t\twrite sample(gama.pref_parallel_grids);\n\n\t\t//Allow experiments to run simulations in parallel\n\t\twrite sample(gama.pref_parallel_simulations);\n\n\t\t//In batch, allow to run simulations with all available processors[WARNING: disables reflexes and permanent displays of batch experiments]\n\t\twrite sample(gama.pref_parallel_simulations_all);\n\n\t\t//Make species schedule their agents in parallel (prevents the reproducibility of simulations)\n\t\twrite sample(gama.pref_parallel_species);\n\n\t\t//Max. number of threads to use (available processors: 16)\n\t\twrite sample(gama.pref_parallel_threads);\n\n\t\t//Size under which populations are executed sequentially\n\t\twrite sample(gama.pref_parallel_threshold);\n\n\t\t//Tolerance for the comparison of points\n\t\twrite sample(gama.pref_point_tolerance);\n\n\t\t//Default seed value (0 is undefined)\n\t\twrite sample(gama.pref_rng_default_seed);\n\n\t\t//Define a default seed\n\t\twrite sample(gama.pref_rng_define_seed);\n\n\t\t//Include random number generation parameters in the parameters view\n\t\twrite sample(gama.pref_rng_in_parameters);\n\n\t\t//Default random number generator\n\t\twrite sample(gama.pref_rng_name);\n\n\t\t//Default buffering strategy for the save statement\n\t\twrite sample(gama.pref_save_buffering_strategy);\n\n\t\t//Send console outputs to clients\n\t\twrite sample(gama.pref_server_console);\n\n\t\t//Interval between two pings (-1 to disable)\n\t\twrite sample(gama.pref_server_ping);\n\n\t\t//Port to which GAMA Server is listening\n\t\twrite sample(gama.pref_server_port);\n\n\t\t//Mapping and caching of shapefiles in memory (optimises access to shapefile data in exchange for increased memory usage). Disable this property if you are dealing with shapefiles that change frequently\n\t\twrite sample(gama.pref_shapefiles_in_memory);\n\n\t\t//Pivot color of simulations\n\t\twrite sample(gama.pref_simulation_color);\n\n\t\t//Default color scheme for simulations in UI\n\t\twrite sample(gama.pref_simulation_colors);\n\n\t\t//Forces the spatial index to synchronize its operations. Useful for interactive models where the users interfere or parallel models with concurrency errors. Note that it may slow down simulations with a lot of mobile agents\n\t\twrite sample(gama.pref_synchronize_quadtree);\n\n\t\t//In OpenGL, orient the textures according to the geometry on which they are displayed (may create visual oddities)\n\t\twrite sample(gama.pref_texture_orientation);\n\n\t\t//Default buffering strategy for the write statement\n\t\twrite sample(gama.pref_write_buffering_strategy);\n\t}\n\n}\n\nexperiment 'Set Preferences' type: gui {\n\n\tinit {\n\t//Append the name of simulations to their outputs\n\t\tgama.pref_append_simulation_name <- false;\n\n\t\t//Graphical resolution of the charts (from 0, small and fast, to 1, best but consuming lots of resources)\n\t\tgama.pref_chart_quality <- 0.8;\n\n\t\t//Max. number of characters to keep when paused (-1 = unlimited)\n\t\tgama.pref_console_buffer <- 20000;\n\n\t\t//Max. number of characters to display (-1 = unlimited)\n\t\tgama.pref_console_size <- 20000;\n\n\t\t//Wrap long lines (can slow down output)\n\t\tgama.pref_console_wrap <- false;\n\n\t\t//Default separator for fields\n\t\tgama.pref_csv_separator <- ';';\n\n\t\t//Default separator for strings\n\t\tgama.pref_csv_string_qualifier <- '\"';\n\n\t\t//Custom date pattern (https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns)\n\t\tgama.pref_date_custom_formatter <- 'yyyy-MM-dd HH:mm:ss';\n\n\t\t//Default date pattern for writing dates (i.e. string(date1))\n\t\tgama.pref_date_default_formatter <- 'CUSTOM';\n\n\t\t//Default starting date of models\n\t\tgama.pref_date_starting_date <- date('1970-01-01 07:00:00');\n\n\t\t//Default time step of models\n\t\tgama.pref_date_time_step <- 1.0;\n\n\t\t//Apply antialiasing\n\t\tgama.pref_display_antialias <- false;\n\n\t\t//Default background color ('background' facet of 'display')\n\t\tgama.pref_display_background_color <- #white;\n\n\t\t//Default camera to use when none is specified\n\t\tgama.pref_display_camera <- 'From above';\n\n\t\t//Limit the number of frames per second if you experience stuttering in the rendering\n\t\tgama.pref_display_cap_fps <- false;\n\n\t\t//Continue to draw displays when in Modeling perspective\n\t\tgama.pref_display_continue_drawing <- false;\n\n\t\t//Default rendering method\n\t\tgama.pref_display_default2 <- true;\n\n\t\t//Default color of agents\n\t\tgama.pref_display_default_color <- #yellow;\n\n\t\t//Default font to use in 'draw'\n\t\tgama.pref_display_default_font <- font('Helvetica', 12, #plain);\n\n\t\t//Defaut shape of agents\n\t\tgama.pref_display_default_shape <- 'shape';\n\n\t\t//Default size of agents\n\t\tgama.pref_display_default_size <- 1.0;\n\n\t\t//Enable fast snapshots (uncomplete when the display is obscured by others but much faster)\n\t\tgama.pref_display_fast_snapshot <- false;\n\n\t\t//Default highlight color\n\t\tgama.pref_display_highlight_color <- rgb(0, 200, 200, 255);\n\n\t\t//Set the sensitivity of the keyboard movements  (0 for slow, 1 for fast)\n\t\tgama.pref_display_keyboard_factor <- 0.5;\n\n\t\t//Set the default intensity of the lights (from 0, dark, to 255, light)\n\t\tgama.pref_display_light_intensity <- 160;\n\n\t\t//Default line width (facet 'width' of 'draw'). Note that this attribute is not supported by all OpenGL implementations\n\t\tgama.pref_display_line_width <- 1.0;\n\n\t\t//Max. number of frames per second\n\t\tgama.pref_display_max_fps <- 60;\n\n\t\t//Keep chart values in memory (to save them as CSV) or not (to lower memory usage)\n\t\tgama.pref_display_memorize_charts <- true;\n\n\t\t//Set the sensitivity of the mouse/trackpad movements  (0 for slow, 1 fast)\n\t\tgama.pref_display_mouse_factor <- 0.5;\n\n\t\t//Disable acceleration for Java2D (necessary on some configurations)\n\t\tgama.pref_display_no_java2d_acceleration <- false;\n\n\t\t//Use Numeric Keypad (2,4,6,8) for camera interaction\n\t\tgama.pref_display_numkeyscam <- true;\n\n\t\t//Show errors thrown in displays and outputs\n\t\tgama.pref_display_show_errors <- false;\n\n\t\t//Number of slices of circular geometries in OpenGL (the higher the more resources consuming)\n\t\tgama.pref_display_slice_number <- 16;\n\n\t\t//Synchronize outputs with the simulation\n\t\tgama.pref_display_synchronized <- false;\n\n\t\t//Use GAMA image cache when building textures in OpenGL (potentially faster when running several simulations, but uses more memory)\n\t\tgama.pref_display_use_cache <- true;\n\n\t\t//Default layout of display views\n\t\tgama.pref_display_view_layout <- 'Split';\n\n\t\t//Only display visible agents in OpenGL (faster, may create visual oddities)\n\t\tgama.pref_display_visible_agents <- false;\n\n\t\t//Draw only the 'external' faces of objects in OpenGL\n\t\tgama.pref_display_visible_faces <- false;\n\n\t\t//Set the zoom factor (0 for slow, 1 fast)\n\t\tgama.pref_display_zoom_factor <- 0.5;\n\n\t\t//Enable GAMA Server mode\n\t\tgama.pref_enable_server <- true;\n\n\t\t//Show execution errors\n\t\tgama.pref_errors_display <- true;\n\n\t\t//Show errors in editors\n\t\tgama.pref_errors_in_editor <- true;\n\n\t\t//Number of errors to display\n\t\tgama.pref_errors_number <- 10;\n\n\t\t//Stop simulation at first error\n\t\tgama.pref_errors_stop <- true;\n\n\t\t//Treat warnings as errors\n\t\tgama.pref_errors_warnings_errors <- false;\n\n\t\t//Ask to close the previous experiment when launching a new one\n\t\tgama.pref_experiment_ask_closing <- true;\n\n\t\t//Auto-run experiments when they are launched\n\t\tgama.pref_experiment_auto_run <- false;\n\n\t\t//Automatically expand the parameters categories\n\t\tgama.pref_experiment_expand_params <- true;\n\n\t\t//Incrementation of the step duration slider\n\t\tgama.pref_experiment_type_slider <- true;\n\n\t\t//Only display failed and aborted tests\n\t\tgama.pref_failed_tests <- false;\n\n\t\t//Let GAMA find which CRS to use to project GIS data\n\t\tgama.pref_gis_auto_crs <- true;\n\n\t\t//...or use the following EPSG code (the one that will also be used if no projection information is found)\n\t\tgama.pref_gis_default_crs <- 32648;\n\n\t\t//...or use the following CRS (EPSG code)\n\t\tgama.pref_gis_initial_crs <- 4326;\n\n\t\t//... or use this following CRS (EPSG code)\n\t\tgama.pref_gis_output_crs <- 4326;\n\n\t\t//When no .prj file or CRS is supplied, consider GIS data to be already projected in this CRS\n\t\tgama.pref_gis_same_crs <- true;\n\n\t\t//When no CRS is provided, save the GIS data with the current CRS\n\t\tgama.pref_gis_save_crs <- true;\n\n\t\t//Connection timeout (in ms)\n\t\tgama.pref_http_connect_timeout <- 20000;\n\n\t\t//Empty the local cache of files downloaded from the web\n\t\tgama.pref_http_empty_cache <- true;\n\n\t\t//Read timeout (in ms)\n\t\tgama.pref_http_read_timeout <- 20000;\n\n\t\t//Number of times to retry if connection cannot be established\n\t\tgama.pref_http_retry_number <- 3;\n\n\t\t//When running out of memory in an experiment, GAMA should\n\t\tgama.pref_memory_action <- true;\n\n\t\t//Interval (in seconds) at which memory should be monitored\n\t\tgama.pref_memory_frequency <- 2;\n\n\t\t//Emit a warning when the percentage of available memory is under\n\t\tgama.pref_memory_threshold <- 20;\n\n\t\t//Display monitors in the parameters view\n\t\tgama.pref_monitors_in_parameters <- true;\n\n\t\t//Increment factor (from 0, none, to 1, max)\n\t\tgama.pref_opengl_z_factor <- 0.05;\n\n\t\t//In OpenGL, add a small increment to the z ordinate of objects and layers to fight visual artefacts\n\t\tgama.pref_opengl_z_fighting <- true;\n\n\t\t//Optimize the 'at_distance' operator\n\t\tgama.pref_optimize_at_distance <- true;\n\n\t\t//Optimize the path computation operators and goto action (but with possible 'jump' issues)\n\t\tgama.pref_optimize_path_computation <- false;\n\n\t\t//Optimize spatial queries: add agents only when necessary in the quadtree (still experimental)\n\t\tgama.pref_optimize_quadtree <- false;\n\n\t\t//Allow grids to schedule their agents in parallel (prevents the reproducibility of simulations)\n\t\tgama.pref_parallel_grids <- false;\n\n\t\t//Allow experiments to run simulations in parallel\n\t\tgama.pref_parallel_simulations <- true;\n\n\t\t//In batch, allow to run simulations with all available processors[WARNING: disables reflexes and permanent displays of batch experiments]\n\t\tgama.pref_parallel_simulations_all <- true;\n\n\t\t//Make species schedule their agents in parallel (prevents the reproducibility of simulations)\n\t\tgama.pref_parallel_species <- false;\n\n\t\t//Max. number of threads to use (available processors: 16)\n\t\tgama.pref_parallel_threads <- 4;\n\n\t\t//Size under which populations are executed sequentially\n\t\tgama.pref_parallel_threshold <- 20;\n\n\t\t//Tolerance for the comparison of points\n\t\tgama.pref_point_tolerance <- 0.0;\n\n\t\t//Default seed value (0 is undefined)\n\t\tgama.pref_rng_default_seed <- 1.0;\n\n\t\t//Define a default seed\n\t\tgama.pref_rng_define_seed <- false;\n\n\t\t//Include random number generation parameters in the parameters view\n\t\tgama.pref_rng_in_parameters <- false;\n\n\t\t//Default random number generator\n\t\tgama.pref_rng_name <- 'mersenne';\n\n\t\t//Default buffering strategy for the save statement\n\t\tgama.pref_save_buffering_strategy <- 'no_buffering';\n\n\t\t//Send console outputs to clients\n\t\tgama.pref_server_console <- true;\n\n\t\t//Interval between two pings (-1 to disable)\n\t\tgama.pref_server_ping <- 10000;\n\n\t\t//Port to which GAMA Server is listening\n\t\tgama.pref_server_port <- 1000;\n\n\t\t//Mapping and caching of shapefiles in memory (optimises access to shapefile data in exchange for increased memory usage). Disable this property if you are dealing with shapefiles that change frequently\n\t\tgama.pref_shapefiles_in_memory <- true;\n\n\t\t//Pivot color of simulations\n\t\tgama.pref_simulation_color <- #darkturquoise;\n\n\t\t//Default color scheme for simulations in UI\n\t\tgama.pref_simulation_colors <- 'Qualitative (9 colors)';\n\n\t\t//Forces the spatial index to synchronize its operations. Useful for interactive models where the users interfere or parallel models with concurrency errors. Note that it may slow down simulations with a lot of mobile agents\n\t\tgama.pref_synchronize_quadtree <- true;\n\n\t\t//In OpenGL, orient the textures according to the geometry on which they are displayed (may create visual oddities)\n\t\tgama.pref_texture_orientation <- true;\n\n\t\t//Default buffering strategy for the write statement\n\t\tgama.pref_write_buffering_strategy <- 'no_buffering';\n\t}\n\n}"}
{"prompt": "Show how to use the clipboard to retrieve and save text or other objects in a simulation model.", "gaml_code": "/**\n* Name: Clipboard\n* Shows how the clipboard can be used to retrieve and save text or other objects \n* Author: A. Drogoul\n* Tags: system, clipboard, casting\n*/\n\n\nmodel Clipboard\n\nglobal {\n\t\n\tinit {\n\t\t// We transform the geometry into a string\n\t\tstring my_shape <- string(shape);\n\t\twrite \"Original shape: \" + my_shape;\n\t\t// We transform it a bit\n\t\tmy_shape <- my_shape replace(\"100\",\"150\");\n\t\t// We copy the string representation of the shape into the clipboard\n\t\tbool copied <- copy_to_clipboard(my_shape);\n\t\t// If it has been correctly copied, we retrieve it as a geometry\n\t\tif (copied) {\n\t\t\tgeometry received <- copy_from_clipboard(geometry);\n\t\t\twrite \"Transformed shape: \" + received;\n\t\t}\n\t}\n\t\n}\n\nexperiment run;"}
{"prompt": "Analyze and demonstrate different buffering strategies in GAML, including per_cycle, per_simulation, and no_buffering, and show how they affect output order and file writing.", "gaml_code": "/**\n* Name: Bufferingexecutionorder\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n\n// This model presents the order of execution of different results you can obtain by using different buffering strategies.\nmodel Bufferingexecutionorder\n\nglobal {\n\t\n\t\n\treflex at_cycle {\n\t\twrite \"at cycle \" + cycle buffering:\"per_cycle\";\n\t\tsave \"at cycle \" + cycle to:\"data.csv\" header:false rewrite:false buffering:\"per_cycle\" format:\"csv\";\n\t}\n\t\n\treflex at_cycle2 {\n\t\twrite \"at cycle2 \" + cycle + \" should appear after 'at cycle \"+ cycle+\"' as it's asked in that order\" buffering:\"per_cycle\";\n\t\tsave \"at cycle2 \" + cycle + \" should appear after 'at cycle \"+ cycle+\"' as it's asked in that order\" to:\"data.csv\" header:false rewrite:false buffering:\"per_cycle\" format:\"csv\";\n\t}\n\t\n\treflex no_buffering {\n\t\twrite \"at cycle \" + cycle + \" too, should appear before all the other, as it's executed right when the code is reached\" buffering:\"no_buffering\";\n\t\tsave \"at cycle \" + cycle + \" too, should appear before all the other, as it's executed right when the code is reached\" rewrite:false to:\"data.csv\" header:false buffering:\"no_buffering\" format:\"csv\";\n\t}\n\t\n\treflex end_of_simulation {\n\t\twrite \"Run at cycle \" + cycle + \" but should only be visible once the simulation is killed.\" buffering:\"per_simulation\";\n\t\tsave \"Run at cycle \" + cycle + \" but should be appended at the end of the file\" to:\"data.csv\" header:false rewrite:false buffering:\"per_simulation\" format:\"csv\";\n\t}\n\t\n\treflex end_sim when:cycle=4{\n\t\tdo die;\n\t}\n\t\n}\n\nexperiment a type:batch until:cycle=10 autorun:true{\n\n}"}
{"prompt": "Design a GAMA model that demonstrates multithreading capabilities, allowing multiple agents to run concurrent threads with adjustable rates and delays.", "gaml_code": "/***\n* Name: RunThread \n* Author: Patrick Taillandier\n* Description: This model illustrates the possibility of GAMA to run a model or any action in a specific thread. \n* A skill called 'thread' allows to run in a thread the built-in 'thread_action' action. If overriden, this 'thread_action' is run in a thread.\n* Two other built-in actions are provided: start_thread that starts the thread, and end_thread, that ends the thread.\n* In this model, the skill is attached to the global species (with a fixed rate) and to a species of agents (with a fixed delay). It can be attached to any species, and multiple agents can run multiple threads.\n* When the agents are killed, their thread is automatically stopped if it is running. \n* Tags: system, thread, skill\n***/\n\n\nmodel testThread \n\nglobal skills: [thread]{\n\tbool create_agents <- false; \n\tinit {\t\t\t\n\t\t//create and start a new thread - the thread_action will be activated continuously with a delay of 2#s between each execution\n\t\t\n\t\tif (create_agents) {\n\t\t\tcreate thread_agent number: 2;\n\t\t}\n\t\tdo run_thread interval: 2#s;\n\t}\n\t  \n  \n\t\n\t//the action run in the thread \n\taction thread_action {\n\t\twrite \"current time: \" + #now;\n\t}\t \n}\n\nspecies thread_agent skills: [thread] {\n\t//create and start a new thread - the thread_action will be activated continuously at a fixed rate every 1#s by the 2 agents\n\t\n\tinit {\n\t\tdo run_thread every: 1#s;\n\t}\n\t\n\t//the action run in the thread\n\taction thread_action {\n\t\twrite \" > \" + self + \"current time: \" + #now;\n\t}\t\n}\n  \nexperiment \"Run global thread\" autorun: true;\n\nexperiment \"Run several threads\" autorun: true {\n\taction _init_ {\n\t\tcreate simulation with: [create_agents:: true];\n\t}\n}"}
{"prompt": "Optimize GAMA model performance by identifying slow code blocks and generating a detailed execution profile for analysis.", "gaml_code": "/***\n* Name: Benchmark \n* Author: Benoit Gaudou\n* Description: This model illustrates the possibility of GAMA in terms of benchmarking and profiling of the code.\n*   In order to optimize a model that begins to become big and slow to run, \n*   it is necessary to identify the pieces of code that are the longest to execute.\n*   This is the purpose of the benchmark statement and facet.\n* \n*   GAML provides 2 ways of doing benchmarking:\n*    - the statement benchmark, that benchmarks a specific block of statements (and shows information in the console)\n*    - the facet benchmark of the statement experiment that benchmark the whole execution of the code (and write results in a csv file)\n* Tags: benchmark, experiment\n***/\n\nmodel Benchmarking\n\n\n\nglobal {\n\tinit {\n\t\tcreate people number: 300;\n\t}\n\t\n\treflex neighboorhood {\n\t\t// benchmark statement will compute the time spent to execute the block of code its embeds.\n\t\t// To get more reliable results, the inner statements can be executed several times (specified by the repeat: facet).\n\t\tbenchmark \"Benchmark of closest_to operator\" repeat: 100 {\n\t\t\task people {\n\t\t\t\tdo get_closest_people;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies people {\n\taction get_closest_people {\n\t\tpeople neigh <- people closest_to self;\n\t} \n}\n\n// When the facet benchmark: is used in an experiment, it will produces step after step a csv file\n// that summarizes the time spent in block and the number of executions of each statement.\nexperiment Benchmarking type: gui benchmark: true { }"}
{"prompt": "Create a GAML model that showcases new features and syntax improvements introduced in GAMA 1.6, including ternary operators, improved attribute and action declarations, enhanced unit usage, and updated aspect definitions.", "gaml_code": "/**\n* Name: Syntax\n* Author: Alexis Drogoul\n* Description: An overview of the new syntactic constructs that have been introduced in GAMA 1.6\n* Tags: attribute, ternary, equation, action, container, list\n*/\n\n@no_warning\nmodel syntax\n\n/**\n * The global section can now sport skills and control, just like other agents. \n * The example below shows a potentially moving world that can be controlled by a finite state machine.\n */\n// TODO ToDo comments can now be added; they appear in the Validation view.\nglobal skills: [moving] control: fsm {\n\n/**\n * EQUATIONS\n */ \n\tfloat x;\n\tfloat y;\n\tfloat t;\n\t\n\tequation eq {\n\t\tdiff(x, t) = x / 2;\n\t\tdiff(y, t) = x + y * 2;\n\t}\n\n\treflex solving {solve eq step_size: 1 method: #rk4;}\n\n\t/** \n * ATTRIBUTES\n */\n\n// Attributes can be declared in different ways, ranging from \"classic\"...\n\tlist a1 of: int const: true init: [1, 2, 3] ;\n\tlist a2 <- [1, 2, 3] of: int;\n\t// ... to \"compact\" Java-like syntax.\n\tlist<int> a3 <- [1, 2, 3];\n\n\t// The declaration of a default size/value in containers is now working correctly\n\tlist<float> f <- list_with(2000,0.0);\n\n\t// Functions can be declared using the regular facet \"->\" / \"function:\" \n\tint b1 ->  100 + length(a1) ;\n\tint b2 -> { 100 + length(a1) };\n\t// ... or using a block (like a statement -- note the absence of semi-column at the end)\n\tint b3 {\n\t\treturn 100 + length(a1);\n\t}\n\tstate first_state initial: true {\n\t//...\n\n\t}\n\tinit {\n\t\tcreate species0 number: 20;\n\t}\n\t\n\n\t/**\n\t * UNITS\n\t */\n// The usage of units is improved and they can be combined\n\tfloat c <- 10 #meter;\n\tfloat speed <- 10 #meter / #sec;\n\n\t// Attributes can (finally!) be named after unit names\n\tfloat meter <- 10.0;\n\n\t// Some mathematical constants have been introduced alongside units\n\tfloat pi_4 <- #pi / 4;\n\tfloat e <- #e;\n\n\t/**\n\t  * ACTIONS\n\t  */\n\t// Actions can also be declared in different ways. Classic:\n\taction dummy1 type: list of: int {\n\t\targ a type: int default: 100;\n\t\targ b type: float;\n\t\treturn [a, int(b)];\n\t}\n\t// Semi-classic (prefixed by the type)\n\tlist dummy2 of: int {\n\t\targ a type: int default: 100;\n\t\targ b type: float;\n\t\treturn [a, int(b)];\n\t}\n\t//Compact\n\tlist<int> dummy1 (int a <- 100, float b) {\n\t\treturn [a, int(b)];\n\t}\n\n\t// An action that returns nothing can still be called \"action\"\n\taction dummy_void {\n\t\twrite \"dummy_void\";\n\t}\n\n\t/**\n\t * DEALING WITH VARIABLES\n\t */\n\treflex variables {\n\n\t// Temporary variables can use the same syntax as attributes. The classic form:\n\t\t//let name: t1 type: int value: length(a1);\n\t\t// is equivalent to the more compact one:\n\t\tint t2 <- length(a1);\n\n\t\t// Assigning a value to variables is also sporting a new syntax \n\t\tset t2 value: 100;\n\t\t// ... can be replaced by \n\t\tset t2 <- 100;\n\t\t// ... or even by\n\t\tt2 <- 100;\n\n\t\t// Species can now act as direct containers of their agents..\n\t\tlist<species0> spec_with_location <- species0 select (each.location = { 0, 0 });\n\t\tspecies0 agent0 <- species0[10];\n\t\twrite string(agent0);\n\n\t\t// ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This \"virtual map\" will now contain, in addition to the attributes, \n\t\t// all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).\n\t\tagent0[\"departure\"] <- { 0, 0 };\n\t\twrite string(agent0);\n\n\t\t// Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.\n\t\tagent0[0] <- 0;\n\n\t\t// Accesses can be combined\n\t\tspecies0[10].name <- \"A new name\"; // which is equivalent to (spec at 10).name = \"A new name\";\n\n\t\t// Points can be used (with or without curly parentheses) to access agents in species\n\t\tspecies0 agent1 <- species0[10, 10]; // returns the agent closest to point {10,10} for a \"regular\" species\n\t\t// The behavior is a bit tweaked for grids, to allow for a \"natural\" access\n\t\tmy_grid cell0 <- my_grid[10, 10]; // Here, it is the cell at {10, 10} in the matrix of cells\n\n\t\t// Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).\n\t\tagent0.name <- string(agent0.shape[\"ID\"]);\n\t\tgeometry geom <- square(100);\n\t\tgeom[\"type\"] <- \"cube\";\n\t\t\n\t\t\n\t\t// All these attributes can be accessed using the casting of agents to map\n\t\twrite string(map(agent0));\n\n\t\t//This access can be used everywhere, easing the use of shape files (and data files in general)\n\t\tlist<geometry> shapes <- list<geometry>(file(\"includes/something.shp\"));\n\n\t\t// If we suppose val1, val2, etc. are defined in the shape file\n\t\tfloat max <- min(shapes collect float(each[\"val1\"]));\n\n\t\t//To allow for an easier access in case the modeler only uses agents, agents' attributes can \"pass through\" towards their shape's attributes \n\t\t//(in case the same attribute has not been defined in the agent, of course)\n\t\tcreate species0 from: shapes;\n\t\tmax <- min(species0 collect float(each[\"val1\"])); // equivalent to each.shape[\"val1\"]. \n\t\t//This last sentence only works, however, for *reading* values.\n\t\tany(species0)[\"val1\"] <- 100; // will result in the creation of a new attribute in the agent (not in its shape)\n\t\tany(species0).shape[\"val1\"] <- 100; // will be correct in that case\n\n\t\t// Container variables have seen their usability clearly improved \n\t\tmap m <- map([]);\n\t\tlist<int> l <- [1, 2, 3, 4, 5];\n\n\t\t// Adding a value\n\t\tadd 1 to: l;\n\t\t// ... can now be written\n\t\tl <+ 1;\n\n\t\t// Removing a value\n\t\tremove 1 from: l;\n\t\tremove \"type\" from: geom;\n\n\t\t// ... can now be written\n\t\tl >- 1;\n\t\tgeom >- \"type\";\n\t\tany(species0)[] >- \"name\"; // removes the \"name\" attribute from a random agent. Can be dangerous in some cases... \n\n\t\t// Setting/putting a value\n\t\tput \"a\" at: 'key' in: m;\n\t\tput 1 at: 0 in: l;\n\t\t// ... can now be written\n\t\tm['key'] <- \"a\";\n\t\tl[0] <- 1;\n\t\tlist<list> ll <- [];\n\t\tll <+ []; // [[]]\n\t\tll[0] <+ 10; // [[10]]\n\n\t}\n\n\t// Species can now be written within the \"global\" section (to enforce the idea that the top-level species are indeed contained in the world)\n\tspecies inside_global {\n\t}\n\n\t/**\n\t  * INVOCATION OF ACTIONS\n\t  */\n\treflex calling_actions {\n\t// IN IMPERATIVE MODE (i.e. in a statement)\n\t// The classic way\n\t\tdo dummy1 with: [a::10, b::100.0];\n\n\t\t// Another by distributing the arguments\n\t\tdo dummy1 a: 10 b: 100.0;\n\n\t\t// The new alternative one \n\t\tdo dummy1(a: 10, b: 100.0);\n\t\task any(species1) {\n\t\t\tdo goto(target: { 10, 10 }, speed: 100);\n\t\t}\n\t\t// ... which has been introduced to unify the functional/imperative use of actions.\n\n\t\t// And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).\n\t\tdo dummy1(10, 100.0);\n\n\t\t// IN FUNCTIONAL MODE (i.e. as part of expressions)\n\t\t// The \"classic\" way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)\n\t\t//list d1 <- self dummy1 [a::10, b::100.0];\n\n\t\t// First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments\n\t\t//list d2 <- self dummy1 (b: 100.0); // a is not passed as it has a default value.\n\n\t\t// To improve the readability of this way of calling actions, the dotted notation is now allowed as well \n\t\tlist d3 <- self.dummy1(a: 100, b: 100.0);\n\t\tfloat s <- any(species1).compute_speed_using_an_action(max: 100);\n\n\t\t// Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.\n\t\t// This unifies the way of calling operators and actions furthermore. \n\n\t\t// The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call\n\t\tlist d4 <- dummy1(10, 100.0);\n\n\t\t// And it can also be called using the \"dotted\" syntax, in which case the callee needs to be explicit (can be \"self\" of course)\n\t\tpath p <- world.move(100, 45, shape); // speed, heading, bounds\n\n\n\t\t/**\n \t \t *  As a summary, the syntaxes kept for future developments of models will likely be: \n \t \t */\n\n\t\t// CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF\n\t\t// This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives), \n\t\t// but also to pass them in any order\n\t\tdo wander(speed: 100, amplitude: 10);\n\t\tpath p1 <- path(self.wander(amplitude: 10, speed: 100));\n\t\t//path p2 <- path(self wander (speed: 100, bounds: square(10)));\n\t\tpath p3 <- path(wander(speed: 100));\n\t\tpath p4 <- path(wander());\n\n\t\t// CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF\n\t\t// This method is convenient as it follows the functional syntax of operators and then allows to declare \"quasi-operators\" in species, even to redefine existing ones.\n\t\tdo wander(100, 100, self.shape); // speed, amplitude, bounds as defined in primitive wander\n\t\tint d5 <- self.max(10, 100);\n\t\t//int d6 <- self max (10, 100);\n\t\tint d7 <- max(10, 100);\n\t\tlist others <- filter(species1);\n\n\t\t// As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance\n\t\tcreate species0 with: (location: { 100, 100 }, name: \"\");\n\t}\n\n\t// The ternary operator \"(condition) ? statement_if_condition_true : statement_if_condition_false\" can be used as follow :\n\tint max (int i, int j) {\n\t\treturn i > j ? i : j;\n\t}\n\n\tlist<agent> filter (container<agent> my_agents) {\n\t\treturn my_agents where (each.location = nil);\n\t}\n\n\t/**\n\t  * USE OF OPERATORS \n\t  */\n\treflex operators {\n\n\t// All the operators can now be written using a function-like form\n\t// It is true for unary operators (as before)\n\t\tbool a <- flip(0.4);\n\t\t// .. but also for binary ones (in addition to the classic way)\n\t\tint b <- div(100, 23) + 100 div 23;\n\t\tgeometry c1 <- union(square(1), circle(10));\n\t\t// The only exception to this rule is that of the built-in operators (like \"and\"/\"or\") and the ones whose names are not alphanumeric (like \"+\")\n\n\t\t// The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)\n\t\t// Here is an example with the \"between\" operator (written specially in Java to test this feature)\n\t\t// @operator(value = \"between\", can_be_const = true)\n\t\t// public static Boolean between(final Integer a, final Integer inf, final Integer sup) {\n\t\t//    \tif ( inf > sup ) { return false; }\n\t\t//\t\treturn a >= sup ? false : a > inf; \n\t\t// }\n\t\tbool e1 <- between(5, 1, 10);\n\t}\n\t/**\n\t  * DEFINITION OF ASPECTS\n\t  */\n\taspect default {\n\t// draw now accepts any kind of arguments and decides what to do based on the type of the argument\n\t\tdraw circle(1);\n\t\tdraw name;\n\t\tdraw file(\"image.jpg\");\n\n\t\t// special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display\n\t\t// This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display\n\t\tdraw circle(10 #px);\n\t\tdraw \"Display dimensions: \" + #display_width + \" \" + #display_height;\n\t}\n\n}\n\n/** Species can \"mirror\" a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored.\n* Their instances, which are actually \"proxy\" agents, possess an attribute called \"target\" that points towards the agent they mirror. Very useful for building graphs, for instance.\n* The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */\nspecies species0 {\n\tfloat speed <- float(rnd(1000));\n}\n\nspecies species1 mirrors: species0 skills: [moving] {\n\tpoint location update: target.location + { 10, 10 };\n\tfloat speed1 update: self.compute_speed_using_an_action(); // No parameter as \"max\" is defaulted\n\tfloat speed2 update: compute_speed_using_a_functional_attribute;\n\tfloat compute_speed_using_a_functional_attribute {\n\t\treturn speed of target;\n\t}\n\tfloat compute_speed_using_an_action (int max <- 100) {\n\t\treturn min([max, int(speed of target)]);\n\t}\n\n\tinit {\n\t\twrite \"I am \" + self.name + \" and my target is \" + target.name;\n\t}\n\n}\n\ngrid my_grid width: 100 height: 100 {\n}\n\nexperiment \"Run this experiment\" type: gui {\n\toutput {\n\t\tdisplay Display type: 3d {\n\t\t// Layers include a new keyword, \"graphics\", that allows to draw arbitrary shapes using the syntax found in the aspects of species\n\t\t// The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)\n\t\t\tgraphics 'G' {\n\t\t\t\tdraw sphere(10) at: { 50, 50 };\n\t\t\t\tif (true) {\n\t\t\t\t\tdraw \"true\";\n\t\t\t\t} else {\n\t\t\t\t\tdraw \"false\";\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Explain how to declare parameters and attributes in GAML, including global variables, experiment parameters, and inheritance of attributes between experiments.", "gaml_code": "/**\n * Name: Parameters\n * A very simple models that showcases the scope of parameters, between simulation parameter and experiment parameters\n * Author: Alexis Drogoul\n * Tags: variables, attributes, parameters\n */\n\nmodel Parameters\n\n\nglobal {\n\n\tint attribute_3 <- 10000;\n\tint attribute_2 <- 1000;\n}\n\nexperiment base_experiment virtual:true {\n\t// This parameter definition in an experiment will be found in all the experiments that inherit from it\n\tparameter \"Experiment attribute directly declared as parameter\" var:attribute_2;\t\n}\n\nexperiment \"Show Parameters\" parent:base_experiment{\n\n\tint attribute_1 <- 100 on_change: {write attribute_1;};\n\t\n\n\t// This attribute sports the same name as one in simulation, and it cannot become a parameter unless the parameter: facet is declared directly on it\n\tint attribute_3 <- 100;\n\n\t// This direct definition of parameters allows to declare the seed of the experiment as a parameter (otherwise the seed of the simulation is used by default)\n\tfloat seed;\n\tparameter \"The random seed of the experiment\" var:seed <- 100.0;\n\t\n\t\n\t\n\t// The following parameter targets an experiment attribute\n\tparameter \"Experiment attribute used by a parameter\" var: attribute_1;\n\t// The following parameter targets the seed of the random number generation. The lookup for this attribute begins in the simulation (not in the experiment). \n\tparameter \"The random seed of the simulation\" var: seed <- 0.0;\n\t// Like the seed, the following parameter targets attribute_3, and the one in the simulation will be used by default. \n\tparameter \"Simulation attribute used by a parameter\" var: attribute_3;\n\n\t\n}"}
{"prompt": "Design a multi-agent system where agents of different species can notify each other and themselves about changes to their attributes (location, state), demonstrating how variables can be used to facilitate communication between agents.", "gaml_code": "/**\n* Name: NotifyingVariables\n* This model shows how certain variables, which are directly manipulated by skills (like `location` by the `moving` skill) can notify a model that they have been changed (allowing the modeler to take appropriate measures if any). \n* Author: Alexis Drogoul\n* Tags: variables, attributes\n*/\nmodel NotifyingVariables\n\nglobal {\n\n\tinit {\n\t\tcreate a;\n\t\tcreate b;\n\t\tcreate c;\n\t}\n\n}\n\n/*\n * Agents of species a are provided with the moving skill, which, among other things, manipulates the location of the agent.\n * Thanks to the 'on_change:' facet on the variable, the agents are being notified of these changes.\n */\nspecies a skills: [moving] {\n\tpoint location on_change: {\n\t\twrite \"Location of \" + self + \" changed to \" + location;\n\t\task b {\n\t\t\tlocation <- myself.location;\n\t\t}\n\t};\n\n\treflex wandering {\n\t\tdo wander;\n\t}\n\n}\n\n/*\n * Agents of species b see their location modified by agents of species a. They can also be notified of it. \n */\nspecies b {\n\tpoint location on_change: {\n\t\twrite \"Location of \" + self + \" changed to \" + location;\n\t};\n}\n\n/*\n * Agents of species c behave according to a finite state machine. One variable, 'state', indicates the current state of the agent. \n * By adding the 'on_change:' facet to state, agents can be notified (or notify others) when they change state.\n */\n\nspecies c control: fsm {\n\t\n\tstring state on_change: {\n\t\twrite \"Transition to \" + state;\n\t};\n\t\n\tstate s1 initial: true {\n\t\twrite name + \" in S1\";\n\t\ttransition to: s2 when: flip(0.5);\n\t}\n\t\n\tstate s2 {\n\t\twrite name + \" in S2\";\n\t\ttransition to: s1 when: flip(0.5);\n\t}\n\t\n}\n\nexperiment Notification;"}
{"prompt": "Create a GeoMondrian model that allows users to declare and manipulate fields from various sources (grid files, matrices, etc.) and visualize them using different displays.", "gaml_code": "/**\n* Name: Fields\n* Based on the internal empty template. \n* Author: kevinchapuis\n* Tags: \n*/\n\n\nmodel Fields\n\nglobal  {\n\tfield field_display <-  field(grid_file(\"includes/Lesponne.tif\"));\n\tfield var_field <- copy(field_display) - mean(field_display);\n}\n\nspecies declaring_field {\n\t\n\t/*\n\t * Declaration of a field\n\t */\n\tfield field_from_grid <- field(matrix(cell));\n\t// Initialize a field from a asc simple raster file\n\tfield field_from_asc <- field(grid_file(\"includes/grid.asc\"));\n\t// initialize using a tiff raster file\n\tfield field_from_tiff  <-  field(grid_file(\"includes/Lesponne.tif\"));\n\t\n\t// Init from a user defined matrix\n\tfield field_from_matrix  <- field(matrix([[1,2,3],[4,5,6],[7,8,9]]));\n\t//  init an empty field of a given size\n\tfield empty_field_from_size <- field(10,10);\n\t// init a field for of a given value\n\tfield full_field_from_size<- field(10,10,1.0);  \n\t// init a field of given size, with a given value and no data\n\tfield full_field_from_size_with_nodata <- field (1,1,1.0,0.0);\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== DECLARING FIELD ==\";\n\t\twrite \"\";\n\t\twrite sample(field_from_grid);\n\t\twrite sample(field_from_asc);\n\t\twrite sample(field_from_tiff);\n\t\twrite sample(field_from_matrix);\n\t\twrite sample(empty_field_from_size);\n\t\twrite sample(full_field_from_size);\n\t\twrite sample(full_field_from_size_with_nodata);\n\t\twrite \"\";\n\t\t\n\t}\n\t\n}\n\n\nspecies manipulating_field {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== MANIPULATING FIELD ==\";\n\t\twrite \"\";\n\t\t// max-minimum value of the field\n\t\twrite sample(max(field_display));\n\t\twrite sample(min(field_display));\n\t\twrite sample(mean(field_display));\n\t\t// accessing bands of the field \n\t\twrite sample(field_display.bands[1]);\n\t\twrite sample(field_display.bands[2]);\n\t\twrite sample(field_display.bands[3]);\n\t\twrite \"\";\t\n\t}\n}\n\n//Grid that will be saved in the ASC File\ngrid cell width: 100 height: 100 {\n\tfloat grid_value <- rnd(1.0,self distance_to world.location);\n\trgb color <- rgb(255 * (1 - grid_value / 100), 0,0);\n}\n\nexperiment Fields type: gui {\n\tuser_command \"Declaring field\" {create declaring_field;}\t\n\tuser_command \"Manipulating field\" {create manipulating_field;}\t\n}\n\nexperiment Field_view type:gui{\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"field through mesh\" type:3d {\n\t\t\tmesh field_display grayscale:true scale: 0.05 triangulation: true smooth: true refresh: false;\n\t\t}\n\t\tdisplay \"rgb field through mesh\" type:3d {\n\t\t\tmesh field_display color:field_display.bands scale: 0.1 triangulation: true smooth: 4 refresh: false;\n\t\t}\n\t\tdisplay \"rnd field with palette mesh\"  type:3d {\n\t\t\tmesh field_display.bands[2] color:scale([#red::100, #yellow::115, #green::101, #darkgreen::105]) scale:0.2 refresh: false ;\n\t\t}\n\t\tdisplay \"var field\" type:3d  {\n\t\t\tmesh var_field color:(brewer_colors(\"RdBu\")) scale:0.0;\n\t\t}\n\t}\n}"}
{"prompt": "Create a graph model that allows for various types of network generation and analysis, including Erd\u0151s-R\u00e9nyi random graphs, scale-free networks, small-world networks, complete graphs, grid graphs, and path finding. The model should also include features for accessing and modifying edges and nodes, calculating connectivity metrics, and visualizing the graph layout.", "gaml_code": "/***\n* Name: graph\n* Author: kevinchapuis\n* Description: All the operators related to graphs\n* Tags: graph, network, path\n***/\nmodel graph\n\nglobal {\n\tint init_nb_nodes <- 1 min: 1;\n\tint nb_nodes <- 10 min: 1;\n\tint av_degree <- 4;\n\tbool node_species_only <- false;\n\tbool no_species <- false;\n\tbool directed_graph <- false;\n\tint x_cells <- 10;\n\tint y_cells <- 10;\n\tgraph g_graph;\n\tstring the_layout init: \"Circle\" among: [\"Circle\", \"Forced\", \"Grid\"];\n\tstring graph_generator init: \"Complete\" among: [\"Random\",\"Scall-free\", \"Small-world\", \"Complete\", \"Distance\", \"Intersection\", \"Grid\"];\n\n\tinit {\n\t\twrite \"- Using dedicated agent that extends 'graph_node' =>  'species my_node parent: graph_node edge_species: my_edge' with my_edge parent: base_edge\";\n\t\t/*\n\t\t * Most of the work is done in the 'related_to(node_agent node)' method\n\t\t * \n\t\t * Use: e.g. if returns always true, will then obtain a complete graph\n\t\t * \n\t\t */\n\t\tcreate builtin_node number: nb_nodes;\n\t\tg_graph <- first(builtin_node).my_graph;\n\t}\n\n\taction clean {\n\t\task regular_agent_node {\n\t\t\tdo die;\n\t\t}\n\n\t\task regular_agent_edge {\n\t\t\tdo die;\n\t\t}\n\n\t\task builtin_edge {\n\t\t\tdo die;\n\t\t}\n\n\t\task builtin_node {\n\t\t\tdo die;\n\t\t}\n\n\t}\n\t\n\t/**\n\t * Generate a random graph based on the G(n,M) Erd\u0151s-R\u00e9nyi model\n\t * https://en.wikipedia.org/wiki/Erd\u0151s\u2013R\u00e9nyi_model\n\t */\n\taction random {\n\t\twrite \"- random graph : Erd\u0151s-R\u00e9nyi = generate_random_graph(nb_nodes,nb_edges,directed,node_species,edge_species)\";\n\t\tdo clean;\n\t\tif no_species { g_graph <- as_spatial_graph(generate_random_graph(nb_nodes,nb_nodes*av_degree,directed_graph));}\n\t\telse if node_species_only { g_graph <- as_spatial_graph(generate_random_graph(nb_nodes,nb_nodes*av_degree,directed_graph,regular_agent_node));}\n\t\telse {\n\t\t\tg_graph <- as_spatial_graph(generate_random_graph(\n\t\t\t\tnb_nodes, // The number of nodes\n\t\t\t\tnb_nodes*av_degree, // The number of edges\n\t\t\t\tdirected_graph, // directed graph\n\t\t\t\tregular_agent_node, // The species of nodes\n\t\t\t\tregular_agent_edge // The species of edges\n\t\t\t));\n\t\t}\n\t\t\n\t\t\n\t}\n\n\t/*\n\t * Generate a graph with scale-free network structural properties:\n\t * https://en.wikipedia.org/wiki/Barab\u00e1si\u2013Albert_model\n\t * \n\t */\n\taction scale_free {\n\t\twrite \"- Scale-free : Barab\u00e1si\u2013Albert = generate_barabasi_albert(node_species, edge_species, nb_nodes, new_edges, synchronize)\";\n\t\tdo clean;\n\t\tint new_edges_addition_per_node_introduction <- 4 > init_nb_nodes ? init_nb_nodes : 4;\n\t\tif no_species {g_graph <- as_spatial_graph(generate_barabasi_albert(init_nb_nodes,new_edges_addition_per_node_introduction,nb_nodes,directed_graph));}\n\t\telse if node_species_only {g_graph <- as_spatial_graph(generate_barabasi_albert(init_nb_nodes,new_edges_addition_per_node_introduction,nb_nodes,directed_graph,regular_agent_node));}\n\t\telse {\n\t\t\tg_graph <- as_spatial_graph(generate_barabasi_albert(\n\t\t\t\tinit_nb_nodes, // The number of nodes in the graph\n\t\t\t\tnew_edges_addition_per_node_introduction, // the number of edges created when a new node enter the graph\n\t\t\t\tnb_nodes, // The number of nodes in the graph\n\t\t\t\tdirected_graph, //directed grah\n\t\t\t\tregular_agent_node, // The species of nodes\n\t\t\t\tregular_agent_edge // The species of edges\n\t\t\t));\n\t\t}\n\t}\n\n\t/*\n\t * Generate a graph with small-world network structural properties\n\t * https://en.wikipedia.org/wiki/Small-world_network\n\t * \n\t */\n\taction small_world {\n\t\twrite \"- Small-world : Watts-Strogatz = generate_watts_strogatz(node_species, edge_species, nb_nodes, rewire_proba, start_degree, synchronize)\";\n\t\tdo clean;\n\t\tfloat rewirering_probability <- 0.1;\n\t\tint fake_lattice_start_degree <- 4; // Even and more than 2\n\t\tif no_species {g_graph <- as_spatial_graph(generate_watts_strogatz(nb_nodes,rewirering_probability,fake_lattice_start_degree,directed_graph));}\n\t\telse if node_species_only {g_graph <- as_spatial_graph(generate_watts_strogatz(nb_nodes,rewirering_probability,fake_lattice_start_degree,directed_graph,regular_agent_node));}\n\t\telse {\n\t\t\tg_graph <- as_spatial_graph(generate_watts_strogatz(\n\t\t\t\tnb_nodes, // The number of nodes\n\t\t\t\trewirering_probability, // The probability to rewire a node in the generation process\n\t\t\t\tfake_lattice_start_degree, // The degree of node at start, before the rewirering process\n\t\t\t\tdirected_graph, //is directed\n\t\t\t\tregular_agent_node, // The species of nodes\n\t\t\t\tregular_agent_edge // The species of edges\n\t\t\t));\n\t\t}\n\t}\n\n\t/*\n\t * Generate a complete graph where each node is connected to all other nodes\n\t */\n\taction complete {\n\t\twrite \"- Complete = generate_complete_graph(node_species, edge_species, nb_node)\";\n\t\tdo clean;\n\t\tif no_species {g_graph <- as_spatial_graph(generate_complete_graph(nb_nodes,directed_graph));}\n\t\telse if node_species_only {g_graph <- as_spatial_graph(generate_complete_graph(nb_nodes,directed_graph,regular_agent_node));}\n\t\telse {\n\t\t\tg_graph <- as_spatial_graph(generate_complete_graph(\n\t\t\t\tnb_nodes,// The number of nodes in the graph\n\t\t\t\tdirected_graph, //is directed\n\t\t\t\tregular_agent_node, // The species of nodes\n\t\t\t\tregular_agent_edge // The species of edges \n\t\t\t));\n\t\t}\n\t}\n\n\taction from_nodes {\n\t\tdo clean;\n\t\tcreate regular_agent_node number: nb_nodes;\n\t\twrite \"\\tas_distance_graph(my_species, distance)\";\n\t\tfloat distance <- 20 #m;\n\t\tg_graph <- as_distance_graph(regular_agent_node, // A list of agent to connect to one another \n\t\tdistance,// The maximal distance between two nodes for them to be connected\n\t\tregular_agent_edge \n);\n\t}\n\n\taction from_polygons {\n\t\tdo clean;\n\t\t// Create a set of lines (no need to create agent) to build network with\n\t\tcreate regular_agent_node number: nb_nodes with: [shape::circle(rnd(5,20)) at_location any_location_in(world)];\n\t\twrite \"\\tas_intersection_graph(my_lines, tolerance)\";\n\t\tfloat tolerance <- 1.0;\n\t\tg_graph <- as_intersection_graph(regular_agent_node, tolerance,regular_agent_edge);\n\t}\n\n\taction grid_graph (int k) {\n\t\tdo clean;\n\t\twrite \"With a grid with 4, 6 or 8 neighbors that correspond to a lattice of 4, 6 and 8 degree\";\n\t\twrite \"- Using 'grid_cells_to_graph(my_grid)'\";\n\t\tswitch k {\n\t\t\tmatch_one [5, 6, 7] {\n\t\t\t\tg_graph <- grid_cells_to_graph(cell6,regular_agent_edge);\n\t\t\t}\n\n\t\t\tmatch_between [8, #infinity] {\n\t\t\t\tg_graph <- grid_cells_to_graph(cell8,regular_agent_edge);\n\t\t\t}\n\n\t\t\tdefault {\n\t\t\t\tg_graph <- grid_cells_to_graph(cell4,regular_agent_edge);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taction access_and_modify_edge_and_node {\n\t\twrite \"\\n==================\";\n\t\twrite \"GRAPH MANIPULATION\\n\";\n\t\tthe_path <- nil;\n\n\t\t/*\n\t\t * build a new age as a pair of point\n\t\t */\n\t\tpair an_edge <- one_of(g_graph.vertices)::one_of(g_graph.vertices);\n\t\twrite \"Test weither the graph contains an edge: 'graph contains_edge edge'\";\n\t\tbool e1_in_graph <- g_graph contains_edge an_edge;\n\t\tgeometry node1 <- any(g_graph.vertices);\n\t\tgeometry node2 <- any(g_graph.vertices);\n\t\twrite \"Test weither the graph contains a node: 'graph contains_vertex node'\";\n\t\tbool n1_in_graph <- g_graph contains_vertex node1;\n\t\tbool n2_in_graph <- g_graph contains_vertex node2;\n\t\twrite \"Access to an edge: 'graph edge_between pair(node1::node2)'\";\n\t\tgeometry the_edge <- g_graph edge_between (node1::node2);\n\t\twrite \"Access to a node from an edge: 'graph target_of edge' or 'graph source_of edge'\";\n\t\tfloat w <- g_graph weight_of an_edge;\n\t\tgeometry target <- g_graph target_of an_edge;\n\t\tgeometry source <- g_graph source_of an_edge;\n\t\twrite \"Add nodes and edges\";\n\t\twrite \"use the 'graph add_edge p1::p2' operator\";\n\t\tg_graph <- g_graph add_edge an_edge;\n\t\twrite \"use the 'graph add_node p1 operator\";\n\t\tif (type_of(first(g_graph.vertices)) = point) {\n\t\t\tg_graph <- g_graph add_node any_location_in(world);\n\t\t\n\t\t}\n\t\twrite \"Remove nodes and edges\";\n\t\twrite \"use the 'p1 remove_node_from graph' operator\";\n\t\tg_graph <- geometry(any(g_graph.vertices)) remove_node_from g_graph;\n\t\twrite \"Rewire nodes\";\n\t\tg_graph <- g_graph rewire_n 10;\n\t\twrite \"Change the weigth of edges\";\n\t\tg_graph <- g_graph with_weights (g_graph.edges as_map (each::rnd(20)));\n\t\twrite \"Turn graph into directed / undirected ones\";\n\t\tg_graph <- directed(g_graph);\n\t\tg_graph <- undirected(g_graph);\n\t}\n\n\taction connectivity_of_node_and_edge {\n\t\twrite \"\\n==================\";\n\t\twrite \"NODES CONNECTIVITY\\n\";\n\t\tgeometry a_node <- one_of(g_graph.vertices);\n\t\twrite \"Access to the list of successors and predecessors:\\n\" + \"'graph successors_of node' or 'graph predecessors_of node'\";\n\t\tlist successors <- g_graph successors_of a_node;\n\t\tlist predecessors <- g_graph predecessors_of a_node;\n\t\twrite \"Access to the neighbords of a node: 'graph neighbors_of node'\";\n\t\tlist neighbors <- g_graph neighbors_of a_node;\n\t\twrite \"The degree of a node (number of neighbords): 'degree_of', 'in_degree_of' and 'out_degree_of'\";\n\t\tint d_n <- g_graph degree_of a_node;\n\t\tint in_d <- g_graph in_degree_of a_node;\n\t\tint out_d <- g_graph out_degree_of a_node;\n\t\tlist in_e <- g_graph in_edges_of a_node;\n\t\tlist out_e <- g_graph out_edges_of a_node;\n\t}\n\n\taction connectivity_of_graph {\n\t\twrite \"\\n==================\";\n\t\twrite \"GRAPH CONNECTIVITY\\n\";\n\t\twrite \"Compute the betweenness centrality of each node: correspond to the number of shortest path \" + \"that pass by the node\";\n\t\tmap<geometry, int> bc <- betweenness_centrality(g_graph);\n\t\twrite \"Number of cycle in the graph = \" + nb_cycles(g_graph);\n\t\twrite \"Alpha index of the graph = \" + alpha_index(g_graph);\n\t\twrite \"Beta index of the graph = \" + beta_index(g_graph);\n\t\twrite \"Gamma index of the graph = \" + gamma_index(g_graph);\n\t\twrite \"Connectivity index of the graph = \" + connectivity_index(g_graph);\n\t\twrite \"Compute main connected component and all connected components of the graph\";\n\t\tg_graph <- main_connected_component(g_graph);\n\t\tlist component <- connected_components_of(g_graph);\n\t\twrite \"Compute the maximum and biggest cliques: 'maximal_cliques_of' and 'biggest_cliques_of'\";\n\t\tlist cliques_max <- maximal_cliques_of(g_graph);\n\t\tlist cliques_big <- biggest_cliques_of(g_graph);\n\t}\n\n\taction layout_graph {\n\t\twrite \"\\n==================\";\n\t\twrite \"GRAPH LAYOUT\\n\";\n\t\tswitch the_layout {\n\t\t\tmatch \"Circle\" {\n\t\t\t\tdo c_layout;\n\t\t\t}\n\n\t\t\tmatch \"Grid\" {\n\t\t\t\tdo g_layout;\n\t\t\t}\n\n\t\t\tmatch \"Forced\" {\n\t\t\t\tdo f_layout;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taction c_layout {\n\t\twrite \"Circle classical layout : nodes are randomly placed on a circle\";\n\t\tg_graph <- layout_circle(g_graph, world.shape, // The geometry to spatialize nodes in \n\t\tfalse // Shuffle or not the nodes\n);\n\t}\n\n\taction f_layout {\n\t\twrite \"Forced based layout : connected node pull each other, while unconnected node push each other away\";\n\t\tg_graph <- layout_force(g_graph, world.shape, // The geometry to spatialize nodes in \n\t\t0.4, // The pull/push force\n\t\t0.01, // The cooling rate of the algorithm\n\t\t100 // Maximum number of iterations\n);\n\t}\n\n\taction g_layout {\n\t\twrite \"Homemade grid based layout : distributes nodes over a grid to minimize edge crossing\";\n\t\tgraph q <- layout_grid(g_graph, world.shape, // The geometry to spatialize nodes in\n\t\t1.5 // The ratio of possible grid position over the total number of nodes (should be higher than 1.0 )\n\t\t);\n\n\t}\n\n\tpath the_path <- nil;\n\taction path_finding_graph {\n\t\twrite \"\\n====================\";\n\t\twrite \"GRAPH PATH OPERATORS\\n\";\n\t\twrite \"The matrix of predecessor in all shortest path: \";\n\t\tmatrix sp <- all_pairs_shortest_path(g_graph);\n\t\twrite first(10, sp);\n\t\tg_graph <- load_shortest_paths(g_graph, sp);\n\t\tgeometry node1 <- any(g_graph.vertices);\n\t\tgeometry node2 <- any(g_graph.vertices - node1);\n\t\t \n\t\tmap<int, geometry> mfb <- map<int, geometry>(g_graph max_flow_between (node1, node2));\n\t\twrite \"Find a path between two nodes: 'graph path_between (node1, node2)'\";\n\t\tthe_path <- g_graph path_between (node1, node2);\n\t}\n\n}\n\n/*\n * GENERAL PURPOSE GRAPH SPECIEIS\n */\nspecies builtin_edge parent: base_edge {\n}\n\nspecies builtin_node parent: graph_node edge_species: builtin_edge {\n\n/*\n\t * This particular methods define the structure of the network\n\t */\n\tbool related_to (builtin_node other) {\n\t\treturn true;\n\t}\n\n}\n\nspecies regular_agent_edge {\n}\n\nspecies regular_agent_node {\n}\n\ngrid cell4 width: x_cells height: y_cells neighbors: 4 {\n}\n\ngrid cell6 width: x_cells height: y_cells neighbors: 6 {\n}\n\ngrid cell8 width: x_cells height: y_cells neighbors: 8 {\n}\n\nexperiment Graph type: gui {\n\t\n\tparameter var:init_nb_nodes;\n\tparameter var:nb_nodes;\n\tparameter var:av_degree;\n\tparameter var:node_species_only;\n\tparameter var:no_species;\n\tparameter var:directed_graph;\n\tparameter var:the_layout;\n\tparameter var:graph_generator;\n\t\n\t\n\tfloat minimum_cycle_duration <- 1#s;\n\ttext \"You have to play the simulation model in order to build and play with network\";\n\tuser_command \"Accessing/modifying graphs\" {\n\t\task world {\n\t\t\tdo access_and_modify_edge_and_node;\n\t\t}\n\n\t}\n\n\tuser_command \"Connectivity of node and edge\" {\n\t\task world {\n\t\t\tdo connectivity_of_node_and_edge;\n\t\t}\n\n\t}\n\n\tuser_command \"Connectivity of graph\" {\n\t\task world {\n\t\t\tdo connectivity_of_graph;\n\t\t}\n\n\t}\n\n\tuser_command \"Layout graph\" {\n\t\task world {\n\t\t\tdo layout_graph;\n\t\t}\n\n\t}\n\n\tuser_command \"Path with graph\" {\n\t\task world {\n\t\t\tdo path_finding_graph;\n\t\t}\n\n\t}\n\n\tuser_command \"Create graphs\" {\n\t\tthe_path <- nil;\n\t\tswitch graph_generator {\n\t\t\tmatch \"Random\" { ask world {do random();} }\n\t\t\tmatch \"Scall-free\" { ask world { do scale_free(); } }\n\t\t\tmatch \"Small-world\" { ask world { do small_world(); } }\n\t\t\tmatch \"Complete\" { ask world { do complete(); } }\n\t\t\tmatch \"Distance\" { ask world { do from_nodes(); } }\n\t\t\tmatch \"Intersection\" { ask world { do from_polygons(); } }\n\t\t\tmatch \"Grid\" { ask world { do grid_graph(av_degree); } }\n\t\t}\n\n\t}\n\n\toutput {\n\t\tdisplay graph_layout {\n\t\t\tgraphics \"graph\" {\n\t\t\t\tloop e over: g_graph.edges {\n\t\t\t\t\tdraw geometry(e) color: #black;\n\t\t\t\t}\n\n\t\t\t\tloop v over: g_graph.vertices {\n\t\t\t\t\tdraw circle(0.5) at: geometry(v).location color: #red border: #black;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tgraphics \"path\"{\n\t\t\t\tif the_path != nil {\n\t\t\t\t\tloop e over:the_path.edges{\n\t\t\t\t\t\tdraw geometry(e) color: #red;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Explain and demonstrate various list operations and functions in GAML.", "gaml_code": "/**\n* Name: Lists\n* Author: Alexis Drogoul\n* Description: Examples of the syntax and various operators used to manipulate the 'list' data type. \n* Read the comments and run the model to get a better idea on how to use lists in GAML. \n* Tags: list, loop\n*/\n\nmodel Lists\n\nspecies declaring_list_attributes {\n\t\n\t/**\n\t * Declarations of list attributes\n\t */\n\t // The simplest declaration identifies empty_list as a list that can contain any type of objects. \n\t // Its default value will be [] (the empty list) if it is not initialized.\n\tlist empty_list;\n\t// To provide it with an initial value, use the '<-' (or 'init:') facet\n\tlist explicit_empty_list <- [];\n\t// lists can also be provided with a default size, in which case they are filled with the nil element\n\tlist list_of_size_10 <-[];// list_size(10); // => [nil,nil,nil,nil,nil,nil,nil,nil,nil,nil]\n\t// to fill them with a given initial value, use the 'list_with' operator\n\tlist list_of_size_10_with_0 <- list_with(10, 0); // => [0,0,0,0,0,0,0,0,0,0]\n\t\n\t// lists can be declared so that they only accept a given type of contents.\n\t// For instance, empty_list_of_int will only accept integer elements\n\tlist<int> empty_list_of_int ;\n\t\n\t// the value passed to 'list_with' is verified and casted to the contents type of the list if necessary\n\tlist<int> list_of_int_size_10_filled_with_string<- list<int>(list_with(10,'1')); // list_of_int_size_10_filled_with_string is filled with the casting of '1' to int, i.e. 1\n\tlist<string> list_of_string_size_10_filled_with_string <- list_with(10,'1'); // while list_of_string_size_10_filled_with_string is filled with the string '1'\n\t// the casting is also realized if the list is initialized with a value\n\tlist<int> list_of_int_with_init_of_string <- list<int>(['10', '20']); // => [10,20]\n\tlist<float> list_of_float_with_init_of_string <- list<float>(list_of_string_size_10_filled_with_string); // => [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]\n\t// When the casting is not obvious, the default value is used\n\tlist<float> list_of_float_with_impossible_casting <- list<float>(['A','B']); \n\t// lists can of course contain lists\n\tlist<list> list_of_lists <- list_with (5,[]);\n\t// untyped lists can contain heterogeneous objects\n\tlist untyped_list <- ['5',5,[5]];\n\t// the casting applies to all elements when a contents type is defined (note the default last value of 0)\n\tlist<int> recasted_list_with_int <- list<int>(untyped_list); //=> [5,5,0]\n\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== DECLARING LISTS ==\";\n\t\twrite \"\";\n\t\twrite sample(empty_list);\n\t\twrite sample(explicit_empty_list);\n\t\twrite sample(list_of_size_10);\n\t\twrite sample(list_of_size_10_with_0);\n\t\twrite sample(empty_list_of_int);\n\t\twrite sample(list_of_int_size_10_filled_with_string);\n\t\twrite sample(list_of_string_size_10_filled_with_string);\n\t\twrite sample(list_of_int_with_init_of_string);\n\t\twrite sample(list_of_float_with_init_of_string);\n\t\twrite sample(list_of_float_with_impossible_casting);\n\t\twrite sample(list_of_lists);\n\t\twrite sample(untyped_list);\n\t\twrite sample(recasted_list_with_int);\n\t\twrite \"\";\n\t\t// lists are not always declared litterally and can be obtained from various elements\n\t\t// by using the casting 'list()' operator\n\t\t// for instance, list(species_name) will return a list of all the instances of species_name\n\t\tcreate test_species number:4;\n\t\tlist<test_species> my_agents <- list(test_species);\n\t\twrite sample(my_agents);\n\t\tlist<string> my_names <- my_agents collect each.name;\n\t\twrite sample(my_names);\n\t\t// 'create' can directly declare (and return) a list of the agents created. For instance:\n\t\tcreate test_species number: 5 returns: my_agents2;\n\t\twrite (sample(my_agents2));\n\t\t// Some special casting operations are applied to specific types, like points...\n\t\twrite sample(list(any(my_agents).location));\n\t\t// ... colors ...\n\t\twrite sample(list(#pink));\n\t\t// ... or strings\n\t\twrite sample(list(\"This is a string\"));\n\t\t\n \t}\n}\n\nspecies test_species{}\n\nspecies accessing_list_elements {\n\tlist<int> l1 <- [1,2,3,4,5,6,7,8,9,10];\n\tlist<string> l2 <- ['this','is','a','list', 'of','strings'];\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== ACCESSING LIST ELEMENTS ==\";\n\t\twrite \"\";\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(first(l1));\n\t\twrite sample(last(l1));\n\t\twrite sample(l1 at 1);\n\t\twrite sample(l1[1]);\n\t\twrite sample(length(l1));\n\t\twrite sample(mean(l1));\n\t\twrite sample(max(l1));\n\t\twrite sample(min(l1));\n\t\twrite sample(any(l1));\n\t\twrite sample(3 among l2);\n\t\twrite sample(l1 contains 1);\n\t\twrite sample(l1 contains_all [1,4,6, 14]);\n\t\twrite sample(l1 contains_any [1,23]);\n\t\twrite sample(reverse(l2));\n\t\twrite sample(l1 collect (each + 1));\n\t\twrite sample(l1 collect (norm({each, each, each})));\n\t\twrite sample(l1 where (each > 5));\n\t\twrite sample(l1 count (each > 5));\n\t\twrite sample(l1 group_by (even(each)));\n\t\twrite sample(l2 index_by (each + \"_index\"));\n\t\twrite sample(l1 index_of 100);\n\t\twrite sample(l2 last_index_of 'is');\n\t\twrite sample(l2 sort_by each);\n\t\twrite sample(l2 sort_by length(each));\n\t\twrite sample(l2 first_with (first(each)  = 'o'));\n\t\twrite sample(l2 where (length(each) = 2) );\n\t\twrite sample(l2 with_min_of (length(each)));\n\t\twrite sample(l2 with_max_of (length(each)));\n\t\twrite sample(l2 min_of (length(each)));\n\t\twrite sample(l2 max_of (length(each))); \n\t\twrite sample(copy_between(l2,1,3));\n\t\twrite sample(copy_between(l2, 1, length(l2) - 1));\n\t\twrite sample(l2 as_map (length(each)::\"new\"+each));\n\t\t// Ranges\n\t\twrite sample(l2[1::3]);\n\t}\n}\n\nspecies combining_lists {\n\tlist<int> l1 <- [1,2,3,4,5,6,7,8,9,10];\n\tlist<int> l2 <- [1,3,5,7,9];\n\tlist<list> useful_list_of_lists <- [['A','B'],['C','D']]; \n\tinit {\n\t\twrite \"\";\n\t\twrite \"== COMBINING LISTS ==\";\n\t\twrite \"\";\n\t\twrite sample(list<list<string>>([[1,2,3]]));\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(l1 + l2);\n\t\twrite sample(l1 - l2);\n\t\twrite sample(l1 inter l2);\n\t\twrite sample(l1 union l2);\n\t\twrite sample(interleave ([l1,l2]));\n\t\tlist<string> l3 <- list<string>(l1 + l2);\n\t\twrite \"list<string> l3 <- l1 + l2; \" + sample(l3);\n\t\twrite sample(l1 as list<float>);\n\t\twrite sample(cartesian_product(useful_list_of_lists));\n\t}\n}\n\nspecies modifying_lists {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== MODIFYING LISTS ==\";\n\t\twrite \"\";\n\t\ttrace {\n\t\t// Besides assigning a new value to a list, lists can be manipulated using\n\t\t// the \"add\", \"remove\" and \"put\" statements. \n\t\t// Let's define an empty list supposed to contain integer elements\n\t\tlist<int> l1;\n\t\t// and add some stuff to it using \"add\"\n\t\tadd 1 to: l1;\n\t\tadd 2 to: l1;\n\t\tadd 3 to: l1;\n\t\twrite sample(l1);\n\t\t// the same can be done with the compact syntax introduced in GAMA 1.6 for \"add\"\n\t\tl1 <+ 4;\n\t\tl1 <+ 5;\n\t\twrite sample(l1);\n\t\t// tired of writing lines of add ? The \"all:\" facet is here to serve:\n\t\tadd all: [6, 7, 8, 9] to: l1;\n\t\t// or, in a more compact way:\n\t\tl1 <<+ [10,11,12,13];\n\t\twrite sample(l1);\n\t\t// modifyng ranges of elements is also possible\n\t\tl1[1::3] <- 100;\n\t\twrite sample(l1);\n\t\t// automatic casting applies to any element added to the list\n \t\tl1 <+ (int(\"14\"));\n\t\t// as well as any container of elements\n\t\tl1 <<+ (list<int>([\"15\", 16.0]));\n\t\twrite sample(l1);\n\t\t// elements are by default added to the end of the list\n\t\t// but they can be introduced at specific positions using the \"at:\" facet\n\t\tadd 0 to: l1 at: 0;\n\t\t// or\n\t\tl1[0] +<- 0;\n\t\t// what about replacing some elements once they have been added ?\n\t\t// \"put\" can be used for that purpose\n\t\tput -2 at: 0 in: l1;\n\t\t// or, more elegantly:\n\t\tl1[0] <- -2;\n\t\t// Trying to put an element outside the bounds of the list will yield an error\n\t\t// l1[20] <- 10; will return the error \"Index 20 out of bounds of l1\"\n\t\twrite sample(l1);\n\t\t// And what about replacing all the values with a new one ?\n\t\tl1[] <- 0;\n\t\twrite sample(l1);\n\t\t// Well, l1 is a bit boring now, isnt't it ?\n\t\t// Let's fill it again with fresh values\n\t\tloop i from: 0 to: length(l1) -1 {\n\t\t\tl1[i] <- rnd(3);\n\t\t}\n\t\twrite(sample(l1));\n\t\t// To remove values from it, the \"remove\" statement (and its compact forms) can be used\n\t\t// For instance, let's try to remove its first element\n\t\tremove first(l1) from: l1;\n\t\t// it can also be written\n\t\tl1 >- first(l1);\n\t\twrite(sample(l1));\n\t\t// To remove all occurrences of a specific element, \"all:\" (or \">>-\") can be used\n\t\t// For instance:\n\t\tl1 >>- 2;\n\t\tl1 >>- 1;\n\t\t// or, written using the long syntactic form\n\t\tremove all: 1 from: l1;\n\t\twrite sample(l1);\n\t\t// To remove all the elements present in a given container, the same syntax can be used\n\t\tl1 >>- [0,3];\n\t\twrite (\"After l1 >>- [0,3] : \" + sample( l1));\n\t\t// By all means, l1 should now be empty! Let's fill it again\n\t\tloop times: 20 {\n\t\t\tl1 <+ rnd(3);\n\t\t}\n\t\twrite(sample(l1));\n\t\t// It is also possible to remove an index rather than a value (this will remove the \n\t\t// value present at this index )\n\t\tl1[] >- 2;\n\t\twrite(\"After l1[] >- 2 : \" + sample(l1));\n\t\t// Removing several indexes can be written using a syntax similar to the one used\n\t\t// for removing values\n\t\tl1[] >>- [1,2,4];\n\t\twrite(\"After l1[] >>- [1,2,4] : \" + sample(l1));\n\t\t// Random things to try out\n\t\t// Using casting back and forth: all number now vary from 1000 to 31000\n\t\tl1 <- list<int>(l1 collect (string(each) + \"1000\"));\n\t\twrite sample(l1);\n\t\t// Removing elements based on a criteria\n\t\tl1 >>- l1 select (each > 20000);\n\t\t// Removing duplicates\n\t\tl1 <- remove_duplicates(l1);\n\t\t// Another way (see \"../Maps.gaml\")\n\t\tl1 <- map(l1).values; \n\t\twrite(sample(l1));\n\t}}\n\t\n}\n\nspecies looping_on_lists {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== LOOPING ON LISTS ==\";\n\t\twrite \"\";\n\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \n\t\t// functional iterations (i.e. filters), one can loop over lists using the imperative\n\t\t// statement 'loop'\n\t\tlist<string> l1 <- list(\"This is a list of strings\");\n\t\twrite sample(l1);\n\t\tint i <- 0;\n\t\tlist l2 <- [];\n\t\t// Here, the value of 's' will be that of each element of the list\n\t\tloop s over: l1 {\n\t\t\ti <- i + 1;\n\t\t\tl2 << \"Word #\" + i + \": \" + s;\n\t\t}\n\t\twrite sample(l2);\n\t\t// 'loop' can also directly use an integer index (remember lists have a zero-based index)\n\t\tl2 <- [];\n\t\tloop k from: 0 to: length(l1) - 1 step:2 {\n\t\t\tl2 << l1[k];\n\t\t}\n\t\twrite sample(l2);\n\t\t// Finally, list containing agents can be the support of implicit loops in the 'ask' statement\n\t\tcreate test_species number: 5 returns: my_agents;\n\t\tl2 <- [];\n\t\task my_agents{\n\t\t\t// attributes of each agent can be directly accessed\n\t\t\tl2 << name;\n\t\t}\n\t\twrite sample(l2);\n\t\t// ... which is formally equivalent to:\n\t\tl2 <- [];\n\t\tl2 <<+ my_agents collect each.name;\n\t\twrite sample(l2);\n\n\t\t// Powerful filter expressions can be built by combining the various 'iterator' operators\n\t\tlist<string> l3 <- list<string>(my_agents where even(int(each))) collect (\"Agent \" + each + \" has an even id\");\n\t\twrite sample(l3);\n\t}\n}\n\nexperiment Lists type: gui {\n\tuser_command \"Declaring lists\" {create declaring_list_attributes;}\n\tuser_command \"Accessing lists\" {create accessing_list_elements;}\n\tuser_command \"Combining lists\" {create combining_lists;}\n\tuser_command \"Modifying lists\" {create modifying_lists;}\n\tuser_command \"Looping on lists\" {create looping_on_lists;}\t\n}"}
{"prompt": "Explain how to declare, access, combine, modify and loop over maps in GAML.", "gaml_code": "/**\n* Name: Maps\n* Author: Alexis Drogoul\n* Description: Examples of the syntax and various operators used to manipulate the 'map' data type. \n* Read the comments and run the model to get a better idea on how to use maps in GAML. \n* Tags: map, loop\n*/\n\nmodel Maps\n\n/* Maps is a data structure consisting of a list of pair<key, value> where each key is unique */\n\nspecies declaring_map_attributes {\n\t\n\t/**\n\t * Declarations of map attributes\n\t */\n\t // The simplest declaration identifies empty_map as a map that can contain any type of objects. \n\t // Its default value will be [] (the empty list/map) if it is not initialized.\n\tmap empty_map;\n\t// To provide it with a literal initial value, use the '<-' (or 'init:') facet and pass a map\n\tmap explicit_empty_map <- [];\n\t// Or, more explicitely\n\tmap explicit_empty_map2 <- map([]);\n\t// Values can be declared litterally in this map, which is nothing more than a list of pair objects\n\tmap explicit_filled_map <- [\"First\"::1, \"Second\"::2];\n\t// If a map is initialized with a list that contains non-pair objects, the pairs element::element are added to the map\n\tmap map_initialized_with_list <- map<int, int>([1,2,3,4]);\n\t// maps can be declared so that they only accept a given type of keys and values\n\t// For instance, empty_map_of_int will accept string keys and integer values\n\tmap<string, int> empty_map_of_int;\n\t// The appropriate casting is realized if the map is initialized with a list of values\n\tmap<string, int> map_of_int_with_init_of_string <- map<string, int>(['10', '20']); // => ['10'::10,'20'::20]\n\t// or with another map\n\tmap<int, float> map_of_float_with_init_of_map <- map<int, float>(map_initialized_with_list); \n\t// When the casting is not obvious, the default values are used\n\t// Here, the list is first casted to return pairs, and they are casted to pair<string, float>\n\tmap<string, float> map_of_float_with_impossible_casting <- map<string, float>(['A','B']); \n\t// maps can of course contain maps\n\tmap<string, map> map_of_maps <- map<string, map>(['A'::[], 'B'::[]]);\n\t// untyped maps can contain heterogeneous objects\n\tmap untyped_map <- [10::'5','11'::5,[12]::[5]];\n\t// the casting applies to all elements when a key and contents type is defined\n\tmap<int, string> recasted_map_with_int_and_string <- map<int, string>(untyped_map); //=> [5,5,0]\n\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== DECLARING MAPS ==\";\n\t\twrite \"\";\n\t\twrite sample(empty_map);\n\t\twrite sample(explicit_empty_map);\n\t\twrite sample(empty_map_of_int);\n\t\twrite sample(explicit_filled_map);\n\t\twrite sample(map_initialized_with_list);\n\t\twrite sample(map_of_int_with_init_of_string);\n\t\twrite sample(map_of_float_with_init_of_map);\n\t\twrite sample(map_of_float_with_impossible_casting);\n\t\twrite sample(map_of_maps);\n\t\twrite sample(untyped_map);\n\t\twrite sample(recasted_map_with_int_and_string);\n\t\twrite \"\";\n\t\t// Declaring temporary variables of type map follows the same pattern\n\t\tmap<int,string> map_of_string <- [1::'A',2::'B',3::'C'];\n\t\t// maps are not always declared litterally and can be obtained from various elements\n\t\t// by using the casting 'map()' operator\n\t\t// for instance, map(species_name) will return a list of all the agents of species_name\n\t\t// using pairs of agent::agent. If the key is explicit, it is used in the casting:\n\t\tcreate test_species number:4;\n\t\tmap<string, test_species> my_agents <- map<string, test_species>(test_species);\n\t\twrite sample(my_agents);\n\t\t// Some special casting operations are applied to specific types, like agents (returns a copy of their attributes)\n\t\twrite sample(map(any(my_agents)));\n\t\t// The 'as_map(pair)' iterator operator also provides a way to build more complex maps\n\t\twrite sample(list(\"This is a string\") as_map (length(each)::each));\n\t\t// As well as \"group_by\" or \"index_by\"\n\t\twrite sample(my_agents index_by (each distance_to {0,0}));\n\t\twrite sample([1,2,3,4,5,6,7] group_by ((each mod 3) = 0));\n \t}\n}\n\nspecies test_species{}\n\nspecies accessing_map_elements {\n\tmap<int, int> l1 <- map<int, int>([1,2,3,4,5,6,7,8,9,10]);\n\tmap<int, string> l2 <- [1::'this',2::'is',3::'a',4::'list', 5::'of',6::'strings'];\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== ACCESSING MAPS ELEMENTS ==\";\n\t\twrite \"\";\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(first(l1));\n\t\twrite sample(last(l1));\n\t\twrite sample(l1 at 1);\n\t\twrite sample(l1[1]);\n\t\twrite sample(length(l1));\n\t\twrite sample(mean(l1));\n\t\twrite sample(max(l1));\n\t\twrite sample(min(l1));\n\t\twrite sample(any(l1));\n\t\twrite sample(3 among l1);\n\t\twrite sample(l1 contains 1);\n\t\twrite sample(l1 contains_all [1,4,6, 14]);\n\t\twrite sample(l1 contains_any [1,23]);\n\t\twrite sample(reverse(l2));\n\t\twrite sample(l1 collect (each + 1));\n\t\twrite sample(l1 collect (norm({each, each, each})));\n\t\twrite sample(l1 where (each > 5));\n\t\twrite sample(l1 count (each > 5));\n\t\twrite sample(l1 group_by (even(each)));\n\t\twrite sample(l2 index_by (each + \"_index\"));\n\t\twrite sample(l1 index_of 100);\n\t\twrite sample(l2 last_index_of 'is');\n\t\twrite sample(l2 sort_by each);\n\t\twrite sample(l2 sort_by length(each));\n\t\twrite sample(l2 first_with (first(each)  = 'o'));\n\t\twrite sample(l2 where (length(each) = 2) );\n\t\twrite sample(l2 with_min_of (length(each)));\n\t\twrite sample(l2 with_max_of (length(each)));\n\t\twrite sample(l2 min_of (length(each)));\n\t\twrite sample(l2 max_of (length(each)));\n\t}\n}\n\nspecies combining_maps {\n\tmap<int, int> l1 <- map<int, int>([1,2,3,4,5,6,7,8,9,10]);\n\tmap<int, int> l2 <- map<int, int>([1,3,5,7,9]);\n\tinit {\n\n\t\twrite \"\";\n\t\twrite \"== COMBINING MAPS ==\";\n\t\twrite \"\";\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(l1 + l2);\n\t\twrite sample(l1 - l2);\n\t\twrite sample(l1 inter l2);\n\t\twrite sample(l1 union l2);\n\t\tmap<int,string> l3 <- map<int, string>(l1 + l2);\n\t\twrite \"map<string> l3 <- l1 + l2; \" + sample(l3);\n\t}\n}\n\nspecies modifying_maps {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== MODIFYING MAPS ==\";\n\t\twrite \"\";\n\t\t// Besides assigning a new value to a map, maps can be manipulated using\n\t\t// the \"add\", \"remove\" and \"put\" statements. \n\t\t// Let's define an empty list supposed to contain integer keys and values\n\t\ttrace { map<int, int> m1 <- [0::0]; \n\t\t// and add some stuff to it using \"add\"\n\t\tadd 1::1 to: m1;\n\t\tadd 2::2 to: m1;\n\t\tadd 3::3 to: m1;\n\t\twrite sample(m1);\n\t\t// the same can be done with the compact syntax introduced in GAMA 1.6.1 for \"add\"\n\t\tm1 <+ 4::4;\n\t\tm1 <+ 5::5;\n\t\twrite sample(m1);\n\t\t// tired of writing lines of add ? The \"all:\" facet is here to serve:\n\t\tadd [6, 7, 8, 9] to: m1 all: true;\n\t\t// or, in a more compact way:\n\t\tm1 <<+ [10,11,12,13];\n\t\twrite sample(m1);\n\t\t// automatic casting applies to any element added to the map\n\t\tm1 <+ int(\"14\");\n\t\t// as well as any container of elements\n\t\tm1 <<+ map<int, int>([15::\"15\", 16::16.0]);\n\t\twrite sample(m1);\n\t\t// elements are by default added to the map while their keys are unique\n\t\t// So, what about replacing some elements once they have been added ?\n\t\t// \"put\" can be used for that purpose\n\t\tput -2 at: 0 in: m1;\n\t\t// or, more simply:\n\t\tm1[0] <- -3;\n\t\t// Trying to put an element outside the \"bounds\" of the map will of course not yield an error\n\t\t m1[20] <- 10; \n\t\twrite sample(m1);\n\t\t// And what about replacing all the values with a new one ?\n\t\tm1[] <- 0;\n\t\twrite(\"m1[] <- 0;\");\n\t\twrite sample(m1);\n\t\t// Well, m1 is a bit boring now, isnt't it ?\n\t\t// Let's fill it again with fresh values\n\t\tloop i over: m1.keys {\n\t\t\tm1[i] <- rnd(3);\n\t\t}\n\t\twrite(sample(m1));\n\t\t// To remove values from it, the \"remove\" statement (and its compact \">-\" form) can be used\n\t\t// WARNING: this form operation on the *values* of the map (i.e. it will remove the first pair\n\t\t// whose value = 0\n\t\tremove 0 from: m1;\n\t\t// it can also be written\n\t\tm1 >- 0;\n\t\twrite(sample(m1));\n\t\t// To remove all occurrences of pairs with a specific value, \"all:\" (or \">>-\") can be used\n\t\t// For instance:\n\t\tm1 >>- 2;\n\t\t// or, written using the long syntactic form\n\t\tremove 1 from: m1 all: true;\n\t\twrite sample(m1);\n\t\t// To remove keys instead, the same syntax can be used, but on the keys of the map (i.e. map[])\n\t\tm1[] >- 1; // This will remove the (unique) pair whose key = 1\n\t\t// The equivalent long syntax is\n\t\tremove key: 1 from: m1;\n\t\t// To remove a set of keys, the following syntax can be used\n\t\tm1[] >>- [2,3,4];\n \t\t// And to remove all the keys present in a given map (using the 'keys' attribute)\n\t\tm1[] >>- m1.keys;\n\t\twrite sample(m1);\n\t\t// By all means, m1 should now be empty! Let's fill it again\n\t\tint i <- 0;\n\t\tloop times: 20 {\n\t\t\ti <- i + 1;\n\t\t\tm1 <+ i::rnd(3);\n\t\t}\n\t\t// Random things to try out\n\t\t// Using the 'pairs' attribute: all number now vary from 1000 to 1003\n\t\tm1 <- m1.pairs as_map (each.key::((each.value) + 1000));\n\t\twrite sample(m1);\n\t\t// Removing values based on a criteria\n\t\tm1 >>- m1 select (each > 1001);\n\t\twrite(sample(m1));\n\t}\n\n\t}\n\t\n}\n\nspecies looping_on_maps {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== LOOPING ON MAPS ==\";\n\t\twrite \"\";\n\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \n\t\t// functional iterations (i.e. filters), one can loop over maps using the imperative\n\t\t// statement 'loop'\n\t\tlist<string> strings <- list(\"This a list of string\");\n\t\twrite sample(strings);\n\t\tmap<string, string> l1 <- strings as_map (first(each)::each);\n\t\twrite sample(l1);\n\t\tint i <- 0;\n\t\tlist l2 <- [];\n\t\t// Here, the value of 's' will be that of each value of each pairs of the list\n\t\tloop s over: l1 { // equivalent to 'loop s over: l1.values'\n\t\t\ti <- i + 1;\n\t\t\tl2 << \"Word #\" + i + \": \" + s;\n\t\t}\n\t\twrite sample(l2);\n\t\t// To loop on the keys of l1, simply use its 'keys' attribute\n\t\tl2 <- [];\n\t\t i <- 0;\n\t\tloop s over: l1.keys{\n\t\t\ti <- i + 1;\n\t\t\tl2 << \"Key #\" + i + \": \" + s;\n\t\t}\n\t\twrite(sample(l2));\n\t\t// Looping on indexes allows to gain access to each element in turn\n\t\tl2 <- [];\n\t\tloop k over: l1.keys {\n\t\t\tl2 <+ l1[k];\n\t\t}\n\t\twrite sample(l2);\n\t\t// Finally, maps containing agents can be the support of implicit loops in the 'ask' statement\n\t\tcreate test_species number: 5 returns: my_agents;\n\t\tmap<int, test_species> map_of_agents <- map<int, test_species>(my_agents);\n\t\twrite(sample(map_of_agents));\n\t\tl2 <- [];\n\t\task map_of_agents{\n\t\t\t// attributes of each agent can be directly accessed\n\t\t\tl2 << name;\n\t\t}\n\t\twrite sample(l2);\n\t\t// Of course, this can be done more simply like this\n\t\tl2 <- map_of_agents collect each.name;\n\t\t}\n\t}\n\n\nexperiment Maps type: gui {\n\tuser_command \"Declaring maps\" {create declaring_map_attributes;}\n\tuser_command \"Accessing maps\" {create accessing_map_elements;}\n\tuser_command \"Combining maps\" {create combining_maps;}\n\tuser_command \"Modifying maps\" {create modifying_maps;}\n\tuser_command \"Looping on maps\" {create looping_on_maps;}\t\n}"}
{"prompt": "Create a GAML model that demonstrates various operations and properties of matrices, including declaring, accessing, combining, modifying, and looping over matrices.", "gaml_code": "/***\n* Name: Matrices\n* Author: Benoit Gaudou\n* Description: Examples of the syntax and various operators used to manipulate the 'matrix' data type. \n* Read the comments and run the model to get a better idea on how to use matrices in GAML. \n* Tags: matrix, loop\n***/\n\nmodel Matrices\n\nspecies declaring_matrix_attributes {\n\t\n\t/**\n\t * Declarations of matrix attributes\n\t */\n\t // The simplest declaration identifies empty_matrix as a matrix that can contain any type of objects. \n\t // Its default value will be [] (the empty matrix) if it is not initialized.\n\tmatrix empty_matrix;\n\t// To provide it with an initial value, use the '<-' (or 'init:') facet\n\tmatrix explicit_empty_matrix <- [];\n\t// matrices can also be provided with a default size, in which case they are filled with a given element\n\tmatrix matrix_of_size_3_3_with_0 <- {3,3} matrix_with 0; // => [[0,0,0],[0,0,0],[0,0,0]]\n\t// matrices can be declared so that they only accept a given type of contents.\n\t// For instance, empty_matrix_of_int will only accept integer elements\n\tmatrix<int> empty_matrix_of_int ;\t\n\t// matrices can be define explicitely by rows\n\t matrix<int> matrix_explicit <- matrix([[1,2,3],[9,8,7]]);\t\n\t// the value passed to 'matrix_with' is verified and casted to the contents type of the matrix if necessary\n\tmatrix<int> matrix_of_int_size_3_3_filled_with_string<- matrix<int>({3,3} matrix_with('1')); // matrix_of_int_size_3_3_filled_with_string is filled with the casting of '1' to int, i.e. 1\n\tmatrix<string> matrix_of_string_size_3_3_filled_with_string <- {3,3} matrix_with('1'); // while matrix_of_string_size_3_3_filled_with_string is filled with the string '1'\n\t// the casting is also realized if the matrix is initialized with a value\n\tmatrix<int> matrix_of_int_with_init_of_string <- matrix<int>([['10', '20'],['30','40']]); // => [[10,20],[30,40]]\n\tmatrix<float> matrix_of_float_with_init_of_string <- matrix<float>(matrix_of_string_size_3_3_filled_with_string); // => [[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0]]\n\t// When the casting is not obvious, the default value is used\n\tmatrix<float> matrix_of_float_with_impossible_casting <- matrix<float>([['A','B'],['C','D']]);   // => [[0.0,0.0],[0.0,0.0]]\n\t// matrices can of course contain lists\n\tmatrix<list> matrix_of_lists <- matrix<list>({5,5} matrix_with [1,2]);\n\t// matrices can of course contain matrices\n\tmatrix<matrix> matrix_of_matrices <- matrix<matrix>({5,5} matrix_with matrix([[1],[2]])) ;\n\t// untyped matrixs can contain heterogeneous objects\n\tmatrix untyped_matrix <- matrix([['5',5],[5,true]]);\n\t// the casting applies to all elements when a contents type is defined (note the default last value of 0)\n\tmatrix<int> recasted_matrix_with_int <- matrix<int>(untyped_matrix); //=> [[5,5],[5,1]]\n\t// Matrices can also been created from other types, such as a list\n\tmatrix<string> matrix_of_string_from_list_3_2 <- ['A','B','C','D','E','F','G'] as_matrix {3,2};\n\t// When the requested dimension exceeds the number of available elements, the empty cells are filled with a nil value.\n\tmatrix<string> matrix_of_string_from_list_3_3 <- ['A','B','C','D','E','F','G'] as_matrix {3,3};\t\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== DECLARING MATRICES ==\";\n\t\twrite \"\";\n\t\twrite sample(empty_matrix);\n\t\twrite sample(explicit_empty_matrix);\n\t\twrite sample(matrix_of_size_3_3_with_0);\n\t\twrite sample(empty_matrix_of_int);\n\t\twrite sample(matrix_explicit);\n\t\twrite sample(matrix_of_int_size_3_3_filled_with_string);\n\t\twrite sample(matrix_of_string_size_3_3_filled_with_string);\n\t\twrite sample(matrix_of_int_with_init_of_string);\n\t\twrite sample(matrix_of_float_with_init_of_string);\n\t\twrite sample(matrix_of_float_with_impossible_casting);\n\t\twrite sample(matrix_of_lists);\n\t\twrite sample(matrix_of_matrices);\n\t\twrite sample(untyped_matrix);\n\t\twrite sample(recasted_matrix_with_int);\n\t\twrite sample(matrix_of_string_from_list_3_2);\t\t\n\t\twrite sample(matrix_of_string_from_list_3_3);\n\t\twrite \"\";\n\n\t\t// Matrices are not always declared litterally and can be obtained from various elements\n\t\t// by using the casting 'matrix()' operator\n\t\t// for instance, matrix(species_name) will return a matrix of all the instances of species_name (as a matrix of one row.\n\t\tcreate test_species number:5;\n\t\tmatrix<test_species> matrix_my_agents <- matrix(test_species);\n\t\twrite sample(matrix_my_agents);\n//\t\tmatrix<test_species> matrix_my_agents_2_2 <- test_species as_matrix {2,2};\n//\t\twrite sample(matrix_my_agents_2_2);\n\t\t// A matrix can also been get from a csv_file (more specifically from its contents)\t\t\n\t\tfile my_csv_file <- csv_file(\"includes/iris_small.csv\",\",\",float,true);\n\t\tmatrix<float> matrix_from_csv_file <- matrix<float>(my_csv_file.contents);\n\t\twrite sample(matrix_from_csv_file);\n \t}\n\n}\n\nspecies test_species {}\n\nspecies accessing_matrix_elements {\n\tmatrix<int> m1 <- matrix([[1,2,3,4],[5,6,7,8]]);\n\tmatrix<string> m2 <- ['this','is','a','matrix', 'of','strings'] as_matrix {3,2};\n\tmatrix<int> m_square <- matrix([[1,2,8],[4,12,6],[7,8,9]]);\t\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== ACCESSING MATRIX ELEMENTS ==\";\n\t\twrite \"\";\n\t\twrite sample(m1);\n\t\twrite sample(m2);\n\t\twrite sample(first(m1));\n\t\twrite sample(last(m1));\n\t\t// Matrices are indexed by a point \n\t\twrite sample(m1 at {0,0});\n\t\twrite sample(m1[{1,3}]);\n\t\twrite sample(length(m1));\n\t\twrite sample(mean(m1));\n\t\twrite sample(max(m1));\n\t\twrite sample(min(m1));\n\t\twrite sample(any(m1));\n\t\twrite sample(3 among m2);\n\t\twrite sample(m1 contains 1);\n\t\twrite sample(m1 contains_all [1,4,6, 14]);\n\t\twrite sample(m1 contains_any [1,23]);\n\t\t// reverse on a matrix is a transpose\n\t\twrite sample(reverse(m2));\n\t\t// collect transforms a matrix into a list\n\t\twrite sample(m1 collect (each + 1));\n\t\t// we thus need to transform again the result list to get a matrix\n\t\twrite sample(m1 collect (each + 1) as_matrix {2,4});\n\t\twrite sample(m1 collect (norm({each, each, each})));\n\t\twrite sample(m1 where (each > 5));\n\t\twrite sample(m1 count (each > 5));\n\t\twrite sample(m1 group_by (even(each)));\n\t\twrite sample(m2 index_by (each + \"_index\"));\n\t\twrite sample(m1 index_of 2);\n\t\twrite sample(m2 last_index_of 'is');\n\t\twrite sample(m2 sort_by each);\n\t\twrite sample(m2 sort_by length(each));\n\t\twrite sample(m2 first_with (first(each)  = 'o'));\n\t\twrite sample(m2 where (length(each) = 2) );\n\t\twrite sample(m2 with_min_of (length(each)));\n\t\twrite sample(m2 with_max_of (length(each)));\n\t\twrite sample(m2 min_of (length(each)));\n\t\twrite sample(m2 max_of (length(each))); \n\t\twrite sample(m2 as_map (length(each)::\"new\"+each));\n\t\t\n\t\t// Rows (resp. columns) can also be accessed\n\t\twrite sample(columns_list(m1));\n\t\twrite sample(rows_list(m1));\t\t\n\t\twrite sample(m1 row_at 1);\n\t\twrite sample(m1 column_at 1);\n\t\t\n\t\t// Some classical operators of matrix computation have been introduced\n\t\twrite sample(det(m_square));\n\t\twrite sample(determinant(m_square));\n\t\twrite sample(eigenvalues(m_square));\n\t\twrite sample(inverse(m_square));\n\t\twrite sample(trace(m_square)); \n\t\twrite sample(transpose(m_square));\t\t\n\t}\n}\n\nspecies combining_matrices {\n\tmatrix<int> m1 <- matrix([[1,2,3],[4,5,6],[7,8,9]]);\n\tmatrix<int> m2 <- [1,3,5,7,9,11] as_matrix {3,2};\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== COMBINING MATRICES ==\";\n\t\twrite \"\";\n\t\twrite sample(m1);\n\t\twrite sample(rows_list(m1));\n\t\twrite sample(m2);\n\t\twrite sample(rows_list(m2));\t\t\n\t\twrite sample(m1 + m1);\n\t\twrite sample(m2 - m2);\n\t\t// inter between 2 matrices returns the list of all the elements part of both matrices.\n\t\twrite sample(m1 inter m2);\n\t\t// union between 2 matrices returns the list of all the elements part at least in one of the two matrices.\n\t\twrite sample(m1 union m2);\n\t\twrite sample(interleave ([m1,m1]));\n\t\tmatrix<string> m3 <- matrix<string>(m1 + m1);\n\t\twrite \"matrix<string> m3 <- m1 + m2; \" + sample(m3);\n\t\twrite sample(m1 as list<float>);\n\t\twrite sample(2 * m1);\n\t\twrite sample(2 + m1);\n\t\t\n\t\twrite sample(m1 * m1);\n\t\twrite sample(m1 / m1);\n\t\t\n\t\t// Multiplication between matrices : * is the product element by element, whereas . is the matrices multiplication\n\t\twrite sample(m1 . m1);\n\t\twrite sample(m2 . transpose(m2));\n\t\t\t\t\n\t\twrite sample(m1 append_horizontally m1);\t\t\t\n\t\t// Notice that when the 2 matrices do not have the same number of rows, m2 is considered as being 3x3.\n\t\t// The matrix is completed by 0 and thus becomes matrix<int>([[1,9,0],[7,5,0],[3,11,0]])\n\t\twrite sample(m1 append_horizontally m2);\n\t\t// m1 dimension is set to the m2 dimension\n\t\twrite sample(m2 append_horizontally m1);\t\t\n\t\twrite sample(m1 append_vertically m1);\n\t\twrite sample(m1 append_vertically m2);\n\n\t\t\n\t\t// Some combinations of matrices are not possible\n\t\twrite \"Following computations have errors due to incompatible sizes\";\n\t\ttry {\n\t\t\twrite sample(m1 + m2);\t\t\t\n\t\t} catch { \n\t\t\twrite \"m1 + m2 : \" + m1 + \" + \" + m2 + \" are not compatibble to sum.\";\n\t\t}\n\t\ttry {\n\t\t\twrite sample(m2 . m2);\t\t\t\n\t\t} catch { \n\t\t\twrite \"m2 . m2 : \" + m2 + \" . \" + m2 + \" are not compatibble to multiply (in the sense of the matrices multiplication).\";\n\t\t}\t\t\n\t}\n}\n\nspecies looping_on_matrices {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== LOOPING ON MATRICES ==\";\n\t\twrite \"\";\n\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \n\t\t// functional iterations (i.e. filters), one can loop over matrices using the imperative\n\t\t// statement 'loop'\n\t    matrix<string> matrix_of_strings <- matrix([[\"A\",\"matrix\"],[\"of\",\"strings\"]]);\n\t\twrite sample(matrix_of_strings);\n\t\t\n\t\tint i <- 0;\n\t\t// Here, the value of 's' will be that added to each element of the matrix\n\t\tloop s over: matrix_of_strings {\n\t\t\ti <- i + 1;\n\t\t\twrite \"Word #\" + i + \": \" + s;\n\t\t}\n\n\t\t// 'loop' can also directly use two integer indices (remember matrices have a zero-based index)\n\t\tloop index_row from: 0 to: matrix_of_strings.rows - 1 {\n\t\t\tloop index_column from: 0 to: matrix_of_strings.columns - 1 {\n\t\t\t\twrite \"The element at row: \" + (index_row+1) + \" and column: \" + (index_column+1) + \" of the matrix is: \" + matrix_of_strings[index_column,index_row];\t\t\t\t\n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\nspecies modifying_matrices {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== MODIFYING MATRICES ==\";\n\t\twrite \"\";\n\t\ttrace {\n\t\t\t// Besides assigning a new value to a matrix, matrices can be manipulated using\n\t\t\t// the \"put\" statements. \n\t\t\t// Notice that they have a fix size (number of elements). \n\t\t\t// As a consequence, add and remove cannot be used on a matrix.\n\t\t    matrix<string> matrix_of_strings <- matrix([[\"A\",\"matrix\"],[\"of\",\"strings\"]]);\n\t\t\twrite sample(matrix_of_strings);\n\t\t\tput \"Two\" in: matrix_of_strings at: {0,0};\t\n\t\t\tput \"matrices\" in: matrix_of_strings at: {0,1};\t\t\t\n\t\t\twrite sample(matrix_of_strings);\n\t\t\t\n\t\t\t// The two previous put called can be replaced bby an assignement \n\t\t\t// Let revert the previous modifications\n\t\t\tmatrix_of_strings[{0,0}] <- \"A\";\t\n\t\t\tmatrix_of_strings[{0,1}] <- \"matrix\";\t\n\t\t\t\n\t\t\twrite sample(matrix_of_strings);\n\t\t\t\n\t\t\t// All the values can also be replaced\n\t\t\t// Let set all the values in the matrix to empty string\n\t\t\tput \"\" in: matrix_of_strings all: true;\n\t\t\twrite sample(matrix_of_strings);\n\t\t}\n\t}\n}\n\nexperiment Matrices type: gui {\n\tuser_command \"Declaring matrices\" {create declaring_matrix_attributes;}\t\n\tuser_command \"Accessing matrix elements \" {create accessing_matrix_elements;}\t\n\tuser_command \"Combining Matrices \" {create combining_matrices;}\t\n\tuser_command \"Modifying Matrices\" {create modifying_matrices;}\n\tuser_command \"Looping on Matrices \" {create looping_on_matrices;}\n}"}
{"prompt": "Explore and demonstrate various casting operations in GAML for different data types.", "gaml_code": "/**\n* Name: Casting Syntax\n* Author: A. Drogoul & P. Taillandier\n* Description: different ways of transforming objects and agents in GAML.\n* Tags: cast, type\n*/\n\nmodel Casting\n\nspecies cast_to_int {\n\tinit {\n\t\twrite sample(int(1));\n\t\twrite sample(int(1.0));\n\t\twrite sample(int(\"1\"));\n\t\twrite sample(int(\"1.0\"));\n\t\twrite sample(int(#pink));\n\t\twrite sample(int(true));\n\t\twrite sample(int(false));\n\t\twrite sample(int(self));\n\t\twrite sample(int([]));\n\t\twrite sample(int([10,11]));\n\t\twrite sample(int({1,2,3}));\n\t\twrite sample(int(3::4));\n\t\twrite sample(int([3::4]));\n\t\twrite sample(int(#meter));\t\t\t\t\n\t}\n}\n\n\nspecies cast_to_float{\n\tinit {\n\t\twrite sample(float(1));\n\t\twrite sample(float(1.0));\n\t\twrite sample(float(\"1\"));\n\t\twrite sample(float(\"1.0\"));\n\t\twrite sample(float(#pink));\n\t\twrite sample(float(true));\n\t\twrite sample(float(false));\n\t\twrite sample(float(self));\n\t\twrite sample(float([]));\n\t\twrite sample(float([1]));\n\t\twrite sample(float(1::2));\n\t\twrite sample(float([1::2]));\n\t\twrite sample(float({1,2,3}));\n\t\twrite sample(float(#meter));\t\t\t\t\n\t}\n}\n\n\nspecies cast_to_string{\n\tinit {\n\t\twrite sample(string(1));\n\t\twrite sample(string(1.0));\n\t\twrite sample(string(\"1\"));\n\t\twrite sample(string(\"1.0\"));\n\t\twrite sample(string(#pink));\n\t\twrite sample(string(true));\n\t\twrite sample(string(false));\n\t\twrite sample(string(self));\n\t\twrite sample(string([]));\n\t\twrite sample(string([0]));\n\t\twrite sample(string({0,0,0}));\n\t\twrite sample(string(#meter));\t\t\t\t\n\t}\n}\n\nspecies cast_to_point{\n\tinit {\n\t\twrite sample(point(1));\n\t\twrite sample(point(1.0));\n\t\twrite sample(point(\"1\"));\n\t\twrite sample(point(\"1.0\"));\n\t\twrite sample(point(#pink));\n\t\twrite sample(point(true));\n\t\twrite sample(point(false));\n\t\twrite sample(point(self));\n\t\twrite sample(point([]));\n\t\twrite sample(point([2]));\n\t\twrite sample(point(1::2));\n\t\twrite sample(point([1::2]));\n\t\twrite sample(point({1,2,3}));\n\t\twrite sample(point(#meter));\t\t\t\t\n\t}\n}\nspecies cast_to_list{\n\tinit {\n\t\twrite sample(list(1));\n\t\twrite sample(list(1.0));\n\t\twrite sample(list(\"1\"));\n\t\twrite sample(list(\"1.0\"));\n\t\twrite sample(list(#pink));\n\t\twrite sample(list(true));\n\t\twrite sample(list(false));\n\t\twrite sample(list(self));\n\t\twrite sample(list([]));\n\t\twrite sample(list([0]));\n\t\twrite sample(list(1::2));\n\t\twrite sample(list([1::2]));\t\n\t\twrite sample(list({1,2,3}));\n\t\twrite sample(list(#meter));\t\t\t\t\n\t}\n}\nspecies cast_to_pair{\n\tinit {\n\t\twrite sample(pair(1));\n\t\twrite sample(pair(1.0));\n\t\twrite sample(pair(\"1\"));\n\t\twrite sample(pair(\"1.0\"));\n\t\twrite sample(pair(#pink));\n\t\twrite sample(pair(true));\n\t\twrite sample(pair(false));\n\t\twrite sample(pair(self));\n\t\twrite sample(pair([]));\n\t\twrite sample(pair([1]));\n\t\twrite sample(pair(1::2));\n\t\twrite sample(pair([1::2]));\n\t\twrite sample(pair({1,2,3}));\n\t\twrite sample(pair(#meter));\t\t\t\t\n\t}\n}\nspecies cast_to_map{\n\tinit {\n\t\twrite sample(map<float, int>(1.5#meter));\n\t\twrite sample(map(1));\n\t\twrite sample(map(1.5));\n\t\twrite sample(map(\"1\"));\n\t\twrite sample(map(\"1.0\"));\n\t\twrite sample(map(#pink));\n\t\twrite sample(map(true));\n\t\twrite sample(map(false));\n\t\twrite sample(map(self));\n\t\twrite sample(map([]));\n\t\twrite sample(map([1]));\n\t\twrite sample(map([1,2,3]));\n\t\twrite sample(map(1::2));\n\t\twrite sample(map([1::2]));\n\t\twrite sample(map({1,2,3}));\n\t\twrite sample(map<int,string>(1));\t\t\t\t\n\t}\n}\nexperiment Casting type: gui{\n\tuser_command \"to int\" {create cast_to_int;}\n\tuser_command \"to float\" {create cast_to_float;}\n\tuser_command \"to string\" {create cast_to_string;}\n\tuser_command \"to point\" {create cast_to_point;}\n\tuser_command \"to list\" {create cast_to_list;}\n\tuser_command \"to pair\" {create cast_to_pair;}\n\tuser_command \"to map\" {create cast_to_map;}\n}"}
{"prompt": "Show me a comprehensive overview of GAML's built-in constants and units, including mathematical, graphical, and time-related values, as well as examples of how to use them in displays.", "gaml_code": "/***\n* Name: Units and constants\n* Author: Benoit Gaudou\n* Description: The model illustrates all the possible constants (including units) existing in  GAML.\n* Tags: unit, constant\n***/\n\nmodel UnitsAndConstants\n\nglobal {\n\tinit {\n\t\t// Constants related to errors\n\t\tdo constant_current_err;\n\t\twrite \"\";\n\t\t\n\t\t// Mathematical classical constants\n\t\tdo constant_math;\n\t\twrite \"\";\n\t\t\n\t\t// Classical unit constants\n\t\tdo length_surface_time_units;\n\t\twrite \"\";\n\t\t\n\t\t// Time constants\n\t\tdo time_units;\t\t\n\t\t\n\t\t// The experiment allows to illustrate all the constant related to graphical aspects.\n\t}\n\n\t// #current_error contains the last error that have been thrown during the current execution.\n\taction constant_current_err {\n\t\twrite \"Constant related to system state (e.g. the last thrown error)\";\n\t\twrite \"=============================================================\";\n\t\ttry {\n\t\t\tfloat error <- 1 / 0;\n\t\t} catch {\n\t\t\twrite \"A \" + #current_error + \" is caught\";\n\t\t}\n\t\twrite \"\";\n\t}\n\t\n\t// Constants include the main mathematical constants (such as pi, e ...)\n\taction constant_math {\n\t\twrite \"Mathematical constants (#e, #pi, #max_float ...)\";\n\t\twrite \"=================================================\";\t\t\n\t\t// #e constant is characterized by the relation ln(#e) = 1\n\t\twrite sample(ln(#e));\n\t\t\n\t\t// Constants include the min and max numbers for integers and floats\n\t\t// #max_int (resp.  #min_int) are the minimum (resp. maximum) possible values for integer variables.\n\t\t// As a consequence, #max_int + 1 is out of the possible values of integers, and thus returns the maximum negative value.\n\t\twrite sample(int(#max_int));\t\t\n\t\twrite sample(int(#max_int) + 1);\n\t\twrite sample(int(#min_int));\n\t\twrite sample(int(#min_int) - 1);\n\t\t// #max_float is the maximum float value, whereas #min_float is the minimum *positive* value.\n\t\twrite sample(#max_float);\n\t\twrite sample(#min_float);\n\t\t// #infinity (and #nan) contains the positivie infinity value: so most of the computations involving #infinity return #infinity\n\t\twrite sample(#infinity * 3);\n\t\twrite sample(#infinity / - 7);\n\t\t// Only few computations involving #infinity do not return #infinity \n\t\twrite sample(#infinity / #infinity);\n\t\twrite sample(0 / #infinity);\n\t\t\n\t\t// #to_deg and #to_rad can be used to convert angle value between radius to degree: 2 * pi rad = 360 degrees.\n\t\twrite sample(2 * #pi * #to_deg);\n\t\twrite sample(180 * #to_rad);\n\t\t\n\t}\n\t\n\t// GAML provides many units. The basic units are meter, kilogram, m2, m3 and second. \n\t// All the other units are converted to the corresponding basic one.\n\taction length_surface_time_units {\n\t\twrite \"Units-related constants (meter, m2, m3, kg and second)\";\n\t\twrite \"=================================================\";\t\t\n\t\twrite \" *** The basic units are: ***\";\t\t\t\n\t\twrite sample(1#m)  + \"(#m, for length)\";  \t// can also be written #meter, #meters\n \t\twrite sample(1#m2) + \"(#m2, for surface)\";  \t\n \t\twrite sample(1#m3) + \"(#m3, for volume)\";\n\t\twrite sample(1#kg) + \"(#kg, for weight)\"; \t// can also be written #kilo, #kilogram, #kilos\n\t\twrite sample(1#s)  + \"(#s, for time)\";  \t// can also be written #sec, #second, #seconds,\n\t\t\n\t\twrite \" *** Metrics length units: ***\";\t\t\t\n \t\twrite sample(1#km) + \" (#m)\";   // can also be written #kilometer, #kilometers\n  \t\twrite sample(1#dm) + \" (#m)\";   // can also be written #decimeter, #decimeters\t\t\n  \t\twrite sample(1#cm) + \" (#m)\";   // can also be written #centimeter, #centimeters\t\n \t\twrite sample(1#mm) + \" (#m)\";\t// can also be written #milimeter, #milimeters\n \t\twrite sample(1#micrometer) + \"#m\";\t// can also be written #micrometers\n \t\t\n \t\t// GAMA also provides non-metrics units such as foot, inch, mile and yard.\n\t\twrite \" *** Non-Metrics length units: ***\";\t\t\t\n \t\twrite sample(1#ft) + \" (#m)\";  \t// can also be written #foot, #feet\n \t\twrite sample(1#inch) + \" (#m)\";   // can also be written #inches\n  \t\twrite sample(1#mile) + \" (#m)\";  // can also be written #miles\t\t\n  \t\twrite sample(1#yard) + \" (#m)\";  // can also be written #yards\t\n \t\t\n\t\t//Surface units\n\t\twrite \" *** Surface units: ***\";\t\t\t\t\t\n \t\twrite sample(1#sqft) + \" (#m2)\";   // can also be written #square_foot, #square_feet\n  \t\twrite sample(1#sqin) + \" (#m2)\";   // can also be written #square_inch, #square_inches\t\n  \t\twrite sample(1#sqmi) + \" (#m2)\";\n  \t\t\n  \t\t// Volume units \n\t\twrite \" *** Volume units: ***\";\t\t\t\t\t\n \t\twrite sample(1#cl) + \" (#m3)\";   // can also be written #centiliter, #centiliters\n  \t\twrite sample(1#dl) + \" (#m3)\";   // can also be written #deciliter, #deciliters\t\n  \t\twrite sample(1#hl) + \" (#m3)\";   // can also be written #hectoliter, #hectoliters\t\n   \t\twrite sample(1#l)  + \" (#m3)\";   // can also be written #liter, #liters, #dm3\t \t\t\n  \t\t\t\n\t\t//Weight units\n\t\twrite \" *** Weight units: ***\";\t\t\t\t\t\n \t\twrite sample(1#gram) + \" (#kg)\";   // can also be written #gram\n  \t\twrite sample(1#ton) + \" (#kg)\";   // can also be written #tons\n  \t\twrite sample(1#lton) + \" (#kg)\";   // can also be written #longton\t\n  \t\twrite sample(1#ounce) + \" (#kg)\";   // can also be written #oz, #ounces\t\n   \t\twrite sample(1#pound)  + \" (#kg)\";   // can also be written #lb,#pounds,#lbm\t\t\n  \t\twrite sample(1#shortton) + \" (#kg)\";   // can also be written #ston\t\n  \t\twrite sample(1#stone) + \" (#kg)\";   // can also be written #st\n\n\t\t//Time units\n\t\twrite \" *** Time units: ***\";\t\t\t\t\t\t\t\n\t\twrite sample(1#ms) + \" (#s)\";   // can also be written #millisecond, #milliseconds, #msec\t\t\n \t\twrite sample(1#mn) + \" (#s)\";   // can also be written #minute, #minutes\n \t\twrite sample(1#h) + \" (#s)\";   // can also be written #hour, #hours\n\t\twrite sample(1#day) + \" (#s)\";   // can also be written #days\n\t\twrite sample(1#week) + \" (#s)\";   // can also be written #weeks\n\t\t\n\t\t// Time not correct units (in the sense that they are ambiguous concept in terms of duration)\n\t\twrite \"1 #month :-\" + #month + \" (#s - NOTE: this is the duration of 30 days. This is an ambiguous duration in natural language.)\";   // can also be written #months\n\t\twrite \"1 #year  :-\" + #year + \"(#s - NOTE: this is the duration of 365 days. This is an ambiguous duration in natural language.)\";   // can also be written #years, #y\n\t\t\n\t}\n  \t\n  \taction \ttime_units {\n \t\twrite \"Time-related constants \";\t\t\n\t\twrite \"=================================================\";\t\t\n \t\twrite \" *** Additional constants related to time: ***\";\t\t\t\n \t\twrite sample(#now) + \" is the current date.\";  \n  \t\twrite sample(#cycle) + \" corresponds to 1 cycle\";  \n\t\twrite \"This constant is used to force a temporal expression to be expressed in terms of cycles rather than seconds\";\n    \twrite sample(#custom) + \" : is the custom date/time defined in the preferences of GAMA.\";  \n  \t   \twrite sample(#epoch) + \" : is the default starting date (defined by the ISO format (1970-01-01T00:00Z)).\"; \n  \t   \t\n  \t   \twrite \"The 3 following constants can be used as output/parsingformat for local dates (\"+#iso_local+\"), dates with a time offset (\"+#iso_offset+\") \";\n  \t   \twrite \"and dates with time zone (\"+#iso_zoned+\").\";  \t\n\t}\n\n\t\n\n}\n\n\n\t\n// Constants include many graphical constants (that can be used only in displays or to define some graphical objects such as font ...).\n// In addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). \n// E.g, #teal, #aliceblue, antiquewhite .... (Model menu in GAMA lists all of them). \nexperiment exp {\n\t\n\t// #bold, #italic and #plan can be used to defin the font style (#bbold and #italic can be combined).\n\tfont my_font_bold <- font(\"Helvetica\", 12, #bold);\n\tfont my_font_italic <- font(\"Arial\", 12, #italic);\n\tfont my_font_bold_italic <- font(\"SansSerif\", 12, #bold + #italic);\n\tfont my_font_plain <- font(\"Helvetica\", 12, #plain);\n\t\n\t// Anchor constants are used to locate text to display in a text area.\n\tmap<string, point> anchors <- [\"center\"::#center, \"top_left\"::#top_left, \"left_center\"::#left_center, \"bottom_left\"::#bottom_left, \n\t\t\"bottom_center\"::#bottom_center, \"bottom_right\"::#bottom_right, \"right_center\"::#right_center, \"top_right\"::#top_right, \n\t\t\"top_center\"::#top_center];\n\n\toutput {\n\t\t// GAML provides several ways to split the various displays (at the launch of the simulation).\n\t\t// Each of them can be set using the one of the following constants:\n\t\t// #horizontal, #vertical, #stack, #split (displays split in a grid-like structure) or #none (no split).\t\n\t\tlayout #split;\n\t\tdisplay \"Strings 2D\" type: 2d {\n\t\t\tgraphics Strings {\n\t\t\t\tdraw world.shape wireframe: true color: #black;\n\t\t\t\tint y <- 7;\n\t\t\t\t\n\t\t\t\t// The loop displays for each anchor an associated text\n\t\t\t\tloop p over: anchors.pairs {\n\t\t\t\t\tdraw circle(0.5) at: {50, y} color: #red;\n\t\t\t\t\tdraw p.key at: {50, y} anchor: p.value color: #black font: my_font_bold_italic;\n\t\t\t\t\ty <- y + 7;\n\t\t\t\t}\n\n\t\t\t\t// These anchors can also been defined at hand using a point\n\t\t\t\tdraw circle(0.5) at: {50, y} color: #red;\n\t\t\t\tdraw \"custom {0.6, 0.1}\" at: {50, y} anchor: {0.6, 0.1} color: #black font: my_font_italic;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"Strings 3D\" type: 3d {\n\t\t\t// #pixels (or #px) corresponds to the value of one pixel, depending on the display, zoom...\n\t\t\t// So pixel is used to define the dimension of an overlay in order to keep it size constant.\n            overlay position: { 0, 0 } size: { 300 #pixels, 200 #px } background: #grey transparency: 0.2 border: #black rounded: true {\n            \t// Constant contain useful information about the way of vizualising the simulation with: the camera location (#camera_location), \n            \t// orientation (#camera_orientation) and target (#camera_target). \n                draw \"Camera location:  \" + string(#camera_location with_precision 3) at:{10#px,20#px,0#px} color: #black font: my_font_plain;\n\t\t\t\tdraw \"Camera orientation:  \" + string(#camera_orientation with_precision 3) at:{10#px,40#px,0} color: #black font: my_font_plain;\n\t\t\t\tdraw \"Zoom level:  \" + string(#zoom) at:{10#px,60#px,0} color: #black font: my_font_plain;\t\n\t\t\t\t// #display_height and #display_width contain the size in pixel of the simulation environment.\n\t\t\t\t// It obviously depends on the zoom level.\t\t\n\t\t\t\tdraw \"Display height:  \" + string(#display_height) at:{10#px,80#px,0} color: #black font: my_font_plain;\t\t\t\t  \t\t\n\t\t\t\tdraw \"Display width:  \" + string(#display_width) at:{10#px,100#px,0} color: #black font: my_font_plain;\t\t\t\t  \t\t  \n\t\t\t}\n\t\t\t\t\t\n\t\t\t// We can access location of the mouse in the display using #mouse_location.\n\t\t\tgraphics circle_mouse {\t\n\t\t\t\t// We can also access the #zoom level: we can thus display a visual element depending on the zoom level, to keep visible some \n\t\t\t\t// elements even when we zoom out.\n\t\t\t\t// We display a sphere at the location of the mouse (with a size depending on the zoom).\n\t\t\t\tdraw sphere(1.0/#zoom) color: #green at: #user_location;\n\t\t\t\tdraw \"       \" +string(#user_location with_precision 3)  at: #user_location color: #black font:font(\"Helveetica\", max(1,14/#zoom), #plain);\n\n\t\t\t\t// We can also visualize the target point of the camera.\n\t\t\t\tdraw sphere(1.0/#zoom ) at: #camera_target color: #red ;\n\t\t\t\tdraw \"       \" +string(#camera_target with_precision 3)   \n\t\t\t\t\tat:#camera_target color: #black font:font(\"Helveetica\", max(1,14/#zoom), #plain);//anchor: #bottom_center;\n\t\t\t\t\t\n\t\t\t\t// A buffer extends a line as a geometry. This buffer can be set #square, #round or #flat\n\t\t\t\t// Note that #flat and #square are both a buffer with a square shape, but the flat stop the rectangle at the limit of the line. \n\t\t\t\tdraw line([#user_location + {1.0/#zoom ,0,0}, #user_location - {1.0/#zoom ,0,0}]) buffer(0.5/#zoom ,0.5/#zoom ,#flat)  at:#user_location color: #black ;\n\t\t\t\tdraw line([#user_location + {0,1.0/#zoom ,0}, #user_location - {0,1.0/#zoom ,0}]) buffer(0.5/#zoom ,0.5/#zoom ,#square) at:#user_location color: #black ;\t\t\t\t\t\n\t\t\t\tdraw line([#user_location + {1.0/#zoom ,0,0}, #user_location - {1.0/#zoom ,0,0}]) at:#user_location color: #red ;\n\t\t\t\tdraw line([#user_location + {0,1.0/#zoom ,0}, #user_location - {0,1.0/#zoom ,0}]) at:#user_location color: #red ;\t\t\t\t\t\t\n\t\t\t}\n\t\t\tevent #mouse_move {\t\t\t\n\t\t\t\tdo update_outputs;\t\t\n\t\t\t}\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that demonstrates the usage of 'init', 'reflex', and 'abort' commands, including user confirmation for simulation termination.", "gaml_code": "/**\n* Name: Abort\n* Shows the usage of 'abort' and 'init'\n* Author: drogoul\n* Tags: abort, init\n*/\nmodel Abort\n\nglobal {\n\n\tinit {\n\t\twrite \"Simulation executes 'init' and creates one agent of species a\";\n\t\tcreate a;\n\t\twrite \"Simulation kills itself\";\n\t}\n\n\treflex {\n\t\twrite \"Simulation does nothing\";\n\t}\n\n\tabort {\n\t\twrite \"Simulation executes 'abort' and kills the agents of species a\";\n\t\task a {\n\t\t\tdo die;\n\t\t}\n\n\t}\n\n}\n\nspecies a {\n\n\tinit {\n\t\twrite \"Agent of species a executes init\";\n\t}\n\n\treflex {\n\t\twrite \"Neither does agent of species a\";\n\t\tif (user_confirm(\"Close simulation\", \"Should we close the simulation ?\")) {\n\t\t\task world {\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tabort {\n\t\twrite \"Agent of species a executes abort\";\n\t}\n\n}\n\nexperiment \"Run me\" {\n\tabort {\n\t\tdo tell(\"You are now leaving this experiment. Hope you enjoyed it ! \", false);\n\t}\n\n}"}
{"prompt": "How to use date variables and manipulate dates in a simulation model, including parsing, formatting, and performing calculations on dates.", "gaml_code": "/**\n* Name: Use of the Date variables\n* Author:  Patrick Taillandier\n* Description: A model to show how to use date variables and more particularly the starting_date and current_date global variables.\n* Tags: date, time\n*/\n@no_warning\nmodel date_model \n\nglobal {\n\t\n\t//definition of the date of begining of the simulation - defining this date will allows to change the normal date management of the simulation by a more realistic one (using calendar) \n\tdate starting_date <- date([2011,1,2,1,1,30]);\n\t\n\t//be careful, when real dates are used, modelers should not use the #month and #year values that are not consistent with them\n\t//#ms, #s, #mn, #h, #day represent exact durations that can be used in combination with the date values\n\t\n\t\n\tfloat step <- 2#year; \n\t\t\n\tinit {\n\t\twrite \"starting_date: \" + starting_date;\n\t\t\n\t\t//there are several ways to define a date.\n\t\t//The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]\n\t\tdate my_date <- date([2010,3,23,17,30,10]); //correspond the 23th of March 2010, at 17:30:10\n\t\t\n\t\t//It is also possible to define a date through a string that respects the ISO format\n\t\tdate my_date2 <- date(\"2010-03-23T17:30:10+07:00\"); \n\t\twrite sample(my_date2);\n\t\t//The format can omit the 'T' for time\n\t\tdate my_date3 <- date(\"2010-03-23 17:30:10+07:00\"); \n\t\t//And also omit time zones / offset informations\n\t\tmy_date3 <- date(\"2010-03-23 17:30:10\"); \n\t\t//Dates (without time) can be defined also using the ISO basic format with no separators\n\t\t my_date3 <- date(\"20100323\");\n\t\t\n\t\t//Or the normal ISO date format with no time / timezone information\n\t\tmy_date3 <- date(\"2013-03-23\");\n\t\twrite sample(my_date2);\n\t\twrite sample(my_date3);\n\t\t// Finally, dates can also be parsed using a custom pattern if one encounters it in a data file, for instance (see https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns) \n\t\twrite(sample(date(\"01 23 2000\",\"MM dd yyyy\")));\n\t\t// Parsed dates that only represent hours will be parsed as departing from the starting_date of the model\n\t\twrite(sample(date(\"01 23 20\",\"HH mm ss\")));\n\t\t//it is possible to get the current date by using the \"now\" string:\n\t\tdate today <- date(\"now\"); \n\t\twrite (today);\n\t\t\n\t\twrite \"\\n ----------------------------------------------- \" ;\n\t\t\n\t\t//GAMA provides several operator to manipulate dates:\t\n\t\t\t\n\t\t//for instance, it is possible to compute the duration in seconds between 2 dates:\n\t\tfloat d <- starting_date - my_date;\n\t\twrite \"duration between \" + my_date2 + \" and \" + starting_date + \" : \" + d + \"s\";\n\t\t\n\t\twrite \"\\n ----------------------------------------------- \" ;\n\t\t\n\t\t//to add or subtract a duration (in secondes) to a date:\n\t\t write sample(my_date2 + 10);\n\t\t write sample(my_date2 - 10);\n\t\t \n\t\t write \"\\n ----------------------------------------------- \" ;\n\t\t \n\t\t // Dates can be compared\n\t\t write sample(my_date2 > my_date3);\n\t\t write sample(#now < my_date3);\n\t\t \n\t\t // Dates can be easily casted from and to other values\n\t\t write \"Casting to float returns the number of seconds of this date since the starting_date of the model: \" + sample(float(my_date3));\n\t\t write \"Casting to list returns a list with the year, month, day, hour, minute, second: \" + sample(list(my_date2));\n\t\t \n\t\t //to add or subtract a duration (in years, months, weeks, days, hours, minutes,  secondes) to a date, use the plus_* (or add_*) / minus_* (or subtract_*) operators\n\t\t  write sample(my_date2 plus_years 1);\n\t\t  write sample(my_date2 plus_months 1);\n\t\t  write sample(my_date2 plus_weeks 1);\n\t\t  write sample(my_date2 plus_days 1);\n\t\t  write sample(my_date2 plus_hours 1);\n\t\t  write sample(my_date2 plus_minutes 1);\n\t\t  write sample(my_date2 plus_seconds 1);\n\t\t  // The three latter examples are equivalent to using the built-in GAMA units\n\t\t  write(sample(my_date2 + 1#d));\n\t\t  write(sample(my_date2 + 1#h));\n\t\t  write(sample(my_date2 + 1#mn));\n\t\t  write(sample(my_date2 + 1#s));\n\t\t  // Adding milliseconds can be done too\n\t\t  write(sample((my_date2 + 0.7) + 0.7)); // should add a second and 400 milliseconds\n\t\t  // Subtraction follows the same rules\n\t\t  write sample(my_date2 minus_years 1);\n\t\t  write sample(my_date2 minus_months 1);\n\t\t  write sample(my_date2 minus_weeks 1);\n\t\t  write sample(my_date2 minus_days 1);\n\t\t  write sample(my_date2 minus_hours 1);\n\t\t  write sample(my_date2 minus_minutes 1);\n\t\t  write sample(my_date2 minus_seconds 1);\n\t\t  // And the same equivalence with the 4 last ones\n\t\t  write(sample(my_date2 - 1#day));\n\t\t  write(sample(my_date2 - 1#h));\n\t\t  write(sample(my_date2 - 1#mn));\n\t\t  write(sample(my_date2 - 1#s));\n\t\t  // As the units #month and #year represent ideal durations (and not actual months or years in a chronology) they cannot be used like #day, #h, #mn or #s.\n\t\t  // For instance, these two expressions return false\n\t\t  write(sample((#now plus_months 5 plus_days 2) = (#now + 5#months + 2#days)));\n\t\t  write(sample(#now - (#now minus_months 5) = 5#month));\n\t\t  \n\t\t  // Dates can be formatted in different ways (see https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns) \n\t\t  \n\t\t  write  string(my_date2, \"MM dd yyyy\");\n\t\t  write  string(my_date2, \"HH:mm:ss\");\n\t\t  write  string(my_date2, \"'Week 'w' of 'yyyy\");\n\t\t  \n\t\t  // For models that do not define a starting_date, GAMA uses a pseudo-starting date represented by the ISO notion of the 'epoch' day (1970-01-01T00:00Z), accessible in GAMA with the constant #epoch\n\t\t  // This allows to output a current date that represents the duration from this zero-date. \n\t\t  starting_date <- #epoch;\n\t\t  write sample(current_date + 3#day);\n\t\t  starting_date <- #now;\n\t\t  \n\t\t // Consistency with existing variables in enforced.  For instance, machine_time can now be obtained in the following way:\n\t\t write \"Machine time value = \" + sample(gama.machine_time);\n\t\t write \"Other way to obtain the same value = \" + sample(milliseconds_between(#epoch, #now));\n\t\t \n\t\t // This allows precise computations of hours, minutes, seconds, etc. \n\t\t write \"Hours between \" + my_date2 + \" and \" + #now + \" = \" + int(milliseconds_between(my_date2, #now) / #hours);\n\t\t write \"Days between \" + my_date2 + \" and \" + #now + \" = \" + int(milliseconds_between(my_date2, #now) / #days);\n\t\t // However, months and years have to use dedicated operators, since they dont capture the notion of duration correctly\n\t\t write \"Months between \" + my_date2 + \" and \" + #now + \" = \" + (months_between(my_date2, #now)); \n\t\t  write \"Years between \" + my_date2 + \" and \" + #now + \" = \" + (years_between(my_date2, #now)); \n\t\t  write \"Milliseconds between now and ... now = \" + milliseconds_between(#now, #now);\n\t}\n\t\n\treflex info_date {\n\t\t//at each simulation step, the current_date is updated - its value can be seen in the top-left info panel. \n\t\t// If a starting date is defined, the current date is printed. If not, its equivalent duration is printed instead\n\t\t// current_date is always equal to starting_date + time or starting_date + cycle * step\n\t\twrite \"current_date at cycle \" + cycle + \" : \" + string(current_date, \"dd MMMM yyyy HH:mm:ss\");\n\t}\n}\n\nexperiment main type: gui;"}
{"prompt": "Create a GAMA model that demonstrates how to manage and display time units (seconds, milliseconds, minutes, hours, days, months, years) and their relationships, including a reflex to print the current simulation step and time.", "gaml_code": "/**\n* Name: Simple definition of time property in a model\n* Author: Patrick Taillandier\n* Description: Show how the time is managed is GAMA.\n* Tags: date, time\n*/\n@no_warning\nmodel SimpleTimedefinition\n\nglobal {\n\t//redifitiion of the duration of one simulation step to 1 hour. By default the duration is one second.\n\tfloat step <- 1 #hour;\n\t\n\t\n\tinit {\n\t\t//GAMA provides different values for temporal units - these values are given in seconds\n\t\twrite \"1#ms:\" + 1#ms;\n\t\twrite \"1#s: \" + 1#s;\n\t\twrite \"1#mn: \" + 1#mn;\n\t\twrite \"1#hour: \" + 1#hour;\n\t\twrite \"1#day: \" + 1#day;\n\t\twrite \"1#month: \" + 1#month;\n\t\twrite \"1#year: \" + 1#year;\n\t\t\n\t\t//Note that these values are constant: the value #month is always equal to 30 #day. It has been deprecated, as well as #year, so that time units represent exact durations as well.\n\t}\n\treflex info_time {\n\t\twrite \"\\n-------------------------------------------\";\n\t\t//the global variable cycle gives the current step of the simulation\n\t\twrite \"cycle: \" + cycle;\n\t\t\n\t\t//the global variable time gives the current duration (in seconds) since the beginning of the simulation: time = cycle * step\n\t\t//The value of the time facet can be seen - in a date-time presentation - in the top-left green info panel (click on the number of cycle to see the time value). \n\t\t//All models, otherwise stated, start at the ISO date of 1970-01-01T00:00Z. \n\t\t//For more realistic accounts of dates, see the Date type and Real dates model in the same folder.\n\t\twrite \"time: \" + time;\n\t}\n}\n\nexperiment SimpleTimedefinition type: gui ;"}
{"prompt": "**The provided code is an Agent-Based Modeling (ABM) simulation using the Repast framework. It models a multi-employer housing market and includes various parameters and outputs for visualization and user interaction.**", "gaml_code": "/***\n* Name: ABValuation\n* Author: Cristian Jara-Figueroa - Arnaud Grignard \n* Description: This model illustrates how housing markets react to businesses and their location. \n* In contrast to the standard Alonso-Muth-Mills Model (AMM), this Agent Based version enables \n* users to understand the complexity of multiple employers within a given region.\n* Tags: EconomHousing Market,\n***/\n\nmodel ABValuation\n\nglobal{\n\t// Model mode\n\tbool updateUnitSize<-true;\n\tbool modeCar <- false;\t\n\t\n\t// Grid parameters\n\tint grid_width<-16;\n\tint grid_height<-16;\n\tfloat cell_width<-100.0/grid_width;\n\tfloat cell_height<-100.0/grid_height;\n\t\n\tint firm_pos_1 <- int(0.5*grid_width);\n\t\n\t// Global model parameters\n\tfloat rentFarm<- 5.0;\n\tfloat buildingSizeGlobal <- 1.2;\n\tint unitsPerBuilding <- 5; \n\tfloat globalWage <-1.0;\n\tfloat wageRatio<-7.0;\n\tfloat commutingCost <- 0.35;\n\tfloat commutingCostCar <- 0.3;\n\tfloat commutingCostCarFixed <- 0.5;\n\tfloat landUtilityParameter <- 10.0;\n\tfloat shareLowIncome <- 0.1;\n\t\n\tint nAgents <- int(0.95*(unitsPerBuilding)*((grid_width+1)*(grid_height+1)-1));\n\t\n\t// Update parameters (non-equilibrium)\n\tfloat rentSplit<- 0.75;\n\tfloat rentDelta <- 0.05;\n\tfloat sizeDelta <- 0.01;\n\tfloat randomMoveRate <- 0.001;\n\tfloat advertiseRatioGlobal <- 0.01;\n\t\n\t// Display parameters\n\tbool controlBool;\n\tstring firmTypeToAdd<-'low';\n\tbool firmDeleteMode <- false;\n\tbool reflexPause<-false;\n\t\n\trgb servicesColor<-rgb('#a50f15');\n\trgb manufactoringColor<-rgb('#fc9272');\n\t\n\treflex updateAgents when: (reflexPause=false) {\n\t\tif (length(firm where (each.skillType=0))!=0) {\n\t\t\tint lowSkilledTarget <- int(nAgents*shareLowIncome);\t\t\t\n\t\t\tloop while: (length(worker where (each.skillType=0))<lowSkilledTarget) {\n\t\t\t\tworker toSwitch <- one_of(worker where (each.skillType=1));\n\t\t\t\ttoSwitch.skillType <- 0;\n\t\t\t\tif (toSwitch.myFirm.skillType>toSwitch.skillType) {\n\t\t\t\t\task toSwitch {\n\t\t\t\t\t\tdo forceFirmUpdate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tloop while: (length(worker where (each.skillType=0))>lowSkilledTarget) {\n\t\t\t\tworker toSwitch <- one_of(worker where (each.skillType=0));\n\t\t\t\ttoSwitch.skillType <- 1;\n\t\t\t}\n\t\t} else {\n\t\t\task (worker where (each.skillType=0)) {\n\t\t\t\tself.skillType<-1;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\taction create_firm {\n\t\tif (firmDeleteMode=false) {\n\t\t\tbuilding toKill<- (building closest_to(#user_location));\n\t\t\treflexPause<-true;\n\t\t\tcreate firm {\n\t\t\t\tmyCity<-one_of(city);\n\t\t\t\tshape<-square(0.95*cell_width);\n\t\t\t\tif (firmTypeToAdd='high') {\n\t\t\t\t\tskillType<-1;\n\t\t\t\t\tcolor <- servicesColor;\n\t\t\t\t} else {\n\t\t\t\t\tskillType<-0;\n\t\t\t\t\tcolor <- manufactoringColor;\n\t\t\t\t}\n\t\t\t\twage<-wageRatio*globalWage;\t\n\t\t\t\tlocation <- toKill.location;\n\t\t\t\tnbWorkers<-0;\n\t\t\t\tadvertiseRatio<-advertiseRatioGlobal;\n\t\t\t\tdo advertise;\n\t\t\t}\n\t\t\task worker {\n\t\t\t\tif (myBuilding=toKill) {\n\t\t\t\t\tdo forceBuildingUpdate;\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\task toKill {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treflexPause<-false;\n\t\t} else {\n\t\t\tif (length(firm)>1) {\n\t\t\t\tfirm toKill<- (firm closest_to(#user_location));\n\t\t\t\t\n\t\t\t\treflexPause<-true;\n\t\t\t\tlist<firm> remainingLowSkilledFirms<-(firm where (each!=toKill and each.skillType=0));\n\t\t\t\tif (length(remainingLowSkilledFirms)=0) {\n\t\t\t\t\task (worker where (each.skillType=0)) {\n\t\t\t\t\t\tskillType<-1;\n\t\t\t\t\t}  \n\t\t\t\t}\n\t\t\t\tcreate building {\n\t\t\t\t\tmyCity<-one_of(city);\n\t\t\t\t\tshape<-square(0.95*cell_width);\n\t\t\t\t\n\t\t\t\t\trent <- rentFarm;\n\t\t\t\t\tbuildingSize <- buildingSizeGlobal;\n\t\t\t\t\tvacant <- buildingSizeGlobal;\n\t\t\t\t\tunitSize <- buildingSizeGlobal/float(unitsPerBuilding);\n\t\t\t\t\n\t\t\t\t\tlocation <- toKill.location;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\task (worker where (each.myFirm=toKill)) {\n\t\t\t\t\tdo forceFirmUpdate;\n\t\t\t\t}\n\t\t\t\task toKill {\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\treflexPause<-false;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tinit{\n\t\twrite \"Number of units \" +unitsPerBuilding*((grid_width+1)*(grid_height+1)-2);\n\t\twrite \"Number of workers \"+nAgents;\n\t\tcreate city {\n\t\t\tmaxRent<-rentFarm;\n\t\t}\n\t\t\n\t\tint i<-0;\n\t\tint j<-0;\n\t\tcreate building number:((grid_width+1)*(grid_height+1)-1){\n\t\t\tmyCity<-one_of(city);\n\t\t\tshape<-square(0.95*cell_width);\n\t\t\t\n\t\t\trent <- rentFarm;\n\t\t\tbuildingSize <- buildingSizeGlobal;\n\t\t\tvacant <- buildingSizeGlobal;\n\t\t\tunitSize <- buildingSizeGlobal/float(unitsPerBuilding);\n\t\t\t\n\t\t\tlocation <- {cell_width*i,cell_height*j};\n\t\t\ti<-((i+1) mod (grid_width+1));\t\t\t\n\t\t\tif (i=0) {\n\t\t\t\tj<-j+1;\n\t\t\t}\n\t\t\tif (i=firm_pos_1 and j=firm_pos_1) {\n\t\t\t\ti<-((i+1) mod (grid_width+1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcreate firm {\n\t\t\tmyCity<-one_of(city);\n\t\t\tshape<-square(0.95*cell_width);\n\t\t\tskillType<-1;\n\t\t\tcolor <- servicesColor;\n\t\t\twage<-globalWage;\n\t\t\tlocation <- {cell_width*firm_pos_1,cell_height*firm_pos_1};\n\t\t\tnbWorkers<-0;\n\t\t\tadvertiseRatio<-advertiseRatioGlobal;\n\t\t}\n\t\t\n\t\tcreate worker number:nAgents {\n\t\t\tskillType<-1;\n\t\t\tlist<firm> possibleFirms<-(firm where (each.skillType=skillType));\n\t\t\tif (length(possibleFirms)!=0) {\n\t\t\t\tmyFirm <- one_of(possibleFirms);\n\t\t\t\tmyFirm.nbWorkers <- myFirm.nbWorkers+1;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tlist<building> possibleBuildings<-(building where (each.vacant>0));\n\t\t\tif (length(possibleBuildings)!=0) {\n\t\t\t\tmyBuilding <- one_of(possibleBuildings);\n\t\t\t\tmyBuilding.vacant <- myBuilding.vacant-myBuilding.unitSize;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t\tlocation <- any_location_in(myBuilding);\n\t\t\tif (myFirm.skillType=1) {\n\t\t\t  color<-rgb('#08519c');\n\t\t    } else {\n\t\t\t  color<-rgb('#6baed6');\n\t\t    }\n\t\t}\n\t\t\n\t\task one_of(city) {\n\t\t\tdo updateCityParams;\n\t\t}\n\t\t\t\n\t}\n\t\n}\n\nspecies city {\n\tfloat maxRent;\n\tfloat maxDensity;\n\tfloat maxWage;\n\tfloat maxSupportedDensity;\n\t\n\taction updateCityParams{\n\t\tmaxRent <- max(building collect each.rent);\n\t\tmaxDensity <- max(building collect each.density);\n\t\tmaxSupportedDensity <- max(building collect each.supportedDensity);\n\t\tmaxWage <- max(firm collect each.wage);\n\t}\n\t\n\treflex update when: (reflexPause=false) {\n\t\tdo updateCityParams;\n\t}\n}\n\nspecies firm{\n\tint nbWorkers;\n\tint skillType;\n\tfloat wage;\n\tcity myCity;\n\tfloat advertiseRatio;\n\trgb color;\n\t\n\taction advertise {\n\t\tint nEmployees <- int(advertiseRatio*length(worker where (each.skillType>=skillType)));\n\t\tint i<-0;\n\t\tloop while: (i<nEmployees) {\n\t\t\tworker targetWorker <- one_of(worker where (each.skillType>=skillType));\n\t\t\task targetWorker {\n\t\t\t\tdo attemptFirmUpdate(myself);\n\t\t\t}\n\t\t\ti<-i+1;\n\t\t}\n\t}\n\n\taspect base{\n\t\tdraw shape color:#blue;\n\t}\n\t\n\treflex updateWage when: (reflexPause=false) {\n\t\tif (skillType=1) {\n\t\t\twage <- wageRatio*globalWage;\n\t\t} else {\n\t\t\twage <- globalWage;\n\t\t}\n\t}\n\t\n\taspect threeD {\n\t\tdraw shape color: color depth: 2+nbWorkers/nAgents*20;\n\t}\n\taspect twoD {\n\t\tdraw shape color: color;\n\t}\n}\n\nspecies building {\n\tcity myCity;\n\tfloat buildingSize;\n\t\n\tfloat rent;\n\tfloat unitSize;\n\tfloat vacant;\n\t\n\tfloat density;\n\tfloat supportedDensity;\n\tfloat heightValue;\n\trgb color;\n\t\n\treflex lowerRent when: (reflexPause=false) {  \n\t\tif (vacant>=unitSize) {\n\t\t\trent <- rent-rentDelta*rent;\n\t\t\tif (rent<rentFarm){\n\t\t\t\trent <-rentFarm;\n\t\t\t}\n\t\t} \n\t\tif (rent<rentFarm){\n\t\t\trent <-rentFarm;\n\t\t}\n\t}\n\t\n\treflex raiseUnitSize when: (updateUnitSize=true) {\n\t\tfloat newUnitSize;\n\t\tnewUnitSize <- (1.0+sizeDelta)*unitSize;\n\t\tif (vacant>=(1.0+sizeDelta)*(buildingSize-vacant) and newUnitSize<=buildingSize) {\n\t\t\tvacant <- buildingSize-(1.0+sizeDelta)*(buildingSize-vacant); \n\t\t\tunitSize <- newUnitSize;\n\t\t}\n\t}\n\t\n\treflex updateParameters {\n\t\tdensity <- float(int((buildingSize-vacant)/(unitSize)));\n\t\tif (density<0) {\n\t\t\tdensity<-0.0;\n\t\t}\n\t\t\n\t\tsupportedDensity <- buildingSize/unitSize;\n\t\tif (supportedDensity=0) {\n\t\t\theightValue<-0.0;\n\t\t} else {\n\t\t\theightValue<-supportedDensity;\n\t\t}\n\t\theightValue<-0.3*heightValue;\n\t\t\n\t}\n\n\taspect density_aspect {\n\t\tint colorValue <- int(220-220*density/myCity.maxDensity);\n\t\tdraw shape color: rgb(colorValue,colorValue,colorValue);\n\t}\n\t\n\taspect threeD{\n\t\tint colorValue<- 35+ int(220-220*log(rent+1.0)/log(myCity.maxRent+1.0));\n\t\tdraw shape color: rgb(colorValue,colorValue,colorValue) depth: heightValue;\n    }\n    \n    aspect twoD{\n\t\tint colorValue<- 35+ int(220-220*log(rent+1.0)/log(myCity.maxRent+1.0));\n\t\tdraw shape color: rgb(colorValue,colorValue,colorValue);\n    }\n\t\n}\n\nspecies worker {\n\tbuilding myBuilding;\n\tfirm myFirm;\n\tbool useCar;\n\tfloat currentUtility;\n\tint skillType;\n\trgb color;\n\n\tfloat myUtility (building referenceBuilding, firm referenceFirm, bool useCarLocal, float myUnitSize<-nil) {\n\t\tfloat utility;\n\t\tfloat workDistance <- (referenceBuilding distance_to referenceFirm);\n\t\tif (myUnitSize=nil){\n\t\t\tutility <- referenceFirm.wage - commutingValue(workDistance,useCarLocal) - referenceBuilding.rent * referenceBuilding.unitSize + landUtilityParameter * log(referenceBuilding.unitSize);\n\t\t} else {\n\t\t\tutility <- referenceFirm.wage - commutingValue(workDistance,useCarLocal) - referenceBuilding.rent * myUnitSize + landUtilityParameter * log(myUnitSize);\n\t\t}\n\t\treturn utility;\n\t}\n\t\n\tfloat commutingValue (float distance, bool useCarLocal) {\n\t\tfloat outValue;\n\t\tif (modeCar=true) {\n\t\t\tif (useCarLocal=false){\n\t\t\t\toutValue <- commutingCost*distance;\n\t\t\t} else {\n\t\t\t\toutValue <- commutingCostCarFixed+commutingCostCar*distance;\n\t\t\t}\n\t\t} else {\n\t\t\toutValue <- commutingCost*distance;\n\t\t}\n\t\treturn outValue; \n\t}\n\t\n\taction checkMyStuff {\n\t\tdo checkSkillFirm;\n\t\tif (myFirm=nil){\n\t\t\tmyFirm <- one_of(firm where (each.skillType=skillType));\n\t\t}\n\t\tif (myBuilding=nil){\n\t\t\tmyBuilding <- one_of(building);\n\t\t}\n\t}\n\t\n\taction checkSkillFirm {\n\t\tif (length(firm where (each.skillType<=skillType))=0) {\n\t\t\twrite \"kill skilltype: \"+skillType;\n\t\t\tskillType<-1;\n\t\t}\n\t}\n\t\n\taction forceFirmUpdate {\n\t\tfirm newFirm;\n\t\tnewFirm <- one_of(firm where (each.skillType<=skillType and each!=myFirm));\n\t\tdo attemptFirmUpdate(newFirm);\n\t}\n\t\n\taction forceBuildingUpdate {\n\t\tbool updateSuccess<-false;\n\t\tbuilding newBuilding;\n\t\t\n\t\tloop while: (updateSuccess=false) {\n\t\t\tnewBuilding <- one_of(building);\n\t\t\tif (newBuilding!=myBuilding) {\n\t\t\t\tif (newBuilding.vacant>=newBuilding.unitSize) {\n\t\t\t\t\tmyBuilding.vacant <- myBuilding.vacant + myBuilding.unitSize;\n\t\t\t\t\tnewBuilding.vacant <- newBuilding.vacant - newBuilding.unitSize;\n\t\t\t\t\tmyBuilding <- newBuilding;\n\t\t\t\t\tlocation <- any_location_in(myBuilding);\n\t\t\t\t\tupdateSuccess<-true;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\t\t\n\taction attemptFirmUpdate (firm newFirm) {\n\t\tif (newFirm!=nil) {\n\t\t\tmyFirm.nbWorkers<-myFirm.nbWorkers-1;\n\t\t\tnewFirm.nbWorkers<-newFirm.nbWorkers+1;\n\t\t\tmyFirm <- newFirm;\n\t\t}\n\t\t\n\t}\n\t\n\taction attemptBuildingUpdate (building newBuilding, float utilityChange<-0.0) {\n\t\tif (newBuilding.vacant<newBuilding.unitSize) {\n\t\t\tif (utilityChange!=0) {\n\t\t\t\tnewBuilding.rent <- newBuilding.rent + rentSplit * utilityChange/newBuilding.unitSize;\n\t\t\t}\n\t\t} else {\n\t\t\tmyBuilding.vacant <- myBuilding.vacant + myBuilding.unitSize;\n\t\t\tnewBuilding.vacant <- newBuilding.vacant - newBuilding.unitSize;\n\t\t\tmyBuilding <- newBuilding;\n\t\t\tlocation <- any_location_in(myBuilding);\n\t\t}\n\t}\n\t\n\treflex updateUtility when: (reflexPause=false) {\n\t\tdo checkMyStuff;\n\t\tfloat utility<-myUtility(myBuilding,myFirm,useCar);\n\t\tcurrentUtility<-utility;\n\t}\n\t\n\treflex updateCommutingMode when: (reflexPause=false) {\n\t\tdo checkMyStuff;\n\t\tfloat utilityCar<-myUtility(myBuilding,myFirm,true);\n\t\tfloat utilityNoCar<-myUtility(myBuilding,myFirm,false);\n\t\tif (utilityCar>utilityNoCar){\n\t\t\tuseCar<-true;\n\t\t} else {\n\t\t\tuseCar<-false;\n\t\t}\n\t}\n\t\n\treflex updateBuilding when: (reflexPause=false) {\n\t\tdo checkMyStuff;\n\t\tfloat utility <- myUtility(myBuilding,myFirm,useCar);\n\t\tbuilding possibleBuilding <- one_of(building);\n\t\tfloat possibleUtility <- myUtility(possibleBuilding,myFirm,useCar);\n\t\tfloat utilityChange <- possibleUtility-utility;\n\t\t\n\t\tif (utilityChange>0.0){\n\t\t\tdo attemptBuildingUpdate(possibleBuilding, utilityChange);\n\t\t}\n\t}\n\t\n\treflex updateWork when: (reflexPause=false) {\t\n\t\tdo checkMyStuff;\t\n\t\tfloat utility <- myUtility(myBuilding,myFirm,useCar);\n\t\tfirm possibleFirm <- one_of(firm where (each.skillType<=self.skillType and each!=myFirm));\n\t\tif (possibleFirm!=nil) {\n\t\t\tfloat possibleUtility<- myUtility(myBuilding,possibleFirm,useCar);\n\t\t\tif (possibleUtility>utility){\n\t\t\t\tdo attemptFirmUpdate(possibleFirm);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex updateBuildingRandom when: (reflexPause=false) {\n\t\tif (rnd(1.0)<randomMoveRate) {\n\t\t\tbuilding possibleBuilding <- one_of(building);\n\t\t\tdo attemptBuildingUpdate(possibleBuilding);\n\t\t}\n\t}\n\t\n\treflex updateWorkRandom when: (reflexPause=false) {\n\t\tdo checkMyStuff;\n\t\tif (rnd(1.0)<randomMoveRate) {\n\t\t\tfirm possibleFirm;\n\t\t\tpossibleFirm <- one_of(firm where (each.skillType<=self.skillType and each!=myFirm));\n\t\t\tdo attemptFirmUpdate(possibleFirm);\n\t\t}\n\t}\n\t\n\treflex updateUnitSize when: (updateUnitSize=true and reflexPause=false) {\n\t\tfloat utility;\t\t\n\t\tfloat newUnitSizem;\n\t\tfloat newUnitSizep;\n\t\tfloat possibleUtilitym;\n\t\tfloat possibleUtilityp;\n\t\tbool updateFlag<-true;\n\t\t\n\t\tloop while: (updateFlag=true) {\n\t\t\tupdateFlag<-false;\n\t\t\t\n\t\t\tdo checkMyStuff;\n\t\t\tutility <- myUtility(myBuilding,myFirm,useCar);\n\t\t\tnewUnitSizem <- (1.0-sizeDelta)*myBuilding.unitSize;\n\t\t\tnewUnitSizep <- (1.0+sizeDelta)*myBuilding.unitSize;\n\t\t\t\n\t\t\tpossibleUtilitym <- myUtility(myBuilding,myFirm,useCar,newUnitSizem);\n\t\t\tpossibleUtilityp <- myUtility(myBuilding,myFirm,useCar,newUnitSizep);\n\t\t\t\n\t\t\tif (possibleUtilityp>utility and myBuilding.vacant>=(1.0+sizeDelta)*(myBuilding.buildingSize-myBuilding.vacant) and newUnitSizep<=myBuilding.buildingSize) {\n\t\t\t\tmyBuilding.vacant <- myBuilding.buildingSize-(1.0+sizeDelta)*(myBuilding.buildingSize-myBuilding.vacant); \n\t\t\t\tmyBuilding.unitSize <- newUnitSizep;\n\t\t\t\tupdateFlag<-true;\n\t\t\t} else {\n\t\t\t\tif (possibleUtilitym>utility) {\n\t\t\t\t\tmyBuilding.vacant <- myBuilding.buildingSize-(1.0-sizeDelta)*(myBuilding.buildingSize-myBuilding.vacant); \n\t\t\t\t\tmyBuilding.unitSize <- newUnitSizem;\n\t\t\t\t\tupdateFlag<-true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateFlag<-false; // Force exit\n\t\t}\n\t}\n\t\n\t/*aspect threeD {\n\t\tint colorValue <- int(30+220*myFirm.wage/myFirm.myCity.maxWage);\n\t\tdraw sphere(1.0) color: rgb(0,0,colorValue);\n\t}*/\n\t\n\taspect base{\n\t\tdraw circle(0.25) color:#green;\t\t\t\t\t\n\t}\n\t\n\taspect wage_aspect {\n\t\tdraw circle(0.25) color: color;\n\t}\n\t\n\taspect threeD {\n\t\tdraw cylinder(0.2,0.75) at_location {location.x,location.y,rnd(myBuilding.heightValue)} color: color;\t\n\t}\n\t\n}\n\ngrid cell width: grid_width height: grid_height {\n\taspect dark_aspect {\n\t\tdraw shape color: #black;\n\t}\n}\n\nexperiment ABValuationDemo type: gui autorun:true{\n\tparameter \"Commuting cost\" var: commutingCost min: 0.0 max: 1.0 step: 0.05; \n\tparameter \"Share of low income\" var: shareLowIncome min: 0.0 max: 1.0 step: 0.05; \n\tparameter \"Housing Supply\" var: updateUnitSize; \n\toutput { \n\t\tdisplay map_3D  type:opengl background: #black axes: false  toolbar:true \n\t\t{\n\t\t\tcamera 'default' location: {139.364,176.9895,71.3573} target: {40.9962,59.7593,0.0} dynamic:false;\n\t\t\tspecies cell aspect: dark_aspect;\t\t\t\n\t\t\tspecies worker aspect:threeD;\n\t\t\tspecies firm aspect: threeD transparency: 0.25;\n\t\t\tspecies building aspect:threeD transparency: 0.35;\n\t\t\tevent #mouse_down {ask simulation {do create_firm;}}  \n\t\t\tevent \"p\" {if(commutingCost<1){commutingCost<-commutingCost+0.1;}}\n\t\t\tevent \"m\" {if(commutingCost>0){commutingCost<-commutingCost-0.1;}}\n\t\t\tevent \"u\" {if(shareLowIncome<0.9){shareLowIncome<-shareLowIncome+0.1;}}\n\t\t\tevent \"e\" {if(shareLowIncome>0.0){shareLowIncome<-shareLowIncome-0.1;}}\n\t\t\tevent \"s\" {updateUnitSize<-!updateUnitSize;}\n\t\t\tevent \"h\" {firmTypeToAdd<-'high'; firmDeleteMode<-false;}\n\t\t\tevent \"l\" {firmTypeToAdd<-'low'; firmDeleteMode<-false;}\n\t\t\tevent \"d\" {firmDeleteMode<-true;}\n\t\t\t\n\t\t\toverlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.0 border: #black rounded: true\n            {   \n            \tfloat y1;\n            \tdraw string(\"MULTI EMPLOYER HOUSING MARKET SIMULATION\") at: { 10#px, 20#px } color: #white font: font(\"Helvetica\", \"bold\" ,72); \n            \ty1<-y1+20#px;\n            \tdraw string(\"This model illustrates how housing markets react to businesses and their location. \\nIn contrast to the standard Alonso-Muth-Mills Model (AMM), this Agent Based version \\nenables users to understand the complexity of multiple employers within a given region.\") at: { 10#px, 20#px+y1 } color: #white font: font(\"Helvetica\", \"bold\" ,72); \n            \t\n            \tfloat y <- 150#px;\n            \tdraw string(\"Population (Income)\") at: { 10#px, y-20#px } color: #white font: font(\"Helvetica\", \"bold\" ,32);\n                draw circle(10#px) at: { 20#px, y } color: rgb('#08519c') border: rgb('#08519c')-25;\n                draw string(\"High\") at: { 40#px, y + 4#px } color: #white font: font(\"Helvetica\",\"plain\", 18);\n                y <- y + 25#px;\n                draw circle(10#px) at: { 20#px, y } color: rgb('#6baed6') border: rgb('#6baed6')-25;\n                draw string(\"Medium\") at: { 40#px, y + 4#px } color: #white font: font(\"Helvetica\", 18);\n                y <- y + 25#px;\n                draw string(\"Employement (Sector)\") at: { 10#px, y } color: #white font: font(\"Helvetica\", \"bold\" ,32);\n                y <- y + 25#px;\n                draw square(20#px) at: { 20#px, y } color: servicesColor border: servicesColor-25;\n                draw string(\"Services\") at: { 40#px, y + 4#px } color: #white font: font(\"Helvetica\", 18);\n                y <- y + 25#px;\n                draw square(20#px) at: { 20#px, y } color: manufactoringColor border: manufactoringColor-25;\n                draw string(\"Manufacturing\") at: { 40#px, y + 4#px } color: #white font: font(\"Helvetica\", 18);\n                \n                y <- y + 25#px;\n                draw string(\"Housing (Cost)\") at: { 10#px, y } color: #white font: font(\"Helvetica\", \"bold\" ,32);\n                y <- y + 25#px;\n                draw square(20#px) at: { 20#px, y } color: rgb(50,50,50) border: rgb(50,50,50)-25;\n                draw string(\"High\") at: { 40#px, y + 4#px } color: #white font: font(\"Helvetica\", 18);  \n                \n                y <- y + 25#px;\n                draw square(20#px) at: { 20#px, y } color: #lightgray border: #lightgray-25;\n                draw string(\"Low\") at: { 40#px, y + 4#px } color: #white font: font(\"Helvetica\", 18); \n                \n                y <- y + 75#px;\n                draw string(\"Commuting Cost\") at: { 0#px, y + 4#px } color: #white font: font(\"Helvetica\", 18);\n                y <- y + 25#px;\n                draw rectangle(200#px,2#px) at: { 50#px, y } color: #white;\n                draw rectangle(2#px,10#px) at: { 5#px+commutingCost*90#px, y } color: #white;\n\n                y <- y + 25#px;\n                draw string(\"Share of low income\") at: { 0#px, y + 4#px } color: #white font: font(\"Helvetica\", 18);\n                y <- y + 25#px;\n                draw rectangle(200#px,2#px) at: { 50#px, y } color: #white;\n                draw rectangle(2#px,10#px) at: { shareLowIncome*90#px, y } color: #white;\n                \n                y <- y + 25#px;\n                float x<-0#px;\n                draw string(\"Housing Supply\") at: { 0#px + x , y + 4#px } color: #white font: font(\"Helvetica\", 18);\n                y <- y + 25#px;\n                draw rectangle(200#px,2#px) at: { 50#px, y } color: #white;\n                draw rectangle(2#px,10#px) at: { (updateUnitSize ? 0.25 :0.75)*100#px, y } color: #white;\n                y<-y+15#px; \n                draw string(\"     Market Driven        Fixed\") at: { 10#px + x , y + 4#px } color: #white font: font(\"Helvetica\", 12);       \t          \t \n            }\n\t\t}\n\t}\n\t\n}"}
{"prompt": "**This appears to be a NetLogo simulation model for evacuation scenarios.**", "gaml_code": "/**\n* Name: Mainxp\n* Author: Patrick Taillandier\n*/\n\nmodel Mainxp\n\nglobal schedules: people_ordered{\n\t\n\tshape_file buildings_shape_file <- shape_file(\"../includes/buildings.shp\");\n\tshape_file evacuation_shape_file <- shape_file(\"../includes/evacuation_points.shp\");\n\tshape_file roads_shape_file <- shape_file(\"../includes/roads.shp\");\n\tshape_file intersections_shape_file <- shape_file(\"../includes/intersections.shp\");\n\t\n\t\n\tstring qualitativePalette <- \"Set1\" among:[\"Accents\",\"Paired\",\"Set3\",\"Set2\",\"Set1\",\"Dark2\",\"Pastel2\",\"Pastel1\"];\n\tlist<rgb> palette_evac <- brewer_colors(qualitativePalette, length(evacuation_shape_file));\n\n\tfloat alpha <-1.0;\n\tfloat beta <- 1.0;\n\tfloat TIME_MAX <- 60.0 #mn;\n\t\n\tfloat coeff_change_path <- 0.01 ;\n\tfloat tj_threshold <- 0.75;\n\tfloat lane_width <- 0.7;\n\t\n\tfloat display_coeff <- 2.0;\n\tfloat step <-0.5#s;\n\t\n\tgeometry shape <- envelope(buildings_shape_file)  ;\n\tgraph road_network;\n\t\n\tfloat priority_min_road;\n\n\tlist<moving_agent> people_ordered;\n\t\n\tint init_num_people;\n\tfloat change_road_lane_perimeters <- 0 #m;\n\t\t\t\t\n\t\n\tlist<moving_agent> people -> {(pedestrian as list) + (car as list) + (motorbike as list) + (bicycle as list)};\n\t\n\tstring model_description_1 <- \"This model is an agent-based simulation developed to analyze mass evacuation strategies\\n in a densely populated district exposed to flood risks (Ph\u00fac X\u00e1, Hanoi)\";\n\tstring model_description_2 <- \"It is built using the GAMA platform and the ESCAPE framework, and specifically accounts\\n for mixed and non-normative traffic types (pedestrians, motorbikes, bicycles, cars), reflecting the Vietnamese context\";\n\tstring model_description_3 <-\"Agents represent residents seeking to evacuate through the nearest exits,\\n with the ability to change routes in response to congestion.\";\n\tstring model_description_4 <-\"Several scenarios are tested, including different mobility types, rerouting behaviors,\\n spatial departure strategies, and minor changes to the road network. \";\n\tstring model_description_5 <- \"Results show that accounting for mixed traffic and using spatially distributed evacuation strategies\\n can significantly reduce total evacuation time.\";\n\tstring model_description_6 <- \"Chapuis, K., Minh-Duc, P., Brugi\u00e8re, A., Zucker, J. D., Drogoul, A., Tranouez, P., ... & Taillandier, P. (2022).\\n Exploring multi-modal evacuation strategies for a landlocked population using large-scale agent-based simulations.\\n International Journal of Geographical Information Science, 36(9), 1741-1783.\";\n\t\n\tinit {\n\t\tcreate intersection from: intersections_shape_file;\n\t\tcreate building from: buildings_shape_file with: (num_car: int(get((\"car\"))),num_moto: int(get((\"moto\"))),num_bicycle: int(get((\"bicycle\"))),num_pedestrian: int(get((\"pedest\"))), urban_block_id:int(get(\"block\")));\n\t\tcreate evacuation_point from: evacuation_shape_file {\n\t\t\tclosest_intersection <- intersection[inters];\n\t\t\tclosest_intersection.evacuation <- self;\n\t\t\tlocation <- closest_intersection.location;\n\t\t\tid <- -1;\n\t\t}\n\t\tevacuation_point current_ev <- evacuation_point closest_to {world.shape.width, world.shape.height};\n\t\tint i <- 0;\n\t\tloop while: not empty(evacuation_point where (each.id = -1)) {\n\t\t\tcurrent_ev.id <- i;\n\t\t\ti <- i +1;\n\t\t\tlist<evacuation_point> pts <- evacuation_point where (each.id = -1);\n\t\t\tif not empty(pts) {\n\t\t\t\tcurrent_ev <- pts closest_to current_ev;\n\t\t\t}\n\t\t}\n\t\tcreate road from: roads_shape_file;\n\t\task building {\n\t\t\tclosest_intersection <- intersection[inters];\n\t\t\tclosest_evac <- evacuation_point[evacua];\n\t\t}\n\t\task road {\t\n\t\t\tlinked_road <- linked = -1 ? nil : road[linked];\n\t\t\tnum_lanes <- lanes;\n\t\t\tgeom_display <- shape + (num_lanes * lane_width);\n\t\t\tcapacity <- round(num_lanes * shape.perimeter);\n\t\t}\n\t\t\n\t\tif (change_road_lane_perimeters > 0) {\n\t\t\t\n\t\t\tlist<road> rds <- (road sort_by (-1 * each.use));\n\t\t\tfloat dist;\n\t\t\tloop while: dist < change_road_lane_perimeters {\n\t\t\t\troad r <- first(rds);\n\t\t\t\trds >> r;\n\t\t\t\tr.num_lanes <- r.num_lanes + 1;\n\t\t\t\tdist <- dist + r.shape.perimeter;\n\t\t\t}\n\t\t}\n\t\troad_network <- (as_driving_graph(road,intersection) with_shortest_path_algorithm #NBAStar) use_cache false;\n\t\tpriority_min_road <- road min_of each.priority;\n\t\t\t\n\t\t\n\t\t\n\t\task building {\n\t\t\tif num_bicycle > 0 {\n\t\t\t\tcreate bicycle number: num_bicycle with: (home:self);\n\t\t\t}\n\t\t\tif num_car > 0 {\n\t\t\t\tcreate car number: num_car with: (home:self);\n\t\t\t}\n\t\t\tif num_moto > 0 {\n\t\t\t\tcreate motorbike number: num_moto with: (home:self);\n\t\t\t}\n\t\t\tif num_pedestrian > 0 {\n\t\t\t\tcreate pedestrian number: num_pedestrian with: (home:self);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfloat distance_max <- building max_of each.distance;\n\t\t\n\t\task people {\n\t\t\tevacuation_time <- TIME_MAX * beta *((alpha * rnd(1.0)) + (1 - alpha) * home.distance/distance_max);\n\t\t}\n\t\t\n\t\tpeople_ordered <- shuffle(people);\n\t\tinit_num_people <- length(people_ordered);\n\t}\n\t\n\treflex update_priority_graph {\n\t\t\n\t\tpeople_ordered <- [];\n\t\task shuffle(road) sort_by each.priority {\n\t\t\tlist<moving_agent> people_on <- shuffle(list<moving_agent>(all_agents));\n\t\t\tpeople_ordered <- people_ordered + (people_on sort_by (each.distance_to_goal/ (100 * world.shape.width) - each.segment_index_on_road)) ;\n\t\t}\n\t\tpeople_ordered <- people_ordered + shuffle(people- people_ordered);\n\t\t\n\t}\n\t\n\treflex end_sim when:  empty(people) or  time > 15000{\n\t\tdo pause;\n\t}\n\n}\n\nspecies evacuation_point schedules:[]{\n\tint id;\n\tint inters;\n\tmap<string, int> nb_arrived;\n\tintersection closest_intersection;\n\t\n\trgb color <- palette_evac[int(self)];\n\taspect default {\n\t\tdraw sphere(10.0) color: color;\n\t\t\n\t}\n\t\n}\n\nspecies building schedules:[]{\n\trgb color <- #gray;\n\tint evacua;\n\tint inters;\n\tint num_car;\n\tint num_bicycle;\n\tint num_moto;\n\tint num_pedestrian;\n\t\n\tevacuation_point closest_evac;\n\tintersection closest_intersection;\n\tint urban_block_id;\n\tfloat distance;\n\taspect default {\n\t\tdraw shape color: color border: #black depth: 10;\n\t}\n}\n\nspecies road skills: [road_skill] {\n\tgeometry geom_display;\n\tint linked;\n\tint use;\n\tint lanes;\n\tfloat vehicles <- 0.0 update: (all_agents sum_of (moving_agent(each).vehicle_length));\n\tbool traffic_jam <- false update: (vehicles/ capacity) > tj_threshold;\n\tint capacity;\n\tfloat priority;\n\t\n\t\n\taspect default {\n\t\tdraw shape + (lanes * lane_width) color:  #lightgray ;\n\t\t//draw shape at: location + {0,0,0.5} color: traffic_jam ? #red : #green end_arrow: 2.0;\n\t}\n\t\n}\n\nspecies intersection skills: [intersection_skill] schedules:[]{\n\tint index <- int(self);\n\tevacuation_point evacuation;\n\taspect default {\n\t\tdraw square(1.0) color: #magenta;\n\t}\n}\nspecies moving_agent skills: [driving] schedules:[] {\n\trgb color <- rnd_color(255);\n\tbool leave <- false ;\n\tevacuation_point evac_pt;\n\tdate leaving_date ;\n\tfloat proba_use_linked_road <- 1.0;\n\tfloat proba_respect_priorities <- 0.5;\n\tint linked_lane_limit <- 1;\n\tint lane_change_limit <- -1;\n\t\n\tbool parked <- false;\n\n\tlist<road> roads_with_traffic_jam;\n\t\n\tfloat priority;\n\tfloat evacuation_time;\n\tbuilding home;\n\tintersection target_node ;\n\tfloat time_before_parking <- 0.0;\n\tfloat time_stuck <- 0.0;\n\t\n\tfloat politeness_factor_init ;\n\tfloat vehicle_length_init;\n\tfloat proba_use_linked_road_init <- 1.0;\n\tfloat safety_distance_coeff_init;\n\tfloat max_acceleration_init;\n\tfloat time_headway_init;\n\tfloat acc_gain_threshold_init <- 0.2;\n\tfloat min_safety_distance_init <- 0.5;\n\tfloat proba_respect_priorities_init;\n\t\n\tint zone_target;\n\tinit {\n\t\tdo reset_properties;\n\t}\n\t\n\taction reset_properties {\n\t\t politeness_factor <- politeness_factor_init ;\n\t\t vehicle_length <- vehicle_length_init;\n\t\t proba_use_linked_road <- proba_use_linked_road_init;\n\t\t  max_acceleration <- max_acceleration_init;\t\n\t\t time_headway <- time_headway_init;\n\t\t safety_distance_coeff <- safety_distance_coeff_init;\n\t\t acc_gain_threshold <- acc_gain_threshold_init;\n\t\tmin_safety_distance <- min_safety_distance_init;\n\t\tproba_respect_priorities <- proba_respect_priorities_init;\n\t}\n\t\n\taction to_park {\n\t\tproba_use_linked_road <- 0.0;\n\t}\n\t\n\t\n\taction choose_evacuation_point(intersection source) {\n\t\tmap<road,float> weights <- roads_with_traffic_jam as_map (each::(each.shape.perimeter * world.shape.width));\n\t\troad_network <- road_network with_weights weights;\n\t\tusing topology (road_network) {\n\t\t\tevac_pt <-  evacuation_point with_min_of (source distance_to each.closest_intersection) ;\n\t\t}\n\t\tweights <- roads_with_traffic_jam as_map (each::(each.shape.perimeter));\n\t\t\n\t\tcolor <-evac_pt.color;\n\t\ttarget_node <- evac_pt.closest_intersection;\n\t}\n\t\n\taction compute_path_traffic_jam(intersection source) {\n\t\tmap<road,float> weights <- roads_with_traffic_jam as_map (each::(each.shape.perimeter * world.shape.width));\n\t\troad_network <- road_network with_weights weights;\n\t\n\t\tdo compute_path(graph: road_network, source: source, target: target_node);\n\t\tweights <- roads_with_traffic_jam as_map (each::(each.shape.perimeter));\n\t\troad_network <- road_network with_weights weights;\n\t\n\t}\n\taction initialize {\n\t\tlocation <- (home.location);\n\t\n\t\tintersection current_node <- home.closest_intersection;\n\t\troads_with_traffic_jam <- (list<road>(current_node.roads_in + current_node.roads_out)) where each.traffic_jam; \n\t\tevac_pt <- home.closest_evac;\n\t\t\n\t\tcolor <-evac_pt.color;\n\t\ttarget_node <- evac_pt.closest_intersection;\n\t\tif current_node = target_node {\n\t\t\tdo die;\n\t\t}\n\t\tdo compute_path_traffic_jam(current_node);\n\t \t\t\n\t}\n\t\n\tfloat external_factor_impact(road new_road, float remaining_time) { \n\t\tintersection current_node <- intersection(new_road.source_node);\n\t\tif (current_node.evacuation != nil) {\n\t\t\tevac_pt <-intersection(new_road.source_node).evacuation;\n\t\t\tfinal_target <- nil;\n\t\t\treturn -1.0;\n\t\t}\n\t\tlist<road> rds <- (list<road>(current_node.roads_in + current_node.roads_out));\n\t\tloop rd over: rds {\n\t\t\tif (rd.traffic_jam)  {\n\t\t\t\tif  not (rd in roads_with_traffic_jam) {\n\t\t\t\t\troads_with_traffic_jam  << rd;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\troads_with_traffic_jam >> rd;\n\t\t\t}\n\t\t}\n\t\t\n\tif (species(self) != car) and (new_road.traffic_jam) and flip(coeff_change_path *  (self distance_to evac_pt)) and length(intersection(new_road.source_node).roads_out ) > 1 and (new_road.target_node != evac_pt.closest_intersection) {\n\t\t\tif (current_road != nil) {\n\t\t\t\tdo unregister;\n\t\t\t\t\n\t\t\t}\n\t\t\tdo choose_evacuation_point(current_node);\n\t\t\t\n\t\t\tif new_road.source_node = target_node {\n\t\t\t\tfinal_target <- nil;\n\t\t\t\treturn -1.0;\n\t\t\t}\n\t\t\t do compute_path_traffic_jam(current_node);\n\t\t\treturn -1.0;\t\n\t\t\t\n\t\t}\n\t\treturn remaining_time;\n\t}\n\t\n\taction arrived(evacuation_point evac) {\n\t\tevac.nb_arrived[string(species(self))] <- evac.nb_arrived[string(species(self))] + 1;\n\t\tif current_road != nil {\n\t\t\tdo unregister;\n\t\t\t\n\t\t}\n\t\tdo die;\n\t}\n\t\n\treflex time_to_leave when: not leave and  time > evacuation_time {\n\t\tleave <- true;\n\t\tleaving_date <- copy(current_date);\n\t\tdo initialize;\n\t}\n\treflex move_to_target when:leave and (final_target != nil ) {\n\t\tdo drive;\n\t\tif parked {\n\t\t\tif real_speed > 0.0 {\n\t\t\t\tparked <- false;\n\t\t\t\ttime_stuck <- 0.0;\n\t\t\t\tdo reset_properties;\n\t\t\t}\n\t\t} else if time_before_parking > 0.0 {\n\t\t\tif (real_speed = 0.0) and using_linked_road  and (moving_agent(leading_vehicle) != nil ) and not dead(leading_vehicle) and not moving_agent(leading_vehicle).using_linked_road and (moving_agent(leading_vehicle).vehicle_length_init >= vehicle_length_init){\n\t\t\t\ttime_stuck <- time_stuck + step;\n\t\t\t}else {\n\t\t\t\ttime_stuck <- 0.0;\n\t\t\t}\n\t\t\tif (time_stuck > time_before_parking ) {\n\t\t\t\tparked <- true;\n\t\t\t\tdo to_park;\n\t\t\t\tdo force_move(road(current_road).num_lanes - 1,max_acceleration,step);\n\t\t\t}\n\t\t}\n\t\tif final_target = nil {\n\t\t\tdo arrived(evac_pt);\n\t\t}\n\t}\n\taspect default {\n\t\tif (current_road != nil) {\n\t\t\tpoint pos <- compute_position();\n\t\t\tdraw rectangle(vehicle_length  * display_coeff, lane_width * num_lanes_occupied * display_coeff) \n\t\t\t\tat: pos color: color rotate: heading;// border: #black depth: 1.0;\n\t\t\tdraw triangle(lane_width * num_lanes_occupied * display_coeff ) \n\t\t\t\tat: pos color: parked ? #red : color rotate: heading + 90 border: #black;\n\t\t}\n\t}\n\taspect demo {\n\t\tif (current_road != nil) {\n\t\t\tpoint pos <- compute_position();\n\t\t\tdraw circle(vehicle_length_init  /1.5 ) at: pos color: rgb(color.red, color.green, color.blue, 0.5);\n\t\t\t\n\t\t\tdraw rectangle(vehicle_length_init , lane_width * num_lanes_occupied) \n\t\t\t\tat: pos color: color rotate: heading;// border: #black depth: 1.0;\n\t\t\tdraw triangle(lane_width * num_lanes_occupied ) \n\t\t\t\tat: pos color: color rotate: heading + 90 ;//border: #black;depth: 1.5;\n\t\t}\n\t}\n\t\n\tpoint compute_position {\n\t\t// Shifts the position of the vehicle perpendicularly to the road,\n\t\t// in order to visualize different lanes\n\t\tif (current_road != nil) {\n\t\t\tfloat dist <- (road(current_road).num_lanes - lowest_lane -\n\t\t\t\tmean(range(num_lanes_occupied - 1)) - 0.5) * lane_width;\n\t\t\tif violating_oneway {\n\t\t\t\tdist <- -dist;\n\t\t\t}\n\t\t \tpoint shift_pt <- {cos(heading + 90) * dist, sin(heading + 90) * dist};\t\n\t\t\n\t\t\treturn location + shift_pt;\n\t\t} else {\n\t\t\treturn {0, 0};\n\t\t}\n\t}\n\t\n\t\n\t\n}\n\n\nspecies car parent: moving_agent schedules:[]{\n\tfloat vehicle_length_init <- 3.8#m;\n\tint num_lanes_occupied <- 2;\n\tfloat max_speed <- 160 #km/#h;\n\tfloat max_acceleration_init <- rnd(3.0,5.0);\t\n\tfloat time_headway_init <- gauss(1.25,0.25) min: 0.5;\n\tfloat politeness_factor_init <- 0.25 ;\n\tfloat acc_bias <- 0.0;\n\tint linked_lane_limit <- 0;\n\tfloat proba_use_linked_road_init <- 0.0;\n\t\n\tfloat proba_respect_priorities_init <- 0.0;\n\tfloat acc_gain_threshold_init <- 0.2;\n\tfloat min_safety_distance_init <- 0.5;\n\t\n\tfloat max_safe_deceleration <- 4.0;\n\tfloat time_before_parking <- #max_float;\n\t\n}\n\nspecies pedestrian parent: moving_agent schedules:[]{\n\tfloat vehicle_length_init <- 0.28#m;\n\tint num_lanes_occupied <- 1;\n\tfloat max_speed <- gauss(1.34,0.26) min: 0.5;\n\tfloat max_acceleration_init <- rnd(1.1,1.6);\n\tfloat safety_distance_coeff_init <- 0.2;\n\tfloat time_headway_init <- gauss(0.5,0.1) min: 0.25;\n\tfloat politeness_factor_init <- 0.0;\n\tfloat max_safe_deceleration <- 2.0;\n\tfloat acc_bias <- 0.0;\n\tfloat lane_change_cooldown <- 0.0;\n\t\n\t\n\tfloat proba_respect_priorities_init <- 0.0;\n\tfloat acc_gain_threshold_init <- 0.01;\n\tfloat min_safety_distance_init <- 0.2;\n\t\n\tfloat time_before_parking <- rnd(5.0, 10.0);\n\t\n\t\n\taspect default {\n\t\tif (current_road != nil) {\n\t\t\tpoint pos <- compute_position();\n\t\t\tdraw triangle(vehicle_length *3) rotate: heading + 90 at: pos color: color  border:  parked ? #red :#black ;//depth: 1.0;\n\t\t}\n\t}\n\t\n\taspect demo {\n\t\tif (current_road != nil) {\n\t\t\tpoint pos <- compute_position();\n\t\t\tdraw circle(vehicle_length_init ) at: pos  color: rgb(color.red, color.green, color.blue, 0.5);\n\t\t\t\n\t\t\tdraw circle(vehicle_length_init ) \n\t\t\t\tat: pos color: color ;// border: #black depth: 1.0;\n\t\t}\n\t}\n}\n\n\nspecies bicycle parent: moving_agent schedules:[]{\n\tfloat vehicle_length_init <- 1.71#m;\n\tint num_lanes_occupied <- 1;\n\tfloat max_speed <- gauss(13.48,4.0) #km/#h min: 5 #km/#h;\n\tfloat max_acceleration_init <- rnd(0.8,1.2);\n\tfloat safety_distance_coeff_init <- 0.2;\n\tfloat time_headway_init <- gauss(1.0,0.25) min: 0.25;\n\tfloat politeness_factor_init <- 0.05;\n\tfloat max_safe_deceleration <- 2.0;\n\tfloat acc_bias <- 0.0;\n\tfloat lane_change_cooldown <- 0.0;\n\t\n\t\n\tfloat proba_respect_priorities_init <- 0.0;\n\tfloat acc_gain_threshold_init <- 0.05;\n\tfloat min_safety_distance_init <- 0.2;\n\t\n\t\n\tfloat time_before_parking <- rnd(10.0, 20.0);\n\t\n}\n\n\nspecies motorbike parent: moving_agent schedules:[]{\n\n\tfloat vehicle_length_init <- 1.9#m;\n\tint num_lanes_occupied <- 1;\n\tfloat max_speed <-70 #km/#h ;\n\tfloat max_acceleration_init <- rnd(2.8,5.0);\n\tfloat safety_distance_coeff_init <- 0.2;\n\tfloat time_headway_init <- gauss(1.09,0.5) min: 0.25;\n\tfloat politeness_factor_init <- 0.1;\n\tfloat max_safe_deceleration <- 3.0;\n\tfloat acc_bias <- 0.0;\n\tfloat lane_change_cooldown <- 0.0;\n\t\n\t\n\tfloat proba_respect_priorities_init <- 0.0;\n\tfloat acc_gain_threshold_init <- 0.1;\n\tfloat min_safety_distance_init <- 0.2;\n\t\n\t\n\tfloat time_before_parking <-  rnd(10.0, 30.0);\n\t\n}\n\nexperiment main type: gui {\n\tfloat minimum_cycle_duration <- 0.01;\n\taction _init_ {\n\t\tcreate simulation with: (alpha:1.0, beta:1.0, coeff_change_path:0.01, tj_threshold:0.75);\n\t}\n\toutput {\n\t\tlayout  tabs:false editors: false consoles: false navigator: false;\n\t\tdisplay map type: opengl axes: false background: #black{\n\t\t\tspecies road refresh: false;\n\t\t\tspecies intersection;\n\t\t\tspecies evacuation_point transparency: 0.3  refresh: false;\n\t\t\tspecies building refresh: false;\n\t\t\tspecies car ;\n\t\t\tspecies motorbike ;\t\n\t\t\tspecies bicycle ;\t\n\t\t\tspecies pedestrian ;\n\t\t\t\n\t\t\t overlay position: { 5, 5 } size: { 320 #px, 60 #px } background: #gray transparency: 0.1 border: #black rounded: true\n            {\n            \tdraw \"Evacuation: \" + (init_num_people - length(people))+ \"/\" + init_num_people + \" people\" font: font(20) color: #white at: { 10#px, 35#px } ;\n\n            }\n            \n            graphics \"model_description\" {\n            \tdraw (rectangle(800, 300).contour + 2) at: {0, 1000} color: #red;\n            \tdraw model_description_1 font: font(10) color: #white at: {-370, 900};\n            \tdraw model_description_2 font: font(10) color: #white at: {-370, 940};\n            \tdraw model_description_3 font: font(10) color: #white at: {-370, 980};\n            \tdraw model_description_4 font: font(10) color: #white at: {-370, 1020};\n            \tdraw model_description_5 font: font(10) color: #white at: {-370, 1060};\n            \tdraw model_description_6 font: font(10) color: #white at: {-370, 1100};\n            }\n\t\t}\n\t\t\n\t}\n}"}
{"prompt": "**This is a simulation of multicriteria decision-making using various methods (Weighted Means, Electre, Promethee, Evidence Theory, and Choquet) to select houses based on their attributes. The user can adjust parameters such as weights, preference thresholds, indifference thresholds, veto thresholds, and max preference values to see how they affect the selection process.**", "gaml_code": "/**\n* Name: Multicriteria\n* Author: Patrick Taillandier\n* Description: This model shows how to use different methods of multicriteria analysis to look for the best house. Five methods are used : \n* the Weighted_Means method , the Electre method , the Promethee method, the Fuzzy Choquet Integral  anc the Evidence Theory method. Each method uses \n* different criteria with different weights according to the methods used. \n* Tags: multi_criteria\n*/\n\nmodel multicriteria\n\nglobal {\n\tfloat weight_standing <- 1.0;\n\tfloat weight_price <- 1.0;\n\tfloat weight_distance <- 1.0;\n\tfloat weight_area <- 1.0;\n\tfloat p_standing <- 0.5;\n\tfloat p_price <- 0.5;\n\tfloat p_distance <- 0.5;\n\tfloat p_area <- 0.5;\n\tfloat q_standing <- 0.0;\n\tfloat q_price <- 0.0;\n\tfloat q_distance <- 0.0;\n\tfloat q_area <- 0.0;\n\tfloat v_standing <- 1.0;\n\tfloat v_price <- 1.0;\n\tfloat v_distance <- 1.0;\n\tfloat v_area <- 1.0;\n\tfloat s_standing <- 1.0;\n\tfloat s_price <- 1.0;\n\tfloat s_distance <- 1.0;\n\tfloat s_area <- 1.0;\n\tfloat s1_standing <- 0.0;\n\tfloat s1_price <- 0.0;\n\tfloat s1_distance <- 0.0;\n\tfloat s1_area <- 0.0;\n\tfloat s2_standing <- 1.0;\n\tfloat s2_price <- 1.0;\n\tfloat s2_distance <- 1.0;\n\tfloat s2_area <- 1.0;\n\tfloat v1p_standing <- 0.0;\n\tfloat v1p_price <- 0.0;\n\tfloat v1p_distance <- 0.0;\n\tfloat v1p_area <- 0.0;\n\tfloat v2p_standing <- 1.0;\n\tfloat v2p_price <- 1.0;\n\tfloat v2p_distance <- 1.0;\n\tfloat v2p_area <- 1.0;\n\tfloat v1c_standing <- 0.0;\n\tfloat v1c_price <- 0.0;\n\tfloat v1c_distance <- 0.0;\n\tfloat v1c_area <- 0.0;\n\tfloat v2c_standing <- 0.0;\n\tfloat v2c_price <- 0.0;\n\tfloat v2c_distance <- 0.0;\n\tfloat v2c_area <- 0.0;\n\t\n\t//Lists that will store the different criteria to use for each method linked with their weights\n\tlist<string> criteria <- [\"standing\", \"price\", \"distance\", \"area\"];\n\tlist criteria_WM <- [[\"name\"::\"standing\", \"weight\" :: weight_standing],[\"name\"::\"price\", \"weight\" :: weight_price],[\"name\"::\"distance\", \"weight\" ::weight_distance],[\"name\"::\"area\", \"weight\" :: weight_area]]; \n\tlist criteria_Electre <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"v\"::v_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"v\"::v_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"v\"::v_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"v\"::v_area,  \"maximize\" :: true]]; \n\tlist criteria_Promethee <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"s\"::s_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"s\"::s_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"s\"::s_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"s\"::s_area,  \"maximize\" :: true]];  \n\tlist criteria_ET <- [[\"name\"::\"standing\", \"s1\"::s1_standing, \"s2\"::s2_standing, \"v1p\"::v1p_standing, \"v2p\"::v2p_standing, \"v1c\"::v1c_standing, \"v2c\"::v2c_standing,\"maximize\" :: true],[\"name\"::\"price\", \"s1\"::s1_price, \"s2\"::s2_price, \"v1p\"::v1p_price, \"v2p\"::v2p_price, \"v1c\"::v1c_price, \"v2c\"::v2c_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"s1\"::s1_distance, \"s2\"::s2_distance, \"v1p\"::v1p_distance, \"v2p\"::v2p_distance, \"v1c\"::v1c_distance, \"v2c\"::v2c_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"s1\"::s1_area, \"s2\"::s2_area, \"v1p\"::v1p_area, \"v2p\"::v2p_area, \"v1c\"::v1c_area, \"v2c\"::v2c_area, \"maximize\" :: true]];\n\tmap<list<string>,float> criteria_FC <- map<list<string>, float>([ \n\t\t[[\"standing\"]::weight_standing, [\"price\"]::weight_price, [\"distance\"]:: weight_distance, [\"area\"]::weight_area,\n\t\t[\"standing\",\"price\"]::(weight_standing+weight_price) * 2/3,[\"area\",\"price\"]::(weight_standing+weight_price) * 2/3 , \n\t\t[\"standing\",\"price\",\"area\"]::(weight_standing+weight_price + weight_area) * 2/3]\n\t]); \n\t\n\tinit {\n\t\tcreate people;\n\t\tgeometry free_space <- copy(shape);\n\t\tfree_space <- free_space - 10;\n\t\tcreate house number: 15 {\n\t\t\tlocation <- any_location_in (free_space);\n\t\t\tfree_space <- free_space - (shape + 10);\n\t\t}\n\t}\n\t\n\treflex reset_selected {\n\t\task house {\n\t\t\tis_selected_WM <- false;\n\t\t\tis_selected_electre <- false;\n\t\t\tis_selected_promethee <- false;\n\t\t\tis_selected_ET <- false;\n\t\t\tis_selected_choquet <- false;\n\t\t}\n\t\tcriteria_WM <- [[\"name\"::\"standing\", \"weight\" :: weight_standing],[\"name\"::\"price\", \"weight\" :: weight_price],[\"name\"::\"distance\", \"weight\" ::weight_distance],[\"name\"::\"area\", \"weight\" :: weight_area]]; \n\t\tcriteria_Electre <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"v\"::v_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"v\"::v_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"v\"::v_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"v\"::v_area,  \"maximize\" :: true]]; \n\t\tcriteria_Promethee <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"s\"::s_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"s\"::s_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"s\"::s_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"s\"::s_area,  \"maximize\" :: true]]; \n\t\tcriteria_ET <- [[\"name\"::\"standing\", \"s1\"::s1_standing, \"s2\"::s2_standing, \"v1p\"::v1p_standing, \"v2p\"::v2p_standing, \"v1c\"::v1c_standing, \"v2c\"::v2c_standing,\"maximize\" :: true],[\"name\"::\"price\", \"s1\"::s1_price, \"s2\"::s2_price, \"v1p\"::v1p_price, \"v2p\"::v2p_price, \"v1c\"::v1c_price, \"v2c\"::v2c_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"s1\"::s1_distance, \"s2\"::s2_distance, \"v1p\"::v1p_distance, \"v2p\"::v2p_distance, \"v1c\"::v1c_distance, \"v2c\"::v2c_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"s1\"::s1_area, \"s2\"::s2_area, \"v1p\"::v1p_area, \"v2p\"::v2p_area, \"v1c\"::v1c_area, \"v2c\"::v2c_area, \"maximize\" :: true]];\n\t\tcriteria_FC <- map<list<string>, float>([ \n\t\t[[\"standing\"]::weight_standing, [\"price\"]::weight_price, [\"distance\"]:: weight_distance, [\"area\"]::weight_area,\n\t\t[\"standing\",\"price\"]::(weight_standing+weight_price) * 2/3,[\"area\",\"price\"]::(weight_standing+weight_price) * 2/3 , \n\t\t[\"standing\",\"price\",\"area\"]::(weight_standing+weight_price + weight_area) * 2/3]]);\n\t}\n\t\n}\n\t\n\nspecies people  {\n\taspect default {\n\t\tdraw sphere(2) color: #red;\n\t}\n\t\n\treflex choose_house_weighted_means {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- weighted_means_DM(cands, criteria_WM);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_WM <- true;}\n\t\t}\n\t}\n\t\n\treflex choose_house_fuzzy_choquet {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- fuzzy_choquet_DM(cands, criteria, criteria_FC);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_choquet <- true;}\n\t\t}\n\t}\n\t\n\treflex choose_house_promethee {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- promethee_DM(cands, criteria_Promethee);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_promethee <- true;}\n\t\t}\n\t}\n\treflex choose_house_electre {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- electre_DM(cands, criteria_Electre, 0.7);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_electre <- true;}\n\t\t}\n\t}\n\treflex choose_house_evidence_theory {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- evidence_theory_DM(cands, criteria_ET, true);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_ET <- true;}\n\t\t}\n\t}\n\t\n\tlist<list> houses_eval {\n\t\tlist<list> candidates;\n\t\tloop bat over: house {\n\t\t\tlist<float> cand;\n\t\t\tadd bat.standing / 5 to: cand;\n\t\t\tadd ((500000 - bat.price) / 500000) to: cand;\n\t\t\tadd ((100 - (self distance_to bat)) / 100) to: cand;\n\t\t\tadd (bat.shape.area / 15^2) to: cand;\n\t\t\tadd cand to: candidates;\n\t\t}\n\t\treturn candidates;\n\t}\n\t\n}\n\nspecies house {\n\tbool is_selected_WM <- false;\n\tbool is_selected_electre <- false;\n\tbool is_selected_promethee <- false;\n\tbool is_selected_ET <- false;\n\tbool is_selected_choquet <- false;\n\tgeometry shape <- square(5 + rnd(10));\n\tfloat price <- 100000.0 + rnd (400000);\n\tint standing <- rnd(5);\n\trgb color <- rgb(255 * (1 - standing/5.0),255 * (1 - standing/5.0),255);\n\tfloat height <- price / 50000;\n\taspect weighted_means_aspect {\n\t\tif (is_selected_WM) {\n\t\t\tdraw shape + 2.0 color: #red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect electre_aspect {\n\t\tif (is_selected_electre) {\n\t\t\tdraw shape + 2.0 color: #red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect promethee_aspect {\n\t\tif (is_selected_promethee) {\n\t\t\tdraw shape + 2.0 color: #red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect evidence_theory_aspect {\n\t\tif (is_selected_ET) {\n\t\t\tdraw shape + 2.0 color: #red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect choquet_aspect {\n\t\tif (is_selected_choquet) {\n\t\t\tdraw shape + 2.0 color: #red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n}\n\n\nexperiment multicriteria type: gui {\n\tparameter \"weight of the standing criterion\" var:weight_standing category: \"Weight\";\n\tparameter \"weight of the price criterion\" var:weight_price category: \"Weight\";\n\tparameter \"weight of the distance criterion\" var:weight_distance category: \"Weight\";\n\tparameter \"weight of the area criterion\" var:weight_area category: \"Weight\";\n\tparameter \"preference threshold of the standing criterion\" var:p_standing category: \"Preference\";\n\tparameter \"preference threshold of the price criterion\" var:p_price category: \"Preference\";\n\tparameter \"preference threshold of the distance criterion\" var:p_distance category: \"Preference\";\n\tparameter \"preference threshold of the area criterion\" var:p_area category: \"Preference\";\n\tparameter \"indifference threshold of the standing criterion\" var:q_standing category: \"Indifference\";\n\tparameter \"indifference threshold of the price criterion\" var:q_price category: \"Indifference\";\n\tparameter \"indifference threshold of the distance criterion\" var:q_distance category: \"Indifference\";\n\tparameter \"indifference threshold of the area criterion\" var:q_area category: \"Indifference\";\n\tparameter \"veto threshold of the standing criterion\" var:v_standing category: \"Veto\";\n\tparameter \"veto threshold of the price criterion\" var:v_price category: \"Veto\";\n\tparameter \"veto threshold of the distance criterion\" var:v_distance category: \"Veto\";\n\tparameter \"veto threshold of the area criterion\" var:v_area category: \"Veto\";\n\tparameter \"max preference value of the standing criterion\" var:v_standing category: \"Max preference value\";\n\tparameter \"max preference value of the price criterion\" var:v_price category: \"Max preference value\";\n\tparameter \"max preference value of the distance criterion\" var:v_distance category: \"Max preference value\";\n\tparameter \"max preference value of the area criterion\" var:v_area category: \"Max preference value\";\n\tparameter \"min criterion threshold of the standing criterion\" var:s1_standing category: \"Evidence Theory\";\n\tparameter \"min criterion threshold of the price criterion\" var:s1_price category: \"Evidence Theory\";\n\tparameter \"min criterion threshold of the distance criterion\" var:s1_distance category: \"Evidence Theory\";\n\tparameter \"min criterion threshold of the area criterion\" var:s1_area category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the standing criterion\" var:s2_standing category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the price criterion\" var:s2_price category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the distance criterion\" var:s2_distance category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the area criterion\" var:s2_area category:\"Evidence Theory\";\n\tparameter \"min preference of the standing criterion\" var:v1p_standing category: \"Evidence Theory\";\n\tparameter \"min preference of the price criterion\" var:v1p_price category: \"Evidence Theory\";\n\tparameter \"min preference of the distance criterion\" var:v1p_distance category: \"Evidence Theory\";\n\tparameter \"min preference of the area criterion\" var:v1p_area category: \"Evidence Theory\";\n\tparameter \"max preference of the standing criterion\" var:v2p_standing category: \"Evidence Theory\";\n\tparameter \"max preference of the price criterion\" var:v2p_price category: \"Evidence Theory\";\n\tparameter \"max preference of the distance criterion\" var:v2p_distance category: \"Evidence Theory\";\n\tparameter \"max preference of the area criterion\" var:v2p_area category: \"Evidence Theory\";\n\tparameter \"min rejection of the standing criterion\" var:v1c_standing category: \"Evidence Theory\";\n\tparameter \"min rejection of the price criterion\" var:v1c_price category: \"Evidence Theory\";\n\tparameter \"min rejection of the distance criterion\" var:v1c_distance category: \"Evidence Theory\";\n\tparameter \"min rejection of the area criterion\" var:v1c_area category: \"Evidence Theory\";\n\tparameter \"max rejection of the standing criterion\" var:v2c_standing category: \"Evidence Theory\";\n\tparameter \"max rejection of the price criterion\" var:v2c_price category: \"Evidence Theory\";\n\tparameter \"max rejection of the distance criterion\" var:v2c_distance category: \"Evidence Theory\";\n\tparameter \"max rejection of the area criterion\" var:v2c_area category: \"Evidence Theory\";\n\toutput {\n\t\tlayout #split;\n\t\tdisplay Map_Weighted_Means type: 3d{\n\t\t\tspecies house aspect: weighted_means_aspect;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Electre type: 3d{\n\t\t\tspecies house aspect: electre_aspect;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Promethee type: 3d{\n\t\t\tspecies house aspect: promethee_aspect;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Evidence_theory type: 3d{\n\t\t\tspecies house aspect: evidence_theory_aspect;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Choquet type: 3d{\n\t\t\tspecies house aspect: choquet_aspect;\n\t\t\tspecies people;\n\t\t}\n\t}\n}"}
{"prompt": "Design a simulation model that compares the performance of an Agent-Based Model (ABM) and a mathematical model in simulating pedestrian movement through corridors, including capturing pedestrians and releasing them at different times.", "gaml_code": "/**\n* Name: Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model\n* Author: Ngoc Anh, Anh, Jean-daniel \n* Description: This model shows how to use multi-level architecture. Two corridors are presented : one which can capture the pedestrians \n* \tgoing through it and computing for them the time before releasing them at the end of the corridor, and an other doing nothing, letting \n* \tthe pedestrians moving by themselves in the corridor. \n* Tags: multi_level, agent_movement\n*/\n\nmodel pedestrian_corridor_Hybrid_vs_ABM\n\nglobal \n{\n\t\n\t//Parameters of the environment\n\tint environment_width <- 200 const: true;\n\tint environment_height <- 100 const: true;\n\tgeometry shape <- rectangle(environment_width, environment_height);\t\n\t\n\t\n\tfloat pedestrian_speed <- 2.0;\n \n \t//Parameters of the corridors\n\tint corridor_width <- 160 ;\n\tint corridor_height <- (int(environment_height * 0.1));\n\n\tpoint corridor_location_0 <- {environment_width / 2, environment_height / 4};\n\tgeometry corridor_shape_0 <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_0) ;\n\n\tpoint corridor_location_1 <- {environment_width / 2, environment_height * 0.75};\n\tgeometry corridor_shape_1 <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_1) ;\n\n\t//Parameters of pedestrian generation\n\tint new_pedestian_generate_frequency <- 2 update: rnd(10) + 1;\n\tpoint pedestrian_source_0 <- {0, corridor_location_0.y} ;\n\tpoint pedestrian_source_1 <- {0, corridor_location_1.y} ;\n\t \n\t \n\t \n\tinit \n\t{\n\t\tcreate corridor number: 2 returns: new_corridors;\n\t\t\n\t\task (new_corridors at 0) \n\t\t{\n\t\t\tdo init_corridor corridor_shape: corridor_shape_0 is_hybrid: false;\n\t\t}\n\n\t\task (new_corridors at 1) \n\t\t{\n\t\t\tdo init_corridor corridor_shape: corridor_shape_1 is_hybrid: true; \n\t\t}\n\t}\n\n\t//Generation of pedestrians according to the frequency of generation : one for each corridor\n\treflex generate_pedestrians when: ( (cycle mod new_pedestian_generate_frequency) = 0 ) \n\t{ \n\t\tcreate pedestrian number: 2 returns: new_pedestrians;\n\t\t\n\t\task (new_pedestrians at 0) \n\t\t{\n\t\t\tdo init_location loc: pedestrian_source_0;\n\t\t}\n\t\t\n\t\task (new_pedestrians at 1) \n\t\t{\n\t\t\tdo init_location loc: pedestrian_source_1;\n\t\t}\n\t}\t\n}\n\n\n//Species for the pedestrians which can move\nspecies pedestrian skills: [moving] {\n\tcorridor last_corridor;\n\tpoint target_location;\n\tfloat speed <- pedestrian_speed;\n\trgb color;\n\t\n\t//Initialisation of the target location according to its generation location\n\taction init_location (point loc) {\n\t\tlocation <- loc;\n\t\ttarget_location <- {environment_width, location.y};\n\t\tint i <- rnd(255);\n\t\tcolor <- rgb(i,i,i);\n\t}\n\n\t//Reflex to move the agent to its target location and make it die once it reached its target\n\treflex move_left \n\t{\n\t\tdo move heading: (self) towards (target_location); \n\t\t\n\t\tif ( (target_location.x - location.x) <= speed ) \n\t\t{\n\t\t\tdo die;\n\t\t}\n\t}\n\t \n}\n\n//Species for the corridor which can capture pedestrians\nspecies corridor  {\n\tbool capture_pedestrians;\n\t\n\t\n\taction init_corridor (geometry corridor_shape, bool is_hybrid) \n\t{\n\t\tshape <- corridor_shape;\n\t\tcapture_pedestrians <- is_hybrid;\n\t}\n\n\tfloat max_speed <- pedestrian_speed;\n\tfloat macro_length min: 0.0 <- float(corridor_width); // the length of macro_patch\n\t\n\t//Species to model the pedestrian captured by the corridor\n\tspecies captured_pedestrian parent: pedestrian schedules: [] \n\t{\n\t\tfloat released_time;  \n\t\t\n\t\taspect default { }\n\t}\n\t\n\tinit \n\t{ \n\t\tcreate corridor_info_drawer number: 1 with: [target :: self];\n\t}\n\t//Reflex to capture the pedestrians overlapping the corridor ie entering the corridor \n\treflex aggregate when: capture_pedestrians \n\t{\n\t\tlist<pedestrian> tobe_captured_pedestrians <- (pedestrian overlapping shape) where ( (each.last_corridor != self) and ((each.location).x < (self.location).x) ) ; \n\t\t\n\t\tif !(empty (tobe_captured_pedestrians)) \n\t\t{\n\t\t\tcapture tobe_captured_pedestrians as: captured_pedestrian returns: cps { \n\t\t\t\tlast_corridor <- myself;\n\t\t\t}\n\t\t\tif !(empty (cps)) \n\t\t\t{\n\t\t\t\t\t//Computation of the time when the pedestrians captured will be released according to the speed\n\t\t\t\t\t// and the time they should make to pass the corridor if they move by themselves\n\t\t\t\t\tfloat group_outgoing_time <- time + (corridor_width / (pedestrian_speed) ); \n\t\t\t\t\tloop cp over: cps \n\t\t\t\t\t{\n\t\t\t\t\t\t\tcp.released_time <- group_outgoing_time;\n\t \t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\t\n\t//Reflex to release the pedestrians when we consider they were enough time inside the corridor \n\treflex disaggregate  \n\t{\n\t\tlist tobe_released_pedestrians <- members where (time >= (captured_pedestrian (each)).released_time);\n\t\t\n\t\tif !(empty (tobe_released_pedestrians)) \n\t\t{\n\t\t\t\n\t\t\trelease tobe_released_pedestrians as: pedestrian in: world returns: released_pedestrians;\n\t\t\t\n\t\t\tloop rp over: released_pedestrians \n\t\t\t{\n\t\t\t\trp.speed <- pedestrian_speed;\n\t\t\t\trp.location <- {((environment_width / 2) + (corridor_width / 2)), ((corridor_shape_1).location).y};\n\t\t\t}\n\t\t}\n\t}\n\n}\n \nspecies corridor_info_drawer \n{\n\tcorridor target;\n\t\n\taspect base \n\t{\n\t\tif target.capture_pedestrians \n\t\t{\n\t\t\tdraw 'Hybrid model (coupling: ABM and Mathematical Model)' color: #yellow at: {(target.location).x - target.shape.width/2, (target.location).y - 10} font: font(\"Helvetica\", 20 * #zoom, #bold);\n\t\t\tdraw  'Captured agents: ' + string(length(target.members)) color: #yellow at: {(target.location).x + 1 - target.shape.width/2, (target.location).y + 1} font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t} \n\t\telse \n\t\t{\n\t\t\tdraw 'Agent-Based Model (ABM)' color: #yellow size: 7 at: {(target.location).x - target.shape.width/2, (target.location).y - 10} font: font(\"Helvetica\", 20 * #zoom, #bold);\n\t\t}\n\t}\n}\n\nexperiment default_experiment type: gui autorun: true\n{\n\tfloat minimum_cycle_duration <- 10 #msec;\n\toutput \n\t{\n\t\tdisplay default_display background: #black toolbar: false fullscreen: true type:2d\n\t\t{\n\t\t\tspecies pedestrian {\n\t\t\t\tdraw circle(2) color: color;\n\t\t\t}\n\t\t\tspecies corridor {\n\t\t\t\tdraw shape wireframe: true color: #white;\n\t\t\t}\n\t\t\tspecies corridor_info_drawer aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of a multi-level ecosystem where preys and predators interact with each other and shelters, demonstrating agent movement, perception, and state changes.", "gaml_code": "/**\n* Name: Multi-Level Architecture with Preys and Predators\n* Author: \n* Description: This model shows how to use multi-level architecture. In this model, prey and predators agents move randomly \n*\t in the environment. When a prey agent perceive a predator, it flees trying to go to the closest shelters while the predator \n* \t agent chases it. The shelters capture the prey agents fleeing, changing them into prey_in_shelter species, that predator \n* \tcan't chase during a certain time. They are released after that time in an invisible state so that they can wander in the  \n* \tenvironment without being chase by the predator, but also, for a certain time.\n* Tags: multi_level, agent_movement\n*/\n\nmodel preys_predators_shelters\n\nglobal { \n\t//Parameters for the prey species\n\trgb prey_color <- #green const: true;\n\tfloat prey_perception <- 20.0;\n\tfloat prey_size <- 2.0 const: true;\n\tfloat prey_speed <- 1.0;\n\trgb prey_flee_color <- #orange;\n\tfloat prey_invisible_speed <- 3 * prey_speed;\n\trgb prey_invisible_color <- #darkgray;  \n\tint prey_in_shelter_max_time min: 1 init: 200;\n\tint prey_invisible_max_time min: 1 max: 100 init: 70; \n\tint number_of_preys min: 1 max: 1000 init: 500;\n\t\n\t//Parameters for the predator species\n\trgb predator_color <- #red const: true;\n\tfloat predator_perception <- 3.0;\n\tfloat predator_size <- 4.0;\n\tfloat predator_speed <- 1.5;\n\tint number_of_predators min: 1 max: 100 init: 30; \n\tgeometry shape <- square(400);\n\t\n\trgb predator_in_shelter_color <- #yellow const: true;\n\t \n\t//Parameters for the shelter species\n\trgb shelter_color <- #blue const: true; \n\tfloat shelter_speed <- 1.5 const: true;\n\tgeometry shelter_shape <- square (50.0);\n\tint number_of_shelter <- 2 const: true;\n\t\n\t\n\tinit {\n\t\tcreate prey number: number_of_preys;\n\t\tcreate predator number: number_of_predators; \n\t\tcreate shelter number: number_of_shelter {\n\t\t\tshape <- shelter_shape at_location any_point_in(world);\n\t\t}\n\t}\n}\n//Species prey which can move using the skill moving and its operators\nspecies prey skills: [moving] control: fsm {\n\tgeometry shape <- square (prey_size);\n\trgb color <- prey_color;\n\t\n\t//List of all predators inside the perception of the prey\n\tlist nearby_predators update:  predator overlapping (shape + prey_perception) ;\n\tint invisible_time min: 1 <- int(time);\n\n\tshelter nearest_shelter;\t\t\n\n\t//State to make the prey move randomly when there isn't any predator, if so, change the state to flee\n\tstate move_around initial: true {\n\t\tenter {\n\t\t\tcolor <- prey_color;\n\t\t}\n\t\tdo wander speed: prey_speed; \n\t\t\n\t\ttransition to: flee_predator when: !(empty (nearby_predators)); \n\t}\n\t\n\t//State to make the prey move to the closest shelter to flee from the predator, if no predator are perceived, change the state to move aroung\n\tstate flee_predator {\n\t\tenter {\n\t\t\tcolor <- prey_flee_color;\n\t\t\tnearest_shelter <- shelter closest_to self;\n\t\t}\n\t\tif !(empty (nearby_predators)) { do move heading: (self) towards (nearest_shelter) speed: prey_speed;}\n\t\t\n\t\ttransition to: move_around when: (empty (nearby_predators));\n\t}\n\t//State to make the prey invisible during a certain time when it is released by the shelters\n\tstate invisible {\n\t\tenter {\n\t\t\tcolor <- prey_invisible_color;\n\t\t\tinvisible_time <- int(time);\n\t\t\theading <- rnd (360.0) ;\n\t\t}\n\n\t\tdo move speed:prey_invisible_speed heading: heading ;\n\t\ttransition to: move_around when: ( (time - invisible_time) > prey_invisible_max_time );\n\t}\n\t\n\taspect default {\n\t\tdraw  shape color: color;\n\t}\n}\n\n//Species predator which can move using the skill moving\nspecies predator skills: [moving] schedules: shuffle (list (predator)) {\n\tgeometry shape <- square (predator_size);\n\tprey target_prey update: self.choose_target_prey();\n\t\n\t//Change the target prey according to the prey who aren't fleeing if it doesn't have any yet\n\taction choose_target_prey type: prey {\n\t\tif ( (target_prey = nil) or (dead (target_prey) ) ) {\n\t\t\treturn one_of ( (list (prey)) where (each.state = 'move_around') );\n\t\t}\n\t\t\n\t\treturn target_prey;\n\t}\n\t//Reflex to move randomly when no prey are perceived\n\treflex move_around when: (target_prey = nil) { do wander speed: predator_speed; }\n\t\n\t//Reflex to make the predator chase a prey\n\treflex chase_prey when: (target_prey != nil) { do move heading: self towards target_prey speed: predator_speed;}\n\t\n\taspect default {\n\t\tdraw shape color: predator_color;\n\t} \n} \n\n//Species shelter that will capture prey agents\nspecies shelter skills: [moving]  frequency: 2 {\n\tgeometry shape <- (square (50.0)) at_location {250, 250};\n\t\n\t//List of all preys which are being chased and inside the shelter but not captured yet\n\tlist<prey> chased_preys update: (prey) where ( (each.shape intersects shape) and (each.state = 'flee_predator') );\n\t\n\t//Capture all the chased preys inside the shelter and change their species to prey_in_shelter\n\treflex capture_chased_preys when: !(empty (chased_preys)) { \n\t\tcapture chased_preys as: prey_in_shelter {\n\t\t\tstate <- 'in_shelter'; \n\t\t\tshape <- ( triangle (4.0) ) at_location location;\n\t\t}\n\t}\n\t\n\t//Release all the prey_in_shelter after a certain time and change their state to invisible after making their species returned to prey\n\treflex release_member_preys {\n\t\tlist<prey_in_shelter> to_be_released <- (prey_in_shelter) where ( (time - each.in_shelter_time) > prey_in_shelter_max_time );\n\t\t \n\t\trelease to_be_released in: world as: prey { \n\t\t\tstate <- 'invisible';\n\t\t\tshape <-  at_location (square (prey_size), self.location);   \n\t\t}\n\t} \n\t\n\t//Subspecies prey_in_shelter that will represent the prey agents captured by the shelter\n\tspecies prey_in_shelter parent: prey frequency: 2 schedules: ( ( int ( (length (prey_in_shelter)) / 2 ) ) among (list (prey_in_shelter)) ) {\n\t\tint in_shelter_time <- int(time);\n\t\t\n\t\tstate in_shelter {\n\t\t\tdo wander speed: shelter_speed;\n\t\t}\n\t\t\n\t\taspect default {\n\t\t\tdraw  shape color: predator_in_shelter_color;\n\t\t} \n\t}\n\t\n\taspect default {\n\t\tdraw shape color: shelter_color;\n\t\tdraw (string (length ((members)))) color: rgb ('white') size: 6 at: location anchor: #center font: font(\"Helvetica\", 12*#zoom, #bold);\n\t}\n}\n\nexperiment default_experiment type: gui {\n\toutput {\n\t\tdisplay default_display background: #black{\n\t\t\tspecies prey aspect: default;\n\t\t\tspecies predator transparency: 0.5 aspect: default;\n\t\t\tspecies shelter transparency: 0.5 aspect: default { \n\t\t\t\tspecies prey_in_shelter aspect: default;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of a corridor where pedestrians can move from one side to another and are captured by the corridor if they enter it. The corridor should have two walls that capture pedestrians and release them after a certain time.", "gaml_code": "/**\n* Name: Corridor Multi-Level Architecture\n* Author: Vo Duc An; Ngoc Anh; JD Zucker; A. Drogoul\n* Description: This model shows how to use multi-level architecture. A corridor can capture pedestrians going from left to right side if \n*\tthey are inside the corridor. This will result in changing their species from pedestrian to captured_pedestrian which will not be \n*\tdisplayed. Once they pass enought time to consider they reach the exit of the corridor, they will be released by the corridor agent \n*\tas pedestrians, letting them been displayed and going to their target. \n* Tags: multi_level, agent_movement\n*/\nmodel corridor\n\nglobal {\n//Capture pedestrians parameter to define if wall will capture pedestrians\n\tbool capture_pedestrians <- false;\n\tint environment_width init: 8000;\n\tint environment_height init: 3000;\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\n\t//Pedestrians parameters\n\trgb pedestrian_color <- #green;\n\tfloat pedestrian_speed <- 10.0;\n\n\t//Wall parameters\n\tfloat corridor_width <- environment_width / 1.5;\n\tint corridor_wall_height <- 800;\n\tgeometry corridor_wall_0_shape <- rectangle({corridor_width, corridor_wall_height}) at_location {environment_width / 2, corridor_wall_height / 2};\n\tgeometry corridor_wall_1_shape <- rectangle({corridor_width, corridor_wall_height}) at_location {environment_width / 2, environment_height - (corridor_wall_height / 2)};\n\t\n\n\t//Corridor parameters\n\tfloat corridor_left_bounds <- (location.x - (corridor_width / 2));\n\tfloat corridor_right_bounds <- (location.x + (corridor_width / 2));\n\n\tinit {\n\t\tcreate corridor;\n\t}\n\n\treflex change_color when: every(200 #cycle) {\n\t\tpedestrian_color <- rnd_color(255);\n\t}\n\n\treflex generate_pedestrians when: every(4 #cycle) {\n\t\tcreate pedestrian number: 30 with: [color::pedestrian_color] {\n\t\t\tdo init_location({0, rnd(environment_height)});\n\t\t}\n\t}\n}\n\n//Species pedestrian which will move from one side of the experiment to another and destroy itself once the other side is reached\nspecies pedestrian skills: [moving] topology: (topology(shape - (corridor_wall_0_shape + corridor_wall_1_shape))) {\n\tpoint target_location;\n\trgb color;\n\n\taction init_location (point loc) {\n\t\tlocation <- loc;\n\t\ttarget_location <- {environment_width, loc.y};\n\t\tspeed <- rnd(pedestrian_speed - 5) + 5.0;\n\t}\n\t\n\t\n\treflex change_speed when: every(rnd(200) #cycle) {\n\t\t\tspeed <- rnd(pedestrian_speed - 5) + 5.0;\n\t}\n\n\t//Reflex to make the agent move to its target_location\n\treflex move {\n\t\tpoint previous_location <- location;\n\n\t\tif (location.y < corridor_wall_height) and (location.x <= (environment_width / 2)) {\n\t\t\tdo move heading: self towards {(environment_width / 2) - (corridor_width / 2), corridor_wall_height};\n\t\t} else if (location.y > environment_height - corridor_wall_height) and (location.x <= (environment_width / 2)) {\n\t\t\tdo move heading: self towards {(environment_width / 2) - (corridor_width / 2), environment_height - corridor_wall_height};\n\t\t} else {\n\t\t\tdo move heading: self towards target_location;\n\t\t}\n\t\tif (location.x = previous_location.x) { // No move detected\n\t\t\tdo move heading: self towards {environment_width, world.shape.location.y};\n\t\t}\n\t}\n\n\treflex arrived when: location.x >= target_location.x {\n\t\tdo die;\n\t}\n\n}\n\n//Species which represents the corridor\nspecies corridor {\n\tgeometry shape <- ((rectangle({corridor_width, environment_height})) at_location world.location) - (corridor_wall_0_shape + corridor_wall_1_shape);\n\n\t//Subspecies for the multi-level architectures : captured pedestrians in this case\n\tspecies captured_pedestrian parent: pedestrian schedules: [] {\n\t\tfloat release_time;\n\t}\n\n\t//Reflex to capture pedestrians if the parameter is checked\n\treflex aggregate when: capture_pedestrians {\n\t//If we have pedestrians inside the corridor, we capture them\n\t//We update the time during which a pedestrian is captured according to the time the pedestrian\n\t// should need to pass through the corridor if it wasn't captured\n\t\tcapture (pedestrian where (p: p.location.x between (corridor_left_bounds, corridor_right_bounds))) as: captured_pedestrian {\n\t\t\trelease_time <- time + ((corridor_width - (location.x - ((environment_width / 2) - (corridor_width / 2)))) / (pedestrian_speed - 2.5));\n\t\t} }\n\n\t\t//Reflex to release pedestrians which have already passed enough time in the corridor\n\t// which means if they weren't captured by the corridor, they would have finish passing through it\n\treflex disaggregate {\n\t\tlist tobe_released_pedestrians <- captured_pedestrian where (time >= each.release_time);\n\t\tif !(empty(tobe_released_pedestrians)) {\n\t\t\trelease tobe_released_pedestrians as: pedestrian in: world {\n\t\t\t\tlocation <- {((environment_width / 2) + (corridor_width / 2)), (location).y};\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nexperiment \"Corridor\" type: gui autorun: true {\n\tpoint button_location;\n\tbool button_hover;\n\tgeometry corridor_wall_0_display <- rectangle({corridor_width-30, corridor_wall_height-30}) at_location {environment_width / 2, corridor_wall_height / 2};\n\tgeometry corridor_wall_1_display <- rectangle({corridor_width-30, corridor_wall_height-30}) at_location {environment_width / 2, environment_height - (corridor_wall_height / 2)};\n\t\n\tinit {\n\t\tbutton_location <- {simulation.corridor_left_bounds + 100, 100};  \n\t}\n\toutput {\n\t\tdisplay defaut_display type: 2d background: #black fullscreen: true toolbar: false {\n\t\t\tgraphics back {\n\t\t\t\tdraw shape color: #black wireframe: false;\n\t\t\t\tdraw corridor_wall_0_display color: #gray wireframe: true;\n\t\t\t\tdraw corridor_wall_1_display color: #gray wireframe: true ;\n\t\t\t}\n\n\t\t\tspecies corridor {\n\t\t\t\tdraw shape color: #black;\n\t\t\t}\n\t\t\t\n\t\t\tagents \"Captured\" value: list(corridor(0).captured_pedestrian) transparency: 0.5 {\n\t\t\t\tdraw square(30) wireframe: false color: #white;\n\t\t\t}\n\n\t\t\tspecies pedestrian {\n\t\t\t\tdraw square(20) wireframe: false color: color;\n\t\t\t}\n\n\t\t\tgraphics front {\n\t\t\t\tdraw (capture_pedestrians ? \"Capturing\":\"Not capturing\") anchor: #left_center at: {corridor_left_bounds + 200, 100} color: !capture_pedestrians ? #darkred : #darkgreen font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Captured: \" + length(corridor(0).captured_pedestrian)) anchor: #left_center at: {corridor_left_bounds + 200, 250} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Pedestrians: \" + length(pedestrian)) anchor: #left_center at: {corridor_left_bounds + 200, 400} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Step duration (ms): \" + (duration copy_between (0, 4))) anchor: #left_center at: {corridor_left_bounds + 200, 550} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t}\n\n\t\t\tgraphics button {\n\t\t\t\tdraw circle(50) color: #darkgray at: button_location;\n\t\t\t\tdraw circle(40) color: !capture_pedestrians ? (button_hover ? #yellow : #red) : (button_hover ? #lightgreen : #darkgreen) at:  button_location;\n\t\t\t}\n\n\t\t\tevent #mouse_down {\n\t\t\t\tif (button_location distance_to #user_location <= 50) {\n\t\t\t\t\tcapture_pedestrians <- !capture_pedestrians;\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #mouse_move {\n\t\t\t\tbutton_hover <- (button_location distance_to #user_location <= 50);\n\t\t\t}\n\t\t}\n\t}\n\n}"}
{"prompt": "**This is a NetLogo model for simulating the behavior of groups and clouds. It includes various species such as balls, groups, and clouds, each with their own behaviors and interactions. The model also includes several experiments to visualize and analyze the simulation results.**", "gaml_code": "/**\n* Name: Balls, Groups and Clouds Multilevel Architecture\n* Author: \n* Description: This model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture \n* \tis used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. \n* \tThe operator release is used to release contained agents and change them into an other species. The experiment shows ball moving \n* \trandomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group \n* \tagents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases \n* \tall its balls repulsively. \n* Tags: multi_level, agent_movement\n*/\nmodel balls_groups_clouds\n\nglobal {\n// Parameters\n\tbool create_group <- true;\n\tbool create_cloud <- true;\n\n\t// Environment\n\tpoint environment_bounds <- {500, 500};\n\tgeometry shape <- rectangle(environment_bounds);\n\n\t//Define a inner environment smaller inside the environment\n\tint inner_bounds_x <- (int((environment_bounds.x) / 20));\n\tint inner_bounds_y <- (int((environment_bounds.y) / 20));\n\tint xmin <- inner_bounds_x;\n\tint ymin <- inner_bounds_y;\n\tint xmax <- int((environment_bounds.x) - inner_bounds_x);\n\tint ymax <- int((environment_bounds.y) - inner_bounds_y);\n\tfloat MAX_DISTANCE <- environment_bounds.x + environment_bounds.y;\n\n\t//Global variables for ball agents\n\trgb ball_color <- #green;\n\trgb chaos_ball_color <- #red;\n\tfloat ball_size <- float(3);\n\tfloat ball_speed <- float(1);\n\tfloat chaos_ball_speed <- 8 * ball_speed;\n\tint ball_number <- 400 min: 2 max: 1000;\n\tgeometry ball_shape <- circle(ball_size);\n\tfloat ball_separation <- 6 * ball_size;\n\n\t//Global variables for group agents\n\tint group_creation_distance <- int(ball_separation + 1);\n\tint min_group_member <- 3;\n\tint group_base_speed <- (int(ball_speed * 1.5));\n\tint base_perception_range <- int(environment_bounds.x / 100) min: 1;\n\tint creation_frequency <- 3;\n\tint update_frequency <- 3;\n\tint merge_frequency <- 3;\n\tfloat merge_possibility <- 0.3;\n\n\t//Global variables for Clouds Agents\n\tint cloud_creation_distance <- 30 const: true;\n\tint min_cloud_member <- 3 const: true;\n\tint cloud_speed <- 3 const: true;\n\tint cloud_perception_range <- base_perception_range const: true;\n\n\tinit {\n\t\tcreate ball number: ball_number;\n\t\tcreate group_agents_viewer;\n\t}\n\n\t//The simulation will try to create group at each frequence cycle\n\treflex create_groups when: (create_group and ((cycle mod creation_frequency) = 0)) {\n\t//create a list from all balls following the nearest ball\n\t\tlist<ball> free_balls <- ball where ((each.state) = 'follow_nearest_ball');\n\t\tif (length(free_balls) > 1) {\n\t\t//Clustering of the balls according to their distance with at least a minimal number of balls in a group\n\t\t\tlist<list<ball>> satisfying_ball_groups <- (free_balls simple_clustering_by_distance group_creation_distance) where ((length(each)) > min_group_member);\n\t\t\tloop one_group over: satisfying_ball_groups {\n\t\t\t\tcreate group {\n\t\t\t\t\tcapture one_group as: ball_in_group;\n\t\t\t\t}\n\t\t\t\t//Capture by the new groups created of the different balls present in the list one_group\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//The simulation will try to create clouds at each frequence cycle\n\treflex create_clouds when: (create_cloud and ((cycle mod creation_frequency) = 0)) {\n\t//A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number\n\t\tlist<group> candidate_groups <- group where (length(each.members) > (0.05 * ball_number));\n\n\t\t//A cloud can be created also only using group which aren't too far away \n\t\tlist<list<group>> satisfying_groups <- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) >= min_cloud_member);\n\n\t\t//Creation of the different clouds using the groups satisfying both conditions\n\t\tloop one_group over: satisfying_groups {\n\t\t\tcreate cloud  {\n\t\t\t\tcapture one_group as: group_delegation {\n\t\t\t\t\tmigrate ball_in_group target: ball_in_cloud;\n\t\t\t\t}\n\t\t\t\tcolor <- one_of(group_delegation).color.darker;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Species with a specified type of control architecture, here the final state machine FSM\nspecies ball control: fsm {\n\tfloat speed <- ball_speed;\n\trgb color <- ball_color;\n\tint beginning_chaos_time;\n\tint time_in_chaos_state;\n\n\t//create the ball in a certain way to not make balls intersect each other\n\tinit {\n\t\tbool continue_loop <- true;\n\t\tloop while: continue_loop {\n\t\t\tpoint tmp_location <- {(rnd(xmax - xmin)) + xmin, (rnd(ymax - ymin)) + ymin};\n\t\t\tgeometry potential_geom <- ball_shape at_location tmp_location;\n\t\t\tif (empty(ball where (each intersects potential_geom))) {\n\t\t\t\tlocation <- tmp_location;\n\t\t\t\tcontinue_loop <- false;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//Action used to separate the balls and make them repulsive for the other balls of the group\n\taction separation (list<ball> nearby_balls) {\n\t\tfloat repulsive_dx <- 0.0;\n\t\tfloat repulsive_dy <- 0.0;\n\t\tloop nb over: nearby_balls {\n\t\t\tfloat repulsive_distance <- ball_separation - (location distance_to nb.location);\n\t\t\tfloat repulsive_direction <- (nb.location) towards (location);\n\t\t\trepulsive_dx <- repulsive_dx + (repulsive_distance * (cos(repulsive_direction)));\n\t\t\trepulsive_dy <- repulsive_dy + (repulsive_distance * (sin(repulsive_direction)));\n\t\t}\n\n\t\tlocation <- location + {repulsive_dx, repulsive_dy};\n\t}\n\n\tbool in_bounds (point a_point) {\n\t\treturn (!(a_point.x < xmin) and !(a_point.x > xmax) and !(a_point.y < ymin) and !(a_point.y > ymax));\n\t}\n\n\t//State that will make the agent follows the closest ball if it is not in the chaos state anymore\n\tstate follow_nearest_ball initial: true {\n\t\tenter {\n\t\t\tcolor <- ball_color;\n\t\t\tspeed <- ball_speed;\n\t\t}\n\n\t\tball nearest_free_ball <- (ball where ((each.state) = 'follow_nearest_ball')) closest_to self;\n\t\tif nearest_free_ball != self {\n\t\t\tfloat heading <- self towards (nearest_free_ball);\n\t\t\tfloat step_distance <- speed * step;\n\t\t\tfloat step_x <- step_distance * (cos(heading));\n\t\t\tfloat step_y <- step_distance * (sin(heading));\n\t\t\tpoint tmp_location <- location + {step_x, step_y};\n\t\t\tif (self.in_bounds(tmp_location)) {\n\t\t\t\tlocation <- tmp_location;\n\t\t\t\tdo separation(((ball overlapping (shape + ball_separation)) - self));\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//Make the ball move randomly during a certain time\n\tstate chaos {\n\t\tenter {\n\t\t\tbeginning_chaos_time <- int(time);\n\t\t\ttime_in_chaos_state <- 10 + (rnd(10));\n\t\t\tcolor <- chaos_ball_color;\n\t\t\tspeed <- chaos_ball_speed;\n\t\t\tfloat heading <- rnd(360.0);\n\t\t}\n\n\t\tfloat step_distance <- speed * step;\n\t\tfloat step_x <- step_distance * (cos(heading));\n\t\tfloat step_y <- step_distance * (sin(heading));\n\t\tpoint tmp_location <- location + {step_x, step_y};\n\t\tif (self.in_bounds(tmp_location)) {\n\t\t\tlocation <- tmp_location;\n\t\t\tdo separation(nearby_balls: (ball overlapping (shape + ball_separation)) - self);\n\t\t}\n\n\t\ttransition to: follow_nearest_ball when: time > (beginning_chaos_time + time_in_chaos_state);\n\t}\n\n\taspect default {\n\t\tdraw ball_shape color: color size: ball_size at: self.location;\n\t} }\n\n\t//Species representing the group of balls\nspecies group {\n\trgb color <- rgb([rnd(255), rnd(255), rnd(255)]);\n\tgeometry shape <- any_point_in(host) update: convex_hull(polygon(ball_in_group collect each.location));\n\tfloat speed update: float(group_base_speed);\n\n\t//Parameter to capture the balls contains in the perception range\n\tfloat perception_range update: float(base_perception_range + (rnd(5)));\n\tagent target update: get_nearer_target();\n\n\t//Function to return the closest ball or small group of balls that the agent could capture\n\tagent get_nearer_target {\n\t\tint size <- length(members);\n\t\tball nearest_free_ball <- (ball where ((each.state = 'follow_nearest_ball'))) closest_to self;\n\t\tgroup nearest_smaller_group <- ((group - self) where ((length(each.members)) < size)) closest_to self;\n\t\tif (nearest_free_ball = nil) and (nearest_smaller_group = nil) {\n\t\t\treturn nil;\n\t\t}\n\n\t\tfloat distance_to_ball <- (nearest_free_ball != nil) ? (self distance_to nearest_free_ball) : MAX_DISTANCE;\n\t\tfloat distance_to_group <- (nearest_smaller_group != nil) ? (self distance_to nearest_smaller_group) : MAX_DISTANCE;\n\t\treturn (distance_to_ball < distance_to_group) ?  nearest_free_ball :  nearest_smaller_group;\n\t}\n\n\t//Action to use when the group of balls explode\n\taction separate_components {\n\t\tloop com over: (list(ball_in_group)) {\n\t\t\tlist<ball_in_group> nearby_balls <- ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members);\n\t\t\tfloat repulsive_dx <- 0.0;\n\t\t\tfloat repulsive_dy <- 0.0;\n\t\t\tloop nb over: nearby_balls {\n\t\t\t\tfloat repulsive_distance <- ball_separation - ((ball_in_group(com)).location distance_to nb.location);\n\t\t\t\tfloat repulsive_direction <- (nb.location) direction_to ((ball_in_group(com)).location);\n\t\t\t\trepulsive_dx <- repulsive_dx + (repulsive_distance * (cos(repulsive_direction)));\n\t\t\t\trepulsive_dy <- repulsive_dy + (repulsive_distance * (sin(repulsive_direction)));\n\t\t\t}\n\n\t\t\t(ball_in_group(com)).location <- (ball_in_group(com)).location + {repulsive_dx, repulsive_dy};\n\t\t}\n\n\t}\n\n\t//Species that will represent the balls captured by the group agent\n\tspecies ball_in_group parent: ball topology: topology((world).shape) {\n\t\tfloat my_age <- 1.0 update: my_age + 0.01;\n\t\tstate follow_nearest_ball initial: true {\n\t\t}\n\n\t\tstate chaos {\n\t\t}\n\n\t\taspect default {\n\t\t\tdraw circle(my_age) color: ((host as group).color).darker;\n\t\t}\n\n\t}\n\n\t//Reflex to capture all the balls close to the group agent\n\treflex capture_nearby_free_balls when: (cycle mod update_frequency) = 0 {\n\t\tlist<ball> nearby_free_balls <- (ball overlapping (shape + perception_range)) where (each.state = 'follow_nearest_ball');\n\t\tif !(empty(nearby_free_balls)) {\n\t\t\tcapture nearby_free_balls as: ball_in_group;\n\t\t}\n\n\t}\n\n\t//Action to do when the group is disaggregated\n\taction disaggregate {\n\t\trelease list<agent>(members) as: ball in: world {\n\t\t\tstate <- 'chaos';\n\t\t}\n\n\t\tdo die;\n\t}\n\n\t//Reflex to merge the group close to the agent when the cycle is in the frequency of merging\n\treflex merge_nearby_groups when: (cycle mod merge_frequency) = 0 and (target != nil) and ((species_of(target)) = group) {\n\t\tlist<group> nearby_groups <- (group overlapping (shape + perception_range)) - self;\n\t\tif target in nearby_groups {\n\t\t\tif (rnd(10)) < (merge_possibility * 10) {\n\t\t\t\tlist<ball> released_balls <- [];\n\t\t\t\task target {\n\t\t\t\t\trelease list(ball_in_group) as: ball in: world {\n\t\t\t\t\t\treleased_balls << self;\n\t\t\t\t\t}\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\tcapture released_balls as: ball_in_group;\n\t\t\t} else {\n\t\t\t\task target as group {\n\t\t\t\t\tdo disaggregate;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//Reflex to chase a target agent \n\treflex chase_target when: (target != nil) {\n\t\tfloat direction_to_nearest_ball <- (self towards (target));\n\t\tfloat step_distance <- speed * step;\n\t\tfloat dx <- step_distance * (cos(direction_to_nearest_ball));\n\t\tfloat dy <- step_distance * (sin(direction_to_nearest_ball));\n\t\tgeometry envelope <- shape.envelope;\n\t\tpoint topleft_point <- (envelope.points) at 0;\n\t\tpoint bottomright_point <- (envelope.points) at 0;\n\t\tloop p over: envelope.points {\n\t\t\tif ((p.x <= topleft_point.x) and (p.y <= topleft_point.y)) {\n\t\t\t\ttopleft_point <- p;\n\t\t\t}\n\n\t\t\tif ((p.x >= bottomright_point.x) and (p.y >= bottomright_point.y)) {\n\t\t\t\tbottomright_point <- p;\n\t\t\t}\n\n\t\t}\n\n\t\tif ((dx + topleft_point.x) < 0) {\n\t\t\tfloat tmp_dx <- dx + topleft_point.x;\n\t\t\tdx <- dx - tmp_dx;\n\t\t} else {\n\t\t\tif (dx + bottomright_point.x) > (environment_bounds.x) {\n\t\t\t\tfloat tmp_dx <- (dx + bottomright_point.x) - environment_bounds.x;\n\t\t\t\tdx <- dx - tmp_dx;\n\t\t\t}\n\n\t\t}\n\n\t\tif (dy + topleft_point.y) < 0 {\n\t\t\tfloat tmp_dy <- dy + topleft_point.y;\n\t\t\tdy <- dy - tmp_dy;\n\t\t} else {\n\t\t\tif (dy + topleft_point.y) > (environment_bounds.y) {\n\t\t\t\tfloat tmp_dy <- (dy + bottomright_point.y) - (environment_bounds.y);\n\t\t\t\tdy <- dy - tmp_dy;\n\t\t\t}\n\n\t\t}\n\n\t\tloop com over: ball_in_group {\n\t\t\tcom.location <- com.location + {dx, dy};\n\t\t}\n\n\t\t//shape <- convex_hull((polygon(ball_in_group collect each.location)) + 2.0);\n\t}\n\t//Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number\n\treflex self_disaggregate {\n\t\tif ((length(members)) > (0.8 * (ball_number))) {\n\t\t\tdo disaggregate;\n\t\t}\n\n\t}\n\n\taspect default {\n\t\tdraw shape color: color;\n\t}\n\n}\n\n//Species cloud that will be created by an agglomeration of groups.\nspecies cloud {\n\tgeometry shape <- any_point_in(host) update: convex_hull(polygon(group_delegation collect ((each.shape).location)));\n\trgb color;\n\n\t//Species contained in the cloud to represent the groups captured by the cloud agent\n\tspecies group_delegation parent: group topology: (topology(world.shape)) {\n\t\tgeometry shape update: convex_hull((polygon((ball_in_cloud) collect (each.location)))) buffer 10;\n\n\t\tinit {\n\t\t\tshape <- convex_hull((polygon((ball_in_cloud) collect (each.location)))) buffer 10;\n\t\t}\n\n\t\treflex capture_nearby_free_balls when: false {\n\t\t}\n\n\t\treflex merge_nearby_groups when: false {\n\t\t}\n\n\t\treflex chase_target when: false {\n\t\t}\n\n\t\treflex self_disaggregate {\n\t\t}\n\n\t\taction move2 (float with_heading, float with_speed) {\n\t\t\task ball_in_cloud {\n\t\t\t\tdo move2(with_heading, with_speed);\n\t\t\t}\n\n\t\t}\n\n\t\tspecies ball_in_cloud parent: ball_in_group topology: (world.shape) as topology control: fsm {\n\n\t\t\taction move2 (float with_heading, float with_speed) {\n\t\t\t\tfloat dx <- cos(with_heading) * with_speed;\n\t\t\t\tfloat dy <- sin(with_heading) * with_speed;\n\t\t\t\tlocation <- {((location.x) + dx), ((location.y) + dy)};\n\t\t\t}\n\n\t\t\taspect default {\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgroup target_group;\n\n\t//The cloud try to look for small groups to capture them\n\treflex chase_group {\n\t\tif ((target_group = nil) or (dead(target_group))) {\n\t\t\ttarget_group <- one_of(group);\n\t\t}\n\n\t\tif (target_group != nil) {\n\t\t\tfloat direction_target <- self towards (target_group);\n\t\t\task group_delegation {\n\t\t\t\tdo move2 with: [with_heading::float(direction_target), with_speed::float(cloud_speed)];\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//Operator to know if a cloud can capture a group overlapping the cloud agent. \n\tbool can_capture (group a_group) {\n\t\tif (a_group = nil or dead(a_group)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (shape overlaps a_group.shape) {\n\t\t\treturn true;\n\t\t}\n\n\t\tloop gd over: group_delegation {\n\t\t\tif ((a_group.shape) overlaps gd.shape) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//Reflex to capture group\n\treflex capture_group {\n\t\tif (can_capture(target_group)) {\n\t\t\tcapture target_group as: group_delegation {\n\t\t\t\tmigrate ball_in_group target: ball_in_cloud;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//Reflex to disaggregate the clouds when they are no more group to capture\n\treflex disaggregate when: (empty(list(group))) {\n\t\task group_delegation {\n\t\t\tmigrate ball_in_cloud target: ball_in_group;\n\t\t}\n\n\t\trelease list(group_delegation) as: group in: world {\n\t\t\tdo disaggregate;\n\t\t}\n\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape color: color wireframe: true;\n\t\tdraw (name + ' with ' + (string(length(members))) + ' groups.') size: 15 color: color at: {location.x - 65, location.y};\n\t}\n\n}\n\nspecies group_agents_viewer {\n\n\taspect default {\n\t\tdraw ('Number of groups: ' + (string(length(group)))) at: {(environment_bounds.x) / 2 - 210, (environment_bounds.y) / 2} color: #blue size: 40;\n\t}\n\n}\n\n\nexperiment group_experiment type: gui {\n\tparameter 'Create groups?' var: create_group <- true;\n\tparameter 'Create clouds?' var: create_cloud <- false;\n\toutput {\n\t\tlayout horizontal([vertical([1::5000, 0::5000])::5000, 2::5000]) tabs: true editors: false;\n\t\tdisplay 'Standard display' {\n\t\t\tspecies ball aspect: default transparency: 0.5;\n\t\t\tspecies group aspect: default transparency: 0.5 {\n\t\t\t\tspecies ball_in_group;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay 'Ball display' {\n\t\t\tspecies ball;\n\t\t}\n\n\t\tdisplay 'Group display' {\n\t\t\tspecies group;\n\t\t\tspecies group_agents_viewer;\n\t\t}\n\n\t}\n\n}\n\nexperiment cloud_experiment type: gui {\n\tparameter 'Create groups?' var: create_group <- true;\n\tparameter 'Create clouds?' var: create_cloud <- true;\n\toutput {\n\t\tlayout vertical([horizontal([0::5000, 1::5000])::5000, horizontal([2::5000, 3::5000])::5000]) tabs: true toolbars: true editors: false;\n\t\tdisplay 'Standard display'  background: #black{\n\t\t\tspecies ball aspect: default transparency: 0.5;\n\t\t\tspecies group aspect: default transparency: 0.5 {\n\t\t\t\tspecies ball_in_group;\n\t\t\t}\n\n\t\t\tspecies cloud aspect: default {\n\t\t\t\tspecies group_delegation transparency: 0.9 {\n\t\t\t\t\tspecies ball_in_cloud;\n\t\t\t\t\tspecies ball_in_group;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay 'Ball display'  {\n\t\t\tspecies ball;\n\t\t}\n\n\t\tdisplay 'Group display'  {\n\t\t\tspecies group;\n\t\t\tspecies group_agents_viewer;\n\t\t}\n\n\t\tdisplay 'Cloud display'  {\n\t\t\tspecies cloud;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAMA model that demonstrates multi-threading capabilities for parallel computation and visualization of agent behavior on a grid.", "gaml_code": "/**\n* Name: multithread\n* Author: Patrick Taillandier\n* Description: Shows how to use the multi-thread capabilities of GAMA\n* Tags: multi-thread, parallel \n*/\n\nmodel multithread\n\nglobal {\n\tinit {\n\t\tcreate simple_agent number: 10;\n\t\t\n\t\t//parallelize the computation ask by the agent\n\t\task simple_agent parallel: true {\n\t\t\tvar1 <- exp(-size);\n\t\t}\n\t}\n}\n\nspecies simple_agent parallel: true{\n\tint size <- rnd(1,10) update: size + (flip(0.5) ? 1 : 0);\n\tfloat var1;\n\treflex behavior {\n\t\tvar1 <- exp(-size);\n\t\twrite string(cycle) + \":\" +name + \"->\" + var1;\n\t}\n}\n\ngrid cell width: 5 height: 5 parallel: true {\n\tfloat val <- rnd(1.0) max: 1.0;\n\t\n\treflex behavior {\n\t\tval <- val + rnd(0.002) - 0.0009;\n\t\tcolor <- rgb((1.0 - val)*255,(1.0 - val)*255,(1.0 - val)*255);\n\t}\n}\nexperiment multithread type: gui {\n\toutput {\n\t\tdisplay map type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t}\n\t}\n}"}
{"prompt": "Create a comodel that demonstrates the importation and instantiation of micro-models using coupling, including two adapters (Flies Adapter.gaml and Mosquitos Adapter.gaml) with 5 instances of Mosquitos.Generic and 1 instance of Flies.Simple, and display their agents in a GUI.", "gaml_code": "/**\n* Name: comodel_with_the_coupling\n* Author: HUYNH Quang Nghi\n* Description: This is a simple comodel to demonstrate the importation and instatiation of micro-model using coupling  \n* Tags: comodel\n*/\nmodel complex_comodeling_example\n\nimport \"Adapters/Flies Adapter.gaml\" as Flies\nimport \"Adapters/Mosquitos Adapter.gaml\" as Mosquitos\n\nglobal\n{\n\tgeometry shape<-envelope(square(100));\n\tinit{\n\t\t//micro_model must be instantiated with the create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).\n\t\tcreate Flies.Simple;\n\t\tcreate Mosquitos.Generic number:5;\n\t}\n\treflex simulate_micro_models{\n\t\t\n\t\t//tell all experiments of micro_model_1 to do 1 step;\n\t\task (Flies.Simple collect each.simulation){\n\t\t\tdo _step_;\n\t\t}\n\t\t\n\t\t//tell the first experiment of micro_model_2 to do 1 step;\n\t\task (Mosquitos.Generic collect each.simulation){\n\t\t\tdo _step_;\n\t\t}\n\t}\n}\n\nexperiment Complex type: gui{\n\toutput{\n\t\tdisplay \"Comodel Display\" {\n\t\t\t//to display the agents of micro-models, we use the agent layer with the values from the coupling.\n\t\t\tagents \"agentB\" value:(Mosquitos.Generic accumulate each.get_mosquitos());\n\t\t\tagents \"agentA\" value:(Flies.Simple accumulate each.get_flies());\n\t\t}\n\t}\n}"}
{"prompt": "Demonstrate comodeling in GAML by importing and instantiating micro-models without using couplings, allowing for simulation of multiple experiments with step-by-step execution.", "gaml_code": "/**\n* Name: Simple syntax demonstration of Comodeling \n* Author: HUYNH Quang Nghi\n* Description: This is a simple comodel serve to demonstrate the importation and instatiation of micro-model without using the couplings  \n* Tags: comodel\n*/\nmodel simple_comodeling_example\n\nimport \"Adapters/Flies Adapter.gaml\" as Flies\nimport \"Adapters/Mosquitos Adapter.gaml\" as Mosquitos\n\n\nglobal\n{\n\tinit\n\t{\n\t//micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).\n\t\tcreate Flies.Simple  number: 2;\n\t\tcreate Mosquitos.Generic;\n\t}\n\n\treflex simulate_micro_models\n\t{\n\n\t//tell the first experiment of micro_model_1 do 1 step;\n\t\task first(Flies.Simple).simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//tell all experiments of micro_model_1 do 1 step;\n\t\task (Flies.Simple collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//tell all experiments of micro_model_2 do 1 step;\n\t\task (Mosquitos.Generic collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t\t\n\t\t//ask  simulation of micro_model to kill all agents every 100 cycles and recreate them\n\t\tif(cycle mod 100 = 0){\t\t\t\n\t\t\task  (Mosquitos.Generic collect each.simulation){\n\t\t\t\task Mosquito{\t\t\t\t\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t}\n\t\t\task  (Mosquitos.Generic collect each.simulation){\n\t\t\t\tseed<-float(rnd(100));\n\t\t\t\tdo _init_;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexperiment main type: gui\n{\n}"}
{"prompt": "Create a GAML model that simulates the mixing of behaviors between prey and predators, where ants are the prey and can flee from predators when not chasing. The environment is a square grid of size 100x100, with 500 ants and 2 predators. Visualize the simulation using a GUI display.", "gaml_code": "/**\n* Name: comodel_mix_behaviors\n* Author: HUYNH Quang Nghi\n* Description: This is a simple comodel serve to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.\n* Tags: comodel\n*/\nmodel comodel_mix_behaviors\n\nimport \"../Co-PreyPredator/Prey Predator Adapter.gaml\" as Organism\nimport \"Ants Adapter.gaml\" as Ant\n\n\nglobal\n{\n\t//set the shape of environment: square 100 \n\tgeometry shape <- square(100);\n\t// the variable that refer to the ants population in micro-model \n\tlist<agent> theAnts;\n\t// the variable that refer to the prey population in micro-model\n\tlist<prey> thePreys;\n\t\n\tinit\n\t{\n\t\t//create the Ants micro-model with the size of grid is 100 and the population have 500 ants.\n\t\tcreate Ant.Base with: [gridsize::100,ants_number::500]{\n\t\t\twrite self;\n\t\t}\n\t\t\n//\t\twrite Ant.Simple collect each.simulations as list;\n\t\t//create the PreyPredator micro-model with the parameters and the number of the prey is equal with the size of ants population\n\t\tcreate Organism.Simple with: [shape::square(100), preyinit::Ant.Base[0].simulation.ants_number, predatorinit::2]  \n\t\t{\n\t\t\t// set the size of micro-model PreyPredator equal with the size of the grid of myAnt\n\t\t\tshape <- square(100);\n\t\t}\n\n\t\twrite  Organism.Simple as list;\n\t\t// save the original population of the Ants and the Preys\n\t\ttheAnts <- Ant.Base accumulate each.get_ants();\n\t\tthePreys <- list<prey>(Organism.Simple accumulate each.get_prey());\n\n\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t// ask myAnt do a step\n\t\task (Ant.Base collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t\t// ask myPreyPredator do a step, too\n\t\task (Organism.Simple collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//check if a Prey is chased, set the position of that agent to the location of prey \n\t\t//if not, set ant's location to agent location.\n\t\t// if the agent (prey) died, then tell the ant do die\n\t\tloop i from: 0 to: length(theAnts) - 1\n\t\t{\n\t\t\tif (!dead(thePreys at i) and !dead(theAnts at i))\n\t\t\t{\n\t\t\t\tif (!(thePreys at i).is_chased)\n\t\t\t\t{\n\t\t\t\t\t(thePreys at i).location <- (theAnts at i).location;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t(theAnts at i).location <- (thePreys at i).location;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t{\n\t\t\t\task (theAnts at i)\n\t\t\t\t{\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment main type: gui\n{\n\toutput synchronized:true\n\t{\n\t\tdisplay \"Comodel display\"\n\t\t{\n\t\t\tagents \"ant_grid\" value: Ant.Base accumulate each.get_ant_grid() transparency: 0.7;\t\t\t\n\t\t\tagents \"agentprey\" value: (Organism.Simple accumulate each.get_prey());\n\t\t\tagents \"agentpredator\" value: (Organism.Simple accumulate each.get_predator());\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that serves as an interface for the Ants model, allowing it to be used in a comodeling example.", "gaml_code": "/**\n* Name: ants_coupling\n* Author: HUYNH Quang Nghi\n* Description:  THIS MODEL IS NOT SUPPOSED TO LAUNCH. This is the coupling of Ants model. It is supposed to use in the Comodeling Example as an interface. \n* Tags: comodel\n*/\nmodel ants_coupling\n\nimport \"../../../Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging.gaml\"\n\n//this is the experiment that supposed to uses\nexperiment Base type: gui \n{\n\tlist<ant> get_ants\n\t{\n\t\treturn list(ant);\n\t}\n\n\tlist<ant_grid> get_ant_grid\n\t{\n\t\treturn list(ant_grid);\n\t}\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiment don't show.\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "Create a GAML model that simulates three populations of predators and prey with different shapes (triangle, square, circle) and interactions, displaying the results in a GUI.", "gaml_code": "/**\n* Name: comodeling_example_populations_mutating\n* Author: Arthur Brugiere & HUYNH Quang Nghi\n* Description: This simple comodel serves to demonstrate the importation and instantiation of micro-model.\n* Here triangle predators can eat any prey, square can eat square and round prey, and round predators can only eat round prey\n* Tags: comodel\n*/ \n\nmodel comodeling_example_populations_mutating\n\nimport \"Prey Predator Adapter.gaml\" as Organism\n\nglobal\n{\n    // set the shape of world as a rectangle 200 x 100\n    geometry shape <- square(100);\n    init\n    {\n        //instantiate three instant of micro-model PreyPredator\n        create Organism.Simple with: [shape::square(100), preyinit::10, predatorinit::1] number: 3;\n    \n        //explicitly save the orginal population of predator and original population of prey of each micro-model\n\n        //the predator population of experiment 0 saved into the list lstpredator0  \n        list<predator> lstpredator0 <- Organism.Simple[0].get_predator(); //PT1\n        //the prey population of experiment 0 saved into the list lstprey0\n        list<prey> lstprey0 <- Organism.Simple[0].get_prey(); //PR1\n        \n        //the predator population of experiment 1 saved into the list lstpredator1\n        list<predator> lstpredator1 <-Organism.Simple[1].get_predator(); //PT2\n        //the prey population of experiment 1 saved into the list lstprey1\n        list<prey> lstprey1 <- Organism.Simple[1].get_prey(); //PR2\n\n        //the predator population of experiment 2 saved into the list lstpredator2\n        list<predator> lstpredator2 <- Organism.Simple[2].get_predator(); //PT3\n        //the prey population of experiment 2 saved into the list lstprey2\n        list<prey> lstprey2 <- Organism.Simple[2].get_prey(); //PR3\n        \n\n        //mutate the popuplation of micro-model by assigning the list above to  the population of micro-models\n        (Organism.Simple[0].simulation).lstPredator <- lstpredator0;\n        (Organism.Simple[1].simulation).lstPredator <- lstpredator0 + lstpredator1;\n        (Organism.Simple[2].simulation).lstPredator <- lstpredator0 + lstpredator1 + lstpredator2;\n    \n\n        (Organism.Simple[0].simulation).lstPrey <- lstprey0;\n        (Organism.Simple[1].simulation).lstPrey <- lstprey1;\n        (Organism.Simple[2].simulation).lstPrey <- lstprey2;\n\n        //change the shape correspond with the new role of agent in the new populations\n\n        ask (Organism.Simple[2].simulation.lstPredator + Organism.Simple[2].simulation.lstPrey)\n        {\n            shape <- circle(1);\n        }\n        ask (Organism.Simple[1].simulation.lstPredator + Organism.Simple[1].simulation.lstPrey)\n        {\n            shape <- square(1);\n        }\n        ask (Organism.Simple[0].simulation.lstPredator + Organism.Simple[0].simulation.lstPrey)\n        {\n            shape <- triangle(1);\n\n\n        }\n\n\n    }\n\n    reflex simulate_micro_models\n    {\n        // ask all simulation do their job\n        ask (Organism.Simple collect each.simulation)\n        {\n            do _step_;\n        }\n    }\n\n}\n\nexperiment main type: gui\n{\n    output synchronized:true\n    {\n        //a mixing display of all agents from all populations\n        display \"Comodel display\"\n        {\n            agents \"agentprey\" value: (Organism.Simple accumulate each.get_prey());\n\n            graphics \"Prey of prey\" {\n                loop pr over:Organism.Simple accumulate each.simulation.lstPrey {\n                    if(!dead(pr)){\n\t                    string n <- \"PR\"+int(pr.host.host);\t                    \t\n\t                    write n;\n\t                    draw \"PREY\" at:pr.location+{1,1,1} color:#green;\n                    }\n                }\n            }\n\n            agents \"agentpredator\" value: (Organism.Simple accumulate each.get_predator());\n\n            graphics \"Prey of prey\" {\n                loop pr over:Organism.Simple accumulate each.simulation.lstPredator {\n                    draw \"PDRT\" at:pr.location+{-1,-1,1} color:#red;\n                }\n            }\n        }\n    }\n}"}
{"prompt": "Create a simple comodel that simulates the behavior of prey and predators interacting with each other. The prey should flee from predators when chased, and the predators should hunt for prey. Include GUI visualization.", "gaml_code": "/**\n* Name: prey predator\n* Author: HUYNH Quang Nghi\n* Description: This is a simple comodel serve to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.\n* Tags: comodel\n*/\nmodel prey_predator\n\n\nglobal\n{\n\tgeometry shape <- square(100);\n\tfloat perceipt_radius <- 20.0;\n\tint preyinit <- 500;\n\tint predatorinit <- 3;\n\tlist<predator> lstPredator;// <- list<agent> (predator);\n\tlist<prey> lstPrey; //<- list<agent> (prey);\n\tinit\n\t{\n\t\tcreate prey number: preyinit;\n\t\tcreate predator number: predatorinit;\n\t\tlstPredator <- list<agent> (predator);\n\t\tlstPrey <- list<agent> (prey);\n\t}\n\n}\n\nspecies generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}\n\nspecies prey parent: generic_species\n{\n\tgeometry shape <- circle(0.5);\n\tfloat speed <- 0.2;\n\trgb color <- # green;\n\treflex fleeing\n\t{\n\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)\n\t\t{\n\t\t\tspeed <- 1.0;\n\t\t\tis_chased <- true;\n\t\t\tcolor <- # lime;\n\t\t\tif (goal = nil)\n\t\t\t{\n\t\t\t\tagent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\n\t\t\t\tif (a != nil and !dead(a))\n\t\t\t\t{\n\t\t\t\t\tif (flip(0.5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- a.location;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t\t}\n\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (goal != nil and self.location distance_to goal < 0.5)\n\t\t{\n\t\t\tgoal <- nil;\n\t\t}\n\n\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)\n\t\t{\n\t\t\tis_chased <- false;\n\t\t\tcolor <- # green;\n\t\t\tspeed <- 0.2;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies predator parent: generic_species\n{\n\tgeometry shape <- triangle(2);\n\trgb color <- # red;\n\treflex hunting\n\t{\n\t\tif (goal = nil)\n\t\t{\n\t\t\tlet tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));\n\t\t\tif (length(tmp) > 0)\n\t\t\t{\n\t\t\t\tagent a <- first(tmp sort (each.shape distance_to self.shape));\n\t\t\t\tif (a = nil)\n\t\t\t\t{\n\t\t\t\t\ta <- any((lstPrey where (!dead(each))));\n\t\t\t\t}\n\n\t\t\t\tif (a != nil)\n\t\t\t\t{\n\t\t\t\t\tspeed <- 2.0;\n\t\t\t\t\tgoal <- a.location;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ((self.location distance_to goal < 0.5))\n\t\t{\n\t\t\task lstPrey where (!dead(each) and each.location distance_to goal < 0.5)\n\t\t\t{\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\tgoal <- nil;\n\t\t\tspeed <- 1.0;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw circle(perceipt_radius) color: # pink wireframe: true;\n\t\tdraw shape color: color rotate: 90 + my heading;\n\t}\n\n}\n\nexperiment \"Prey Predator Exp\" type: gui\n{\n\toutput\n\t{\n\t\tdisplay main_display\n\t\t{\n\t\t\tspecies prey;\n\t\t\tspecies predator;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GAML model that imports and interfaces with an existing 'Prey Predator' model, allowing for comodeling and GUI experimentation.", "gaml_code": "/**\n* Name: prey_predator_coupling\n* Author: HUYNH Quang Nghi\n* Description: This is the coupling of Prey Predator  model. It is supposed to be used in the Comodeling Example as an interface. \n* Tags: comodel\n*/\nmodel prey_predator_coupling\n\nimport \"Prey Predator.gaml\"\n\n\nglobal\n{\n}\n\nexperiment Simple type: gui\n{\n\tgeometry shape <- square(100);\n\tlist<prey> get_prey\n\t{\n\t\treturn list(prey);\n\t}\n\n\tlist<predator> get_predator\n\t{\n\t\treturn list(predator);\n\t}\n\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiment don't show.\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "**Create a GAML model that serves as an interface for the \"Complex Comodeling Example\", coupling the Mosquitos model and providing a GUI experiment to retrieve mosquito instances.**", "gaml_code": "/**\n* Name: mosquitos_coupling\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Mosquitos model. It is used in the \"Complex Comodeling Example\" as an interface. \n* Tags: comodel\n*/\nmodel mosquitos_coupling\nimport \"../Models/Mosquitos.gaml\"\n\nglobal\n{\n}\n\nexperiment Generic type: gui\n{\n\tlist<Mosquito> get_mosquitos{\n\t\treturn list(Mosquito);\n\t}\n\t\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "**Create a GAML model that serves as an interface for coupling the Flies model with another experiment, specifically for the \"Complex Comodeling Example\", and include a GUI to retrieve flies data.**", "gaml_code": "/**\n* Name: flies_coupling\n* Author: HUYNH Quang Nghi\n* Description: It is NOT supposed to launch. This is the coupling of Flies model. It is used in the \"Complex Comodeling Example\" as an interface. \n* Tags: comodel\n*/\nmodel flies_coupling\nimport \"../Models/Flies.gaml\"\n\nglobal\n{\n}\n\nexperiment Simple type: gui\n{\n\tlist<Fly> get_flies{\n\t\treturn list(Fly);\n\t}\n\t\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\n\toutput\n\t{\n\t}\n\n}"}
{"prompt": "Create a simple simulation of flies moving randomly on a GUI interface using NetLogo-like modeling language.", "gaml_code": "/**\n* Name: Flies\n* Author: HUYNH Quang Nghi\n* Description: This is a dummy model that show the randomly movement of the flies.\n* Tags: comodel\n*/\nmodel Flies\n\n\nglobal\n{\n\tgeometry shape<-square(100);\n\timage_file icon<-image_file(\"./img/fly.gif\");\n\tint n <- 1;\n\tinit\n\t{\n\t\tcreate Fly number: n;\n\t}\n\n}\n\nspecies Fly skills: [moving]\n{\n\tgeometry shape<-circle(1);\n\tint durability<- rnd(100);\n\treflex dolive\n\t{\t\n\t\twrite \"I can fly\";\n\t\tdo wander amplitude:200.0;\t\t\n\t}\n\n\taspect default\n\t{\n\t\tdraw icon size:4 color: # green rotate:heading+180;\n\t}\n\n}\n\nexperiment Simple type: gui\n{ \n\toutput\n\t{\n\t\tdisplay \"Flies display\"\n\t\t{\n\t\t\tspecies Fly aspect: default;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a simple simulation of mosquitoes moving randomly on a GUI screen using NetLogo-like modeling language.", "gaml_code": "/**\n* Name: Flies\n* Author: HUYNH Quang Nghi\n* Description: This is a dummy model that show the randomly movement of the flies.\n* Tags: comodel\n*/\nmodel Mosquitos\n\n\nglobal\n{\n\tgeometry shape<-square(100);\n\timage_file icon<-image_file(\"./img/mosquito.png\");\n\tint n <- 1;\n\tinit\n\t{\n\t\tcreate Mosquito number: n;\n\t}\n\n}\n\nspecies Mosquito skills: [moving]\n{\n\tgeometry shape<-circle(1);\n\tint durability<- rnd(100);\n\treflex dolive\n\t{\t\n\t\twrite \"I can bite\";\n\t\tdo wander amplitude:rnd(30.0) speed:0.5;\t\t\n\t}\n\n\taspect default\n\t{\n\t\tdraw icon size:4 color: # green rotate:heading+180;\n\t}\n\n}\n\nexperiment Generic type: gui\n{ \n\toutput\n\t{\n\t\tdisplay \"Mosquitos display\"\n\t\t{\n\t\t\tspecies Mosquito aspect: default;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a NetLogo model where two agents interactively change the values of a field in a 3D terrain.", "gaml_code": "/**\n* Name: AccessingFields\n* How to create simple fields and access/change the information they contain is covered in this model.\n* One agent increases the values in the field, another one decreases them. \n* Author: Alexis Drogoul\n* Tags: \n*/\nmodel AccessingFields\n\nglobal torus: true{\n\tgeometry shape <- square(2000);\n\tfield terrain <- field(300, 300);\n\n\tinit {\n\t\tcreate increaser with: [location::location];\n\t\tcreate decreaser with: [location::location];\n\t}\n\n\tspecies increaser skills: [moving] {\n\t\tgeometry shape <- square(40);\n\n\t\treflex move {\n\t\t\tdo wander amplitude: 2.0;\n\t\t\tloop s over: terrain cells_in self {\n\t\t\t\tterrain[geometry(s).location] <- terrain[geometry(s).location] + 1.0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tspecies decreaser skills: [moving] {\n\t\tgeometry shape <- square(40);\n\n\t\treflex move {\n\t\t\tdo wander amplitude: 2.0;\n\t\t\tloop s over: terrain cells_in self {\n\t\t\t\tterrain[geometry(s).location] <- terrain[geometry(s).location] - 1.0;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Show\" {\n\tlist<rgb> palette <- brewer_colors(any(brewer_palettes(0)));\n\toutput {\n\t\tdisplay Field type: 3d {\n\t\t\tmesh terrain color: palette triangulation: true smooth: 4;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a model that generates a graph using agents as vertices, allowing for two types of graph construction: one based on distance and another based on intersection, with adjustable parameters.", "gaml_code": "/**\n* Name: Graph Generation using Agents\n* Author: Patrick Taillandier\n* Description: Model which shows how to create a graph using agents of a species as vertices. Two kinds of generations are presented : one where the distance \n* taken into account to link two vertices by an edge, an other where the intersections of two vertices joins these vertices by an edge. \n* Tags: graph\n*/\n\nmodel graphbuilding\n\nglobal {\n\tgraph<geometry, geometry> the_graph ;\n\tstring graph_builing_type <- \"distance\";\n\tfloat distance <- 20.0;\n\tfloat tolerance <- 0.0;\n\tinit {\n\t\tcreate dummy_agent number: 30; \n\t\tswitch graph_builing_type {\n\t\t\tmatch \"distance\" {\n\t\t\t\tthe_graph <- as_distance_graph(dummy_agent, distance);\t\n\t\t\t}\n\t\t\tmatch \"intersection\" {\n\t\t\t\tthe_graph <- as_intersection_graph(dummy_agent, tolerance);\t\n\t\t\t}\t\n\t\t}\n\t\twrite \"nb vertices: \" + length(the_graph.vertices);\n\t\twrite \"nb edges: \" + length(the_graph.edges);\n\t}\n\t\n}\n\nspecies dummy_agent {\n\tgeometry shape <- square (5);\n\taspect default {\t\n\t\tdraw shape color: #red;\n\t}\n}\n\nexperiment loadgraph type: gui {\n\tparameter \"Method to build the graph\" var: graph_builing_type among: [ \"distance\", \"intersection\"];\n\tparameter \"Tolerance\" var: tolerance min: 0.0 max: 2.0 category: \"Intersection\";\n\tparameter \"Distance\" var: distance min: 1.0 max: 50.0 category: \"Distance\";\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy_agent ;\n\t\t\tgraphics \"the graph\" {\n\t\t\t\tloop edge over: the_graph.edges {\n\t\t\t\t\tdraw edge color: #blue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a model that loads a graph from a GraphML file and allows for dynamic layout changes using various force-directed and grid-based algorithms. The model should include parameters for adjusting the layout time, force coefficient, cooling coefficient, normalization factor, theta value, and layout type.", "gaml_code": "/**\n* Name: Graph from DGS File and Layout Changed\n* Author: Patrick Taillandier\n* Description: Model which shows how to load a graph from a graphml File, and change its layout. \n* Tags: graph, load_file, dgs\n*/\n\nmodel graphloadinglayout\n\nglobal {\n\tgraph<agent,agent> the_graph ;\n\tstring barabasi_file <- \"../includes/simple.graphml\";\n\tgeometry shape <- rectangle(500,500);\n\tstring layout_type;\n\tint layout_time <- 1000 min: 0 max: 10000;\n\tfloat coeff_force <- 0.8 min: 0.1 max: 1.0;\n\tfloat cooling_coefficient <- 0.1 min: 0.01 max: 0.5; \n\tfloat coeff_nb_places <- 1.2 min: 0.0 max: 2.0; \n\tfloat normalizationFactor <- 0.5 min: 0.1 max: 2.0; \n\tfloat theta <- 0.5 min: 0.1 max: 2.0; \n\t\n\t\n\t//The operator load_graph_from_file generates the graph from the file, and chose the vertices as agents of node_agent \n\t//species, and edges as edge_agent agents\n\tinit {\n\t\tthe_graph <- graphml_file(\"../includes/simple.graphml\", node_agent, edge_agent).contents;\n\t}\n\t\n\t//In case the layout type is forcedirected or random, the reflex will change at each step the layout of the graph\n\treflex layout_graph {\n\t\tswitch layout_type {\n\t\t\tmatch \"Force\" {\n\t\t\t\tthe_graph <- layout_force(the_graph, world.shape,coeff_force , cooling_coefficient, layout_time);\n\t\t\t}\n\t\t\tmatch \"Force FR\" {\n\t\t\t\tthe_graph <- layout_force_FR(the_graph, world.shape,normalizationFactor,layout_time);\n\t\t\t}\n\t\t\tmatch \"Force FR Indexed\" {\n\t\t\t\tthe_graph <- layout_force_FR_indexed(the_graph, world.shape,theta,normalizationFactor,layout_time);\n\t\t\t}\n\t\t\tmatch \"Circular\" {\n\t\t\t\tthe_graph <- layout_circle(the_graph, world.shape, false);\n\t\t\t}\n\t\t\tmatch \"Grid\" {\n\t\t\t\tthe_graph <- layout_grid(the_graph, world.shape,coeff_nb_places);\n\t \t\t}\n\t\t}\t\n\t}\n}\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\taspect default {\t\n\t\tdraw circle(2) color: #red;\n\t}\n}\n\nexperiment loadgraph type: gui {\n\tparameter \"Max number of iterations\" var:layout_time;\n\tparameter \"Force coefficient\" category: \"Force\"var:coeff_force;\n\tparameter \"Decreasing coefficient of the temperature\" category: \"Force\" var:cooling_coefficient; \n\tparameter \"Coefficient for the number of places to locate the vertices\" category:\"Grid\" var:coeff_nb_places; \n\tparameter \"Normalization factor\" category: \"Force_FR\" var:normalizationFactor; \n\tparameter \"Theta\" category:\"Force_FR_indexed\" var:theta; \n\tparameter \"Layout type\" var: layout_type among:[\"Force FR\",\"Force FR Indexed\" , \"Force\", \"Circular\", \"Grid\"] init:\"Force FR\";\n\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D graph simulation where nodes (spheres) move and adapt their size based on their degree of connectivity, using a dynamic graph structure.", "gaml_code": "/**\n* Name: 3D Graph\n* Author: Arnaud Grignard\n* Description: Model using a 3D Graph and updating it at each step according to the location and the degree of each sphere. \n* An arc is created between two adjacent spheres. Two different experiments are proposed : one with a dynamic size for \n* the spheres according to their degree, one simpler with no update of the size.\n* Tags: graph, 3d, skill\n*/\n  \n\nmodel graph3D\n\nglobal {\n\tint number_of_agents min: 1 <- 200;\n\tint width_and_height_of_environment min: 100 <- 500;\n\t\n\t//Distance to know if a sphere is adjacent or not with an other\n\tint distance min: 1 <- 100;\n\t\n\t\n\tint degreeMax <- 1;\n\tgeometry shape <- cube(width_and_height_of_environment);\n\t\n\t\n\tgraph my_graph;\n\tinit {\n\t\t\n\t\t//creation of the node agent ie the spheres with a random location in the environment\n\t\tcreate node_agent number: number_of_agents {\n\t\t\tlocation <- { rnd(width_and_height_of_environment), rnd(width_and_height_of_environment), rnd(width_and_height_of_environment) };\n\t\t}\n\t\t\n\t\tdo degreeMax_computation;\n\t\t\n\t\task node_agent {\n\t\t\tdo compute_degree;\n\t\t}\n\t}\n\t\n\treflex updateDegreeMax {\n\t\tdo degreeMax_computation;\n\t}\n\n\taction degreeMax_computation {\n\t\tmy_graph <- node_agent as_distance_graph(distance);\n\t\tdegreeMax <- 1;\n\t\task node_agent {\n\t\t\tif ((my_graph) degree_of (self) > degreeMax) {\n\t\t\t\tdegreeMax <- (my_graph) degree_of (self);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nspecies node_agent skills: [moving3D] {\n\tint degree;\n\tfloat radius;\n\trgb color ;\n\tfloat speed <- 5.0;\n\treflex move {\n\t\t//make the agent move randomly\n\t\tdo wander;\n\t\t//compute the degree of the agent\n\t\tdo compute_degree;\n\t}\n\t\n\t\n\taction compute_degree {\n\t\tdegree <- my_graph = nil ? 0 : (my_graph) degree_of (self);\n\t\tradius <- ((((degree + 1) ^ 1.4) / (degreeMax))) * 5;\n\t\tcolor <- hsb(0.66,degree / (degreeMax + 1), 0.5);\n\t}\n\n    aspect base {\n\t\tdraw sphere(10) color:#black;\n\t}\n\t\n\taspect dynamic {\n\t\tdraw sphere(radius) color: color;\n\t}\n\n}\n\nexperiment Display type: gui {\n\t \n\tparameter 'Number of Agents' var:number_of_agents category: 'Initialization';\n\tparameter 'Dimensions' var:width_and_height_of_environment category: 'Initialization';\n\tparameter 'distance ' var:distance;\n\t\n\toutput {\n\t\tdisplay WanderingSphere type: 3d { \n\t\t\tcamera 'default' location: {-528.0266,911.2309,549.1574} target: {572.0892,-62.0693,0.0};\t\t\t\n\t\t\tspecies node_agent aspect: dynamic;\n\t\t\tgraphics \"edges\" {\n\t\t\t\t//Creation of the edges of adjacence\n\t\t\t\tif (my_graph != nil) {\n\t\t\t\t\tloop eg over: my_graph.edges {\n\t\t\t\t\t\tgeometry edge_geom <- geometry(eg);\n\t\t\t\t\t\tfloat val <- 255 * edge_geom.perimeter / distance; \n\t\t\t\t\t\tdraw line(edge_geom.points, 0.5)  color: rgb(val,val,val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nexperiment SimpleDisplay type: gui {\n\toutput {\n\t\tdisplay WanderingSphere type: 3d { \n\t\t\tcamera 'default' location: {-528.0266,911.2309,549.1574} target: {572.0892,-62.0693,0.0};\t\t\t\n\t\t\tspecies node_agent aspect: base;\n\t\t\tgraphics \"edges\" {\n\t\t\t\tif (my_graph != nil) {\n\t\t\t\t\tloop eg over: my_graph.edges {\n\t\t\t\t\t\tgeometry edge_geom <- geometry(eg);\n\t\t\t\t\t\tfloat val <- 255 * edge_geom.perimeter / distance; \n\t\t\t\t\t\tdraw line(edge_geom.points) color:#black;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Show a graph clustering model using three different algorithms (Girvan-Newman, K-Spanning Tree, and Label Propagation) on a 20-node Watts-Strogatz network.", "gaml_code": "/**\n* Name: Clustering\n* Author: Patrick Taillandier\n* Description: This model shows how to use clustering algorithms to create communities in a graph. 3 algorithms are avalaible: girvan_newman_clustering, k_spanning_tree_clustering and label_propagation_clustering \n* Tags: Graph, Clustering\n*/\n\nmodel Clustering\n\nglobal {\n\tint k <- 4;\n\tint max_iteration <- 100;\n\tlist<list<node_agent>> clusters;\n\tinit {\n\t\tgraph the_graph <- generate_watts_strogatz(20, 0.01, 4, true,node_agent, edge_agent);\t\n\t\tthe_graph <- layout_force(the_graph, world.shape,0.5,0.5,100);\n\t\tclusters <- girvan_newman_clustering(the_graph, k);\n\t\t\t\n\t\tloop c over: clusters {\n\t\t\trgb col <- rnd_color(255);\n\t\t\task list<node_agent>(c) {\n\t\t\t\tcol_cluster_gn <- col;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclusters <- k_spanning_tree_clustering(the_graph, k);\n\t\t\t\n\t\tloop c over: clusters {\n\t\t\trgb col <- rnd_color(255);\n\t\t\task list<node_agent>(c) {\n\t\t\t\tcol_cluster_stc <- col;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclusters <- label_propagation_clustering(the_graph, max_iteration);\n\t\t\t\n\t\tloop c over: clusters {\n\t\t\trgb col <- rnd_color(255);\n\t\t\task list<node_agent>(c) {\n\t\t\t\tcol_cluster_lpc <- col;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\trgb col_cluster_gn;\n\trgb col_cluster_stc;\n\trgb col_cluster_lpc;\n\taspect default {\t\n\t\tdraw circle(1) color: #red;\n\t}\n\taspect color_cluster_gn {\t\n\t\tdraw circle(1) color: col_cluster_gn ;\n\t}\n\taspect color_cluster_stc {\t\n\t\tdraw circle(1) color: col_cluster_stc ;\n\t}\n\taspect color_cluster_lpc {\t\n\t\tdraw circle(1) color: col_cluster_lpc ;\n\t}\n}\n\nexperiment clustering type: gui {\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay general_graph type: 3d axes: false{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent ;\n\t\t}\n\t\tdisplay cluster_girvan_newman type: 3d axes: false{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent aspect: color_cluster_gn ;\n\t\t}\n\t\tdisplay cluster_k_spanning_tree type: 3d axes: false{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent aspect: color_cluster_stc ;\n\t\t}\n\t\tdisplay cluster_label_propagation type: 3d axes: false{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent aspect: color_cluster_lpc ;\n\t\t}\n\t}\n}"}
{"prompt": "Generate a NetLogo model that visualizes the Strahler number computation on a river network from a shapefile.", "gaml_code": "/**\n* Name: testStrahler\n* Author: Patrick Taillandier\n* Description: exemple of Strahler number computation\n* Tags: graph, strahler\n*/\n\nmodel exempleStrahler\n\nglobal {\n\tgraph river_network;\n\tmap strahler_numbers;\n\tfile river_shapefile <- file(\"../includes/rivers.shp\");\n\tgeometry shape <- envelope(river_shapefile);\n\tmap<int,rgb> color_index <- [1::#lightblue, 2::#green,3::#orange, 4::#red];\n\tinit {\n\t\tcreate river from:river_shapefile ;\n\t\triver_network <- directed(as_edge_graph(river));\n\t\tstrahler_numbers <- strahler(river_network);\n\t\task river {\n\t\t\tindex <- strahler_numbers[self] as int;\n\t\t}\n\t}\n}\n\nspecies river {\n\tint index <- 1;\n\taspect default {\n\t\tdraw shape + index/2.0 color: color_index[index] end_arrow: 5;\n\t\tdraw \"\"+index color: #black font: font(30);\n\t}\n}\n\nexperiment testStrahler type: gui {\n\toutput {\n\t\tdisplay map type:2d {\n\t\t\tspecies river;\n\t\t}\n\t}\n}"}
{"prompt": "Generate a GAML model that demonstrates various graph operators and visualizes their results on a GUI.", "gaml_code": "/**\n* Name: Graph Operators\n* Author: Patrick Taillandier\n* Description: Model to show how to use the different existing operators for the graph species\n* Tags: Graph\n*/\n\nmodel graphoperators\n\nglobal {\n\tgraph<geometry,geometry> the_graph;\n\tlist<list> cliques;\n\tmap<geometry,int> ec;\n\tinit {\n\t\tcreate people number: 50;\n\t\t\n\t\t//creation of the graph: all vertices that are at distance <= 20 are connected\n\t\tthe_graph <- as_distance_graph(people, 20);\n\t\t\n\t\t//compute the betweenness_centrality of each vertice\n\t\tmap<people,int> bc <- map<people, int>(betweenness_centrality(the_graph));\n\t\tint max_centrality <- max(bc.values);\n\t\tint min_centrality <- min(bc.values);\n\t\task people {\n\t\t\tcentrality <- (bc[self] - min_centrality) / (max_centrality - min_centrality);\n\t\t\tcentrality_color <- rgb(255, int(255 * (1 - centrality)), int(255 * (1 - centrality)));\n\t\t}\n\t\t\n\t\t//compute the edge_betweenness of each edge\n\t\tec <- map<geometry, int>(edge_betweenness(the_graph));\n\t\t\n\t\twrite \"mean vertice degree: \" + mean(the_graph.vertices collect (the_graph degree_of each));\n\t\twrite \"nb_cycles: \" + nb_cycles(the_graph);\n\t\twrite \"alpha_index: \" + alpha_index(the_graph);\n\t\twrite \"beta_index: \" + beta_index(the_graph);\n\t\twrite \"gamma_index: \" + gamma_index(the_graph);\n\t\twrite \"connectivity_index: \" + connectivity_index(the_graph);\n\t\twrite \"connected_components_of: \" + length(connected_components_of(the_graph));\t\t\n\t\twrite \"maximal_cliques_of:\" + (maximal_cliques_of(the_graph) collect (length(each)));\n\t\twrite \"biggest_cliques_of:\" + (biggest_cliques_of(the_graph) collect (length(each)));\n\t}\n}\n\nspecies people {\n\tfloat centrality;\n\trgb centrality_color;\n\taspect centrality{\n\t\tdraw circle(1) color: centrality_color;\n\t\t\n\t}\n}\n\nexperiment graphoperators type: gui {\n\toutput {\n\t\tdisplay map background:#lightgray{\n\t\t\tgraphics \"edges\" {\n\t\t\t\tloop edge over: the_graph.edges {\n\t\t\t\t\tdraw edge + (0.1+ec[edge]/500) color: #yellow border: #black;\n\t\t\t\t}\n \t\t\t}\n \t\t\tspecies people aspect: centrality;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that demonstrates three ways to build a graph from scratch using NetLogo, including creating graphs from lists of edges and manually adding nodes and edges.", "gaml_code": "/**\n* Name: Hand Made Graph\n* Author: Patrick Taillandier\n* Description: Model to show how to build a graph from scratch using three ways : by putting a list of edges as parameter of as_edge_graph, by adding \n* a node or an edge manually using facet to or by changing the graph itself after adding a node or an edge. The experiment has two displays : one for \n* the first graph created from the list of edges, an other for the graph creating by adding the nodes and edges manually using add operator.\n* Tags: graph, node, edge\n*/\n\n@no_warning\nmodel handMadeGraph\n\nglobal {\n\tgraph<geometry, geometry> the_graph1 ;\n\tgraph<geometry, geometry> the_graph2;\n\t\n\tinit {\n\t\tthe_graph1 <- as_edge_graph([edge({10,5}, {20,3}), edge({10,5}, {30,30}),edge({30,30}, {80,35}),edge({80,35}, {40,60}),edge({80,35}, {10,5}), node ({50,50})]);\t\n\t\t\n\t\tthe_graph2 <- graph<geometry, geometry>([]);\n\t\t//first way to add nodes and edges\n\t\tthe_graph2 << node({50,50}) ;\n\t\tthe_graph2 << edge({10,10},{90,50});\n\t\t\n\t\t//second way to add nodes and edges\n\t\tthe_graph2 <- the_graph2 add_node {10,40} ;\n\t\tthe_graph2 <- the_graph2 add_edge ({35,50}:: {50,50}) ;\n\t}\n\t\n}\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\taspect default {\t\n\t\tdraw circle(1) color: #red;\n\t}\n}\n\nexperiment create_graph type: gui {\n\t\n\toutput {\n\t\tdisplay graph1 type: 3d{\n\t\t\tgraphics \"the graph 1\" {\n\t\t\t\tloop e over: the_graph1.edges {\n\t\t\t\t\tdraw e color: #blue; \n\t\t\t\t}\n\t\t\t\tloop n over: the_graph1.vertices {\n\t\t\t\t\tdraw circle(2) at: point(n) color: #blue; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay graph2 type: 3d{\n\t\t\tgraphics \"the graph 2\" {\n\t\t\t\tloop e over: the_graph2.edges {\n\t\t\t\t\tdraw e color: #red; \n\t\t\t\t}\n\t\t\t\tloop n over: the_graph2.vertices {\n\t\t\t\t\tdraw circle(2) at: point(n) color: #red; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a model to compute and visualize the shortest paths between agents on a network graph using various algorithms (Dijkstra, Bidirectional Dijkstra, AStar, etc.) and display the results in a GUI.", "gaml_code": "/**\n* Name:  Shortest Path Computation on a Graph\n* Author:  Patrick Taillandier\n* Description: Model to show how to use the optimizer methods to compute the shortest path for the agents placed on a network with all of them \n*\thaving the same goal location. It also shows how to save these paths computed into a text file.\n* Tags: graph, agent_movement, skill, shortest_path, algorithm\n*/\n\nmodel Network\n\nglobal {\n\tfile shape_file_in <- file('../includes/roads.shp') ;\n\tgraph the_graph; \n\tgeometry shape <- envelope(shape_file_in);\n\tbool save_shortest_paths <- false;\n\tbool load_shortest_paths <- false;\n\tstring shortest_paths_file <- \"../includes/shortest_paths.csv\";\n\tbool memorize_shortest_paths <- false; //true by default\n\t\n\tlist<rgb> colors <- [#red,#orange,#yellow];\n\t\n\tbool display_k_shortest_paths <- false;\n\tint nb_shortest_paths <- 3;\n\tpoint source;\n\tpoint target;\n\tpath shortest_path;\n\tlist<path> k_shortest_paths;\n\t\n\t/*11 shortest path algorithms can be used for the shortest path computation:\n\t *    - Dijkstra: ensure to find the best shortest path - compute one shortest path at a time: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n\t * \t  - BidirectionalDijkstra: default one - ensure to find the best shortest path - compute one shortest path at a time: https://www.homepages.ucl.ac.uk/~ucahmto/math/2020/05/30/bidirectional-dijkstra.html\n\t *    - BellmannFord: ensure to find the best shortest path - compute one shortest path at a time: https://en.wikipedia.org/wiki/Bellman-Ford_algorithm\n\t * \t  - AStar: ensure to find the best shortest path if for any edge, the weight of the edge is greater than or equal to the distance between the source and the target of the edge. - compute one shortest path at a time: https://en.wikipedia.org/wiki/A*_search_algorithm\n\t *    - NBAStar: ensure to find the best shortest path if for any edge, the weight of the edge is greater than or equal to the distance between the source and the target of the edge.- compute one shortest path at a time: http://repub.eur.nl/pub/16100/ei2009-10.pdf\n\t *    - NBAStarApprox: does not ensure to find the best shortest path - compute one shortest path at a time: http://repub.eur.nl/pub/16100/ei2009-10.pdf\n\t *    - FloydWarshall: ensure to find the best shortest path - compute all the shortest paths at the same time (and keep them in memory): https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm\n\t * \t  - BellmannFord: ensure to find the best shortest path - compute one shortest path at a time: https://en.wikipedia.org/wiki/Bellman-Ford_algorithm\n\t *    - DeltaStepping: ensure to find the best shortest path - compute one shortest path at a time: The delta-stepping algorithm is described in the paper: U. Meyer, P. Sanders, $\\Delta$-stepping:  a parallelizable shortest path algorithm, Journal of Algorithms, Volume 49, Issue 1, 2003, Pages 114-152, ISSN 0196-6774\n\t *    - CHBidirectionalDijkstra: ensure to find the best shortest path - compute one shortest path at a time. Based on precomputations (first call of the algorithm). Implementation of the hierarchical query algorithm based on the bidirectional Dijkstra search. The query algorithm is originally described the article: Robert Geisberger, Peter Sanders, Dominik Schultes, and Daniel Delling. 2008. Contraction hierarchies: faster and simpler hierarchical routing in road networks. In Proceedings of the 7th international conference on Experimental algorithms (WEA'08), Catherine C. McGeoch (Ed.). Springer-Verlag, Berlin, Heidelberg, 319-333\n\t *    - TransitNodeRouting: ensure to find the best shortest path - compute one shortest path at a time. Based on precomputations (first call of the algorithm). The algorithm is designed to operate on sparse graphs with low average outdegree. the algorithm is originally described the article: Arz, Julian &amp; Luxen, Dennis &amp; Sanders, Peter. (2013). Transit Node Routing Reconsidered. 7933. 10.1007/978-3-642-38527-8_7.\n\t */\n\t \n\tstring shortest_path_algo <- #BidirectionalDijkstra among: [#NBAStar, #NBAStarApprox, #Dijkstra, #AStar, #BellmannFord, #FloydWarshall, #BidirectionalDijkstra, #CHBidirectionalDijkstra, #TransitNodeRouting];\n\t\n\t/*2 K shortest path algorithms can be used for the shortest path computation:\n\t *    - Yen: default one. Implementation of Yen`s algorithm for finding k shortest loopless paths. The algorithm is originally described in: Q. V. Martins, Ernesto and M. B. Pascoal, Marta. (2003). A new implementation of Yen\u2019s ranking loopless paths algorithm. Quarterly Journal of the Belgian, French and Italian Operations Research Societies. 1. 121-133. 10.1007/s10288-002-0010-2.\n\t * \t  - Bhandari: an implementation of Bhandari algorithm for finding K edge-disjoint shortest paths. Bhandari, Ramesh 1999. Survivable networks: algorithms for diverse routing. 477. Springer. p. 46. ISBN 0-7923-8381-8. Iqbal, F. and Kuipers, F. A. 2015. Disjoint Paths in Networks.\n\t */\n\tstring k_shortest_path_algo <- #Yen among: [#Yen, #Bhandari];\n\t\n\tinit {    \n\t\tcreate road from: shape_file_in  {\n\t\t\tcreate road with: (shape:line(reverse(shape.points)));\n\t\t}\n\t\tthe_graph <- directed(as_edge_graph(road));\n\t\t\n\t\t//allows to choose the type of algorithm to use compute the shortest paths\n\t\tthe_graph <- the_graph with_shortest_path_algorithm shortest_path_algo;\n\t\t\n\t\t//allows to define if the shortest paths computed should be memorized (in a cache) or not\n\t\tthe_graph <- the_graph use_cache memorize_shortest_paths;\n\t\t\n\t\t//computes all the shortest paths, puts them in a matrix, then saves the matrix in a file\n\t\tif save_shortest_paths {\n\t\t\tmatrix ssp <- all_pairs_shortest_path(the_graph);\n\t\t\tsave ssp format:\"text\" to:shortest_paths_file;\n\t\t\t\n\t\t//loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph\n\t\t} else if load_shortest_paths {\n\t\t\tthe_graph <- the_graph load_shortest_paths matrix(file(shortest_paths_file));\n\t\t}\n\t\tdo compute_shortest_path;\n\t}\n\t\n\treflex update {\n\t\tdo compute_shortest_path;\n\t}\n\t\n\taction compute_shortest_path {\n\t\tsource <- one_of(the_graph.vertices);\n\t\ttarget <- one_of(the_graph.vertices);\n\t\t\n\t\t//allows to choose the type of algorithm to use compute the shortest paths\n\t\tthe_graph <- the_graph with_shortest_path_algorithm shortest_path_algo;\n\t\tthe_graph <- the_graph with_k_shortest_path_algorithm k_shortest_path_algo;\n\t\t\n\t\tshortest_path <- the_graph path_between(source,target); \n\t\tk_shortest_paths <- the_graph paths_between(source::target, nb_shortest_paths);\n\t}\n}\n\nspecies road  {\n\tfloat speed_coef ;\n\taspect default {\n\t\tdraw shape color: #black ;\n\t}\n} \n\n\nexperiment goto_network type: gui {\n\tparameter \"Shortest path algorithm\" var: shortest_path_algo ;\n\tparameter \"K shortest paths algorithm\" var: k_shortest_path_algo ;\n\tparameter \"Computed all the shortest paths and save the results\" var: save_shortest_paths;\n\tparameter \"Load the shortest paths from the file\" var: load_shortest_paths;\n\tparameter \"Display k shortest paths instead of one\" var: display_k_shortest_paths;\n\tparameter \"Number of shortest paths to compute (k)\" var: nb_shortest_paths min: 1 max: 3;\n\t\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies road aspect: default ;\n\t\t\tgraphics \"path\"{\n\t\t\t\tif source != nil {\n\t\t\t\t\tdraw circle(5.0) color: #blue at: source;\n \t\t\t\t}\n \t\t\t\tif target != nil {\n\t\t\t\t\tdraw circle(5.0) color: #red at: target;\n \t\t\t\t}\n \t\t\t\tif (display_k_shortest_paths) {\n \t\t\t\t\tif length(k_shortest_paths) >0 {\n \t\t\t\t\t\tk_shortest_paths <- reverse(k_shortest_paths);\n \t\t\t\t\t\tloop i from: 0 to: length(k_shortest_paths) - 1  {\n\t \t\t\t\t\t\tpath sp <- k_shortest_paths[i];\n\t \t\t\t\t\t\t if sp != nil and sp.shape != nil {\n\t \t\t\t\t\t\t \tdraw sp.shape + 2.0  color: colors[i] ;\n\t \t\t\t\t\t\t }\n\t \t\t\t\t\t}\n\t \t\t\t\t}\n \t\t\t\t} else if shortest_path != nil and shortest_path.shape != nil{\n\t\t\t\t\tdraw shortest_path.shape + 2.0  color: #magenta ;\n \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Generate a GAML model that allows users to interactively create and visualize four types of graphs (scale-free, small-world, complete, and random) with adjustable parameters.", "gaml_code": "/**\n* Name: Graph Generation\n* Author: Patrick Taillandier\n* Description: Model which shows how to create three kind of graphs : a scale-free graph, a small-world graph, a complete graph and a complete graph with a radius.\n* Tags: graph\n*/\n\nmodel classicgraphgeneration\n\nglobal {\n\tgraph the_graph ;\n\tstring graph_type <- \"scale-free\" among: [\"small-world\", \"scale-free\",\"complete\", \"random\" ];\n\tint nb_nodes <- 30;\n\tint nb_edges <- 100;\n\tfloat p <- 0.2;\n\tint k <- 4;\n\tint m <- 4;\n\t\n\tinit {\n\t\tswitch graph_type {\n\t\t\tmatch \"random\" {\n\t\t\t\tthe_graph <- generate_random_graph(nb_nodes,nb_edges, true, node_agent, edge_agent);\n\t\t\t}\n\t\t\tmatch \"scale-free\" {\n\t\t\t\tthe_graph <- generate_barabasi_albert(int(nb_nodes/2), 5, nb_nodes, true, node_agent, edge_agent);\t\n\t\t\t}\n\t\t\tmatch \"small-world\" {\n\t\t\t\tthe_graph <- generate_watts_strogatz(nb_nodes, p, k, true,node_agent, edge_agent);\t\n\t\t\t}\n\t\t\tmatch \"complete\" {\n\t\t\t\tthe_graph <- generate_complete_graph(nb_nodes, true, node_agent, edge_agent);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\twrite the_graph;\n\t\twrite \"Edges : \"+length(the_graph.edges);\n\t\twrite \"Nodes : \"+length(the_graph.vertices);\n\t}\n\t\n}\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\taspect default {\t\n\t\tdraw circle(1) color: #red;\n\t}\n}\n\nexperiment loadgraph type: gui {\n\tparameter \"Graph type\" var: graph_type;\n\tparameter \"Number of nodes\" var: nb_nodes min: 5 ;\n\tparameter \"Probability to rewire an edge (beta)\" var: p min: 0.0 max: 1.0 category: \"small-world\";\n\tparameter \"Base degree of each node. k must be even\" var: k min: 2 max: 10 category: \"small-world\";\n\tparameter \"Number of edges added per novel node\" var: m min: 1 max: 10 category: \"scale-free\";\n\t\n\toutput {\n\t\tdisplay map type: 2d{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a multi-agent simulation that models the movement of people agents on a GIS-based spatial graph and their social connections represented by a non-spatial friendship graph. The simulation should include 50 people agents, each with a target person to move towards, and display the road network, friendship links, and agent movements in a 3D GUI.", "gaml_code": "/**\n* Name: Multigraph\n* Author: Patrick Taillandier\n* Description: This model shows how to build a graph on which people agents will move with GIS Shapefile, but also to generate \n* an other graph representing the friendship between the people agents, people agents trying to be closer spatially to each other\n* Tags: graph, load_file, skill\n*/\n\nmodel multigraph\n\nglobal {\n\tfile shape_file_in <- file('../includes/road.shp') ;\n\tfile shape_file_bounds <- file('../includes/bounds.shp') ;\n\tgeometry shape <- envelope(shape_file_bounds);\n\t\n\t//spatial graph representing the road network\n\tgraph road_graph; \n\t\n\t//social graph (not spatial) representing the friendship links between people\n\tgraph friendship_graph <- graph([]);\n\t\n\tinit {\n\t\tcreate road from: shape_file_in;\n\t\t\n\t\t//creation of th road graph from the road agents\n\t\troad_graph <- as_edge_graph(road);\n\t\t\n\t\t//creation of 50 people agent, and add each people agent as a node in the friendship graph\n\t\tcreate people number: 50 {\n\t\t\tadd node(self) to: friendship_graph;\n\t\t}\n\t\t\n\t\t//creation of 50 friendship link between people agents\n\t\tloop times: 50 {\n\t\t\tpeople p1 <- one_of(people);\n\t\t\tpeople p2 <- one_of(list(people) - p1);\n\t\t\tcreate friendship_link  {\n\t\t\t\tadd edge (p1, p2, self) to: friendship_graph;\n\t\t\t\tshape <- link(p1,p2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies people skills: [moving]{\n\tfloat size <- 3.0;\n\tpeople target_people;\n\tpoint target;\n\t\n\tinit {\n\t\tlocation <- any_location_in(one_of(road));\n\t\ttarget_people <- one_of(people - self);\n\t\ttarget <- target_people.location;\n\t\n\t}\n\t\n\t//action that make recompute the size of the agents as the distance between it and its target people in the friendship graph (the farthest, the biggest)\n\taction updateSize {\n\t\tpath friendship_path <- path_between(friendship_graph,self,target_people);\n\t\tif (friendship_path != nil) {\n\t\t\tsize <-max([2,length( friendship_path.edges)]) as float;\n\t\t}\n\t}\n\t\n\t//the agent moves toward its target, when reaching it, it chooses another target as the location of one of the people agent\n\treflex movement {\n\t\tif (location distance_to target < 5.0) {\n\t\t\ttarget_people <- one_of(people - self);\n\t\t\ttarget <- target_people.location;\n\t\t\tdo updateSize;\n\t\t}\n\t\tdo goto on:road_graph target:target speed:1 + rnd(2.0);\n\t}\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\t\n}\n\t\nspecies friendship_link {\n\t\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n\t\nspecies road  {\n\taspect default {\n\t\tdraw shape color:#black ;\n\t}\n} \n\n\nexperiment multigraph type: gui {\n\toutput {\n\t\tdisplay friendship type: 3d{\n\t\t\tspecies road ;\n\t\t\tspecies friendship_link ;\n\t\t\tspecies people;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates an agent's movement on different paths, including one defined by vertices, another by roads, and a third by a weighted graph. The agent should change its path and color based on the cycle number.", "gaml_code": "/**\n* Name:  Movement of an agent on different paths\n* Author: \n* Description: Model showing the movement of an agent following three different paths : one defined by its vertices, an other defined thanks to all the roads species, and finally \n*       a path defined by a graph with weights (graph created thanks to an other species)\n* Tags: graph, agent_movement, skill\n*/\nmodel path_and_follow\n\nglobal{\n\tgraph the_graph;\n    init{\n    \t\t//It is possible to define a road by defining its shape, being a line. The line need to be created by passing the location of the vertices\n       create road {\n       \t\tshape <- line([{0,50},{40,60}]);\n       }\n       create road {\n       \t\tshape <- line([{40,60},{50,50},{55,60}]);\n       }\n       create road {\n       \t\tshape <- line([{55,60},{65,40}]);\n       }\n       \n       create road_of_graph {\n       \t\tshape <- line([{65,40},{75,35}]);\n       }\n       create road_of_graph {\n       \t\tshape <- line([{75,35},{85,40},{80,60}]);\n       }\n       //It is possible to define a weights map by linking the road and their weights (the road will be the key of the weight)\n       map<road_of_graph,float> weight_map <- road_of_graph as_map (each::each.shape.perimeter * 10);\n       \n       //A graph can be defined by using a list or all the agents of a species and it is possible to use a map of weights with each key \n       // of the map being a road to link the road and its weight\n       //The as_edge_graph operator is an operator creating a graph using the list of agents passed as edges of the graph\n       the_graph <- as_edge_graph(road_of_graph) with_weights weight_map;\n      \n       create myCircle {\n       \t\tlocation <- {0,0};\n       }\n      \n    }  \n}\n\nspecies myCircle skills:[moving]{\n\t//The different ways to declare a path : declaring all the lines of the path using their vertices\n\t//\t\t\t\t\t\t\t  using a list of agents representing the lines of the path\n\t//\t\t\t\t\t\t\t  using the graph as a path\n\t\n\t\n \tpath path_to_follow1 <- path([{0,0},{10,10},{0,20},{20,30},{20,40},{0,50}]);\t\n \tpath path_to_follow2 <- path(list(road));\t\n \tpath path_to_follow3 <- list(road_of_graph) as_path the_graph;\t\n \t\n \t//These two variables will change when the cycle will be higher than 100 and 200\n \tpath path_following<- path_to_follow1;\n \trgb color <- #green;\n \t\n\treflex myfollow{ \n\t\t//The operator follow make the agent move from the starting vertice of the starting edge of a path to the last vertice of the last edge of the path\n\t\t// but following the edges of the concerned path\n\t \tdo follow path: path_following;\t\n\t \tif(cycle>200)\n\t \t{\n\t \t\tpath_following<- path_to_follow3;\t\n\t \t\tcolor<-#pink;\n\t \t}\n\t \telse\n\t \t{\n\t \t\tif(cycle>100)\n\t\t \t{\n\t\t \t\tpath_following<- path_to_follow2;\t\n\t\t \t\tcolor<-#blue;\n\t\t \t}\n\t \t}\n\t}\n\t\n\taspect base {\n\t  draw circle(1) color:#red ;\t\n\t  //We loop on all the edges of the path the agent follow to display them\n\t  \tloop seg over: path_following.edges {\n\t  \t\tdraw seg color: color;\n\t \t }\n\t  \n\t} \n}\n\nspecies road {\n\taspect base {\n\t  draw shape color:#blue ;\t\n\t  \n\t} \n}\n\nspecies road_of_graph {\n\taspect base {\n\t  draw shape color:#red ;\t\n\t  \n\t} \n}\n\nexperiment main type: gui {\n\tfloat minimum_cycle_duration <- 0.10;\n\toutput {\n\t\tdisplay myView { \n\t\t\tspecies myCircle aspect:base; \n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates movement of agents on a grid with obstacles, using either A* or Dijkstra algorithm to find the shortest path, and visualize the path taken by each agent.", "gaml_code": "/**\n* Name:  Movement on a Grid of Cells\n* Author:  Patrick Taillandier\n* Description: Model to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring \n* \tin magenta the cells intersecting the path of an agent\n* Tags: grid, agent_movement, skill, obstacle, shortest_path\n*/\n\nmodel Grid\n\nglobal {\n\t/*2 algorithms for the shortest path computation on a grid with weights:\n\t*      - A* : default algorithm: An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tfile dem <- file(\"../includes/vulcano_50.asc\");\n\tgeometry shape <- envelope(dem);\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\"];\n\tint neighborhood_type <- 8 among:[4,8];\n\tmap<cell,float> cell_weights;\n\n\tinit {    \n\t\task cell {grid_value <- grid_value * 5;}  \n\t\tfloat max_val <- cell max_of (each.grid_value);\n\t\task cell {\n\t\t\tfloat val <- 255 * (1 - grid_value / max_val);\n\t\t\tcolor <- rgb(val, val,val);\n\t\t}\n\t\tcell_weights <- cell as_map (each::each.grid_value);\n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell file: dem neighbors: neighborhood_type optimizer: algorithm {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- 1.0;\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t\tif (current_path != nil) {\n\t\t\tdraw current_path.shape color: #red;\n\t\t}\n\t}\n\t\n\treflex move when: location != target{\n\t\t//We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path\n\t\t//followed by the agent\n\t\t//the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.\n\t\tdo goto (on:cell_weights, target:target, speed:speed, recompute_path: false);\n\t\t\n\t\t//As a side note, it is also possible to use the path_between operator and follow action with a grid\n\t\t//Add a my_path attribute of type path to the people species\n\t\t//if my_path = nil {my_path <- path_between((cell where not each.is_obstacle), location, target);}\n\t\t//do follow (path: my_path);\n\t}\n}\n\nexperiment goto_grid type: gui {\n\t\n\t\n\tparameter var:algorithm among: [\"A*\", \"Dijkstra\"];\n\tparameter var:neighborhood_type among:[4,8];\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\toutput {\n\t\tdisplay objects_display type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tspecies goal aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of a directed graph representing a road network with agents moving between points on the graph, using GIS data to define road directions and agent movement.", "gaml_code": "/**\n* Name:  Directed Graph Model\n* Author:  Patrick Taillandier\n* Description: Model representing how to directed graph using GIS Data for the road networks : the GIS contains a column defining the direction of the roads \n* \tand people moving from one random point to another on this graph\n* Tags: graph, agent_movement, skill \n*/\n\nmodel simplemodel\n\nglobal {\n\tfile road_file <- file(\"../includes/gis/roads.shp\");\n\tgeometry shape <- envelope(road_file);\n\tgraph the_graph; \n\t\n\tinit {\n\t\tcreate road from: road_file with:[direction::int(read(\"DIRECTION\"))] {\n\t\t\tswitch direction {\n\t\t\t\tmatch 0 {color <- #green;}\n\t\t\t\tmatch 1 {color <- #red;\n\t\t\t\t\t//inversion of the road geometry\n\t\t\t\t\tshape <- polyline(reverse(shape.points));\n\t\t\t\t}\n\t\t\t\tmatch 2 {color <- #blue;\n\t\t\t\t\t//bidirectional: creation of the inverse road\n\t\t\t\t\tcreate road {\n\t\t\t\t\t\tshape <- polyline(reverse(myself.shape.points));\n\t\t\t\t\t\tdirection <- 2;\n\t\t\t\t\t\tcolor <- #blue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t//The operator directed modify the graph created by as_edge_graph(road) to a directed graph\n\t\tthe_graph <- directed(as_edge_graph(road)) ;\n\t\t\n\t\t\n\t\tcreate people number: 1000 {\n\t\t\t//The operator any_location_in returns a random point located in one of the road agents\n\t\t\ttarget <- any_location_in(one_of (road)) ;\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t} \n\t}\n}\n\nspecies road {\n\tint direction;\n\trgb color;\n\taspect geom {\n\t\tdraw shape color: color;\n\t}\n}\n//The people agents use the skill moving which have built-in variables such as speed, target, location, heading and built-in operators\nspecies people skills: [moving] {\n\tpoint target;\n\tpath my_path; \n\taspect circle {\n\t\tdraw circle(10) color: #green;\n\t}\n\t\n\treflex movement {\n\t\t\n\t\t//The operator goto is a built-in operator derivated from the moving skill, moving the agent from its location to its target, \n\t\t//   restricted by the on variable, with the speed and returning the path followed\n\t\tmy_path <- goto(on:the_graph, target:target, speed:10.0, return_path: true);\n\t\t\n\t\t//If the agent arrived to its target location, then it choose randomly an other target on the road\n\t\tif (target = location) {\t\t\t\n\t\t\ttarget <- any_location_in(one_of (road)) ;\n\t\t}\n\t}\n}\n\nexperiment simplemodel type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies road aspect: geom;\n\t\t\tspecies people aspect: circle;\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of multiple agents moving in different ways (move, wander, goto, and follow) within a maze or environment, allowing for customization of agent appearance, movement type, and visualization settings.", "gaml_code": "/**\n* Name:  Movement in 3D\n* Author:  Arnaud Grignard - Tri Nguyen Huu\n* Description: This model illustrates the different action and effect offered by the movingSkill3D (move,wander,goto and follow)\n* Tags: 3d, agent_movement, graph, skill\n*/\n\n\n\nmodel Moving3DModel   \n\nglobal {\n\tint number_of_agents min: 1 <- 250 step:10; \n\tint envSize <-100; //max:100;\n\tint mazeSize <-10;\n\tint radius min: 1 <- 1 ;\n\tint directionSize min: 1 <- 10 ;\n\tstring movingType <-\"move\";\n\tgraph mazeGraph;\n\tgeometry shape <- cube(envSize);\n\tbool trace <-false;\n\tstring agentAspect <- \"sphere\" among:[\"circle\", \"sphere\",\"direction\"];\n\n\tinit { \n\t\t\n\t\tif(movingType = \"move\" or movingType = \"complete\"){\n\t\t  create movingAgent number: number_of_agents{\n\t  \t\tlocation <- {rnd(envSize), rnd(envSize), rnd(envSize)};\n\t\t    color<-#red;\t\n\t\t  }\t\n\t\t}\n\t\t  \n\t\tif(movingType = \"wander\" or movingType = \"complete\"){\n\t\t\tcreate wanderAgent number: number_of_agents{\n\t\t\t  location <- {rnd(envSize), rnd(envSize), rnd(envSize)};\n\t\t\t  color<-#green;\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(movingType = \"goto\" or movingType = \"complete\"){\n\t\t\tcreate gotoAgent number: number_of_agents{\n\t\t\t  location <- {rnd(envSize), rnd(envSize), rnd(envSize)};\n\t\t\t  myTarget <-{rnd(envSize),rnd(envSize),rnd(envSize)};\n\t\t\t  color<-#yellow;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(movingType = \"gotoOnNetwork\" or movingType = \"complete\"){\n\t\t\t\n\t\t\tloop i from:0 to:mazeSize{\n\t\t      loop j from:0 to: mazeSize{\n\t\t\t    loop k from:0 to:mazeSize{\n\t\t\t      create cell{\n\t\t\t\t    location <-{(i)*envSize/mazeSize,(j)*envSize/mazeSize, (k)*envSize/mazeSize};\n\t\t\t      }\t\n\t\t\t    }\t\n\t          }\n\t\t    }\n\t\t    create gotoAgentOnNetwork number: number_of_agents{\n\t\t\t  location <- {floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10};\n\t\t\t  myTarget <-{0,0,0};\n\t\t\t  speed <-0.1;\n\t\t\t  color<-#orange;\t\t\n\t\t\t}\n\t\t    mazeGraph <- as_distance_graph(cell, 10.0,edge_agent);\n\t\n\t\t}\n\t }\n}\n\nspecies abstractAgent skills: [moving3D]{\n\trgb color;\n\taspect default {\n\t\tif(agentAspect = \"sphere\"){\n\t\t\tdraw sphere(radius) color:color at:{location.x,location.y,location.z-radius/2};\n\t\t}\n\t\tif(agentAspect = \"circle\"){\n\t\t\tdraw circle(radius) color:color;\n\t\t}\n\t\tif(agentAspect = \"direction\"){\n\t\t  draw sphere(radius) color:color at:{location.x,location.y,location.z-radius/2};\n          draw line([{location.x,location.y,location.z},{location.x+directionSize*cos(pitch)*cos(heading),location.y+directionSize*cos(pitch)*sin(heading),location.z+directionSize*sin(pitch)}]) end_arrow:1.0 color:color;\t\n\t\t}  \t \t\n    }\n} \n\nspecies movingAgent  parent:abstractAgent{ \n\treflex move{\n\t  do move;\n\t}\t\t\n}\n\nspecies wanderAgent parent:abstractAgent{ \n\treflex wander{\n\t  do wander amplitude:90.0;\n\t}\n}\n\nspecies gotoAgent parent:abstractAgent{ \n\tpoint myTarget;\n\tstring gotoType;\n\treflex goto{\n\t\tmyTarget<-{rnd(envSize),rnd(envSize),rnd(envSize)};\n\t\tdo goto target:myTarget;\t  \n\t}\n}\n\nspecies gotoAgentOnNetwork parent:abstractAgent{ \n\tpoint myTarget;\n\tstring gotoType;\n\treflex goto{\n\t  \tdo goto target:myTarget on: mazeGraph;\n\t}\t\t\n}\n\n\n    \nspecies cell schedules:[]{\n\t\n\taspect myPoint{\n\t\tdraw sphere(0.01 * envSize/mazeSize) color:rgb(255,255,255,0.5) at:location ;\n\t}\n\t\n}\n\nspecies edge_agent schedules:[]{\n\taspect base2 {\n\t\tdraw shape color: rgb(255,255,255);\n\t}\n}\n\t\n\t\nexperiment base virtual:true{\n\tparameter 'Number of Agents' var:number_of_agents category: 'Initialization'; \n\tparameter var:envSize; \n\tparameter var:mazeSize;\n\tparameter 'Radius' var:radius;\n\tparameter 'direction size'var:directionSize;\n\t\n\t\n\tfloat minimum_cycle_duration <- 0.05#s;\n\t\t\n\t\n}\n\nexperiment Moving  type: gui parent:base{\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"move\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\t\n\tinit {\n\t\task world.movingAgent{\n\t\t\tlocation <- {envSize/2, envSize/2, envSize/2};\n\t\t}\n\t}\n\t\n\toutput {\t\n\t\tdisplay MovingAgent type:3d  background:rgb(10,40,55) {\n\t\t\tcamera 'default' location: {55.5312,184.9648,188.2995} target: {55.5312,18.3657,0.0};\n\t\t\tspecies movingAgent trace:trace;\n\t\t}\n\t}\n}\n\nexperiment Wandering  type: gui parent:base{\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"wander\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\t\n\t\tdisplay WanderingAgent type:3d  background:rgb(10,40,55) {\n\t\t\tcamera 'default' location: {55.5312,184.9648,188.2995} target: {55.5312,18.3657,0.0};\n\t\t\tspecies wanderAgent trace:trace;\n\t\t}\n\t}\n}\n\nexperiment Goto  type: gui parent:base{\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"goto\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\t\n\t\tdisplay GotoAgent type:3d  background:rgb(10,40,55) {\n\t\t\tcamera 'default' location: {55.5312,184.9648,188.2995} target: {55.5312,18.3657,0.0};\n\t\t\tspecies gotoAgent trace:trace;\n\t\t}\n\t}\n}\n\nexperiment GotoOnNetwork  type: gui parent:base{\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"gotoOnNetwork\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\n\t\t\t\n\t\tdisplay GotoOnNetworkAgent type:3d background:rgb(10,40,55) {\n\t\t\tcamera 'default' location: {-149.2264,96.1645,136.3544} target: {115.5586,27.6864,0.0};\n\t\t\tspecies gotoAgentOnNetwork trace:trace;\n\t\t\tspecies cell aspect:myPoint;\n\t\t\tspecies edge_agent aspect: base2 ;\n\t\t}\n\t}\n}\n\nexperiment Complete  type: gui parent:base{\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"complete\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\n\t\t\t\n\t\tdisplay GotoOnNetworkAgent type:3d background:rgb(10,40,55) {\n\t\t\tcamera 'default' location: {-51.3023,242.3741,147.6937} target: {153.2868,19.1041,0.0};\n\t\t\tspecies movingAgent position:{0,0,0} trace:trace;\n\t\t\tspecies wanderAgent position:{envSize,0,0} trace:trace;\n\t\t\tspecies gotoAgent position:{envSize*2,0,0} trace:trace;\n\t\t\tspecies gotoAgentOnNetwork position:{envSize*3,0,0} trace:trace;\n\t\t\tspecies cell aspect:myPoint position:{envSize*3,0,0};\n\t\t\tspecies edge_agent aspect: base2 position:{envSize*3,0,0};\n\t\t}\n\t}\n}"}
{"prompt": "Design a NetLogo model that computes shortest paths on a graph using various algorithms and saves or loads these paths to/from a file.", "gaml_code": "/**\n* Name:  Shortest Path Computation on a Graph\n* Author:  Patrick Taillandier\n* Description: Model to show how to use the optimizer methods to compute the shortest path for the agents placed on a network with all of them \n*\thaving the same goal location. It also shows how to save these paths computed into a text file.\n* Tags: graph, agent_movement, skill, shortest_path, algorithm\n*/\n\nmodel Network\n\nglobal {\n\tfile shape_file_in <- file('../includes/gis/roads.shp') ;\n\tgraph the_graph; \n\tgeometry shape <- envelope(shape_file_in) + 100;\n\tbool save_shortest_paths <- false;\n\tbool load_shortest_paths <- false;\n\tstring shortest_paths_file <- \"../includes/shortest_paths.csv\";\n\tbool memorize_shortest_paths <- true;\n\t\t\n\t/*11 shortest path algorithms can be used for the shortest path computation:\n\t *    - Dijkstra: ensure to find the best shortest path - compute one shortest path at a time: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n\t * \t  - BidirectionalDijkstra: default one - ensure to find the best shortest path - compute one shortest path at a time: https://www.homepages.ucl.ac.uk/~ucahmto/math/2020/05/30/bidirectional-dijkstra.html\n\t *    - BellmannFord: ensure to find the best shortest path - compute one shortest path at a time: https://en.wikipedia.org/wiki/Bellman-Ford_algorithm\n\t * \t  - AStar: ensure to find the best shortest path if for any edge, the weight of the edge is greater than or equal to the distance between the source and the target of the edge. - compute one shortest path at a time: https://en.wikipedia.org/wiki/A*_search_algorithm\n\t *    - NBAStar: ensure to find the best shortest path if for any edge, the weight of the edge is greater than or equal to the distance between the source and the target of the edge.- compute one shortest path at a time: http://repub.eur.nl/pub/16100/ei2009-10.pdf\n\t *    - NBAStarApprox: does not ensure to find the best shortest path - compute one shortest path at a time: http://repub.eur.nl/pub/16100/ei2009-10.pdf\n\t *    - FloydWarshall: ensure to find the best shortest path - compute all the shortest paths at the same time (and keep them in memory): https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm\n\t * \t  - BellmannFord: ensure to find the best shortest path - compute one shortest path at a time: https://en.wikipedia.org/wiki/Bellman-Ford_algorithm\n\t *    - DeltaStepping: ensure to find the best shortest path - compute one shortest path at a time: The delta-stepping algorithm is described in the paper: U. Meyer, P. Sanders, $\\Delta$-stepping:  a parallelizable shortest path algorithm, Journal of Algorithms, Volume 49, Issue 1, 2003, Pages 114-152, ISSN 0196-6774\n\t *    - CHBidirectionalDijkstra: ensure to find the best shortest path - compute one shortest path at a time. Based on precomputations (first call of the algorithm). Implementation of the hierarchical query algorithm based on the bidirectional Dijkstra search. The query algorithm is originally described the article: Robert Geisberger, Peter Sanders, Dominik Schultes, and Daniel Delling. 2008. Contraction hierarchies: faster and simpler hierarchical routing in road networks. In Proceedings of the 7th international conference on Experimental algorithms (WEA'08), Catherine C. McGeoch (Ed.). Springer-Verlag, Berlin, Heidelberg, 319-333\n\t *    - TransitNodeRouting: ensure to find the best shortest path - compute one shortest path at a time. Based on precomputations (first call of the algorithm). The algorithm is designed to operate on sparse graphs with low average outdegree. the algorithm is originally described the article: Arz, Julian &amp; Luxen, Dennis &amp; Sanders, Peter. (2013). Transit Node Routing Reconsidered. 7933. 10.1007/978-3-642-38527-8_7.\n\t */\n\t \n\tstring shortest_path_algo <- #BidirectionalDijkstra among: [#NBAStar, #NBAStarApprox, #Dijkstra, #AStar, #BellmannFord, #FloydWarshall, #BidirectionalDijkstra, #CHBidirectionalDijkstra, #TransitNodeRouting];\n\t\n\tint nb_people <- 100;\n\tinit {    \n\t\tcreate road from: shape_file_in ;\n\t\tthe_graph <- as_edge_graph(list(road));\n\t\t\n\t\t//allows to choose the type of algorithm to use compute the shortest paths\n\t\tthe_graph <- the_graph with_shortest_path_algorithm shortest_path_algo;\n\t\t\n\t\t//allows to define if the shortest paths computed should be memorized (in a cache) or not\n\t\tthe_graph <- the_graph use_cache memorize_shortest_paths;\n\t\t\n\t\t//computes all the shortest paths, puts them in a matrix, then saves the matrix in a file\n\t\tif save_shortest_paths {\n\t\t\tmatrix ssp <- all_pairs_shortest_path(the_graph);\n\t\t\tsave ssp format:\"text\" to:shortest_paths_file;\n\t\t\t\n\t\t//loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph\n\t\t} else if load_shortest_paths {\n\t\t\tthe_graph <- the_graph load_shortest_paths matrix(file(shortest_paths_file));\n\t\t}\n\t\t\n\t\tcreate goal number: 1 {\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t}\n\t\tcreate people number: nb_people {\n\t\t\ttarget <- one_of (goal) ;\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t} \n\t}\n}\n\nspecies road  {\n\tfloat speed_coef ;\n\taspect default {\n\t\tdraw shape color: #black ;\n\t}\n} \n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(50) color: #red;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\taspect default {\n\t\tdraw circle(50) color: #green;\n\t}\n\treflex movement {\n\t\tdo goto on:the_graph target:target speed:1.0;\n\t}\n}\n\n\nexperiment goto_network type: gui {\n\tparameter \"Shortest path algorithm\" var: shortest_path_algo ;\n\tparameter \"Number of people\" var: nb_people min: 1 max: 10000;\n\tparameter \"Computed all the shortest paths and save the results\" var: save_shortest_paths;\n\tparameter \"Load the shortest paths from the file\" var: load_shortest_paths;\n\t\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies road aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t\tspecies goal aspect: default ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates movement of agents on a grid with obstacles and computes the shortest path using A* algorithm. Include visualization of the path and agent movements.", "gaml_code": "/**\n* Name:  Movement on a Grid of Cells\n* Author:  Patrick Taillandier\n* Description: Model to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring \n* \tin magenta the cells intersecting the path of an agent\n* Tags: grid, agent_movement, skill, obstacle, shortest_path\n*/\n\nmodel Grid\n\nglobal {\n\t/*4 algorithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https://harablog.wordpress.com/2011/09/07/jump-point-search/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\", \"JPS\", \"BF\"];\n\tint neighborhood_type <- 8 among:[4,8];\n\t\n\n\tinit {    \n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell width: 50 height: 50 neighbors: neighborhood_type optimizer: algorithm {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- float(3);\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t\tif (current_path != nil) {\n\t\t\tdraw current_path.shape color: #red;\n\t\t}\n\t}\n\t\n\treflex move when: location != target{\n\t\t//We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path\n\t\t//followed by the agent\n\t\t//the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.\n\t\tdo goto (on:(cell where not each.is_obstacle), target:target, speed:speed, recompute_path: false);\n\t\t\n\t\t//As a side note, it is also possible to use the path_between operator and follow action with a grid\n\t\t//Add a my_path attribute of type path to the people species\n\t\t//if my_path = nil {my_path <- path_between((cell where not each.is_obstacle), location, target);}\n\t\t//do follow (path: my_path);\n\t}\n}\n\nexperiment goto_grid type: gui {\n\t\n\tparameter var:algorithm;\n\tparameter var:neighborhood_type;\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\toutput {\n\t\tdisplay objects_display type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tspecies goal aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation model that demonstrates how an agent perceives its surroundings and navigates through obstacles in a 2D environment, using the masked_by operator to compute the field of vision.", "gaml_code": "/**\n* Name: fieldofvision\n* Author: Patrick Taillandier\n* Description: This model illustrate how to use the masked_by operator to compute the field of vision of an agent (with obtsacles)\n* Tags: perception, spatial_computation, masked_by\n*/\n\nmodel fieldofvision\n\nglobal {\n\t//number of obstacles\n\tint nb_obstacles <- 20;\n\t\n\t//perception distance\n\tfloat perception_distance <- 40.0;\n\t\n\t//precision used for the masked_by operator (default value: 120): the higher the most accurate the perception will be, but it will require more computation\n\tint precision <- 600;\n\t\n\t//space where the agent can move.\n\tgeometry free_space <- copy(shape);\n\tinit {\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tshape <- rectangle(2+rnd(20), 2+rnd(20));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people  {\n\t\t\tlocation <- any_location_in(free_space);\n\t\t}\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nspecies people skills: [moving]{\n\t//zone of perception\n\tgeometry perceived_area;\n\t\n\t//the target it wants to reach\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\tif (perceived_area = nil) or (perceived_area.area < 2.0) {\n\t\t\t\t//if the agent has no target and if the perceived area is empty (or too small), it moves randomly inside the free_space\n\t\t\t\tdo wander bounds: free_space;\n\t\t\t} else {\n\t\t\t\t//otherwise, it computes a new target inside the perceived_area .\n\t\t\t\ttarget <- any_location_in(perceived_area);\n\t\t\t}\n\t\t} else {\n\t\t\t//if it has a target, it moves towards this target\n\t\t\tdo goto target: target;\n\t\t\t\n\t\t\t//if it reaches its target, it sets it to nil (to choose a new target)\n\t\t\tif (location = target)  {\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\n\t}\n\t//computation of the perceived area\n\treflex update_perception {\n\t\t//the agent perceived a cone (with an amplitude of 60\u00b0) at a distance of  perception_distance (the intersection with the world shape is just to limit the perception to the world)\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(perception_distance); \n\t\t\n\t\t//if the perceived area is not nil, we use the masked_by operator to compute the visible area from the perceived area according to the obstacles\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,precision);\n\n\t\t}\n\t}\n\t\n\taspect body {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t}\n\taspect perception {\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t\tdraw circle(1) at: target color: #magenta;\n\t\t}\n\t}\n}\n\nexperiment fieldofvision type: gui {\n\t\n\tparameter var:nb_obstacles;\n\t\n\tparameter var:perception_distance;\n\t\n\tparameter var:precision;\n\t\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput synchronized: true {\n\t\tdisplay view{\n\t\t\tspecies obstacle;\n\t\t\tspecies people aspect: perception transparency: 0.5;\n\t\t\tspecies people aspect: body;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that simulates two agents navigating a weighted graph, one with and one without knowledge of edge weights. The model should visualize the path taken by each agent and highlight the impact of weights on movement time.", "gaml_code": "/**\n* Name:  Follow Weighted Network\n* Author:  Martine Taillandier\n* Description: Model representing how to make a weighted graph and the impacts of the weights on the time to follow the path for the agents. \n* \tTwo agents are represented to show this difference : one knowing the weights and following a fast path, an other following a path longer \n* \twithout knowing it's a longer path.\n* Tags: graph, agent_movement, skill\n*/\n\nmodel weightperagents\n\nglobal {\n\tmap<road, float> roads_weight;\n\tgraph road_network;\n\tfloat slow_coeff <- 3.0;\n\tinit {\n\t\t//This road will be slow\n\t\tcreate road {\n\t\t\tshape <- line ([{10,50},{90,50}]);\n\t\t\tslow <- true;\n\t\t}\n\t\t//The others will be faster\n\t\tcreate road {\n\t\t\tshape <- line ([{10,50},{10,10}]);\n\t\t\tslow <- false;\n\t\t}\n\t\tcreate road {\n\t\t\tshape <- line ([{10,10},{90,10}]);\n\t\t\tslow <- false;\n\t\t}\n\t\tcreate road {\n\t\t\tshape <- line ([{90,10},{90,50}]);\n\t\t\tslow <- false;\n\t\t}\n\t\t\n\t\t//Weights map of the graph for those who will know the shortest road by taking into account the weight of the edges\n\t\troads_weight <- road as_map (each:: each.shape.perimeter * (each.slow ? slow_coeff : 1.0));\n\t\troad_network <- as_edge_graph(road);\n\t\t\n\t\t//people with information about the traffic\n\t\tcreate people {\n\t\t\tcolor <- #blue;\n\t\t\tsize <- 2.0;\n\t\t\troads_knowledge <- roads_weight;\n\t\t}\n\t\t\n\t\t//people without information about the traffic\n\t\tcreate people {\n\t\t\tcolor <- #yellow;\n\t\t\tsize <- 1.0;\n\t\t\troads_knowledge <- road as_map (each:: each.shape.perimeter);\n\t\t}\n\t}\n\t\n}\n\nspecies road {\n\tbool slow;\n\taspect geom {\n\t\tdraw shape color: slow ? #red : #green;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tmap<road, float> roads_knowledge;\n\tpoint the_target;\n\trgb color;\n\tfloat size;\n\tpath path_to_follow;\n\t\n\tinit {\n\t\tthe_target <- {90,50};\n\t\tlocation <- {10,50};\n\t}\n\t\t\n\treflex movement when: location != the_target{\n\t\tif (path_to_follow = nil) {\n\t\t\t\n\t\t\t//Find the shortest path using the agent's own weights to compute the shortest path\n\t\t\tpath_to_follow <- path_between(road_network with_weights roads_knowledge, location,the_target);\n\t\t}\n\t\t//the agent follows the path it computed but with the real weights of the graph\n\t\tdo follow path:path_to_follow speed: 5.0 move_weights: roads_weight;\n\t}\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\nexperiment weightperagents type: gui {\n\tfloat minimum_cycle_duration <- 0.1;\n\toutput {\n\t\tdisplay map type:2d{\n\t\t\tspecies road aspect: geom;\n\t\t\tspecies people aspect: base;\n\t\t}\n\t}\n}"}
{"prompt": "Create a simulation of agents moving randomly on a graph, where each agent has a probability to choose a road based on a map of probabilities.", "gaml_code": "/***\n* Name: Wander\n* Author: Patrick Taillandier\n* Description: This model illustrates the use of the wander action of the moving Skill on a graph: the probability to choose a road is given by\n* a map (road::probability). \n* Tags: agent_movement, graph, wander, skill\n***/\n\nmodel WanderonGraph\n\nglobal {\n\t\n\tgraph network;\n\t\n\t//map that gives the probability to choose a road\n\tmap<road,float> proba_use_road;\n\t\n\tinit {\n\t\tcreate road with: [shape::line([{10,10}, {40,10}])];\n\t\tcreate road with: [shape::line([{40,10}, {40,40}])];\n\t\tcreate road with: [shape::line([{40,10}, {80,10}])];\n\t\tcreate road with: [shape::line([{80,10}, {80,40}])];\n\t\tcreate road with: [shape::line([{40,40}, {80,40}])];\n\t\tcreate road with: [shape::line([{80,40}, {80,80}])];\n\t\tcreate road with: [shape::line([{80,80}, {10,80}])];\n\t\tcreate road with: [shape::line([{80,80}, {50,50}])];\n\t\tcreate road with: [shape::line([{50,50}, {10,80}])];\n\t\tcreate road with: [shape::line([{10,80}, {10,10}])];\n\t\t\n\t\t\n\t\tcreate people number: 50 with: [location::any_location_in(one_of(road))];\n\t\t\n\t\t//directed graph build from the road agents\n\t\tnetwork <- directed(as_edge_graph(road));\n\t\t\n\t\t//the map of probability to choose a road is build from the proba_use attribute of roads\n\t\tproba_use_road <- road as_map (each::each.proba_use);\n\t}\n}\n\nspecies road {\n\t// probability for a agent to choose this road\n\tfloat proba_use <- rnd(0.1, 1.0);\n\t\n\taspect default {\n\t\tdraw shape +(proba_use/2.0)  color: #gray end_arrow: 2.0;\n\t}\n}\n\nspecies people skills: [moving]{\n\trgb color <- rnd_color(255);\n\taspect default {\n\t\tdraw circle(1.0) color:color border: #black;\n\t}\n\t\n\treflex move {\n\t\t// move randomly on the network, using proba_use_road to define the probability to choose a road.\n\t\tdo wander on: network proba_edges: proba_use_road ;\n\t}\n}\n\nexperiment WanderonGraph type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tdisplay map type:2d{\n\t\t\tspecies road;\n\t\t\tspecies people;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates movement of agents on a graph created by skeletonizing polygons from a shapefile, using shortest paths to reach a common target location.", "gaml_code": "/**\n* Name:  Movement on a Graph created by Polygons\n* Author:  Patrick Taillandier\n* Description: Model to show how to create a graph using a polygon shapefile by skeletonizing it, and creating roads using the skeleton. \n* \tAll of the agents will use this graph to go to the same targeted location.\n* Tags: graph, agent_movement, shapefile, skill, shortest_path\n*/\n\nmodel polygon\nglobal {\n\t//Import of the shapefile containing the different polygons\n\tfile shape_file_in <- file('../includes/gis/squareHole.shp') ;\n\tgraph the_graph;\n\t\n\tgeometry shape <- envelope(shape_file_in);\n\t\n\tinit {    \n\t\tcreate object from: shape_file_in ;\n\t\tobject the_object <- first(object);\n\t\t\n\t\t//triangulation of the object to get the different triangles of the polygons\n\t\tlist<geometry> triangles <- list(triangulate(the_object, 0.01));\n\t\t\n\t\tloop trig over: triangles {\n\t\t\tcreate triangle_obj {\n\t\t\t\tshape <- trig;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//creation of a list of skeleton from the object \n\t\tlist<geometry> skeletons <- list(skeletonize(the_object, 0.01));\n\t\t\n\t\t//Split of the skeletons list according to their intersection points\n\t\tlist<geometry> skeletons_split  <- split_lines(skeletons);\n\t\tloop sk over: skeletons_split {\n\t\t\tcreate skeleton {\n\t\t\t\tshape <- sk;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Creation of the graph using the edges resulting of the splitted skeleton\n\t\t the_graph <- as_edge_graph(skeleton);\n\t\t \n\t\t \n\t\tcreate goal  {\n\t\t\t location <- any_location_in (one_of(skeleton)); \n\t\t}\n\t\tcreate people number: 100 {\n\t\t\t target <- one_of (goal) ; \n\t\t\t location <- any_location_in (one_of(skeleton));\n\t\t} \n\t}\n}\n\nspecies object  {\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}\n\nspecies triangle_obj  {\n\trgb color <- rgb(150 +rnd(100),150 + rnd(100),150 + rnd(100));\n\taspect default {\n\t\tdraw shape color: color ; \n\t}\n}\n\nspecies skeleton  {\n\taspect default {\n\t\tdraw shape + 0.2 color: #red ;\n\t}\n}\n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(3) color:#red;\n\t}\n}\n\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\treflex goto {\n\t\tdo goto on:the_graph target:target speed:1.0;\n\t}\n\taspect default {\n\t\tdraw circle(3) color: #green;\n\t}\n}\n\nexperiment goto_polygon type: gui {\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies object aspect: default ;\n\t\t\tspecies triangle_obj aspect: default ;\n\t\t\tspecies skeleton aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t\tspecies goal aspect: default ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a model that simulates the computation of the shortest path on a grid using four algorithms (A*, Dijkstra, JPS, and BF) for different neighborhood types (Moore and Von Neumann) with varying obstacle rates and grid sizes.", "gaml_code": "/**\n* Name:  Computation of the shortest path on a Grid of Cells\n* Author:  Patrick Taillandier\n* Description: Model to represent how to compute the shortest path from a grid (with the 4 algorithms).\n* Tags: grid, obstacle, shortest_path\n*/\n\nmodel Grid\n\nglobal {\n\t\n\t/*4 algorithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https://harablog.wordpress.com/2011/09/07/jump-point-search/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tstring scenario <- \"wall\" among: [\"random\", \"wall\"];\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\", \"JPS\", \"BF\"];\n\tint neighborhood_type <- 8 among:[4,8];\n\tfloat obstacle_rate <- 0.1 min: 0.0 max: 0.9;\n\tint grid_size <- 50 min: 5 max: 100;\n\t\n\tpoint source;\n\tpoint goal;\n\tpath the_path;\n\tinit toto {    \n\t\tif (scenario = \"wall\") {\n\t\t\task cell {is_obstacle <- false;}\n\t\t\tint x_max <- round(grid_size * 2/3);\n\t\t\tloop i from: 2 to:x_max {\n\t\t\t\tcell[i, 3].is_obstacle <- true;\n\t\t\t\tcell[i, grid_size - 4].is_obstacle <- true;\n\t\t\t}\n\t\t\tloop i from: 3 to: grid_size - 4 {\n\t\t\t\tcell[x_max, i].is_obstacle <- true;\n\t\t\t}\n\t\t\task cell {color <- is_obstacle ? #black : #white;}\n\t\t}\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t} \n\t\n\treflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}\n}\n\ngrid cell width: grid_size height: grid_size neighbors: neighborhood_type optimizer: algorithm{\n\tbool is_obstacle <- flip(0.1);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\n\t\n\nexperiment goto_grid type: gui {\n\t\n\tparameter var:scenario;\n\tparameter var:algorithm;\n\tparameter var:neighborhood_type;\n\tparameter var:obstacle_rate;\n\tparameter var:grid_size;\n\t\n\tfloat minimum_cycle_duration <- 0.5#s;\n\t\n\t\n\toutput {\n\t\tdisplay objects_display type: 2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tgraphics \"elements\" {\n\t\t\t\tdraw circle(1) color: #green at: source border: #black;\n\t\t\t\tdraw circle(1) color: #red at: goal  border: #black;\n\t\t\t\tloop v over: the_path.vertices {\n\t\t\t\t\tdraw triangle(0.5) color: #yellow border: #black at: point(v);\n\t\t\t\t}\n\t\t\t\tloop s over: the_path.segments {\n\t\t\t\t\tdraw s color: #red ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Generate a GAML model for computing and visualizing shortest paths on a grid using four different algorithms (A*, Dijkstra, JPS, BF) with adjustable neighborhood types.", "gaml_code": "/**\n* Name:  Computation of the shortest path on a Grid of Cells\n* Author:  Patrick Taillandier\n* Description: Model to represent how to compute the shortest path from a grid (with the 4 algorithms).\n* Tags: grid, obstacle, shortest_path\n*/\n\nmodel Grid\n\nglobal {\n\t\n\t/*4 alogirithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https://harablog.wordpress.com/2011/09/07/jump-point-search/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tfile dem <- file(\"../includes/vulcano_50.asc\");\n\tgeometry shape <- envelope(dem);\n\tstring algorithm <- \"Dijkstra\" among: [\"A*\", \"Dijkstra\"];\n\tint neighborhood_type <- 8 among:[4,8];\n\tpoint source;\n\tpoint goal;\n\tpath the_path;\n\t\n\tfloat height_factor <- 0.05; // used to reduced the height displayed\n\t\n\tinit {  \n\t\task cell {grid_value <- grid_value * 5;}  \n\t\tfloat max_val <- cell max_of (each.grid_value);\n\t\task cell {\n\t\t\tfloat val <- 255 * (1 - grid_value / max_val);\n\t\t\tcolor <- rgb(val, val,val);\n\t\t}\n\t\tsource <- (one_of (cell)).location;\n\t\tgoal <- (one_of (cell)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell as_map (each::each.grid_value)), source, goal);\t\n\t\t}\n\t} \n\t\n\treflex compute_path {\n\t\tsource <- (one_of (cell)).location;\n\t\tgoal <- (one_of (cell)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell as_map (each::each.grid_value)), source, goal);\t\n\t\t}\n\t}\n}\n\ngrid cell file: dem neighbors: neighborhood_type optimizer: algorithm;\n\n\t\n\nexperiment goto_grid type: gui {\n\t\n\t\n\tparameter var:algorithm;\n\tparameter var:neighborhood_type;\n\t\n\tfloat minimum_cycle_duration <- 300 #msec;\n\t\n\toutput synchronized: true { // synchronized to make sure that we do not run into issue #3737\n\t\tdisplay objects_display type: 3d antialias:false background:#lightgrey axes:false{ \n\t\t\tcamera 'default' location: {24.6963,59.7992,64.0919} target: {25.0,25.0,0.0};\n\t\t\tgrid cell border: #black elevation:grid_value*height_factor triangulation:true;\n\t\t\tgraphics \"elements\" {\n\t\n\t\t\t\tloop s over: the_path.segments {\n\t\t\t\t\tdraw s color: #red at:{s.location.x, s.location.y, (cell overlapping s + cell(s.centroid).neighbors) max_of each.grid_value*height_factor + 0.05} ;\n\t\t\t\t}\n\t\t\t\tloop v over: the_path.vertices {\n\t\t\t\t\tdraw triangle(0.5) color: #yellow border: #black at: {point(v).x, point(v).y, (cell(point(v)).neighbors) max_of each.grid_value*height_factor + 0.05};\n\t\t\t\t}\n\t\t\t\tdraw circle(1) color: #green at: {source.x, source.y, (cell(source).neighbors max_of (each.neighbors max_of each.grid_value))*height_factor} border: #black;\n\t\t\t\tdraw circle(1) color: #red at: {goal.x, goal.y, (cell(goal).neighbors max_of (each.neighbors max_of each.grid_value))*height_factor}  border: #black;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a hexagonal grid simulation model for a GUI experiment with adjustable orientation and visualization of neighborhood relationships.", "gaml_code": "/**\n* Name: HexagonalGrid\n* Author: Patrick Taillandier\n* Description: \n* Tags: grid, hexagon\n*/\n\nmodel HexagonalGrid\n\nglobal {\n\tstring orientation <- \"horizontal\" among: [\"horizontal\", \"vertical\"];\t\n\t\n\tinit {\n\t\task cell {color <- #white;}\n\t}\n\treflex show_neighborhood {\n\t\task cell {color <- #white;}\n\t\task one_of(cell) {\n\t\t\tcolor <- #red;\n\t\t\task neighbors {\n\t\t\t\tcolor <- #green;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";\n\n\nexperiment hexagonal type: gui{\n\tparameter var:orientation;\n\tfloat minimum_cycle_duration <- 0.5#s;\n\toutput  synchronized:true{\n\t\tdisplay view type: 2d{\n\t\t\tgrid cell border: #black ;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that demonstrates various topological transformations on 2D and 3D geometries, including discretization, triangulation, voronoi diagrams, and sub-geometry extraction.", "gaml_code": "/**\n* Name: Discretization of Topology\n* Author: Patrick Taillandier\n* Description: A model which shows how to use the different convert topologies operators : to_square, to_rectangle, points_on, triangulate, voronoi.\n* Tags: topology, spatial_computation, spatial_transformation\n*/\n\nmodel discretization\n\nglobal \n{\n\t//Geometry that will be used for each display : a circle\n\tgeometry init_geom <- circle (35);\n\tgeometry init_line <- line([{10,50}, {50, 20}, {70, 80}]);\n}\n\nexperiment to_squares type: gui {\n\toutput {\n\t\t//Display that will show a circle converted in squares\n\t\tdisplay decretization_squares type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into squares of 5.0 \n\t\t\t\tloop g over: to_squares(init_geom, 5.0) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in squares overlapping the shape\n\t\tdisplay squares_overlapping type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"squares\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into rectangles of 5.0 and keep the squares going out of the borders of the circle but still overlapping it\n\t\t\t\tloop g over: to_squares(init_geom,5.0, true) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in squares inside the shape\n\t\tdisplay squares_inside type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"squares\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into squares of 5.0 and remove the squares going out of the borders of the circle\n\t\t\t\tloop g over: to_squares(init_geom, 5.0, false) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\t\t\n\t}\n}\n\t\nexperiment to_rectangles type: gui {\n\toutput {\n\t\t//Display that will show a circle converted in rectangles with a size of 10.0 and 5.0\n\t\tdisplay decretization_rectangles type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: to_rectangles(init_geom, {10.0,5.0}) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles forming a grid of 15 cols and 20 rows\n\t\tdisplay decretization_rectangles_grid type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: to_rectangles(init_geom, 15,20) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles overlapping the shape\n\t\tdisplay rectangles_overlapping type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"rectangles\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into rectangles of 5.0 and keep the rectangles going out of the borders of the circle but still overlapping it\n\t\t\t\tloop g over:  to_rectangles(init_geom, {10.0,5.0}, true){\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles inside the shape\n\t\tdisplay rectangles_inside type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"rectangles\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into rectangles of 5.0 and remove the rectanges going out of the borders of the circle\n\t\t\t\tloop g over: to_rectangles(init_geom, {10.0,5.0}, false) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t}\n}\n\n\nexperiment point_on_contours type: gui {\n\toutput{\n\t\t//Display that will show a circle with points on its perimeter every 10.0\n\t\tdisplay points_on_contours type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: points_on(init_geom,10.0) {\n\t\t\t\t\tdraw circle(2) at: g color: #red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t}\t\n}\nexperiment triangles_voronoi type: gui {\n\toutput{\n\t\t//Display that will show a circle triangulated\n\t\tdisplay triangles type: 2d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"triangles\" transparency: 0.5{\n\t\t\t\tloop g over: triangulate(init_geom, 0.01) {\n\t\t\t\t\tdraw g color: rnd_color(255);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\t\n\t\tdisplay voronoi type: 2d{\n\t\t\t//Creates a voronoi diagram from the points given and display them\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: voronoi([{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}]) {\n\t\t\t\t\tdraw g color: #red border: #black;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics \"points\" {\n\t\t\t\tloop pt over: [{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}] {\n\t\t\t\t\tdraw circle(2) at: pt color: #black;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\t\n\t\t\n\t}\t\n}\t\nexperiment to_sub_geometries type: gui {\n\toutput{\n\t\tdisplay to_sub_geometries_polygon type: 3d{\n\t\t\tgraphics \"init_geom\" {draw init_geom color: #black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into 3 sub-geometries representing respectively 30%, 50% and 20% of the init geom using square of 0.5meters size\n\t\t\t\tloop g over: to_sub_geometries(init_geom,[0.3, 0.5, 0.2], 0.5) {\n\t\t\t\t\tdraw g color: rnd_color(255) border:#black;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\tdisplay to_sub_geometries_lines type: 3d{\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\t//Convert the initial line into 3 sub-geometries representing respectively 30%, 50% and 20% of the line\n\t\t\t\tloop g over: to_sub_geometries(init_line,[0.3, 0.5, 0.2]) {\n\t\t\t\t\tdraw g + 0.5 color: rnd_color(255) border: #black;\n\t\t\t\t} \n\t\t\t} \n\t\t\tgraphics \"init_line\" {draw init_line color: #black;}\n\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a model that demonstrates spatial interpolation using IDW (Inverse Distance Weighting) on a 50x50 grid, where cell values are calculated based on both the shape and centroid of each cell. Include two displays: one showing points with their corresponding values and another displaying the interpolated map.", "gaml_code": "/**\n* Name: Spatial Interpolation\n* Author: Patrick Taillandier\n* Description: A model which shows how to use spatial interpolation\n* Tags: topology, grid, spatial_computation\n*/\n\nmodel spatialinterpolation\n\nglobal {\n\tmap<point, float> pts;\n\tfloat max_val; \n\tfloat min_val ; \n\t\n\t//power parameter\n\tint power <- 2;\n\t\n\t//cell properties\n\tint nb_rows <- 50;\n\tint nb_columns <- 50;\n\t\n\tinit {\n\t\t//creation of random point for demo puporse\n\t\tloop times: 50 {\n\t\t\tpoint pt <- any_location_in(world);\n\t\t\tpts[pt] <-pt.x ^2 + pt.y ^2;\n\t\t}\n\t\t\n\t\t//computation of the min and max values of the points (just use to define the color of the cells).\n\t\tmax_val <- max(pts.values);  \n\t\tmin_val <- min(pts.values); \n\t\t\n\t\t//computation of the value for each cell\n\t\tmap<cell_shape, float> results_shape <- map<cell_shape, float>(IDW(cell_shape, pts, power));\n\t\t\n\t\t//setting of the value and color of each cell\n\t\task cell_shape {\n\t\t\tval <- results_shape[self];\n\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\tcolor <- rgb(val_col,0,0);\n\t\t}\n\t\t\n\t\t//same computation, but in this case, we consider only the centroid (location) of the cell for the computation of the distance\n\t\tmap<point, float> results_location <- map<point, float>(IDW(cell_location collect each.location, pts, power));\n\t\t\t\n\t\task cell_location {\n\t\t\tval <- results_location[self.location];\n\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\tcolor <- rgb(val_col,0,0);\n\t\t}\n\t}\n}\n\n//cells where the distance is based on the shape of the cell (min distance between the rectangle and the points)\ngrid cell_shape width: nb_columns height: nb_rows {\n\tfloat val;\n}\n\n//cells where the distance is based on the centroid of the cell (distance between the centroid and the points)\ngrid cell_location width: nb_columns height: nb_rows {\n\tfloat val;\n}\n\n\nexperiment spatialinterpolation type: gui {\n\tparameter \"nb of columns\" var: nb_columns;\n\tparameter \"nb of rows\" var: nb_rows;\n\tparameter \"power parameter\" var: power;\n\toutput {\n\t\tdisplay map_shape type:2d{\n\t\t\tgrid cell_shape;\n\t\t\tgraphics \"points\" {\n\t\t\t\tloop pt over: pts.keys {\n\t\t\t\t\tfloat val <- pts[pt];\n\t\t\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\t\t\tdraw circle(1) at: pt color: rgb(val_col,0,0) border: #white;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay map_location type:2d{\n\t\t\tgrid cell_location;\n\t\t\tgraphics \"points\" {\n\t\t\t\tloop pt over: pts.keys {\n\t\t\t\t\tfloat val <- pts[pt];\n\t\t\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\t\t\tdraw circle(1) at: pt color: rgb(val_col,0,0) border: #white;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a model that demonstrates various spatial queries (overlapping, partially overlapping, intersecting, inside, touching, crossing, covering, closest to, farthest to) on different types of geometric agents (polygon, polyline, point) in a 2D environment. The user can select the type of query and an agent will be highlighted in magenta if it matches the query.", "gaml_code": "/**\n* Name: Spatialqueries\n* Author: Patrick Taillandier\n* Description: A model which shows how to use spatial queries - in magenta the source geometry, in red the agents concerned by the spatial query\n* Tags: topology, spatial_computation, spatial_queries\n*/\n\nmodel Spatialqueries\n\nglobal {\n\t/*\n\t * overlapping: the geometries have at least one point in common with the source geometry\n\t * inside: the geometries are completely within the source geometry (no touching edges)\n\t * touhcing: the geometries only touch edges of the source geometry and do not overlap it in any way\n\t * crossing: the geometries do more than touch the source geometry, they actually overlap edges of it\n\t * covering: the geometries completely cover the source geometry (no touching edges)\n\t * closest_to: the geometry closest to the source geometry\n\t * farthest_to: the geometry farthest to the source geometry\n\t */\n\tstring type_query <- \"overlapping\" among: [\"overlapping\", \"partially_overlapping\", \"intersecting\", \"inside\", \"touching\", \"crossing\", \"covering\", \"closest_to\", \"farthest_to\"] ;\n\tagent_base selected_agent;\n\t\n\tinit {\n\t\tcreate polygon_agent number:10 {\n\t\t\tshape <- square(20);\n\t\t}\n\t\t\n\t\tcreate polyline_agent number:10 {\n\t\t\tshape <- line([any_location_in(world),any_location_in(world)]);\n\t\t}\n\t\t\n\t\tcreate point_agent number: 10 {\n\t\t\tshape <-any_location_in(world);\n\t\t}\n\t\tselected_agent <- one_of (polygon_agent);\n\t\tdo apply_query;\n\t}\n\t\n\taction change_agent {\n\t\tselected_agent <- (polygon_agent + polyline_agent + point_agent) closest_to #user_location; \t\n\t\tdo apply_query;\n\t}\n\t\n\taction apply_query {\n\t\tlist<agent_base> agents_concerned;\n\t\tswitch type_query {\n\t\t\tmatch \"overlapping\" {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) overlapping selected_agent;\n\t\t\t}\n\t\t\tmatch \"partially_overlapping\"  {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) partially_overlapping selected_agent;\t\t\t\t\n\t\t\t}\n\t\t\tmatch \"intersecting\" {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) intersecting selected_agent;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tmatch \"inside\" {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) inside selected_agent;\n\t\t\t}\n\t\t\tmatch \"touching\" {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) touching selected_agent;\n\t\t\t}\n\t\t\tmatch \"crossing\" {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) crossing selected_agent;\n\t\t\t}\n\t\t\tmatch \"covering\" {\n\t\t\t\tagents_concerned <- (polygon_agent + polyline_agent + point_agent) covering selected_agent;\n\t\t\t}\n\t\t\tmatch \"closest_to\" {\n\t\t\t\tagents_concerned <- [polygon_agent closest_to selected_agent,polyline_agent closest_to selected_agent,point_agent closest_to selected_agent];\n\t\t\t}\n\t\t\tmatch \"farthest_to\" {\n\t\t\t\tagents_concerned <- [polygon_agent farthest_to selected_agent,polyline_agent farthest_to selected_agent,point_agent farthest_to selected_agent];\n\t\t\t}\n\t\t}\n\t\task polygon_agent +  polyline_agent + point_agent{\n\t\t\tis_concerned <- false;\n\t\t}\n\t\task agents_concerned {\n\t\t\tis_concerned <- true;\n\t\t}\n\t}\n}\nspecies agent_base {\n\tbool is_concerned <- false;\n\t\n}\nspecies polygon_agent parent:agent_base {\n\trgb color <- #gray;\n\taspect default {\n\t\tif (self = selected_agent) {\n\t\t\t\n\t\t\tdraw shape + 1.0 color: #magenta; \n\t\t}\n\t\tdraw shape color: is_concerned ? #red : color border: #black; \n\t}\n}\n\nspecies polyline_agent parent:agent_base {\n\trgb color <- #black;\n\taspect default {\n\t\tif (self = selected_agent) {\n\t\t\tdraw shape + 0.5 color: #magenta; \n\t\t}\n\t\tdraw shape color: is_concerned ? #red : color; \n\t}\n}\n\nspecies point_agent parent:agent_base {\n\trgb color <- #green;\n\taspect default {\n\t\tif (self = selected_agent) {\n\t\t\tdraw circle(1.5) color: #magenta; \n\t\t}\n\t\tdraw circle(1.0) color:is_concerned ? #red : color border: #black; \n\t}\n}\n\nexperiment Spatialqueries type: gui {\n\tparameter Query var: type_query on_change: {ask simulation{do apply_query;} do update_outputs();};\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies polygon_agent;\n\t\t\tspecies point_agent;\n\t\t\tspecies polyline_agent;\t\n\t\t\tevent #mouse_down  {ask simulation{do change_agent;}}\n\t\t}\n\t}\n}"}
{"prompt": "Create a GeoMesa model that allows interactive manipulation of simplification tolerance and buffer value for visualizing their impact on 3D shapes.", "gaml_code": "/***\n* Name: Tolerance\n* Author: A. Drogoul\n* Description: Allows a live manipulation of the tolerance used in simplifications and buffer value, and demonstrates their impact visually\n***/\n\nmodel Tolerance\n\nglobal {\n\t\n\tint tolerance <- 0;\n\tint buffer <- 0;\n\tfile complex <- file(\"../gis/water_body.shp\");\n\tgeometry shape <- envelope(complex);\n\t\n\tinit {\n\t\tcreate shapes from: complex ;\n\t}\n}\n\n\nspecies shapes;\n\nexperiment \"Simplify this ! \" {\n\t\n\tparameter \"Simplification tolerance\" category: \"Change the value and observe the visual result\" var:tolerance min: 0 max: 800 step: 1 {\n\t\tdo update_outputs;\n\t}\n\t\n\tparameter \"Buffer value\" category: \"Change the value and observe the visual result\" var:buffer min: -100 max: 100 step: 1  {\n\t\tdo update_outputs;\n\t}\n\t\n\tuser_command \"Close the simulation\"  category:\"Change the value and observe the visual result\" color: #red {\n\t\tdo die;\n\t}\n\t\n\t\n\t\n\toutput {\n\t\tlayout #split consoles: false tray: false tabs: false controls: false editors: false toolbars: false navigator: false;\n\t\tdisplay my_display type:3d axes: false { \n\t\t\tspecies shapes {\n\t\t\t\tdraw shape color: #red;\n\t\t\t}\n\t\t\tspecies shapes {\n\t\t\t\tdraw simplification(shape, tolerance) + buffer color: #blue;\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\t\n}"}
{"prompt": "Create a GAML model that demonstrates and compares different spatial operators (e.g. closest_to, at_distance, neighbors_at) on a grid topology, allowing users to interactively select and visualize the results of each operator.", "gaml_code": "/**\n* Name: Spatial Operators\n* Author: Patrick Taillandier\n* Description: A model which shows how to use spatial operator, allowing the user to change the parameter operator in the \n* \texperiment to test the different operators and see the results\n* Tags: topology, grid\n*/\n\nmodel gridfilter\n\nglobal {\n\tmap<string,map<dummy,rgb>> theDummies;\n\tmap<string,map<cell,rgb>> theCells;\n \tstring parameter_operator <-\"closest_to\" among:[\"closest_to\",\"at_distance\",\"neighbors_at\",\"distance_to\",\"path_to\",\"cluster_distance\",\"cluster_hierarchical\"];\n\tinit {\n\t\t\n\t\t//Create the agents\n\t\tdo create_dummy_agents;\n \n\n\t\t//Different actions to test the operators\n\t\tdo test_agents_at_distance;\n\t\tdo test_distance_to;\n\t\tdo test_neighbors_at;\n\t\tdo test_path_to;\n\t\tdo test_simple_clustering_by_distance;\n\t\tdo test_hierarchical_clustering;\n\t\tdo test_agent_closest_to; \t\n\t}  \n\t\n\taction test_agent_closest_to {\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\tadd [dummy(8)::#yellow] at:\"closest_to\" to:theDummies;\n\t\tadd #red at:dummy closest_to (dummy(8)) to:theDummies[\"closest_to\"];\n\t\t\n\t\t\n\t\tadd [cell(40)::#yellow] at:\"closest_to\" to:theCells;\n\t\tadd #red at:cell closest_to (cell(40)) to:theCells[\"closest_to\"];\n\t}\n\taction test_agents_at_distance {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\task dummy(8)\n\t\t{\n\t\t\tadd [self::#yellow] at:\"at_distance\" to:theDummies;\n\t\t\tloop a_dummy over: agents_at_distance(30) of_species dummy\n\t\t\t{\t\n\t\t\t\tadd #red at:a_dummy to:theDummies[\"at_distance\"];\n\t\t\t}\n\t\t}\n\t\task cell(40)\n\t\t{\n\t\t\tadd [self::#yellow] at:\"at_distance\" to:theCells;\n\t\t\tloop a_cell over: agents_at_distance(10) of_species cell\n\t\t\t{\t\n\t\t\t\tadd #red at:a_cell to:theCells[\"at_distance\"];\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction test_neighbors_at {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\t//The operator neighbors_at gives the same results that neighbors_of( an_agent, a_distance )\n\t\t\n\t\tadd [dummy(8)::#yellow] at:\"neighbors_at\" to:theDummies;\n\t\tloop a_dummy over: dummy(8) neighbors_at 30\n\t\t{\t\n\t\t\tadd #red at:a_dummy to:theDummies[\"neighbors_at\"];\n\t\t}\n\t\tadd [cell(40)::#yellow] at:\"neighbors_at\" to:theCells;\n\t\tloop a_cell over: cell(40) neighbors_at 20\n\t\t{\t\n\t\t\tadd #red at:a_cell to:theCells[\"neighbors_at\"];\n\t\t}\n\t}\n\t\n\taction test_distance_to {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\t//The operator distance_to gives the same results that the operator topology distance_between[an_agent_A,an_agent_B]\n\t\tadd [dummy(8)::#yellow] at:\"distance_to\" to:theDummies;\n\t\tadd #red at:dummy(5) to:theDummies[\"distance_to\"];\n\t\t\n\t\tadd [cell(40)::#yellow] at:\"distance_to\" to:theCells;\n\t\tadd #red at:cell(27) to:theCells[\"distance_to\"];\n\t}\n\t\n\taction test_path_to {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\t//The operator distance_to gives the same results that the operator topology path_between[an_agent_A,an_agent_B]\n\t\tadd [dummy(8)::#yellow] at:\"path_to\" to:theDummies;\n\t\tadd #red at:dummy(9) to:theDummies[\"path_to\"];\n\t\t\n\t\tadd [cell(40)::#yellow] at:\"path_to\" to:theCells;\n\t\tadd #red at:cell(28) to:theCells[\"path_to\"];\n\t}\n\taction test_simple_clustering_by_distance \n\t{\n\t\t//Can be used for other topologies by adding using(topology(cell)) for example\n\t\t\n\t\tlist<list<dummy>> clusteredDummies <- list<list<dummy>>(dummy simple_clustering_by_distance 30);\n\t\tloop a_list over: clusteredDummies\n\t\t{\n\t\t\trgb colorList <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\tloop a_dummy over: a_list\n\t\t\t{\n\t\t\t\tif(!(theDummies contains_key \"cluster_distance\") or length(theDummies[\"cluster_distance\"])=0)\n\t\t\t\t{\n\t\t\t\t\tadd map<dummy,rgb>([a_dummy::colorList]) at:\"cluster_distance\" to:theDummies;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd colorList at:a_dummy to:theDummies[\"cluster_distance\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction test_hierarchical_clustering {\n\t\t//Can be used for other topologies by adding using(topology(cell)) for example\n\t\tlist<list<dummy>> clusteredDummies <- list<list<dummy>>(dummy hierarchical_clustering 10);\n\t\t\n\t\tloop a_list over: clusteredDummies\n\t\t{\n\t\t\trgb colorList <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\tloop a_dummy over: a_list\n\t\t\t{\n\t\t\t\tif(!(theDummies contains_key \"cluster_hierarchical\") or length(theDummies[\"cluster_hierarchical\"])=0)\n\t\t\t\t{\n\t\t\t\t\tadd map<dummy,rgb>([a_dummy::colorList]) at:\"cluster_hierarchical\" to:theDummies;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd colorList at:a_dummy to:theDummies[\"cluster_hierarchical\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction create_dummy_agents {\n\t\tcreate dummy with: [location :: {5,5}];\n\t\tcreate dummy with: [location :: {8,9}];\n\t\tcreate dummy with: [location :: {14,6}];\n\t\tcreate dummy with: [location :: {35,55}];\n\t\tcreate dummy with: [location :: {25,75}];\n\t\tcreate dummy with: [location :: {56,80}];\n\t\tcreate dummy with: [location :: {10,70}];\n\t\tcreate dummy with: [location :: {80,8}];\n\t\tcreate dummy with: [location :: {34,78}];\n\t\tcreate dummy with: [location :: {67,32}];\n\t\tloop i from: 0 to: length(dummy) - 1 {\n\t\t\task dummy[i] {id <- string(i);}\n\t\t}\n\t}\n\t\n}\n\ngrid cell width: 10 height: 10 neighbors: 4{\n\trgb color <- #green;\n}\n\nspecies dummy {\n\tstring id;\n\taspect default {\n\t\tdraw circle(2) color: #yellow;\n\t\tdraw id size: 6 color: #black;\n\t}\n}\nexperiment topology_test type: gui {\n\t/** Insert here the definition of the input and output of the model */\n\tparameter \"Operator\" var: parameter_operator;\n\toutput {\n\t\t\n\t\tdisplay Continuous_Environment  \n\t\t{\n\t\t\tgraphics cell\n\t\t\t{\n\t\t\t\tloop a_key over: theCells[parameter_operator].pairs {\n\t\t\t\t\tdraw a_key.key at:a_key.key.location color: theCells[parameter_operator][a_key.key] ;\n\t\t\t\t}\n\t\t\t\tloop a_cell over: cell-theCells[parameter_operator].keys\n\t\t\t\t{\n\t\t\t\t\tdraw a_cell at:a_cell.location color: #green ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Display a line between the two chosen cell for the distance_to operator\n\t\t\t\tif(parameter_operator=\"distance_to\")\n\t\t\t\t{\n\t\t\t\t\tgeometry aLine <- line([theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location]) +1.2;\n\t\t\t\t\tdraw (aLine) color:#silver;\n\t\t\t\t\tdraw string(distance_to (theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #silver;\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Display a path between the two chosen cell for the path_to operator\n\t\t\t\t\tif(parameter_operator=\"path_to\")\n\t\t\t\t\t{\n\t\t\t\t\t\t\tpath aPath <- theCells[parameter_operator].keys[0] path_to theCells[parameter_operator].keys[1].location;\n\t\t\t\t\t\t\tloop eg over: aPath.edges\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdraw (geometry(eg)+1.2) color:#silver;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics dummy\n\t\t\t{\n\t\t\t\tloop a_key over: theDummies[parameter_operator].pairs {\n\t\t\t\t\tdraw circle(2) at:a_key.key.location color: theDummies[parameter_operator][a_key.key] ;\n\t\t\t\t\tdraw a_key.key.id at:a_key.key.location size: 6 color: #black;\t\n\t\t\t\t}\n\t\t\t\tloop a_dummy over: dummy-theDummies[parameter_operator].keys\n\t\t\t\t{\n\t\t\t\t\tdraw circle(2) at:a_dummy.location color: #grey ;\n\t\t\t\t\tdraw a_dummy.id at:a_dummy.location size: 6 color: #black;\t\n\t\t\t\t}\n\t\t\t\t//Display a line between the two chosen dummies for the distance_to operator\n\t\t\t\tif(parameter_operator=\"distance_to\")\n\t\t\t\t{\n\t\t\t\t\tgeometry aLine <- line([theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location]) +1.2;\n\t\t\t\t\tdraw (aLine) color:#pink;\n\t\t\t\t\tdraw string(distance_to (theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #pink;\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Display a path between the two chosen dummies for the path_to operator\n\t\t\t\t\tif(parameter_operator=\"path_to\")\n\t\t\t\t\t{\n\t\t\t\t\t\t\tpath aPath <- theDummies[parameter_operator].keys[0] path_to theDummies[parameter_operator].keys[1].location;\n\t\t\t\t\t\t\tloop eg over: aPath.edges\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdraw (geometry(eg)+1.2) color:#pink;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Design a NetLogo model that simulates spatial evolution of agents using shapefiles for initial and background environments, incorporating features such as agent growth, rotation, crossover, and death based on geometric constraints.", "gaml_code": "/**\n* Name: Spatial Operators\n* Author: Patrick Taillandier\n* Description: A model which shows how to use spatial operators like rotated_by, scaled_by and convex_hull\n* Tags: topology, shapefile, spatial_computation, spatial_transformation\n*/\nmodel example_spatial_operators\n\nglobal {\n\t// Parameters for the shapefiles\n\tfile shape_file_name_init  <- file('../gis/init.shp') ;\n\tfile shape_file_name_background  <- file('../gis/background.shp');\n\t\n\t//Parameters for the agents\t\t\n\tfloat dying_size min: 100.0  <-10000.0 ; \n\tfloat crossover_size min: 100.0  <- 1000.0;\n\tfloat minimum_size min: 100.0 <- 500.0; \n\tint time_wthout_co min: 1 <- 7;\n\tfloat speed min: 1.0  <- 10.0; \n\tfloat crossover_rate min: 0.1  <- 0.95; \n\tfloat scaling_factor min: 1.001 <- 1.05;\n\tfloat angle_rotation_max min: 0.0 <- 45.0;\n\tint nb_partners_max min: 1  <- 1;\n\tint max_side_size min: 1 <- 5;  \n\tint background_size_side min: 20 max: 100 <- 80 ;\n\t\n\t// Environment\n\tgeometry shape <- envelope(shape_file_name_background);\n\t\n\n\treflex stop when: empty ( object ) {\n\t\tdo pause;\n  \t} \n\n}\n\nspecies object topology: topology(shape_file_name_init) {\n\trgb color <- rgb ( [ rnd ( 255 ) , rnd ( 255 ) , rnd ( 255 ) ]);\n\tpoint location_new_Ag <- nil;\n\trgb color_new_Ag <- nil;\n\tint nb_last_rep <- 0;\n\t\t\n\t//Reflex making the shape of the agent growing and rotate it randomly\n\treflex evolve {\n\t\tnb_last_rep <- nb_last_rep + 1;\n\t\tshape <- shape scaled_by scaling_factor;\n\t\tshape <- shape rotated_by ((rnd ( 100 * angle_rotation_max))/ 100.0);\t\t\n\t}\n\t\n\t//Make the agent move, kill it if is area is greater than the dying size or intersecting contours of the world\n\treflex move {\n\t\tlocation <- location + { speed * ( 1 - rnd ( 2 ) ) , speed * ( 1 - rnd ( 2 ) ) };\n\t\tif ( (shape.area > dying_size) or (shape intersects world.shape.contour)) {\n\t\t\tdo die; \n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\t//Reflex to change the shape of the agent intersects an other agent and create a convex hull of the shape of the new agent resulting in the intersection of the shapes of the agent and an other one\n\treflex crossover when: ( shape.area > crossover_size ) and ( nb_last_rep > time_wthout_co ) { \n\t\tint nb_partners  <- 0;\n\t\tlist<object> list_people <- shuffle ( object );\n\t\tloop p over: list_people {\n\t\t\tif ( p != self ) and ( nb_partners <= nb_partners_max ) and (rnd ( 100 ) < ( crossover_rate * 100 ) ) and ( (p.shape).area > crossover_size ) and ( p . nb_last_rep > time_wthout_co ) and (shape intersects p.shape) {\n\t\t\t\tnb_partners <- nb_partners + 1;\n\t\t\t\tgeometry new_ag <- (shape inter p.shape);\n\t\t\t\tif ( new_ag != nil ) and ( new_ag.area > minimum_size ) {\n\t\t\t\t\tnb_last_rep <- 0;\n\t\t\t\t\task p {\n\t\t\t\t\t\tnb_last_rep <- 0;\n\t\t\t\t\t}\n\t\t\t\t\tcreate object  {\n\t\t\t\t\t\tcolor <- (myself.color + p.color) / 2;\n\t\t\t\t\t\tshape <-  convex_hull(new_ag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\taspect geometry {\n\t\tdraw shape color: color border:color-20;\n\t}\n}\n\n\n\nexperiment example_spatial_operators type: gui {\n\tparameter 'Path of shapefile to load for the initial agent:' var: shape_file_name_init  category: 'GIS specific' ;\n\tparameter 'Path of shapefile to load for the background:' var: shape_file_name_background category: 'GIS specific';\n\tparameter 'Size (area) from which an agent dies:' var: dying_size min: 100.0  category: 'Population'; \n\tparameter 'Min size (area) for crossover:' var:crossover_size category: 'Population';\n\tparameter 'Minimum size (area) of a agent produced by a crossover:' var:minimum_size category: 'Population';\n\tparameter 'Number of steps without crossing-over for an agent:' var:time_wthout_co category: 'Population';\n\tparameter 'Agent deplacement speed:' var:speed category: 'Population' ; \n\tparameter 'Rate of crossover' var:crossover_rate category: 'Population'; \n\tparameter 'Scaling factor for agent geometry (at each step):' var:scaling_factor category: 'Population';\n\tparameter 'Max rotation angle for agent geometry (at each step):' var:angle_rotation_max category:'Population';\n\tparameter 'Max number of possible partners for crossing-overs (per step)' var:nb_partners_max category: 'Population' ;\n\tparameter 'Size max of the initiale side of an agent:' var:max_side_size category: 'Population'; \n\tparameter 'Size background side:' var: background_size_side category: 'Population' ;\n\n\toutput {\n\t\tdisplay space_display {\n\t\t\tspecies object aspect: geometry;\n\t\t}\n\t}\n}"}
{"prompt": "Design a spatial analysis model that computes the Moran's I index for various grid sizes and initialization methods, allowing users to visualize the results on a 2D map.", "gaml_code": "/**\n* Name: moran_Index\n* Author: Patrick Taillandier\n* Description: Computes the moran index of geometries\n* Tags: spatial, distance\n*/\n\nmodel moranIndex\n\nglobal {\n\tstring grid_spatial_init <- \"random\" among: [\"random\", \"checkerboard\", \"blocks\"];\n\tstring weight_type <- \"neighbors\" among: [\"overlapping\", \"neighbors\", \"distance\"];\n\tint grid_size <- 20;\n\t\n\tlist<float> vals;\n\tmatrix<float> weights;\n\t\n\tfloat I;\n\t\n\tinit {\n\t\task cell {\n\t\t\tswitch grid_spatial_init {\n\t\t\t\tmatch \"random\" {color <- flip(0.5) ? #white: #black;}\n\t\t\t\tmatch \"checkerboard\" {color <- even(grid_x) ? (even(grid_y) ? #white: #black) : (not even(grid_y) ? #white: #black) ;}\n\t\t\t\tmatch \"blocks\" {color <- grid_x < grid_size/2 ? #white: #black;}\n\t\t\t}\t\n\t\t}\n\t\tvals <- cell collect (each.color = #white ? 0.0 : 1.0);\n\t\tweights <- 0.0 as_matrix {length(vals), length(vals)};\n\t\task cell {\n\t\t\tswitch weight_type {\n\t\t\t\tmatch \"neighbors\" {\n\t\t\t\t\task self.neighbors {\n\t\t\t\t\t\tweights[int(self), int(myself)] <- 1.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatch \"overlapping\" {\n\t\t\t\t\task cell overlapping self {\n\t\t\t\t\t\tif self != myself {\n\t\t\t\t\t\t\tweights[int(self), int(myself)] <- 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatch \"distance\" {\n\t\t\t\t\task cell {\n\t\t\t\t\t\tif self != myself {\n\t\t\t\t\t\t\tweights[int(self), int(myself)] <- 1/(self distance_to myself);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tI <- moran(vals, weights);\n\t\twrite \"moran I: \" + I;\n\t}\n}\ngrid cell width: grid_size height: grid_size neighbors: 4;\n\nexperiment \"Moran\" type: gui {\n\tparameter \"grid size: \" var: grid_size min: 2 max: 100;\n\tparameter \"Type of spatial Initialization of grid value: \" var: grid_spatial_init;\n\tparameter \"Weight type used for the computation: \" var: weight_type ;\n\t\n\toutput {\n\t\tdisplay map type:2d antialias:false {\n\t\t\tgrid cell border: #red;\n\t\t\tgraphics \"moran\" {\n\t\t\t\tdraw \"I = \" + (I with_precision 3) color: #green font:font(\"Helvetica\", 60 * #zoom, #bold);\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates 50 agents (bugs) and saves their attributes to CSV files at cycle 100.", "gaml_code": "/**\n* Name: Save to CSV\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save agents inside a CSV File to reuse it later or to keep it.\n* Tags: save_file, csv\n*/\nmodel SavetoCSV\n\nglobal {\n\tinit { \n\t\t//Create all the agents\n\t\tcreate bug number: 50;\n\t}\n\t//Save the agents bug when the cycle is equals to 100\n\treflex save_bug_attribute when: cycle = 100{\n\t\task bug {\n\t\t\t// save the values of the variables name, speed and size to the csv file; the rewrite facet is set to false to continue to write in the same file\n\t\t\tsave [name,speed, size] to: \"../results/bug.csv\" format:\"csv\" rewrite: false;\n\t\t\t// save all the attributes values of the bug agents in a file. The file is overwritten at every save\n\t\t\tsave bug to: \"../results/bug_agents.csv\" format:\"csv\" rewrite: true;\n\t\t}\n\t\t//Pause the model as the data are saved\n\t\tdo pause;\n\t}\n}\n\n//Species that will be saved\nspecies bug skills:[moving]{\n\tfloat size <- 1.0 + rnd(4) min: 1.0 max: 5.0;\n\tfloat speed <- 1.0 + rnd(4.0);\n\t\n\treflex update_size {\n\t\tint nb_neigh <- length(bug at_distance 20.0);\n\t\tif (nb_neigh > 5) {\n\t\t\tsize <- size + 1;\n\t\t} else {\n\t\t\tsize <- size - 1;\n\t\t}\n\t} \t\n\treflex move {\n\t\tdo wander;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies bug;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that generates a KML file displaying a building and an ant moving around it, using the shapefile 'building.shp' as input.", "gaml_code": "/***\n* Name: exportkml\n* Author: Patrick Taillandier\n* Description: \n* Tags: KML, KMZ, export, save\n***/\n\nmodel exportkml\n\nglobal {\n\tfile shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(shapefile);\n\tdate starting_date <- #now;\n\t\n\t//define the kml variable that will be used to store the geometry to display in the KML/KMZ file\n\tkml kml_export;\n\t\n\tgeometry bounds;\n\t\n\t\n\tinit {\n\t\tcreate building from: shapefile ;\n\t\tbounds <- union(building);\n\t\tcreate bug number: 5 with: [location:: any_location_in(bounds)];\n\t}\n\treflex add_objects_to_kml {\n\t\t\n\t\task building {\n\t\t\t//add a geometry to the kml : add_geometry(kml, geometry, line width, border color, color)\n\t\t\tkml_export <- kml_export add_geometry (shape,2.0,#black,color);\t\n\t\t\t\n\t\t\t//it is also possible to specify the begin date (current_date by default) and the ending date (current_date + step by default)\n\t\t\t//kml_export <- kml_export add_geometry (shape,2.0,#black,color, #now, #now plus_hours 1);\t\n\t\t}\n\t\task bug {\n\t\t\t//add an icon to the kml: add_icon(kml,location,scale,orientation,file) ... like for add_geometry, it is also possible to specify the begin/end date\n\t\t\tkml_export <- kml_export add_icon (location,1.0,heading,\"../includes/full_ant.png\");\n\t\t}\n\t}\n\t\n\treflex end_sim when: cycle = 5 {\n\t\t\n\t\t// export the kml to a kmz/kml file\n\t\tsave kml_export to:\"../results/result.kmz\";\n\t\tdo pause;\n\t}\n}\nspecies bug skills: [moving]{\n\treflex move {\n\t\tdo wander speed: 10.0 bounds: bounds;\n\t}\n\taspect default {\n\t\tdraw file(\"../includes/full_ant.png\") size: 10 ;\n\t}\n}\n\n\nspecies building {\n\trgb color <-rnd_color(155,255);\n\treflex new_color {\n\t\tcolor <- rnd_color(155,255);\n\t}\n\taspect default {\n\t\tdraw shape color: color border: #black;\n\t}\n}\n\nexperiment exportkml type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies building;\n\t\t\tspecies bug;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that saves agents to a GeoJSON file, including 50 buildings with random locations and types.", "gaml_code": "/**\n* Name: Save to GeoJson\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save agents inside a GeoJSon to reuse it later or to keep it.\n* Tags: save_file, geojson\n*/\n\nmodel SavetoGeoJson\n\nglobal {\n\tinit {\n\t\tgeometry free_space <- copy(shape);\n\t\t\n\t\t//creation of the building agents that will be saved\n\t\tcreate building number: 50 {\n\t\t\tshape <- square(5.0);\n\t\t\tlocation <- any_location_in (free_space - 5.0);\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\tsave building to:\"../results/buildings.geojson\" format: \"geojson\";\n\t} \n} \n  \n//species that represent the building agents that will be saved\nspecies building {\n\tstring type <- flip(0.8) ? \"residential\" : \"industrial\";\n\taspect default {\n\t\tdraw shape color: type = \"residential\" ? #gray : #pink;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies building;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that saves agents to a Shapefile for later reuse, including their geometry and attributes.", "gaml_code": "/**\n* Name: Save to Shapefile\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save agents inside a Shapefile to reuse it later or to keep it.\n* Tags: save_file, shapefile\n*/\n\nmodel Savetoshapefile\n\nglobal {\n\tinit {\n\t\tgeometry free_space <- copy(shape);\n\t\t\n\t\t//creation of the building agents that will be saved\n\t\tcreate building number: 50 {\n\t\t\tshape <- square(5.0);\n\t\t\tlocation <- any_location_in (free_space - 5.0);\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t//save building geometry into the shapefile: add the attribute TYPE which value is set by the type variable of the building agent and the attribute ID \n\t\tsave building to:\"../results/buildings.shp\" format:\"shp\" attributes: [\"ID\":: int(self), \"TYPE\"::type]; \n\t}\n}\n  \n//species that represent the building agents that will be saved\nspecies building {\n\tstring type <- flip(0.8) ? \"residential\" : \"industrial\";\n\taspect default {\n\t\tdraw shape color: type = \"residential\" ? #gray : #pink;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies building;\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates a population of agents (bugs) interacting with each other and saving their data to a text file at regular intervals.", "gaml_code": "/**\n* Name: Save to Text\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save agents inside a text file to reuse it later or to keep it.\n* Tags: save_file, txt\n*/\n\n\nmodel SavetoText\n \nglobal {\n\tinit {\n\t\t//Create the agents that will be saved in the text file.\n\t\tcreate bug number: 50;\n\t}\n\t\n\t//Reflex saving the agents every 10 steps. \n\treflex save_data when: every(10#cycles){\n\t\t//save the following text into the given text file. Note that each time the save statement is used, a new line is added at the end of the file.\n\t\tsave (\"cycle:\" + cycle + \", mean size: \" + mean(bug collect each.size)) to: \"../results/data.txt\" rewrite: false;\n\t}\n\t//Reflex that will pause the simulation when the number of cycles reach 100.\n\treflex end_simulation when: cycle = 100 {\n\t\tdo pause; \n\t}\n}\n\n//Species bug that will be saved using the skill moving\nspecies bug skills:[moving]{\n\tfloat size <- 1.0 + rnd(4) min: 1.0 max: 5.0;\n\tfloat speed <- 1.0 + rnd(4.0);\n\t\n\t//At each step, the size of the agent is update according to the number of bugs close to the agent\n\treflex update_size {\n\t\tint nb_neigh <- length(bug at_distance 20.0);\n\t\tif (nb_neigh > 5) {\n\t\t\tsize <- size + 1;\n\t\t} else {\n\t\t\tsize <- size - 1;\n\t\t}\n\t} \t\n\t\n\t//Make the agent move randomly \n\treflex move {\n\t\tdo wander;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies bug;\n\t\t}\n\t}\n}"}
{"prompt": "Create a Netlogo model that saves a 50x50 grid to an ASCII file, displaying it as a 2D map with a GUI interface.", "gaml_code": "/**\n* Name: Save to Ascii\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save a grid inside a ASCII File to reuse it later or to keep it.\n* Tags: save_file, asc, grid\n*/\n\nmodel SavetoAsc\n\nglobal {\n\tinit {\t\n\t\t//save grid \"grid_value\" attribute into the asc file.\n\t\tsave cell to:\"../results/grid.asc\";\n\t}\n}\n\n//Grid that will be saved in the ASC File\ngrid cell width: 50 height: 50 {\n\tfloat grid_value <- self distance_to world.location;\n\trgb color <- rgb(255 * (1 - grid_value / 50), 0,0);\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t}\n\t}\n}"}
{"prompt": "Generate a NetLogo model that demonstrates how to save a graph in various formats, including GML, DIMACS, DOT, GraphML, Graph6, and GEXF, using a randomly generated graph with 20 nodes and edges.", "gaml_code": "/**\n* Name: Save graphs\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save a graph with diverse formats.\n* Tags: save_file, graph\n*/\n\nmodel Savetoshapefile\n\nglobal {\n\tinit {\n\t\tgraph the_graph <- generate_random_graph(20, 20, true,node_agent, edge_agent);\n\t\t\n\t\t//save the graph with different format.\n\t\tsave the_graph to:\"../results/my_graph.gml\" format:\"gml\";\n\t\tsave the_graph to:\"../results/my_graph.dimacs\" format:\"dimacs\";\n\t\tsave the_graph to:\"../results/my_graph.dot\" format:\"dot\";\n\t\tsave the_graph to:\"../results/my_graph.graphml\" format:\"graphml\";\n\t\tsave the_graph to:\"../results/my_graph.g6\" format: \"graph6\" ;\n\t\tsave the_graph to:\"../results/my_graph.gexf\" format:\"gexf\" ;\n\t\t\n\t\t\n\t}\n} \n  \n//species that represent the nodes of the graph\nspecies node_agent {\n\taspect default {\n\t\tdraw circle(1.0) color:#red border: #black;\n\t}\n}\n\n//species that represent the edges of the graph\nspecies edge_agent {\n\taspect default {\n\t\tdraw shape color:#black end_arrow: 1.0;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies node_agent;\n\t\t\tspecies edge_agent;\n\t\t}\n\t}\n}"}
{"prompt": "Create a Geospatial Model that Saves a Grid to a Geo-TIFF File from a Shapefile.", "gaml_code": "/**\n* Name: Save to Geotiff\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save a grid inside a georefrenced png file to reuse it later or to keep it.\n* Tags: save_file, png, grid\n*/\n\nmodel SavetoGeotiff\n\nglobal {\n\tshape_file buildings <- shape_file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(buildings);\n\tinit {\t \n\t\task cell {\n\t\t\tif not empty(buildings overlapping self) {\n\t\t\t\tcolor <- #blue;\n\t\t\t}\n\t\t}\n\t\t//save grid \"grid_value\" attribute into the georefrenced png file.\n\t\tsave cell to:\"../results/grid.png\";\n\t}\n}\n\ngrid cell width: 50 height: 50 ;\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map type:2d antialias:false {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t}\n}"}
{"prompt": "Create a Netlogo model that saves a grid as a Geotiff file and displays it in a GUI.", "gaml_code": "/**\n* Name: Save to Geotiff\n* Author: Patrick Taillandier\n* Description: This is a model that shows how to save a grid inside a Geotiff File to reuse it later or to keep it.\n* Tags: save_file, tiff, grid\n*/\n\nmodel SavetoGeotiff\n\nglobal {\n\tinit {\t \n\t\t//save grid \"grid_value\" attribute into the geotiff file.\n\t\tsave cell to:\"../results/grid.tif\" format:\"geotiff\";\n\t}\n}\n\n//Grid that will be saved in the Geotiff File\ngrid cell width: 50 height: 50 {\n\tfloat grid_value <- self distance_to world.location * 2;\n\trgb color <- rgb(255 * (1 - grid_value / 50), 0,0);\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t}\n}"}
{"prompt": "Clean and visualize a road network from a shapefile data source, allowing for customization of cleaning options and display of connected components.", "gaml_code": "/**\n* Name: clean_road_network\n* Author: Patrick Taillandier\n* Description: shows how GAMA can help to clean network data before using it to make agents move on it\n* Tags: gis, shapefile, graph, clean\n*/\n\nmodel clean_road_network\n\nglobal {\n\t//Shapefile of the roads\n\tshape_file road_shapefile <- shape_file(\"../includes/roads.shp\");\n\t\n\t//Shape of the environment\n\tgeometry shape <- envelope(road_shapefile);\n\t\n\t\n\t//clean or not the data\n\tbool clean_data <- true;\n\t\n\t//tolerance for reconnecting nodes\n\tfloat tolerance <- 3.0;\n\t\n\t//if true, split the lines at their intersection\n\tbool split_lines <- true;\n\t\n\t//if true, keep only the main connected components of the network\n\tbool reduce_to_main_connected_components <- true;\n\t\n\tstring legend <- not clean_data ? \"Raw data\" : (\"Clean data : tolerance: \" + tolerance + \"; split_lines: \" + split_lines + \" ; reduce_to_main_connected_components:\" + reduce_to_main_connected_components );\n\t\n\tlist<list<point>> connected_components ;\n\tlist<rgb> colors;\n\t\t\t\n\tinit {\n\t\t\n\t\t//clean data, with the given options\n\t\tlist<geometry> clean_lines <- clean_data ? clean_network(road_shapefile.contents,tolerance,split_lines,reduce_to_main_connected_components) : road_shapefile.contents;\n\t\t\n\t\t//create road from the clean lines\n\t\tcreate road from: clean_lines;\n\t\t\n\t\t//build a network from the road agents\n\t\tgraph road_network_clean <- as_edge_graph(road);\n\t\t\n\t\t//computed the connected components of the graph (for visualization purpose)\n\t\tconnected_components <- list<list<point>>(connected_components_of(road_network_clean));\n\t\tloop times: length(connected_components) {colors << rnd_color(255);}\n    }\n}\n\n//Species to represent the roads\nspecies road {\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\n\nexperiment clean_network type: gui {\n\t\n\tparameter \"Clean data\" var:clean_data;\n\tparameter \"Tolerance\" var:tolerance;\n\tparameter \"Split lines\" var:split_lines;\n\tparameter \"Reduce to main connected components\" var:reduce_to_main_connected_components;\n\t\n\tinit {\n\t\tcreate clean_road_network_model with:[clean_data::false]; \n\t\tcreate clean_road_network_model with:[split_lines::false,reduce_to_main_connected_components::false]; \n\t\tcreate clean_road_network_model with:[split_lines::true,reduce_to_main_connected_components::false]; \n\t}\n\toutput {\n\t\tlayout #split;\n\t\tdisplay network type: 2d {\n\t\n\t\t\t overlay position: { 10#px, 10#px } size: { 800 #px, 60 #px } background: # black transparency: 0.5  rounded: true\n            {\n\t\t\t\tdraw legend color: #white font: font(\"SansSerif\", 12, #bold) at: {40#px, 40#px, 1 };\n\t\t\t}\n\t\t\tspecies road ;\n\t\t\tgraphics \"connected components\" {\n\t\t\t\tloop i from: 0 to: length(connected_components) - 1 {\n\t\t\t\t\tloop j from: 0 to: length(connected_components[i]) - 1 {\n\t\t\t\t\t\tdraw circle(2) color: colors[i] at: connected_components[i][j];\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D grid visualization from a GeoTIFF file using GAMA, assuming grayscale data type.", "gaml_code": "/**\n* Name: GeoTIFF file to Grid of Cells \n* Author:  Patrick Taillandier\n* Description: Model which shows how to create a grid of cells by using a GeoTIFF File. \n*   It is important to notice that GAMA can only read GeoTIFF files with Bytes data type (files that are often displayed in grayscale)\n*   The GeoTIFF files with Float32 or Float64 data type cannot be read for the moments.\n*   Their metadata can neither been read in the Model library explorer.\n* Tags:  load_file, tif, gis, grid\n*/\n\nmodel geotiffimport\n\nglobal {\n\t//definiton of the file to import\n\tfile grid_data <- grid_file(\"../includes/bogota_grid.tif\");\n\n\t//computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n\t\n\tfloat max_value;\n\tfloat min_value;\n\tinit {\n\t\tmax_value <- cell max_of (each.grid_value);\n\t\tmin_value <- cell min_of (each.grid_value);\n\t\task cell {\n\t\t\tint val <- int(255 * ( 1  - (grid_value - min_value) /(max_value - min_value)));\n\t\t\tcolor <- rgb(val,val,val);\n\t\t}\n\t}\n}\n\n//definition of the grid from the geotiff file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data;\n\nexperiment show_example type: gui {\n\toutput {\n\t\tdisplay test axes:false type:3d{\n\t\t\tcamera 'default' location: {16384.6813,51385.7828,15210.911} target: {15510.9655,18019.9225,0.0};\n\t\t\tgrid cell border: #black elevation:grid_value*5 triangulation:true;\n\t\t}\n\t} \n}"}
{"prompt": "Create a Geospatial Analysis Model (GAML) that loads an ESRI ASCII file and visualizes it as both 3D DEM and 2D grid using a GUI interface.", "gaml_code": "/**\n* Name: ESRI ASCII to grid model\n* Author:  Patrick Taillandier\n* Description: Model which shows how to initialize a grid using a ESRI ASCII file\n* Tags: grid, load_file, asc\n*/\n\nmodel ascimport\n\nglobal {\n\t//definiton of the file to import\n\tfile grid_data <- file('../includes/hab10.asc') ;\n\t\n\t//computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n}\n\n\n\n//definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data{\n\tinit {\n\t\tcolor<- grid_value = 0.0 ? #black  : (grid_value = 1.0  ? #green :   #yellow);\n\t}\n}\n\nexperiment gridloading type: gui {\n\toutput {\n\t\tdisplay \"As DEM\" type: 3d axes:false{\n\t\t\tgrid cell border: #gray elevation: self.grid_value * 300 ;\n\t\t}\n\t\t\n\t\tdisplay \"As 2D grid\"  type: 2d {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t} \n}"}
{"prompt": "Create a 3D grid model that combines DEM and land cover data from two separate files (ASC and TIFF) to visualize elevation and land use information.", "gaml_code": "/**\n* Name: importationraster\n* Author: Patrick Taillandier\n* Description: Shows how to use several grid files to initialize a grid \n* Tags: load_file, gis, 3d, dem, tif, asc\n*/\n\nmodel importationraster\n\nglobal {\n\t//the two grid files that we are going to use to initialize the grid\n\tfile dem_file <- file(\"../includes/mnt.asc\");\n\tfile land_cover_file <- file(\"../includes/land-cover.tif\");\n\t\n\t//we use the dem file to initialize the world environment\n\tgeometry shape <- envelope(dem_file);\n\t\n\t//map of colors (key: land_use, value: color)  just uses to visualize the different land_use\n\tmap<int,rgb> colors;\n\t\n\tinit {\n\t\t//we set the value of the land_use variable by the second (index = 1) value stored in the bands attribute \n\t\task cell {\n\t\t\tland_use <- int(bands[1]);\n\t\t}\n\t\t\n\t\t//we define a color per land_use and use it to define the color of the cell\n\t\tlist<int> land_uses <- remove_duplicates(cell collect each.land_use);\n\t\tcolors <- land_uses as_map (each::rnd_color(255));\n\t\task cell {\n\t\t\tcolor <- colors[land_use];\n\t\t}\n\t}\n}\n\n//we define the cell grid from the two grid files: the first file (dem_file) will be used as reference for the definition of the grid number of rows and columns and location\n//the value of the files are stored in the bands built-in list attribute: each value of the list corresponds to the value in the file\n//the value of the first file is also stored in thr grid_value built-in variable\ngrid cell files: [dem_file,land_cover_file] {\n\tint land_use;\n}\n\nexperiment importationraster type: gui {\n\toutput {\n\t\tdisplay map type: 3d axes:false antialias:false{\n\t\t\tgrid cell elevation: true  triangulation: true refresh: false;\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of a house using data from a DXF file, where each room is represented by an agent with its own color and layer.", "gaml_code": "/**\n* Name: DXF to Agents Model\n* Author:  Patrick Taillandier\n* Description: Model which shows how to create agents by importing data of a DXF file\n* Tags:  dxf, load_file\n*/\nmodel DXFAgents\n\n\nglobal\n{\n\tdxf_file house_file <- dxf_file(\"../includes/house.dxf\",#m);\n\n\t//compute the environment size from the dxf file envelope\n\tgeometry shape <- envelope(house_file);\n\tinit\n\t{\n\t//create house_element agents from the dxf file and initialized the layer attribute of the agents from the the file\n\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\n\t\t\n\t\t//define a random color for each layer\n\t\tlet layers <- list(house_element) group_by each.layer;\n\t\tloop la over: layers.keys\n\t\t{\n\t\t\trgb col <- rnd_color(255);\n\t\t\task layers[la]\n\t\t\t{\n\t\t\t\tcolor <- col;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies house_element\n{\n\tstring layer;\n\trgb color;\n\taspect default\n\t\t{\n\t\tdraw shape color: color;\n\t}\n\tinit {\n\t\tshape <- polygon(shape.points);\n\t}\n}\n\nexperiment DXFAgents type: gui\n{   \n\toutput\n\t{\tlayout #split;\n\t\tdisplay map type: 3d\n\t\t{\n\t\t\tspecies house_element;\n\t\t}\n\n\t\tdisplay \"As_Image\" type: 3d\n\t\t{\n\t\t\tgraphics \"House\"\n\t\t\t{\n\t\t\t\tdraw house_file at: {0,0} color: # brown;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a GeoMesa model that loads a satellite map and displays buildings on it, using MapBox API and allowing user input for access token.", "gaml_code": "/***\n* Name: mainroadcells\n* Author: minhduc0711\n* Description: \n* Tags: Tag1, Tag2, TagN\n***/\nmodel main\n\nglobal {\n\tstring appkey <-\"KEY\";\n\timage_file static_map_request;\n\tstring map_center;\n\tpoint map_size;\n\n\taction load_map {\n\t\tfloat s <- world.shape.height / world.shape.width;\n\t\tmap_size <- {500, 500 * s};\n\t\tstring request <- \"https://api.mapbox.com/styles/v1/mapbox/satellite-v9/static/\" + \"[\" + map_center + \"]/\" + int(map_size.x) + \"x\" + int(map_size.y) + \"@2x?\" + \"access_token=\" + appkey;\n\t\twrite \"Request : \" + request;\n\t\tstatic_map_request <- image_file(request, \"JPEG\");\n\t}\n\n\tshape_file buildings_shape_file <- shape_file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(buildings_shape_file);\n\n\tinit {\n\t\tgeometry loc <- (world.shape CRS_transform (\"EPSG:4326\"));\n\t\tmap_center <- \"\" + loc.points[0].x + \",\" + loc.points[0].y + \",\" + loc.points[2].x + \",\" + loc.points[2].y;\n\t\twrite loc;\n\t\twrite map_center;\n\t\t\n\t\tif(appkey = \"KEY\") {\n\t\t\tmap useless <- user_input_dialog(\"Please enter your MapBox access token as a value for the appkey variable in the code instead of \\\"KEY\\\".\", []);\t\t\t\n\t\t} else {\n\t\t\tdo load_map;\n\t\t}\n\t\t\n\t\tcreate building from: buildings_shape_file;\n\t}\n\n}\n\nspecies building {\n}\n\nexperiment exp {\n\toutput {\n\t\tdisplay main type: 3d {\n\t\t\timage static_map_request;\n\t\t\tspecies building;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a NetLogo model that loads a JSON file and initializes a grid from its contents.", "gaml_code": "/**\n* Name: JSON File Loading\n* Author:  Arnaud Grignard\n* Description: Initialize a grid from a JSON FIle. \n* Tags:  load_file, grid, json\n*/\n\nmodel json_loading   \n\nglobal {\n\tfile JsonFile <- json_file(\"../includes/cityIO.json\");\n    map<string, unknown> c <- JsonFile.contents;\n\n\tinit { \n\t\tlist<map<string, int>> cells <- c[\"grid\"];\n        loop mm over: cells {                 \n            cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n            cell.type <-int(mm[\"type\"]);\n        }\n\t}  \n} \n\ngrid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay cityMatrixView   type: 3d axes:false{\t\n\t\t\tspecies cityMatrix aspect:base;\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D simulation of agents moving around a complex geometry drawn from an OBJ file, using NetLogo modeling language.", "gaml_code": "/**\n* Name: OBJ File to Geometry\n* Author:  Arnaud Grignard\n* Description: Model which shows how to use a OBJ File to draw a complex geometry. The geometry is simply used, in this case, to draw the agents.\n* Tags:  load_file, 3d, skill, obj\n*/\n\n\nmodel obj_drawing   \n\nglobal {\n\tgeometry shape <- square(40);\n\n\tinit { \n\t\tcreate object number: 30;\n\t}  \n} \n\nspecies object skills: [moving]{\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\tint size <- rnd(10) + 1;\n\tint rot <- 1000 + rnd(1000);\n\treflex m  {\n\t\tdo wander amplitude: 30.0 speed: 1.0;\n\t}\n\taspect obj {\n\t\tdraw obj_file(\"../includes/teapot.obj\") color: color size: size rotate: cycle/rot::{0,1,0} ;\n\t}\n}\t\n\nexperiment Display  type: gui {\n\toutput synchronized: true{\n\t\tdisplay ComplexObject type: 3d background:#orange{\n\t\t\tspecies object aspect:obj;\t\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that loads an ASCII file as a DEM representation and applies textures to it, allowing for various 3D displays and experiments.", "gaml_code": "/**\n* Name: ASCII File to DEM Representation\n* Author: Arnaud Grignard\n* Description: Model to show how to import a ASCII File to make a DEM Representation and apply a Texture on it. In this \n* \tmodel, three experiments are presented : DEM to show the grid elevation using the ASCII File as data for the height of the \n* \tcells, and showing different 3D displays. GridDEMComplete shows more displays with the three of the previous experiment, the grid \n* \tof the cells in a 2D Display, with the Elevation but without triangulation, and the grid with text values to show the content of the \n* \tASCII used by the cells. GraphicDEMComplete shows the use of the z_factor to amplify or reduces the difference between the z values \n* \tof a Dem geometry.\n* Tags:  load_file, gis, 3d, dem\n*/\nmodel gridloading\n\nglobal {\n\tfile grid_data <- file(\"../includes/DEM-Vulcano/vulcano_50.asc\");\n\tfile dem_file <- file('../includes/DEM-Vulcano/DEM.png');\n\timage_file europe <- image_file(\"../images/mnt/europe.jpg\");\n\tfile texture <- file('../includes/DEM-Vulcano/Texture.jpg');\n\tgeometry shape <- envelope(200);\n\n\tinit {\n\t\task cell {\n\t\t\tfloat r;\n\t\t\tfloat g;\n\t\t\tfloat b;\n\t\t\tif (grid_value < 20) {\n\t\t\t\tr <- 76 + (26 * (grid_value - 7) / 13);\n\t\t\t\tg <- 153 - (51 * (grid_value - 7) / 13);\n\t\t\t\tb <- 0.0;\n\t\t\t} else {\n\t\t\t\tr <- 102 + (122 * (grid_value - 20) / 19);\n\t\t\t\tg <- 51 + (173 * (grid_value - 20) / 19);\n\t\t\t\tb <- 224 * (grid_value - 20) / 19;\n\t\t\t}\n\n\t\t\tself.color <- rgb(r, g, b);\n\t\t}\n\n\t}\n\n}\n\ngrid cell file: grid_data;\n\nexperiment base virtual:true {\n\tparameter 'DEM' var:dem_file ;\n\tparameter 'Texture' var:texture;\t\n}\n\nexperiment Comparison type: gui parent:base{\n\toutput {\n\t\tlayout #split;\n\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\n \t\tdisplay \"Grid with triangles\" type: 3d {\n\t\t\tgrid cell elevation: true triangulation: true;\n\t\t}\n\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n\t\tdisplay \"Grid with triangles and grayscale\" type: 3d {\n\t\t\tgrid cell elevation: true grayscale: true triangulation: true;\n\t\t}\n\n\t\t//Display the textured grid in 3D with the cell altitude corresponding to its grid_value.\t\t\t\t\n\t\tdisplay \"Grid with triangles and texture\" type: 3d {\n\t\t\tgrid cell texture: texture triangulation: true elevation: true;\n\t\t}\n\n\t\t//Display the field triangulated in 3D with the cell altitude corresponding to its value and the color defined (otherwise in default color)\n \t\tdisplay \"Field with triangles, green color\" type: 3d {\n\t\t\tmesh grid_data triangulation: true color: #green;\n\t\t}\n\n\t\t//Display the field triangulated in 3D with the cell altitude corresponding to its value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n \t\tdisplay \"Field with triangles and grayscale\" type: 3d {\n\t\t\tmesh grid_data grayscale: true triangulation: true;\n\t\t}\n\n\t\t//Display the textured field in 3D with the cell altitude corresponding to its value.\t\t\t\t\n \t\tdisplay \"Field scaled by 2, with triangles and texture\" type: 3d {\n\t\t\tmesh grid_data texture: texture triangulation: true scale: 2.0;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Grids\" type: gui parent:base{\n\toutput {\n\t\tlayout #split toolbars: false;\n\n\t\t//Display the grid on a plan with cell color (if defined otherwise in black)\n \t\tdisplay grid type: 3d { //Same as in 2d\n \t\t\tgrid cell border: #black;\n\t\t}\n\n\t\t//Display the grid in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\n \t\tdisplay gridWithElevation type: 3d {\n\t\t\tgrid cell elevation: true;\n\t\t}\n\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\n \t\tdisplay gridWithElevationTriangulated type: 3d {\n\t\t\tgrid cell elevation: true triangulation: true;\n\t\t}\n\n\t\t//Display the grid in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n \t\tdisplay gridGrayScaled type: 3d {\n\t\t\tgrid cell elevation: true grayscale: true;\n\t\t}\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n\t\tdisplay gridGrayScaledTriangulated type: 3d {\n\t\t\tgrid cell elevation: true grayscale: true triangulation: true;\n\t\t}\n\n\t\t//Display the textured grid in 3D with the cell altitude corresponding to its grid_value.\t\t\t\t\n\t\tdisplay gridTextured type: 3d {\n\t\t\tgrid cell texture: texture text: false triangulation: false elevation: true;\n\t\t}\n\n\t\t//Display the textured triangulated grid in 3D with the cell altitude corresponding to its grid_value.\n \t\tdisplay gridTexturedTriangulated type: 3d {\n\t\t\tgrid cell texture: texture text: false triangulation: true elevation: true;\n\t\t}\n\n\t\tdisplay gridWithText type: 3d {\n\t\t\tgrid cell text: true elevation: true wireframe: true refresh: false;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Meshes\" type: gui parent:base{\n\toutput {\n\t\tlayout #split toolbars: false;\n\t\tdisplay \"Large file, rectangles, wireframe and scaled\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh europe wireframe: true border: #green refresh: false size: {1, 1, 0.2};\n\t\t}\n\n\t\tdisplay \"Large file, triangles, wireframe and scaled\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh europe grayscale: true triangulation: true smooth: true refresh: false size: {1, 1, 0.2};\n\t\t}\n\n\t\tdisplay \"Large file, triangles, smooth, wireframe and scaled\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh europe wireframe: true triangulation: true border: #green refresh: false size: {1, 1, 0.2} smooth: true;\n\t\t}\n\n\t\tdisplay \"Triangles, grayscale, lines, colored and scaled\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh grid_data size: {1, 1, 0.75} triangulation: true border: #yellow color: #violet;\n\t\t}\n\n\t\tdisplay \"Triangles, textured, no scale\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh grid_data texture: texture triangulation: true;\n\t\t}\n\n\t\tdisplay \"Triangles, textured and scaled\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh grid_data texture: texture triangulation: true scale: 0.75;\n\t\t}\n\n\t\tdisplay \"Triangles, textured, smooth and scaled\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh grid_data texture: texture smooth: true triangulation: true size: {1, 1, 0.75};\n\t\t}\n\n\t\tdisplay \"Triangles, textured, scaled, with labels\" type: 3d axes: false {\n\t\t\tcamera \"default\" location: {100.0, 269.7056, 169.7056} target: {100.0, 100.0, 0.0};\n\t\t\tmesh grid_data texture: texture triangulation: true size: {1, 1, 0.5} text: true;\n\t\t}\n\n\t\tdisplay \"Large file, trianges, grayscale, scaled\" type: 3d axes: false {\n\t\t\tcamera 'default' location: {104.7273,233.3361,685.4581} target: {100.135,-29.7603,0.0};\n\t\t\tmesh dem_file grayscale: true triangulation: true scale: 2.0;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a model that loads and displays a Bing Maps image, allowing users to input their desired location and zoom level, and automatically updates the map display.", "gaml_code": "/**\n* Name: BingMapImageImport\n* Author: Alexis Drogoul\n* Description: Demonstrates how to load a image from BingMap https://docs.microsoft.com/en-us/bingmaps/rest-services/imagery/get-a-static-map and how to refresh it\n* Tags: data_loading, displays, user_input, on_change\n*/\n@no_warning\nmodel BingMapImageImport\n\n\n\nglobal\n{\n\t\n\tuser_command \"Change destination\" action: load_map;\n\t\n\timage_file static_map_request;\n\tgeometry shape<-square(500);\n\t\n\t\n\tstring zoom_title <- \"Zoom (between 1 and 20)\";\n\tstring lat_lon_title <- \"Latitude and longitude\";\n\t\n\tint current_zoom <- 15;\n\tstring current_lat_lon <- \"48.8566140,2.3522219\";\n\t\n\taction load_map\n\t{ \n\t\tmap\tanswers <- user_input_dialog(\"Address can be a pair lat,lon (e.g; '48.8566140,2.3522219')\", [enter(lat_lon_title,current_lat_lon),enter(zoom_title,current_zoom)]);\n\t\tcurrent_zoom <- max(min(20,int(answers[zoom_title])),1);\n\t\tcurrent_lat_lon <- answers[lat_lon_title]; \n\t\tstring rest_link<- \"https://dev.virtualearth.net/REST/v1/Imagery/Map/AerialWithLabels/\"+current_lat_lon+\"/\"+current_zoom+\"?mapSize=\"+int(world.shape.width)+\",\"+int(world.shape.height)+\"&key=AvZ5t7w-HChgI2LOFoy_UF4cf77ypi2ctGYxCgWOLGFwMGIGrsiDpCDCjliUliln\";\n\t\twrite rest_link;\n\t\tstatic_map_request <- image_file(rest_link);\n\t\task experiment {do update_outputs(true);}\n\t}\n \n\tinit\n\t{\n\t\tdo load_map;\n\t}\n\n}\n\nexperiment Display\n{\n\tuser_command \"Change destination\" category: \"Bing service\" {ask simulation {do load_map;}}\n\n\t \n\toutput\n\t{\n\t\tdisplay \"Bing Map\" type: 3d axes:false\n\t\t{\n\t\t\timage static_map_request refresh:true;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a NetLogo model that loads and displays a dynamic map from MapQuest using user input for center coordinates, zoom level, and size.", "gaml_code": "/**\n* Name: MapQuestImageImport\n* Author: Alexis Drogoul\n* Description: Demonstrates how to load a (possibly dynamic) image from MapQuest https://developer.mapquest.com/documentation/samples/static-map/v5/map/ and how to refresh it\n* Tags: data_loading, displays, user_input, on_change\n*/\nmodel MapQuestImageImport\n\n \nglobal {\n\t// If you want to use MapQuest data, you need to grab a key from the official MapQuest website:\n\t// https://developer.mapquest.com/documentation/\n\tstring appkey<-\"KEY\";\n\timage_file static_map_request;\n\tstring map_center <- \"48.8566140,2.3522219\"; \n\tint map_zoom <- 8 max: 20 min: 0;\n\tpoint map_size <-{600,600};\n\n\taction load_map\n\t{ \n\t\tstring zoom_request <- \"zoom=\" + map_zoom;\n\t\tstring center_request <- \"locations=\" + map_center;\n\t\tstring size_request <- \"size=\" + int(map_size.x) + \",\" + int(map_size.y) + \"@2x\";\n\t\tstring request <- \"https://www.mapquestapi.com/staticmap/v5/map?key=\"+appkey+\"&\"+size_request+\"&imagetype=jpg&\"+zoom_request+\"&\"+center_request+\"&type=hyb\";\n\t\twrite \"Request : \" + request;\n\t\tstatic_map_request <- image_file(request);\n\t}\n \n\tinit\n\t{\n\t\tif(appkey = \"KEY\") {\n\t\t\tmap useless <- user_input_dialog(\"Please enter your MapQuest key in the model code.\", []);\t\t\t\n\t\t} else {\n\t\t\tmap answers <- user_input_dialog(\"Center of the map can be a pair lat,lon (e.g; '48.8566140,2.3522219')\", [enter(\"Center\",map_center),enter(\"Zoom x\",map_zoom),enter(\"Size\", map_size)]);\n\t\t    map_center <- answers[\"Center\"]; \n\t\t\tmap_zoom <- int(answers[\"Zoom x\"]);\n\t\t\tmap_size <- point(answers[\"Size\"]);\n\t\t\t\n\t\t\tdo load_map;\t\t\t\n\t\t}\n\t}\n\n}\n\nexperiment Display\n{\n\tparameter \"Zoom\" var: map_zoom  {\n\t\task simulation  {do load_map;}\n\t\tdo update_outputs(true);\n\t}\n\n\toutput\n\t{\n\t\t\n\t\tdisplay \"MapQuest\" type: 3d axes:false\n\t\t{\n\t\t\tgraphics toto {\n\t\t\t\tdraw static_map_request;\n\t\t\t}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a NetLogo model that imports contour lines from a shapefile, triangulates them, and visualizes the resulting 3D terrain.", "gaml_code": "/**\n* Name: Contour Lines Import\n* Author: Patrick Taillandier\n* Description: Model which imports a shapefile of contour lines, build triangles from these contour lines, compute their elevation by using \n* \tthe elevation attribute of the contour lines which had been linked to the elevation column of the shapefile. \n* Tags:  load_file, gis, shapefile\n*/\n\n\nmodel contour_lines_import\n\nglobal {\n\t//the contour lines shapefile\n\tfile shape_file_cl <- file('../includes/contourLines.shp') ;\n\t\n\t//define the size of the world from the countour line shapefile\n\tgeometry shape <- envelope(shape_file_cl);\n\n        //tolerance for the triangulation; if an error appears during the triangulation, a workaround consists in increasing this tolerance (0.01 for instance).\n\tfloat tolerance <- 0.0;\n\t\n\tinit {\n\t\t//create the contour line agents from the shapefile, and init the elevation for each agent\n\t\tcreate contour_line from: shape_file_cl with: [elevation:: float(read(\"ELEVATION\"))];\n\t\t\n\t\t//triangulate the contour lines\n\t\tlist<geometry> triangles  <- triangulate (list(contour_line), tolerance);\n\t\t\n\t\t//for each triangle geometry, create a triangle_ag agent and compute the elevation of each of its points (and modified their z value)\n\t\tloop tr over: triangles {\n\t\t\tcreate triangle_ag {\n\t\t\t\tshape <- tr;\n\t\t\t\tloop i from: 0 to: length(shape.points) - 1{ \n\t\t\t\t\tfloat val <- (contour_line closest_to (shape.points at i)).elevation;\n\t\t\t\t\tshape <- shape set_z (i,val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies contour_line {\n\tfloat elevation;\n\taspect default {\n\t\tdraw shape color: #red depth: 30 at: {location.x,location.y, elevation}; \n\t}\n}\nspecies triangle_ag {\n\taspect default {\n\t\tdraw shape color: #grey ; \n\t}\n}\n\n\nexperiment contour_lines_import type: gui {\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tcamera 'default' location: {4341.8834,20215.2668,9585.3894} target: {5500.0,5500.0,0.0};\n\t\t\tspecies triangle_ag refresh: false;\n\t\t\tspecies contour_line refresh: false;\n\t\t}\n\t}\n}"}
{"prompt": "Show how to load and visualize different types of graph files using a GUI, including graphml, gml, dot, dimacs, gexf, tsplib, and graph6 formats.", "gaml_code": "/**\n* Name: GraphImportation\n* Author: P. Taillandier\n* Description:  Shows how to load diverse graph files. \n* Tags: Graph, File\n*/\n\nmodel GraphImportation\n\nglobal {\n\t\n\tstring type <- \"graphml\" among: [\"graphml\", \"gml\",\"dot\", \"dimacs\", \"gexf\", \"tsplib\", \"graph6\"]; \n\t\n\tmap loc_nodes;\n\t\n\tgraph g;\n\tinit {\n\t\tdo importation;\n\t}\n\treflex reimport {\n\t\tdo importation;\n\t}\n\taction importation {\n\t\t\n\t\tswitch type {\n\t\t\tmatch \"graphml\" {\n\t\t\t\tg <- graphml_file(\"../includes/graphs/simple.graphml\").contents;\n\t\t\t}\n\t\t\tmatch \"gml\" {\n\t\t\t\tg <- graphgml_file(\"../includes/graphs/simple.gml\").contents;\n\t\t\t}\n\t\t\tmatch \"dot\" {\n\t\t\t\tg <- graphdot_file(\"../includes/graphs/simple.dot\").contents;\n\t\t\t}\n\t\t\tmatch \"dimacs\" {\n\t\t\t\tg <- graphdimacs_file(\"../includes/graphs/simple.dimacs\").contents;\n\t\t\t}\t\n\t\t\tmatch \"gexf\" {\n\t\t\t\tg <- graphgexf_file(\"../includes/graphs/simple.gexf\").contents;\n\t\t\t}\n\t\t\tmatch \"tsplib\" {\n\t\t\t\tg <- graphtsplib_file(\"../includes/graphs/simple.tsplib\").contents;\n\t\t\t}\n\t\t\tmatch \"graph6\" {\n\t\t\t\tg <- graph6_file(\"../includes/graphs/simple.g6\").contents;\n\t\t\t}\t\n\t\t}\n\t\twrite g;\n\t\t\n\t\tloop v over: g.vertices {\n\t\t\tloc_nodes[v] <- any_location_in(world);\t\n\t\t} \n\t}\n}\n\nexperiment import_graph type: gui {\n\t\n\tparameter var:type;\n\t\n\toutput {\n\t\tdisplay graph_display type: 3d axes: false{\n\t\t\tgraphics \"graph \" {\n\t\t\t\t\n\t\t\t\tloop v over: g.vertices {\n\t\t\t\t\tdraw circle(1) at: point(loc_nodes[v]) color: #red border: #black;\n\t\t\t\t}\n\t\t\t\tloop e over: g.edges {\n\t\t\t\t\tstring s <- g source_of e;\n\t\t\t\t\tstring t <- g target_of e;\n\t\t\t\t\tdraw line([point(loc_nodes[s]),  point(loc_nodes[t])]) color: #black end_arrow: 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}"}
{"prompt": "Create a GAMA model that imports a raster file and uses its color attributes to initialize a grid of cells. The grid should have 250 agents (izards) placed on cells based on certain conditions, with each agent having a unique location and appearance.", "gaml_code": "/**\n* Name: Raster File in a Grid of cells\n* Author: Maroussia Vavasseur and Benoit Gaudou\n* Description: Model which shows how to import a Raster file in GAMA and use it to initialize the color attributes of a grid of cells. \n* This model represents a grid with a cell, each cell has a color, and this color is used for animals (izards) to be placed on a cell \n* that verifies some conditions. The izards do not move once they have been placed. \n* Tags:  load_file, gis, raster\n*/\n\nmodel HowToImportRaster\n\nglobal {\t\n\t// Constants \n\tint heightImg const: true <- 492;\n\tint widthImg const: true <- 526;\t \n\t  \n\t// Global variables\n\tfloat factorDiscret <- 2.0 ;\n\tfile mntImageRaster <- image_file('../images/mnt/testAG.jpg') ;\n\t\n\tint nbIzard <- 250 ; \n\timage_file izardShape <- image_file('../images/icons/izard.gif');\n\t\t\t\n\t// Initialization of grid and creation of the izard agents\n\t// - we use the as_matrix operator to resize the image file into a matrix of colors with the same size of the grid\n\t// (Note that as_matrix takes a Point as right operand, this point specifies the number of lines and columns of the matrix)\n\t// - we then set the color built-in attribute of the cell with the value of the corresponding matrix cell     \n\tinit {\t\t\n\t\tmatrix mapColor <- mntImageRaster as_matrix {int(widthImg/factorDiscret), int(heightImg/factorDiscret)} ;\n\t\t\n\t\task cell {\t\t\n\t\t\tcolor <- rgb( mapColor at {grid_x,grid_y}) ;\n\t\t}\n\t\tcreate izard number: nbIzard; \n    }\n}\n \n\n// We create izard agents and locate them on one 'cell' among the list of cellules in which there is no izard \n// and with a color that is not white 'each.color != #white'\n// the shuffle operator is used to randomized the list of cells\n\nspecies izard {\t\n\tinit{\n\t\tlocation <- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ;\n\t}\t\t\n\taspect default{\n\t\tdraw square(1) color: #orange;\n\t}\n\taspect image{\n\t\tdraw izardShape size: 3;\n\t}\n}\n\n// We create a grid with the same dimensions as the matrix in which we want to store the image\n// Note that the height (resp. the width) of the grid corresponds to the number of rows (resp. of columns) of the matrix:\n// - in the creation of a matrix: ([...] as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;)\n// - in the creation of the grid: grid cellule width: widthImg/factorDiscret height: heightImg/factorDiscret;\n\ngrid cell  width: int(widthImg/factorDiscret) height: int(heightImg/factorDiscret);\n\n\n\nexperiment main type: gui {\t\n\t// We can thus compare the original MNT image and the discretized image in the grid.\n\t// We define 2 displays:\n\t// 1. with the original MNT image as background + izard agents\n\t// 2. with the grid + izard agents \n\toutput {\n\t\tlayout #split;\n\t\tdisplay Image type:2d antialias:false{\n\t       image mntImageRaster.path;\n\t       species izard aspect: image; \n\t    }   \n\t\tdisplay Grid type:2d antialias:false{\n\t       grid cell;\n\t       species izard aspect: image; \n\t    }   \t    \n\t}\t\n}"}
{"prompt": "Create a GAML model that loads an image from a URL and saves it locally as a shuffled version of the original.", "gaml_code": "/**\n* Name: URLImageImport\n* Author: Drogoul\n* Description: Shows how to load an image from an URL (from the Gama website) and save it locally (the saved version is a shuffled version of the original one)\n* Tags: image, load_file\n*/\nmodel URLImageImport\n\nglobal {\n\timage_file im <- image_file(\"https://raw.githubusercontent.com/wiki/gama-platform/gama/resources/images/general/GamaPlatform.png\");\n\tgeometry shape <- envelope(im);\n\t// We modify a bit the image \n\tmatrix<int> shuffle <- shuffle(im.contents); \n\t// We create a file with the new contents\n\timage_file shuffled_copy <- image_file(\"../images/local_copy.png\", shuffle);\n\tinit {\n\t\t// And save it\n\t\tsave shuffled_copy;\n\t}\n}\n\nexperiment urlImage {\n\toutput {\n\t\tdisplay 'Original' background: #white {\n\t\t\timage im ;\n\t\t}\n\t\tdisplay 'Shuffled_copy' background: #white {\n\t\t\timage  shuffled_copy;\n\t\t}\n\n\t}\n}"}
{"prompt": "How to load a CSV file into a matrix and display its contents in the console using GAML.", "gaml_code": "/**\n* Name: Convertion of CSV data to Matrix\n* Author:  Patrick Taillandier\n* Description: Model which shows how to initialize a matrix by using the content of a CSV File. The model load a CSV File, and write its content in the console. \n* Tags: csv, load_file\n*/\n\n\nmodel CSVfileloading\n\nglobal {\n\tfile my_csv_file <- csv_file(\"../includes/iris.csv\",\",\");\n\t\n\tinit {\n\t\t//convert the file into a matrix\n\t\tmatrix data <- matrix(my_csv_file);\n\t\t//loop on the matrix rows (skip the first header line)\n\t\tloop i from: 1 to: data.rows -1{\n\t\t\t//loop on the matrix columns\n\t\t\tloop j from: 0 to: data.columns -1{\n\t\t\t\twrite \"data rows:\"+ i +\" colums:\" + j + \" = \" + data[j,i];\n\t\t\t}\t\n\t\t}\t\t\n\t}\n}\n\nexperiment main type: gui;"}
{"prompt": "Create a 3D simulation of animated GIFs being used as textures or displayed directly, including fish swimming and water ripples, using the NetLogo modeling language.", "gaml_code": "/**\n* Name: AnimatedGIFLoading\n* Author: A. Drogoul\n* Description:  Shows how to load animated GIF files and use them as textures or display them directly. \n* Tags: Image, Display, File\n*/\n\nmodel AnimatedGIFLoading\n\nglobal {\n\tinit {\n\t\tcreate fish number: 100;\n\t}\n}\n\n\tspecies fish skills:[moving] {\n\t\treflex r {\n\t\t\tdo wander amplitude:2.0 speed: 0.1;\n\t\t}\n\t\t\n\t\taspect default {\n\t\t\tdraw gif_file(\"../images/fish3.gif\") size: {10,10} rotate: heading-45 ;\n\t\t}\n\t}\n\n\nexperiment \"Ripples and Fish\" type: gui {\n\t\n\toutput synchronized: true{\n\t\tdisplay Ripples  type: 3d camera: #from_up_front\n\t\t{\n\t\t\tspecies fish position: {0,0,0.05};\n\t\t\tgraphics world transparency: 0.4{ \n\t\t\t\tdraw cube(100) scaled_by {1,1,0.08} texture:(\"../images/water2.gif\") ;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a NetLogo model that displays PNG icons in both 3D and 2D, allowing them to be resized and rotated dynamically.", "gaml_code": "/**\n* Name: PNGIcons\n* Author: drogoul\n* Description: Shows how to load icons in PNG format and display them, playing with their size and rotation\n* Tags: Image, Display\n*/\nmodel PNGIcons\n\n\nglobal\n{\n// We fist load the folder of icons\n\tdirectory icons <- directory(\"../includes/icons/\");\n\t// And filter the file names that contain \"png\"\n\tlist<image_file> file_list <- icons select (each contains (\"png\")) collect (png_file: image_file(icons.path + \"/\" + png_file));\n\t// We give an arbitrary size to the world \n\tgeometry shape <- envelope(200);\n\tinit\n\t{\n\t// We create a number of people equivalent to the number of icons\n\t\tcreate people number: length(file_list) ;\n\t}\n\n}\n\nspecies people skills: [moving]\n{\n\t\n// Each people is provided with the path of its icon (can be changed dynamically, of course)\n\timage_file icon <- file_list[int(self)];\n\t// 'increment' is used to change the size dynamically\n\tint increment <- 1;\n\t// The size with which the icon will be displayed (w.r.t. to the size of the world). It is incremented or decremented each step\n\tint size <- rnd(int(world.shape.width / 4)) update: size + increment on_change:\n\t{\n\t\tif (increment = 1)\n\t\t{\n\t\t// When the size is greater than the half the size of the world, the 'increment' becomes -1\n\t\t\tif (size > world.shape.width / 2)\n\t\t\t{\n\t\t\t\tincrement <- -1;\n\t\t\t}\n\n\t\t} else\n\t\t{\n\t\t// Otherwise if the size is too small, 'increment\" becomes 1\n\t\t\tif (size < 1)\n\t\t\t{\n\t\t\t\tincrement <- 1;\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// The default behavior of people is to move around\n\treflex default\n\t{\n\t//\theading <- heading + 30;\n\t\tdo wander amplitude: 100.0;\n\t}\n\n\t// The default aspect will be used when no other aspect is invoked in displays\n\taspect 3d\n\t{ \n\t\t// We draw the image corresponding to the path, with a size given by 'size' and we use the heading of the people to rotate it\n\t\tdraw \tsphere(size/4) \n\t\t\t\tlighted: false \n\t\t\t\trotate:heading \n\t\t\t\twireframe: false \n\t\t\t\ttexture: icon \n\t\t\t\tat: location + {0,0,increment} \n\t\t\t\tcolor: rgb (251, 217, 113,255);\n \t}\n \t\n \taspect java2d {\n \t\t// We draw the image corresponding to the path, with a size given by 'size' and we use the heading of the people to rotate it\n\t\tdraw icon size: size/2 rotate: heading;\n \t}\n\n}\n\nexperiment Icons\n{\n\t// We slow down the simulation in order to see something !\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\t\n\t\tdisplay \"Colorful in 3D\" type: 3d axes:false\n\t\t{\n\t\t\t// We simply display people, which will use their aspect named 3d\n\t\t\tspecies people aspect: 3d;\n\t\t}\n\t\t\n\t\tdisplay \"Colorful in 2D\" type:  2d {\n\t\t\t\n\t\t\t// Idem for 2d\n\t\t\tspecies people aspect: java2d;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a model that loads data from a CSV file and creates agents based on its attributes, where each agent has specific characteristics linked to the corresponding columns of the CSV file.", "gaml_code": "/**\n* Name: CSV to Agents Model\n* Author:  Patrick Taillandier\n* Description: Model which shows how to create agents by importing data of a CSV file. The model read the CSV File and create an agent Iris for each line of the CSV, \n* \tlinking its attributes to columns of the CSV File. \n* Tags: csv, load_file\n*/\n\nmodel CSVfileloading\n\nglobal {\n\t\n\tinit {\n\t\t//create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \n\t\t//we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n\t\tcreate iris from:csv_file( \"../includes/iris.csv\",true) with:\n\t\t\t[sepal_length::float(get(\"sepallength\")), \n\t\t\t\tsepal_width::float(get(\"sepalwidth\")), \n\t\t\t\tpetal_length::float(get(\"petallength\")),\n\t\t\t\tpetal_width::float(get(\"petalwidth\")), \n\t\t\t\ttype::string(get(\"type\"))\n\t\t\t];\t\n\t}\n}\n\nspecies iris {\n\tfloat sepal_length;\n\tfloat sepal_width;\n\tfloat petal_length;\n\tfloat petal_width;\n\tstring type;\n\trgb color ;\n\t\n\tinit {\n\t\tcolor <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n\t}\n\t\n\taspect default {\n\t\tdraw circle(petal_width) color: color; \n\t}\n}\n\nexperiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies iris;\n\t\t}\n\t}\n\t\n}"}
{"prompt": "How can I import an OSM file into GAMA and create agents for roads and buildings?", "gaml_code": "/**\n* Name: OSM file to Agents\n* Author:  Patrick Taillandier\n* Description: Model which shows how to import a OSM File in GAMA and use it to create Agents. In this model, a filter is done to take only into account the roads \n* and the buildings contained in the file. \n* Tags:  load_file, osm, gis\n*/\nmodel simpleOSMLoading\n\n\nglobal\n{\n\n//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\tmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\", \"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);\n\t//OSM file to load\n\tfile<geometry> osmfile;\n\n\t//compute the size of the environment from the envelope of the OSM file\n\tgeometry shape <- envelope(osmfile);\n\tinit\n\t{\n\t//possibility to load all of the attibutes of the OSM data: for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\t\tcreate osm_agent from: osmfile with: [highway_str::string(read(\"highway\")), building_str::string(read(\"building\"))];\n\n\t\t//from the created generic agents, creation of the selected agents\n\t\task osm_agent\n\t\t{\n\t\t\tif (length(shape.points) = 1 and highway_str != nil)\n\t\t\t{\n\t\t\t\tcreate node_agent with: [shape::shape, type:: highway_str];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (highway_str != nil)\n\t\t\t\t{\n\t\t\t\t\tcreate road with: [shape::shape, type:: highway_str];\n\t\t\t\t} else if (building_str != nil)\n\t\t\t\t{\n\t\t\t\t\tcreate building with: [shape::shape];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//do the generic agent die\n\t\t\tdo die;\n\t\t}\n\n\t}\n\n}\n\nspecies osm_agent\n{\n\tstring highway_str;\n\tstring building_str;\n}\n\nspecies road\n{\n\trgb color <- rnd_color(255);\n\tstring type;\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies node_agent\n{\n\tstring type;\n\taspect default\n\t{\n\t\tdraw square(3) color: # red;\n\t}\n\n}\n\nspecies building\n{\n\taspect default\n\t{\n\t\tdraw shape color: #grey;\n\t}\n\n}\n\nexperiment \"Load OSM\" type: gui\n{\n\tparameter \"File:\" var: osmfile <- file<geometry> (osm_file(\"../includes/rouen.gz\", filtering));\n\toutput\n\t{\n\t\tdisplay map type: 3d\n\t\t{\n\t\t\tspecies building refresh: false;\n\t\t\tspecies road refresh: false;\n\t\t\tspecies node_agent refresh: false;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Load OSM from Internet\" type: gui parent: \"Load OSM\"\n{\n\tparameter \"File:\" var: osmfile <- file<geometry> (osm_file(\"http://download.geofabrik.de/europe/andorra-latest.osm.pbf\", filtering));\n\t\n}"}
{"prompt": "Create a 3D shapefile model that loads and displays a 3D object from a Shapefile using NetLogo's GAML language.", "gaml_code": "/**\n* Name: 3D shapefile loading\n* Author:  \n* Description: Model which shows how to create a shape using a 3D Shapefile after this one has been loaded. \n* Tags: 3d, shapefile, load_file\n*/\nmodel shapefile_loading\n\nglobal {\n\t \n\t//file variable that will store the shape file : the \"true\" argument allows to specify that we want to take into account the 3D dimension of the data\n\tfile shape_file_gis_3d_objects <- shape_file('../includes/Mobilier.shp', true);\n\tgeometry shape <- envelope(shape_file_gis_3d_objects);\n\tinit {\n\t\tcreate gis_3d_object from: shape_file_gis_3d_objects with:[location::location];\n\t}\n}\n\nspecies gis_3d_object {\n\taspect base {\n\t\tdraw shape  color: #gray border: #darkgray width: 4;\n\t}\n}\n\nexperiment display_shape type: gui {\n\n\toutput {\n\t\tdisplay city_display type: 3d axes:false background: #black{\n\t\t\tspecies gis_3d_object aspect: base;\n\t\t}\n\n\t}\n}"}
{"prompt": "Vectorize a synthetic environment from an image file and save the result as a shapefile, considering color-based species classification.", "gaml_code": "/***\n* Name: EscapeTrainingEnvironment\n* Author: pataillandie and kevinchapuis\n* Description: Vectorize an image and save result into shapefile\n* Tags: Vectorization, image, synthetic environment\n***/\n\nmodel EscapeTrainingEnvironment\n\nglobal {\n\t\n\t/*\n\t * How precise the vectorization is\n\t */\n\tfloat resolution_factor <- 0.2max:1.0;\n\t \n\t/*\n\t * Import the image to vectorize\n\t */\n\timage_file im <- image_file(\"../images/drawing.png\");\n\t\n\t/*\n\t * Get the resolution of the image\n\t */\n\tint res_x <- int(envelope(im).width);\n\tint res_y <- int(envelope(im).height);\n\t\n\t/*\n\t * \n\t * Adapt the underlying grid to vectorize and the shape of the world\n\t * according to image resolution and the ratio of vectorization\n\t * \n\t */\n\tint g_x <- int(res_x * resolution_factor);\n\tint g_y <- int(res_y * resolution_factor);\t\n\tgeometry shape <- rectangle(res_x,res_y);\n\t\n\t/*\n\t * The color and associated species\n\t * WARNING: Model specific\n\t */\n\tmap<rgb,string> color_to_species <- [\n\t\t#brown::string(ground),#blue::string(water),#yellow::string(beach),\n\t\t#green::string(tree),#gray::string(building)\n\t];\n\t\n\tinit {\n\t\tfloat t <- gama.machine_time;\n\t\t\n\t\twrite \"START CREATION OF THE ENVIRONMENT\";\n\t\t\n\t\twrite \"Image resolution : \"+string(res_x)+\" x \"+string(res_y);\n\t\t\n\t\t/*\n\t\t * Manage resolution ratio\n\t\t */\n\t\tfloat factorDiscret_width <- res_y / g_y;\n\t\tfloat factorDiscret_height <- res_x / g_x;\n\t\task cell {\t\t\n\t\t\tcolor <-rgb( (im) at {grid_x * factorDiscret_height,grid_y * factorDiscret_width}) ;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Find the different color in the image\n\t\t */\n\t\tmap<rgb, list<cell>> cells_per_color <- cell group_by each.color;\n\t\t\n\t\twrite \"Found \"+length(cells_per_color)+\" color in the draw\";\n\t\t\n\t\t/*\n\t\t * Loop over all colors and match them with proper species\n\t\t */\n\t\tloop col over: cells_per_color.keys {\n\t\t\tgeometry geom <- union(cells_per_color[col]) + 0.001;\n\t\t\tif (geom != nil) {\n\t\t\t\t\n\t\t\t\twrite \"--------\";\n\t\t\t\trgb best_match;\n\t\t\t\tlist<int> bm <- [255,255,255];\n\t\t\t\tloop cl over:color_to_species.keys {\n\t\t\t\t\tint r <- abs(cl.red-col.red);\n\t\t\t\t\tint g <- abs(cl.green-col.green);\n\t\t\t\t\tint b <- abs(cl.blue-col.blue);\n\t\t\t\t\tif(r+g+b < sum(bm)){\n\t\t\t\t\t\tbest_match <- cl;\n\t\t\t\t\t\tbm <- [r,g,b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twrite \"Detected color image [\"+string(col)+\"] has been associated to [\"+string(best_match)+\"]\";\n\n\t\t\t\t/*\n\t\t\t\t * Create the proper species where color have been detected\n\t\t\t\t */\n\t\t\t\tstring species_name <- color_to_species[best_match];\n\t\t\t\tswitch species_name {\n\t\t\t\t\tmatch string(water) {\n\t\t\t\t\t\tcreate water from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(ground) {\n\t\t\t\t\t\tcreate ground from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(beach) {\n\t\t\t\t\t\tcreate beach from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(tree) {\n\t\t\t\t\t\tcreate tree from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(building) {\n\t\t\t\t\t\tcreate building from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite \"END - TIME ELAPSE: \"+((gama.machine_time-t)/1000)+\"sec\";\n\t\t\n\t\twrite \"EXPORT TO FILES\";\n\t\tsave water to:\"../results/water_body.shp\" ;\n\t\tsave ground to:\"../results/ground.shp\" ;\n\t\tsave beach to:\"../results/beach.shp\" ;\n\t\tsave tree to:\"../results/trees.shp\" ;\n\t\tsave building to:\"../results/building.shp\" ;\n\t\t\n\t}\n\t\n}\n\ngrid cell  width: g_x height: g_y;\n\nspecies water {\n\taspect default {\n\t\tdraw shape color: #navy border: #black;\n\t}\n}\n\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nspecies ground {\n\taspect default {\n\t\tdraw shape color: rgb (128, 64, 3) border: #black;\n\t}\n}\n\nspecies beach {\n\tfloat capacity;\n\taspect default {\n\t\tdraw shape color:#yellow;\n\t}\n}\n\nspecies tree {\n\taspect default {\n\t\tdraw shape border:#black color:#green;\n\t}\n}\n\nexperiment Vectorize type: gui {\n\tparameter var:resolution_factor;\n\t\n\toutput {\n\t\tdisplay map_vector type:3d axes:false{\n\t\t\tspecies water;\n\t\t\tspecies ground;\n\t\t\tspecies beach;\n\t\t\tspecies tree;\n\t\t\tspecies building;\n\t\t}\n\t\tdisplay image {\n\t\t\timage im;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that imports a GML file and uses it to create agents representing roads in a GIS environment.", "gaml_code": "/**\n* Name: GML File to Agents\n* Author:  Patrick Taillandier\n* Description: Model which shows how to import a GML (Geography Markup Language) file in GAMA and use it to create Agents.\n* Tags:  load_file, gml file, gis\n*/\nmodel simpleGMLfileLoading\n\n\n\nglobal { \n\tfile gml_file_roads <- gml_file(\"../includes/road.gml\", \"EPSG:2154\" );\n\t\n\t//definition of the geometry of the world agent (environment) as the envelope of the gml file\n\tgeometry shape <- envelope(gml_file_roads);\n\t\n\tinit {\n\t\t//creation of the road agents from the gml file: the name and type attributes of the road agents are initialized according to the NOM and TYPE attributes of the gml file\n\t\tcreate road from: gml_file_roads with:[name::string(get(\"NOM\")), type::string(get(\"TYPE\"))] ;\n\t}\n}\n\nspecies road {\n\tstring type;\n\trgb color <- #black;\n\t\n\taspect default {\n\t\tdraw shape  color: color;\n\t\tdraw type color: #black;\n\t}\n\t\n}\n\nexperiment GIS_agentification type: gui {\n\toutput {\n\t\tdisplay city_display  {\n\t\t\tspecies road;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAML model that loads graph files and imports attributes from graphml datafiles, visualizing the graph in 3D using a GUI.", "gaml_code": "/**\n* Name: GraphAttributesImportation\n* Author: K. Johnson and B. Gaudou\n* Description:  Shows how to load graph files and import attributes. \n* Tags: Graph, File\n*/\n\nmodel GraphAttributesImportation\n\nglobal {\n\t\n\tstring type <- \"graphml\" among: [\"graphml\"]; \n\t\n\tgraph<node_graph,edge_graph> g;\n\t\n\tinit {\n\t\tdo importation;\t\t\n\t}\n\t\n\treflex reimport {\n\t\tdo importation;\n\t}\n\t\n\taction importation {\t\n\t\t// Up to now, attributes importation are only available for graphml\tdatafiles.\n\t\tswitch type {\n\t\t\tmatch \"graphml\" {\n\t\t\t\t// att and attEdges are the name of the attribute off the nodde_graph and edge_graph species\n\t   \t\t\tg <- graphml_file(\"../includes/graphs/agents-attributes.graphml\", node_graph, edge_graph,\"att\",\"attEdges\").contents; \n\t\t\t}\n\t\t}\n\t\t\t\n\t\task node_graph {\n\t   \t\tdo init_agt;\n\t\t}\n\t\task edge_graph {\n\t\t\tdo init_agt;\n\t\t}\n\t\t\n\t\twrite g;\t\t\n\t}\n}\n\nspecies edge_graph {   \n\tfloat prob <- 0.0;\n\trgb my_color <- #green;\n    map<string,string> attEdges;\t\n    \n    action init_agt {\n    \tname <- attEdges[\"name\"]; \n    \tprob <- float(attEdges[\"prob\"]);\t\t\n    }\n}\n\nspecies node_graph {\n    map<string,string> att;\n    \n    action init_agt {\n    \tlocation <- {att[\"xpoint\"] as float,att[\"ypoint\"] as float}; \t\t\n    }\n}\n\nexperiment import_graph type: gui {\n\t\n\tparameter var:type;\n\t\n\toutput {\n\t\tdisplay graph_display type: 3d axes: false{\n\t\t\tgraphics \"graph \" {\n\t\t\t\t\n\t\t\t\tloop v over: g.vertices {\n\t\t\t\t\tdraw circle(1) at: v.location color: #red border: #black;\n\t\t\t\t}\n\t\t\t\tloop e over: g.edges {\n\t\t\t\t\tnode_graph s <- g source_of e;\n\t\t\t\t\tnode_graph t <- g target_of e;\n\t\t\t\t\tdraw line([s.location, t.location]) color: #black end_arrow: 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}"}
{"prompt": "Create a 3D model of a teapot that can be loaded and displayed by agents in a simulation environment.", "gaml_code": "/**\n* Name: Complex Object Loading\n* Author:  Arnaud Grignard\n* Description: Provides a  complex geometry to agents (svg,obj or 3ds are accepted). The geometry becomes that of the agents.\n* Tags:  load_file, 3d, skill, obj\n*/\n\nmodel obj_loading   \n\nglobal {\n\t\n\tgeometry shape <- square(10000);\n\n\tinit { \n\t\tcreate object{\n\t\t\tlocation <- world.location;\n\t\t}\n\t}  \n} \n\nspecies object {\n\t\n\tgeometry shape <- obj_file(\"../includes/teapot.obj\") as geometry;\n\n\n\t\t\t\n}\t\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay complex  background:#gray type: 3d{\n\t\t  species object;\t\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Load a GEOJSON file and display its geometries as a 3D grid with labels in a GUI environment.", "gaml_code": "/**\n* Name: GEOJSON File Loading\n* Author:  Alexis Drogoul\n* Description: Initialize a set of geometries from a GEOJSON FIle. \n* Tags:  load_file, grid, json, gis\n*/\n\nmodel geojson_loading   \n\nglobal {\n\tfile geo_file <- geojson_file(\"../includes/countries.geojson\");\n\tgeometry shape <- envelope(geo_file);\n\tinit {\n\t\tcreate countries from: geo_file with: [name::read(\"name\")];\n\t}\n} \n\nspecies countries {\n\trgb color <- rnd_color(255);\n\trgb text_color <- (color.brighter);\n\t\n\tinit {\n\t\tshape <- (simplification(shape,0.01));\n\t}\n\taspect default {\n\t\tdraw shape color: color depth: 10;\n\t\tdraw name font: font(\"Helvetica\", 12 + #zoom, #bold) color: #black at: location + {0,0,12} perspective:false;\n\t}\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay Countries type: 3d{\t\n\t\t\tspecies countries;\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that imports a Shapefile and uses it to create Agents with attributes from the Shapefile, displaying them in 3D.", "gaml_code": "/**\n* Name: Shapefile to Agents\n* Author:  Patrick Taillandier\n* Description: Model which shows how to import a Shapefile in GAMA and use it to create Agents.\n* Tags:  load_file, shapefile, gis\n*/\nmodel simpleShapefileLoading\n\n\n\nglobal {\n\tfile shape_file_buildings <- shape_file(\"../includes/buildings_simple.shp\");\n\t\n\t//definition of the geometry of the world agent (environment) as the envelope of the shapefile\n\tgeometry shape <- envelope(shape_file_buildings);\n\t\n\tinit {\n\t\t//creation of the building agents from the shapefile: the height and type attributes of the building agents are initialized according to the HEIGHT and NATURE attributes of the shapefile\n\t\tcreate building from: shape_file_buildings with:[height::float(get(\"HEIGHT\")), type::string(get(\"NATURE\"))];\n\t}\n}\n\nspecies building {\n\tfloat height;\n\tstring type;\n\trgb color <- type = \"Industrial\" ? #pink : #gray;\n\t\n\taspect default {\n\t\tdraw shape depth: height color: color;\n\t}\n\t\n}\n\nexperiment GIS_agentification type: gui {\n\toutput {\n\t\tdisplay city_display type: 3d axes:false{\n\t\t\tspecies building;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that demonstrates the to_GAMA_CRS operator for translating WGS84 coordinates to GAMA CRS using a shapefile and CSV data.", "gaml_code": "/**\n* Name: To GAMA CRS\n* Author: Patrick Taillandier\n* Description: A model which shows how to to_GAMA_CRS operator which allows to translate a geometry (or a point) to GAMA CRS\n* Tags:  gis, shapefile, spatial_computation, spatial_transformation, projection\n*/\nmodel To_GAMA_CRS\n\nglobal {\n\t\n\tfile building_file <- shape_file(\"../gis/init.shp\");\n\tfile data_csv_file <- csv_file(\"../gis/data.csv\", \",\", float);\n\t\n\tgeometry shape <- envelope(building_file); //set the GAMA coordinate reference system using the one of the building_file (Lambert zone II).\n\t\n\tinit {\n\t\tcreate building from: building_file;\n\t\tmatrix<float> data <- matrix<float>(data_csv_file);\n\t\tloop i from: 0 to: data.rows - 1 {\n\t\t\tpoint poi_location_WGS84 <- {data[0,i],data[1,i]};\n\t\t\tpoint poi_location_GAMA <- point(to_GAMA_CRS(poi_location_WGS84, \"EPSG:4326\"));\n\t\t\twrite \"\\nPOI location - WGS84: \" + poi_location_WGS84 +\"\\nGAMA CRS: \"+ poi_location_GAMA; \n\t\t\tcreate poi with: [location::poi_location_GAMA];\n\t\t}\n\t}\n}\n\nspecies poi {\n\taspect default {\n\t\tdraw circle(5) color: #red border: #black;\n\t}\n}\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\n\nexperiment ProjectionManagement type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies building;\n\t\t\tspecies poi;\n\t\t}\n\t}\n}"}
{"prompt": "Create a GAMA model that demonstrates the CRS_transform operator to translate a geometry from GAMA's coordinate reference system to WGS84 and UTM 31N, using a shapefile as input.", "gaml_code": "/**\n* Name: From GAMA CRS\n* Author: Patrick Taillandier\n* Description: A model which shows how to CRS_transform operator which allows to translate a geometry (or a point) in GAMA CRS to a given CRS\n* Tags:  gis, shapefile, spatial_computation, spatial_transformation, projection\n*/\nmodel From_GAMA_CRS\n\nglobal {\n\t\n\tfile building_file <- shape_file(\"../gis/init.shp\");\n\tgeometry shape <- envelope(building_file); //set the GAMA coordinate reference system using the one of the building_file (Lambert zone II).\n\t\n\tinit {\n\t\tcreate building from: building_file;\n\t\t\n\t\tpoint poi_location <- first(building).location; //location of the first building in the GAMA reference system\n\t\t\n\t\tcreate poi with: [location::poi_location];\n\t\t\n\t\tpoint poi_location_WGS84 <- CRS_transform(poi_location, \"EPSG:4326\").location; //project the point to WGS84 CRS\n\t\t\n\t\tpoint poi_location_UTM31N <- CRS_transform(poi_location, \"EPSG:32631\").location; //project the point to UMT 31N CRS\n\t\t\n\t\twrite \"POI location - GAMA coordinates: \" + poi_location +\"\\nWGS84: \"+ poi_location_WGS84 + \"\\nUTM 31N: \" + poi_location_UTM31N; \n\t\t\n\t\n\t}\n}\n\nspecies poi {\n\taspect default {\n\t\tdraw circle(5) color: #red border: #black;\n\t}\n}\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\n\nexperiment ProjectionManagement type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies building;\n\t\t\tspecies poi;\n\t\t}\n\t}\n}"}
{"prompt": "Can you write a simple GAML model that tests the reachability of a web address using the is_reachable operator?", "gaml_code": "/**\n* Name: TestWebAddress\n* Example of the is_reachable operator to test the reachability of an web address\n* Author: Patrick Taillandier \n* Tags: Web address\n*/\n\nmodel WebUtils\n\nglobal {\n\tstring address_to_test <- \"www.google.com\";\n\tint time_out <- 200; // the time, in milliseconds, before the call aborts\n\tinit {\n\t\twrite \"Is address \\\"\" + address_to_test +\"\\\" is reachable: \" + (is_reachable(address_to_test, 200));\t\t\t\n\t}\n\t\n}\n\nexperiment testWebAddress type: gui ;"}
{"prompt": "Show an example of how to use file operators in GAML, including copying, deleting, renaming files and folders, checking folder existence, and listing contents.", "gaml_code": "/**\n* Name: Copyfile\n* Example of file operators\n* The delete_file operator is used to delete a file or a folder \n* The rename_file is used to rename a file or a folder\n* The copy_file operator is used to copy a file or a folder\n* Author: Patrick Taillandier and Tri Nguyen-Huu\n* Tags: file\n*/\n\nmodel FileUtils\n\nglobal {\n\tinit {\n\t\tsave \"testA\" to: \"a_folder/fileA.txt\";\n\t\t\n\t\tbool copy_file_ok <- copy_file(\"a_folder/fileA.txt\",\"a_folder/fileB.txt\");\n\t\t\n\t\twrite \"copy file is ok: \" + copy_file_ok;\n\t\t\n\t\tbool delete_file_ok <- delete_file(\"a_folder/fileA.txt\");\n\t\t\n\t\twrite \"delete file is ok: \" + delete_file_ok;\n\t\t\n\t\tbool rename_file_ok <- rename_file(\"a_folder/fileB.txt\",\"a_folder/fileA.txt\");\n\t\t\n\t\twrite \"rename file is ok: \" + rename_file_ok;\n\t\t\n\t\tbool delete_folder_ok <- delete_file(\"a_folder\");\n\t\n\t\twrite \"delete folder is ok: \" + delete_folder_ok;\n\t\t\n\t\tbool folder_exist_ok <- folder_exists(\"..\");\n\t\t\n\t\twrite \"folder exists ok: \" + folder_exist_ok;\n\t\t\n\t\tfile current_folder <- folder(\".\");\n\t\t\n\t\twrite \"folder the model is in: \"+current_folder;\n\t\t\n\t\tlist folder_contents <- current_folder.contents;\n\t\t\n\t\twrite \"list of file inside the model folder: \"+ folder_contents;\n\t\t\t\n\t}\n\t\n}\n\nexperiment fileUtils type: gui ;"}
{"prompt": "I want to demonstrate an example of using the zip and unzip operators in a model to compress and decompress files.", "gaml_code": "/**\n* Name: ZipUnzip\n* Example of use of the zip and unzip operators to compress/uncompress files \n* Author: Patrick Taillandier\n* Tags: file\n*/\n\nmodel ZipUnzip\n\nglobal {\n\n\tinit {\n\t\t//zip fileA.txt and folderB into the archive.zip file\n\t\tbool zip_ok <- zip([\"../includes/fileA.txt\", \"../includes/folderB\"], \"archive.zip\");\n\t\twrite \"Zip operation is \" + (zip_ok ? \"ok\" : \"not ok\");\n\t\t\n\t\t//unzip the archive.zip file into the results folder\n\t\tbool unzip_ok<- unzip( \"archive.zip\", \"results\");\n\t\twrite \"Unzip operation is \" + (unzip_ok ? \"ok\" : \"not ok\");\n\t}\n}\n\nexperiment ZipUnzip type: gui ;"}
{"prompt": "**The code provided is a GAMA (General Agent Modeling Architecture) simulation script for downloading and processing GIS data from various sources, including Google Maps. The script includes several actions and species definitions for handling different types of data and visualizing them in a 3D map display.**", "gaml_code": "/**\n* Name: generate_environment\n* Author: Patrick Taillandier\n* Description: Demonstrates how to import data from OSM, Bing and google map to generate geographical data. More precisely, the model allows from a shapefile giving the area of the study area to download all the OSM data on this area, to vectorize the buildings and the points of interest from google map data and to download a Bing satellite image of the area.\n* Tags: data_loading, OSM, Google Map, Bing, shapefile\n*/\nmodel download_spatial_data\n\nglobal {\n\n/* ------------------------------------------------------------------ \n\t * \n\t *             MANDATORY PARAMETERS\n\t * \n\t * ------------------------------------------------------------------\n\t */\n\n\t//define the bounds of the studied area\n\tfile data_file <-shape_file(\"../includes/boundary.shp\");\n\t\n\t//path where to export the created shapefiles\n\tstring exporting_path <- \"results/\";\n\t\n\t//if true, GAMA is going to use OSM data to create the building file\n\tbool use_OSM_data <- true;\n\t\n\t//if true, GAMA is going to use google map image to create the building file\n\tbool use_google_map_data <- true;\n\t\n\t//if true, GAMA is going to download the background satellite image (Bing image).\n\tbool do_load_satellite_image <- true;\n\t\n\t//image to display as background if there is no satellite image\n\tstring default_background_image <- \"../includes/white.png\";\n\t\n\t/* ------------------------------------------------------------------ \n\t * \n\t *             OPTIONAL PARAMETERS\n\t * \n\t * ------------------------------------------------------------------\n\t */\n\t// --------------- OSM data parameters ------------------------------\n\t//path to an existing Open Street Map file - if not specified, GAMA is going to directly download to correct data\n\tstring osm_file_path <- \"../includes/map.osm\";\n\t\n\t//type of feature considered\n\tmap<string, list> osm_data_to_generate <- [\"building\"::[], \"shop\"::[], \"historic\"::[], \"amenity\"::[], \"sport\"::[], \"military\"::[], \"leisure\"::[], \"office\"::[],  \"highway\"::[], \"water\"::[], \"natural\"::[], \"landuse\"::[]];\n\t\n\n\t// --------------- google image parameters ------------------------------\n\t//path to an existing google map image - if not speciefied, GAMA can try to download the correct image - WARNING: can be blocked by google\n\tstring googlemap_path <-  \"../includes/googlemap.png\";\n\t\n\t//possibles colors for buildings\n\tlist<rgb> color_bds <- [rgb(241,243,244), rgb(255,250,241)];\n\t\n\t//type of markers considered with their associated color\n\tmap<string,list<rgb>> google_map_type <- [\"restaurant\"::[rgb(255,159,104)], \"shop\"::[rgb(73,149,244),rgb(238,103,92)], \"culture\"::[rgb(18,181,203)], \"nature\"::[rgb(52,168,83)]];\n\t\n\t//number of pixels per tile\n\tint TILE_SIZE <- 256;\n\t\n\t//when downloading google images, the level of zoom\n\tint zoom <- 18 min: 17 max: 20;\n\n\t//min area to consider a building (in m^2)\n\tfloat min_area_buildings <- 20.0 min: 0.0;\n\t\t\n\t//simplification distance for building (using Douglas Peucker algorithm)\n\tfloat simplication_dist <- 1.0 min: 0.0;\n\t\n\t//tolerance (distance in meters) for the union of \"building\" pixels \n\tfloat tolerance_dist <- 0.2 min: 0.0;\n\t\n\t//tolerance for the color of building (for a pixel to be considered as a building pixel)\n\tint tolerance_color_bd <- 1 min: 0 max: 10;\n\t\n\t//tolerance for the color of markers (for a pixel to be considered as a marker pixel)\n\tint tolerance_color_type <- 7 min: 0 max: 20;\n\t\n\t//coefficient (area of the building/area of the convex hull of the building) to keep the convex hull of the building rather than its shape (if convex_hull_coeff = 0.0, the convex hull is never used)\n\tfloat convex_hull_coeff <- 0.05 min: 0.0 max: 1.0;\n\t\n\t//coeffient used to apply a buffer to the building (distance = buffer_coeff * width of a pixel).\n\tfloat buffer_coeff <- 0.5 min: 0.0;\n\t\n\t//parallel computation\n\tbool parallel <- true;\n\t\n\t/* ------------------------------------------------------------------ \n\t * \n\t *              DYNAMIC VARIABLES\n\t * \n\t * ------------------------------------------------------------------\n\t */\n\n\t//geometry of the bounds\n\tgeometry bounds_tile;\n\t\n\t//index used to read google map tiles\n\tint ind <- 0;\n\t\n\t//list of google map tile with their associated metadata\n\tmap<string, map<string,int>> data_google; \n\t\n\t//\n\tlist<geometry> building_google; \n\t\n\t//when using a google map image, the nomber of pixel of this image\n\tint nb_pixels_x <- (use_google_map_data and file_exists(googlemap_path)) ? matrix(image_file(googlemap_path)).columns :1;\n\tint nb_pixels_y <- (use_google_map_data and file_exists(googlemap_path)) ? matrix(image_file(googlemap_path)).rows :1;\n\t\n\t//geometry of the world\n\tgeometry shape <- envelope(data_file);\n\t\n\t\n\tinit {\n\t\twrite \"Start the pre-processing process\";\n\t\tcreate Boundary from: data_file;\n\t\t\n\t\tif use_OSM_data {\n\t\t\tosm_file osmfile;\n\t\t\tif (file_exists(osm_file_path)) {\n\t\t\t\tosmfile  <- osm_file(osm_file_path, osm_data_to_generate);\n\t\t\t} else {\n\t\t\t\tpoint top_left <- CRS_transform({0,0}, \"EPSG:4326\").location;\n\t\t\t\tpoint bottom_right <- CRS_transform({shape.width, shape.height}, \"EPSG:4326\").location;\n\t\t\t\tstring adress <-\"http://overpass-api.de/api/xapi_meta?*[bbox=\"+top_left.x+\",\" + bottom_right.y + \",\"+ bottom_right.x + \",\" + top_left.y+\"]\";\n\t\t\t\twrite \"adress: \" + adress;\n\t\t\t\tosmfile <- osm_file<geometry> (adress, osm_data_to_generate);\n\t\t\t}\n\t\t\t\n\t\t\twrite \"OSM data retrieved\";\n\t\t\tcreate OSM_agent from: osmfile  where (each != nil);\n\t\t\tloop type over: osm_data_to_generate.keys {\n\t\t \t\trgb col <- rnd_color(255);\n\t\t \t\tlist<OSM_agent> ags <-  OSM_agent where (each.shape.attributes[type] != nil);\n\t\t \t\task ags {color <- col;}\n\t\t \t\tlist<OSM_agent> pts <- ags where (each.shape.perimeter = 0);\n\t\t \t\tdo save_data(pts,type,\"point\");\n\t\t \t\t\n\t\t \t\tlist<OSM_agent> lines <- ags where ((each.shape.perimeter > 0) and (each.shape.area = 0)) ;\n\t\t \t\tdo save_data(lines,type,\"line\");\n\t\t \t\t\n\t\t \t\tlist<OSM_agent> polys <- ags where (each.shape.area > 0);\n\t\t \t\tdo save_data(polys,type,\"polygon\");\n\t\t \t}\n\t\t}\t \t\n\t \tif (do_load_satellite_image) {\n\t \t\tdo load_satellite_image;\n\t \t}\n\t \t//load google map image (if necessary)\n\t \tif (use_google_map_data) {\n\t \t\t//if the image already exists, just load this image and vectorize it\n\t\t\tif (file_exists(googlemap_path)) {\n\t\t\t\tdo load_google_image;\n\t\t\t} else {\n\t\t\t\t//otherwise propose to download the image from google (WARNING: direct access to google map image without using the google api (and key) is recommended).\n\t\t\t\tmap input_values <- user_input_dialog(\"Do you want to download google maps to fill in the data? (warning: risk of being blocked by google!)\",[enter(\"Download data\",false), enter(\"Delay (in s) between two requests\",5.0)]);\n\t\t\t\texperiment.minimum_cycle_duration <- max(0.5, float(input_values[\"Delay (in s) between two requests\"]));\n\t\n\t\t\t\t//if the user choose to download the data anyway, build and store the url to the needed tiles.\n\t\t\t\tif bool(input_values[\"Download data\"]) {\n\t\t\t\t\tpoint bottom_right <- CRS_transform({shape.width, shape.height}, \"EPSG:4326\").location;\n\t\t\t\t\tpoint top_left <- bottom_right - (bottom_right - CRS_transform(location, \"EPSG:4326\").location) * 2;\n\t\t\t\t\tlist<int> indtl <- index_tile(top_left);\n\t\t\t\t\tlist<int> indbr <- index_tile(bottom_right);\n\t\t\t\t\t\n\t\t\t\t\tint resolution_x <- abs(indbr[2] - indtl[2])  ;\n\t\t\t\t\tint resolution_y <- abs(indbr[3] - indtl[3]);\t\n\t\t\t\t\tint id_x <- 0;\n\t\t\t\t\tint id_y <- 0;\n\t\t\t\t\tint offset_x <- min(indbr[0],indtl[0]);\n\t\t\t\t\tint offset_y <- min(indbr[1],indtl[1]);\n\t\t\t\t\tloop ind_tile_x from: 0 to: abs(indbr[0] - indtl[0])  {\n\t\t\t\t\t\tloop ind_tile_y from: 0 to:abs(indtl[1] - indbr[1]) {\n\t\t\t\t\t\t\tstring img <- \"http://mt2.google.com/vt/lyrs=m&x=\" +(ind_tile_x + offset_x)+\"&y=\"+ (ind_tile_y  + offset_y)+\"&z=\"+zoom;\n\t\t\t\t\t\t\tdata_google[img] <- [\"ind_tile_x\":: (ind_tile_x + offset_x) ,  \"ind_tile_y\"::(ind_tile_y + offset_y)];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tbool acceptable_color(rgb current_col, rgb ref_col) {\n\t\treturn ((abs(current_col.red - ref_col.red)+abs(current_col.green - ref_col.green) + abs(current_col.blue - ref_col.blue)) < tolerance_color_bd);\n\t}\n\t\n\tlist<geometry> keep_cell(list<geometry> rectangles, list<rgb> colors, list<rgb> color_ref) {\n\t\tlist<geometry> cells_to_keep;\n\t\tloop i from: 0 to: length(rectangles) - 1 {\n\t\t\tgeometry r <- rectangles[i];\n\t\t\trgb col_r <- colors[i];\n\t\t\tloop col over: color_ref {\n\t\t\t\tif acceptable_color(col_r,col) { \n\t\t\t\t\tcells_to_keep << r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cells_to_keep;\n\t}\n\t\n\tlist<geometry> generate_geoms(list<geometry> cells) {\n\t\t//if this list is not empty, recompute the geometry of each element\n\t\tgeometry geom <- union(cells collect (each + tolerance_dist));\n\t\t\t\n\t\tlist<geometry> output_el <- geom.geometries collect clean(each);\n\t\t\t\n\t\t//keep only elements inside the boundary\n\t\toutput_el <- output_el where (not empty(Boundary overlapping each));\n\t\t\t\t\t\t\n\t\t//apply a buffer to the element to take into account the imperfection of the vectorization\n\t\tif (buffer_coeff > 0) {\n\t\t\tfloat buffer_dist <- first(cells).width * buffer_coeff;\n\t\t\toutput_el <- output_el collect (each + buffer_dist);\n\t\t}\n\t\treturn output_el;\n\t}\n\t\n\tlist<geometry> define_building_from_image(list<geometry> rectangles, list<rgb> colors) {\n\t\tlist<geometry> building ;\n\t\t\n\t\t//select the building pixel\n\t\tlist<geometry> cells_building <- keep_cell(rectangles, colors, color_bds);\n\t\t\n\t\tif (not empty(cells_building)) {\n\t\t\t\n\t\t\tbuilding <- generate_geoms(cells_building);\n\t\t\t\n\t\t\t//simplify the geometry of the building to remove some vectorization acrtifact\n\t\t\tif simplication_dist > 0 {\n\t\t\t\tbuilding <- building collect (each simplification simplication_dist);\n\t\t\t}\n\t\t\t\n\t\t\t//use the convex hull for building that are nearly convex\n\t\t\tif (convex_hull_coeff > 0.0) {\n\t\t\t\tlist<geometry> gs2;\n\t\t\t\tloop g over: building {\n\t\t\t\t\tgeometry ch <- convex_hull(g);\n\t\t\t\t\tif (g.area/ch.area > (1 - convex_hull_coeff)) {\n\t\t\t\t\t\tgs2 << ch;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgs2 << g;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuilding <- gs2;\n\t\t\t}\n\t\t\t//remove building that are too small\n\t\t\tbuilding <- building where (each.area >= min_area_buildings);\n\t\t}\t\t\n\t\t\n\t\t\n\t\t//for each type of marker, create the marker agents from the google image and use to it to give a type to the closest building (of the bottom of the marker)\n\t\tloop type over: google_map_type.keys {\n\t\t\tlist<rgb> col <- google_map_type[type];\n\t\t\t\n\t\t\t//select the pixel of the given color \n\t\t\tlist<geometry> cells_type <- keep_cell(rectangles, colors, col);\n\t\t\t\n\t\t\t\t\t\t\t\n\t\t\tif not empty(cells_type) {\n\t\t\t\t//and build geometries from them\n\t\t\t\tlist<geometry> geom_markers <- generate_geoms(cells_type);\n\t\t\t\t\t\t\t\n\t\t\t\t//create the marker agents\n\t\t\t\tcreate marker from: geom_markers with: [type::type];\n\t\t\t\tfloat min_area <- marker mean_of each.shape.area;\n\t\t\t\t\t\t\t\t\n\t\t\t\task marker {\t\n\t\t\t\t\t//keep only the marker that are not too small (to take into account only \"complete\" markers)\n\t\t\t\t\tif (shape.area < (min_area * 0.5)) {do die;}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcolor <- (type in google_map_type.keys) ? first(google_map_type[type]) : rnd_color(255);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn building;\n\t}\n\t\n\n\t\n\t//reflex used to download a google map tile and to vectorize it\n\treflex vectorization {\n\t\tif (ind < length(data_google)) {\n\t\t\tbool continue <- true;\n\t\t\t//continue until downloading an image located in the boundary\n\t\t\tloop while: continue and (ind < length(data_google)) { \n\t\t\t\t//verify that the tile is really inside the boundary\n\t\t\t\tlist<rgb> colors;\n\t\t\t\tmap<string, int> infos <- data_google[data_google.keys[ind]];\n\t\t\t\tint tx <- infos[\"ind_tile_x\"];\n\t\t\t\tint ty <- infos[\"ind_tile_y\"];\n\t\t\t\tpoint sw <- toMeter(tx*TILE_SIZE, ty*TILE_SIZE);\n\t\t\t\tpoint ne <- toMeter((tx+1)*TILE_SIZE, (ty+1)*TILE_SIZE);\n\t\t\t\tsw <- to_GAMA_CRS(sw, \"EPSG:3857\").location;\n\t\t\t\tne <- to_GAMA_CRS(ne, \"EPSG:3857\").location;\n\t\t\t\t\n\t\t\t\t//build the bounds of the tile\n\t\t\t\tbounds_tile <- polygon({sw.x,sw.y}, {sw.x,ne.y}, {ne.x,ne.y}, {ne.x,sw.y});\n\t\t\t\t\n\t\t\t\t//if the tile really overlaps the boundary\n\t\t\t\tif not empty(Boundary overlapping bounds_tile) {\n\t\t\t\t\tcontinue <- false;\n\t\t\t\t\t// download the google map tile\n\t\t\t\t\tstring path_ <-  data_google.keys[ind];\n\t\t\t\t\timage_file img<- image_file(path_,\"png\");\n\t\t\t\t\t//transform each pixel into a rectangle geometry\n\t\t\t\t\tlist<geometry> rectangles <- bounds_tile to_rectangles(TILE_SIZE,TILE_SIZE);\n\t\t\t\t\tloop i from: 0 to: length(rectangles) - 1 {\n\t\t\t\t\t\tcolors << rgb(img.contents at {int(i/TILE_SIZE),i mod TILE_SIZE});\n\t\t\t\t\t}\n\t\t\t\t\tbuilding_google <- building_google + define_building_from_image(rectangles, colors);\n\t\t\t\t}\n\t\t\t\tind <- ind + 1; \n\t\t\t}\n\t\t} else {\n\t\t\t//at the end, save the building\n\t\t\tif (not empty(building_google)) {\n\t\t\t\tsave building_google crs:\"EPSG:3857\" format: \"shp\" to:exporting_path +\"google_map_building.shp\";\n\t\t\t}\n\t\t\tif (not empty(marker)) {\n\t\t\t\tsave marker format: \"shp\"   crs:\"EPSG:3857\" to: exporting_path + \"google_map_markers.shp\" attributes:[\"type\"];\n\t\t\t}\n\t\t\tdo pause;\n\t\t}\n\t\t\n\t\t \n\t}\n\t\n\t//a function used to compute the coordinate when retrieving google map images\n\tpoint toMeter(int px, int py) {\n\t\tfloat res <- (2 * #pi * 6378137 / TILE_SIZE) / (2^zoom);\n\t\tfloat originShift <- 2 * #pi * 6378137 / 2.0;\n\t\treturn { px * res - originShift,  - py * res + originShift};\n\t} \n\t\n\t//a function to compute the google map tile from coordinate\n\tlist<int> index_tile(point coord) {\n\t\tpoint worldCoordinate <- project_to_wp({coord.x,coord.y});\n\t\tfloat scale <- 2^zoom;\n\t\t\n\t\tint pix <- int(worldCoordinate.x * scale);\n\t\tint piy <- int(worldCoordinate.y * scale);\n\t\tint ind_x <- int(worldCoordinate.x * scale / TILE_SIZE);\n\t\tint ind_y <- int(worldCoordinate.y * scale / TILE_SIZE);\n\t\treturn [ind_x,ind_y,pix,piy];\n\t}\n\t\n\t\n\t//a function to compute the google map coordinate from WGS84 coordinate\n\tpoint project_to_wp(point latLng) {\n\t\tfloat siny <- sin_rad(latLng.y * #pi / 180);\n\t\tsiny <- min(max(siny, -0.9999), 0.9999);\n        return {TILE_SIZE * (0.5 + latLng.x / 360),TILE_SIZE * (0.5 - ln((1 + siny) / (1 - siny)) / (4 * #pi))};\n    }\n\t\n\t\n\taction save_data(list<OSM_agent> ags, string type, string geom_type) {\n\t\tif (not empty(ags)) {\n\t \t\tlist<string> atts <-  remove_duplicates(ags accumulate each.shape.attributes.keys);\n\t \t\tsave (ags collect each.shape) format: \"shp\" to: exporting_path + type + \"_\" + geom_type+\".shp\" attributes: atts;\n\t \t}\n\t}\n\t\n\taction save_image (string rest_link) {\n\t\tmatrix mat <- (image_file(rest_link).contents);\n\t\twrite \"Satellite image retrieved\";\n\t\tsave mat to: exporting_path +\"satellite.png\"; \n\t}\n\t\n\taction save_meta_data (string rest_link) {\n\t\tlist<string> v <- string(json_file(rest_link).contents) split_with \",\";\n\t\twrite \"Satellite image retrieved\";\n\t\tint id <- 0;\n\t\tloop i from: 0 to: length(v) - 1 {\n\t\t\tif (\"bbox\" in v[i]) { \n\t\t\t\tid <- i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} \n\t\tfloat long_min <- float(v[id] replace (\"'bbox'::[\",\"\"));\n\t\tfloat long_max <- float(v[id+2] replace (\" \",\"\"));\n\t\tfloat lat_min <- float(v[id + 1] replace (\" \",\"\"));\n\t\tfloat lat_max <- float(v[id +3] replace (\"]\",\"\"));\n\t\tpoint pt1 <- CRS_transform({lat_min,long_max},\"EPSG:4326\", \"EPSG:3857\").location ;\n\t\tpoint pt2 <- CRS_transform({lat_max,long_min},\"EPSG:4326\",\"EPSG:3857\").location;\n\t\tfloat width <- abs(pt1.x - pt2.x)/1500;\n\t\tfloat height <- (pt2.y - pt1.y)/1500;\n\t\t\t\n\t\tstring info <- \"\"  + width +\"\\n0.0\\n0.0\\n\"+height+\"\\n\"+min(pt1.x,pt2.x)+\"\\n\"+(height < 0 ? max(pt1.y,pt2.y) : min(pt1.y,pt2.y));\n\t\n\t\tsave info to: exporting_path +\"satellite.pgw\" format:\"text\";\n\t}\n\t\n\taction load_satellite_image\n\t{ \n\t\tpoint top_left <- CRS_transform({0,0}, \"EPSG:4326\").location;\n\t\tpoint bottom_right <- CRS_transform({shape.width, shape.height}, \"EPSG:4326\").location;\n\t\tint size_x <- 1500;\n\t\tint size_y <- 1500;\n\t\t\n\t\tstring rest_link<- \"https://dev.virtualearth.net/REST/v1/Imagery/Map/Aerial/?mapArea=\"+bottom_right.y+\",\" + top_left.x + \",\"+ top_left.y + \",\" + bottom_right.x + \"&mapSize=\"+int(size_x)+\",\"+int(size_y)+ \"&key=AvZ5t7w-HChgI2LOFoy_UF4cf77ypi2ctGYxCgWOLGFwMGIGrsiDpCDCjliUliln\" ;\n\t\tdo save_image(rest_link);\n\t\tfloat ct <- gama.machine_time + 2000;\n\t\tloop while: gama.machine_time < ct {\n\t\t\t\n\t\t}\n\t\tstring rest_link2<- \"https://dev.virtualearth.net/REST/v1/Imagery/Map/Aerial/?mapArea=\"+bottom_right.y+\",\" + top_left.x + \",\"+ top_left.y + \",\" + bottom_right.x + \"&mmd=1&mapSize=\"+int(size_x)+\",\"+int(size_y)+ \"&key=AvZ5t7w-HChgI2LOFoy_UF4cf77ypi2ctGYxCgWOLGFwMGIGrsiDpCDCjliUliln\" ;\n\t\tdo save_meta_data(rest_link2);\n\t\t\n\t\twrite \"Satellite image saved with the right meta-data\";\n\t\t \n\t\t \n\t}\n\n\n//action for vectorizing an existing google image\n\taction load_google_image {\n\t\timage_file im <- image_file(googlemap_path);\n\t\task cell_google {\t\t\n\t\t\tcolor <-rgb( (im) at {grid_x ,grid_y }) ;\n\t\t}\n\t\t\t\n\t\tbuilding_google <- building_google + define_building_from_image(cell_google collect each.shape, cell_google collect each.color);\n\t\t\t\t\t\n\t\tif (not empty(building_google)) {\n\t\t\tsave building_google crs:\"EPSG:3857\" format: \"shp\" to:exporting_path +\"google_map_building.shp\";\n\t\t}\n\t\tif (not empty(marker)) {\n\t\t\tsave marker format: \"shp\"   crs:\"EPSG:3857\" to: exporting_path + \"google_map_markers.shp\" attributes:[\"type\"];\n\t\t}\n\t\t\t\n\t\twrite \"google image vectorized\";\n\t}\n\t\t\n}\n\n\nspecies marker {\n\tstring type;\n\tpoint loc_define;\n\taspect default{\n\t\tdraw shape color: google_map_type[type] depth: 1;\n\t}\n}\n\ngrid cell_google width: nb_pixels_x height: nb_pixels_y use_individual_shapes: false use_regular_agents: false neighbors:8;\n\nspecies OSM_agent {\n\trgb color;\n\taspect default {\n\t\tif (shape.area > 0) {\n\t\t\tdraw shape color: color border: #black;\n\t\t} else if shape.perimeter > 0 {\n\t\t\tdraw shape color: color;\n\t\t} else {\n\t\t\tdraw circle(5) color: color;\n\t\t}\n\t\t\n\t}\t\n}\n\nspecies Boundary {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\n\nexperiment downloadGISdata type: gui autorun: true{\n\taction _init_ {\n\t\tbool pref_gis <- gama.pref_gis_auto_crs ;\n\t\tint crs <- gama.pref_gis_default_crs;\n\t\n\t\tgama.pref_gis_auto_crs <- false;\n\t\tgama.pref_gis_default_crs <- 3857;\n\t\tcreate simulation;\n\t\tgama.pref_gis_auto_crs <- pref_gis;\n\t\tgama.pref_gis_default_crs <- crs;\n\t}\n\toutput {\n\t\tdisplay map type: 3d axes: false{\n\t\t\timage file_exists(exporting_path + \"satellite.png\")? (exporting_path + \"satellite.png\") : default_background_image  transparency: 0.2 refresh: true;\n\t\t\tspecies OSM_agent;\n\t\t\tgraphics \"google map building\" {\n\t\t\t\tloop bd over: building_google {\n\t\t\t\t\tdraw bd color: #gray border: #black;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspecies marker;\n\t\t}\n\t}\n}"}
{"prompt": "Design a simple BDI (Belief-Desire-Intention) architecture for a multi-agent system where miners search for and collect gold nuggets in a 3D environment.", "gaml_code": "/**\n *  GoldBdi\n *  Author: Philippe Caillou, Mathieu Bourgais, Patrick Taillandier\n *  Description: A simple model that uses the simple_bdi architecture. In this model, the Miner agent has a general desire to  find gold. \n * As it is the only thing it wants at the beginning, it is its initial intention (what it is currently doing). To  find gold, it wanders around (its plan is to wander). \n * When it perceives some gold nuggets, it stores this information (it has a new belief about the existence and location of this gold nugget), \n * and it adopts a new desire (it wants to extract the gold). When it perceives a gold nugget, the intention to  find gold is put on hold and a new intention is selected (to extract gold).\n * To achieve this intention, the plan has two steps, i.e. two new (sub)intentions: to choose a gold nugget to extract (among its known gold nuggets) and to go and take it. And so on.\n *  Tags: simple_bdi, perception, rule, plan, predicate\n */\n\nmodel GoldBdi\n\nglobal {\n\tint nbgold<-20;\n\tint nbminer<-3;\n\tbase the_base;\n\tgeometry shape <- square(200);\n\tinit\n\t{\n\t\tcreate base {\n\t\t\tthe_base <- self;\n\t\t}\n\t\tcreate gold number:nbgold;\n\t\tcreate miner number:nbminer;\n\t}\n\t\n\treflex stop when:length(gold)=0{\n\t\tdo pause;\n\t}\n}\n\n//give the simple_bdi architecture to the miner agents\nspecies miner skills: [moving] control:simple_bdi {\n\t//definition of the agent attributes\n\tfloat viewdist<-20.0;\n\tfloat speed <- 3.0;\n\trgb mycolor<-rnd_color(255);\n\t\n\t//to simplify the writting of the agent behavior, we define as variables 4 desires for the agents\n\tpredicate define_gold_target <- new_predicate(\"define_gold_target\");\n\tpredicate get_gold <- new_predicate(\"get_gold\");\n\tpredicate wander <- new_predicate(\"wander\");\n\tpredicate return_base <- new_predicate(\"return_base\");\n\t\n\tpredicate sac <- new_predicate(\"sac\",[\"contenance\"::5]);\n\t\n\t//we define in the same way a belief that I have already gold that I have to return to the base\n\tpredicate has_gold <- new_predicate(\"has_gold\");\n\t\n\tpoint target;\n\t\n\t//at the vreation of the agent, we add the desire to patrol (wander)\n\tinit\n\t{\n\t\tagent friend <- nil;\n\t\t\n\t\tdo add_social_link(new_social_link(friend));\n\t\t\n\t\temotion joie <- new_emotion(\"joie\",wander);\n\t\tdo add_emotion(joie);\n\t\t\n\t\tdo add_desire(wander);\n\t}\n\t\n\t//if the agent perceive a gold nugget in its neighborhood, it adds a belief a belief concening its location and remove its wandering intention\n\tperceive target:gold in:viewdist {\n\t\tfocus id:\"location_gold\" var:location;\n\t\task myself {do remove_intention(wander, false);}\n\t}\n\t\n\t\n\t\tperceive target:miner in: /*2**/viewdist{\n\t\tenforcement law:\"working\" sanction:\"sanctionToLaw\";\n\t\tenforcement obligation:has_gold sanction: \"sanctionToObligation\" reward:\"rewardToObligation\";\n\t\tenforcement norm:\"share_information\" reward:\"rewardToNorm\";\n\t}\n\t\n\t//if the agent has the belief that their is gold at given location, it adds the desire to get gold \n\trule belief: new_predicate(\"location_gold\") new_desire: get_gold strength:10.0;\n//\trule belief: new_predicate(\"location_gold\") new_desire: new_predicate(\"toto\") all: true strength:0.1;\n\t\n\t//if the agent has the belief that it has gold, it adds the desire to return to the base\n\trule belief: has_gold new_desire: return_base strength:100;\n\t\n\t\n\t// plan that has for goal to fulfill the wander desire\t\n\tplan letsWander intention:wander \n\t{\n\t\tdo wander amplitude: 60.0;\n\t}\n\t\n\t//plan that has for goal to fulfill the get gold desire\n\tplan getGold intention:get_gold \n\t{\n\t\t//if the agent does not have chosen a target location, it adds the sub-intention to define a target and puts its current intention on hold\n\t\tif (target = nil) {\n\t\t\tdo add_subintention(get_current_intention(),define_gold_target, true);\n\t\t\tdo current_intention_on_hold();\n\t\t} else {\n\t\t\tdo goto target: target ;\n\t\t\t\n\t\t\t//if the agent reach its location, it updates it takes the gold, updates its belief base, and remove its intention to get gold\n\t\t\tif (target = location)  {\n\t\t\t\tgold current_gold <- gold first_with (target = each.location);\n\t\t\t\tif current_gold != nil {\n\t\t\t\t \tdo add_belief(has_gold);\n\t\t\t\t\task current_gold {do die;}\t\n\t\t\t\t}\n\t\t\t\tdo remove_belief(new_predicate(\"location_gold\", [\"location_value\"::target]));\n\t\t\t\ttarget <- nil;\n\t\t\t\tdo remove_intention(get_gold, true);\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\t//plan that has for goal to fulfill the define gold target desire. This plan is instantaneous (does not take a complete simulation step to apply).\n\tplan choose_gold_target intention: define_gold_target instantaneous: true{\n\t\tlist<point> possible_golds <- get_beliefs(new_predicate(\"location_gold\")) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tif (empty(possible_golds)) {\n\t\t\tdo remove_intention(get_gold, true);\n\t\t} else {\n\t\t\ttarget <- (possible_golds with_min_of (each distance_to self)).location;\n\t\t}\n\t\tdo remove_intention(define_gold_target, true);\n\t}\n\t\n\t////plan that has for goal to fulfill the return to base desire\n\tplan return_to_base intention: return_base {\n\t\tdo goto target: the_base ;\n\t\tif (the_base.location = location)  {\n\t\t\tdo remove_belief(has_gold);\n\t\t\tdo remove_intention(return_base, true);\n\t\t\tthe_base.golds <- the_base.golds + 1;\n\t\t}\n\t}\n\n\taspect default {\n\t  draw circle(2) color: mycolor border:mycolor-50;\n\t  draw circle(viewdist) color:rgb(mycolor,0.5);\t\t\n\t}\n}\n\n\nspecies gold {\n\taspect default\n\t{\n\t  draw triangle(5) color:rgb(#yellow,0.8) border:#yellow;\t\n\t}\n}\n\nspecies base {\n\tint golds;\n\taspect default\n\t{\n\t  draw square(20) color: #black;\n\t}\n}\n\n\nexperiment GoldBdi type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tdisplay map background:#gamablue type:3d\n\t\t{\n\t\t\tspecies base ;\n\t\t\tspecies miner aspect:default;\n\t\t\tspecies gold ;\n\t\t}\n\t}\n}"}
{"prompt": "Design a basic BDI (Belief-Desire-Intention) architecture for an agent that can express a simple greeting.", "gaml_code": "/**\n* Name: HelloWorldBDI\n* Author: Patrick Taillandier\n* Description: Minimal model\n* Tags: simple_bdi, plan, predicate, desire\n*/\n\nmodel HelloWorldBDI\n\nglobal {\n\tinit {\n\t\tcreate bdi_species;\n\t}\n}\n\n//add the simple_bdi architecture to the agents\nspecies bdi_species control: simple_bdi {\n\t\n\t//define a new predicate that will be used as a desire\n\tpredicate saying_hello_desire <- new_predicate(\"say hello\");\n\t\n\t//at init, add the saying_hello_desire to the agent desire base\n\tinit {\n\t\tdo add_desire(saying_hello_desire);\n\t}\n\t\n\t//definition of a plan that allow to fulfill the  saying_hello_desire intention\n\tplan saying_hello intention: saying_hello_desire{\n\t\twrite \"Hello World!\";\n\t}\n}\n\nexperiment HelloWorldBDI type: gui ;"}
{"prompt": "Simulate a city evacuation scenario where people respond to a technological accident with emotions and social influence.", "gaml_code": "/**-\n* Name: City Evacuation\n* Author: Mathieu Bourgais & Patrick Taillandier\n* Description:  Example model concerning the  use of the simpleBDI plug-in  with emotions. \n* A technological accident is simulated in one of the buildings of the city center.\n\n* Tags: simple_bdi, emotion, evacuation\n*/\n \nmodel City_Evacuation\n\nglobal {\n\tfile shapefile_roads <- file(\"../includes/Rouen roads.shp\");\n\tfile shapefile_hazard <- file(\"../includes/Technological hazard.shp\");\n\tfile shapefile_shelters <- file(\"../includes/Escapes.shp\");\n\tgeometry shape <- envelope(shapefile_roads);\n\tgraph road_network;\n\tmap<road,float> current_weights;\n\t\n\tfloat hazard_distance <- 400.0;\n\tfloat catastrophe_distance <- 100.0;\n\tfloat proba_detect_hazard <- 0.2;\n\tfloat proba_detect_other_escape <- 0.01;\n\tfloat other_distance <- 10.0;\n\t\n\tinit {\n\t\tcreate road from: shapefile_roads;\n\t\tcreate hazard from: shapefile_hazard;\n\t\tcreate catastrophe;\n\t\tcreate shelter from: shapefile_shelters;\n\t\t\n\t\t//at the begining of the simulation, we add to the people agent the desire to go to their target.\n\t\tcreate people number: 200{\n\t\t\tlocation <- any_location_in(one_of(road));\n\t\t\tdo add_desire(at_target);\n\t\t\t\n\t\t \t//the agent has also the desire that there is no catastrophe (we set the piority of this desire to 0 as it is a general desire)\n\t\t\tdo add_desire(nonCatastrophe ,0.0);\n\t\t\t\n\t\t\t// we give the agent a random charisma and receptivity (built-in variables linked to the emotions)\n\t\t\tcharisma<-rnd(1.0);\n\t\t\treceptivity<-rnd(1.0);\n\t\t\t\n\t\t\tif(flip(0.9)){\n\t\t\t\tfearful<-true;\n\t\t\t}else{\n\t\t\t\tfearful <- false;\n\t\t\t}\n      \t}\n      \troad_network <- as_edge_graph(road);\n      \tcurrent_weights <- road as_map (each::each.shape.perimeter);\n\t}\n\t\n\treflex update_speeds when: every(10#cycle){\n\t\tcurrent_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);\n\t\troad_network <- road_network with_weights current_weights;\n\t}\n\t\n\treflex stop_sim when: empty(people) {\n\t\tdo pause;\n\t}\n}\n \nspecies people skills: [moving] control: simple_bdi{\n\tpoint target;\n\tfloat speed <- 30 #km/#h;\n\trgb color <- #blue;\n\tbool escape_mode <- false;\n\tbool fearful;\n\t\n\t//in order to simplify the model we define  4 desires as variables\n\tpredicate at_target <- new_predicate(\"at_target\");\n\tpredicate in_shelter <- new_predicate(\"shelter\");\n\tpredicate has_target <- new_predicate(\"has target\");\n\tpredicate has_shelter <- new_predicate(\"has shelter\");\n\n    //we give them as well 2 beliefs as variables\n\tpredicate catastropheP <- new_predicate(\"catastrophe\");\n\tpredicate nonCatastrophe <- new_predicate(\"catastrophe\",false);\n\t\n\t//at last we define 2 emotion linked to the knowledge of the catastrophe\n\temotion fearConfirmed <- new_emotion(\"fear_confirmed\",catastropheP);\n\temotion fear <- new_emotion(\"fear\",catastropheP);\n\t\n\tbool noTarget<-true;\n\t\n\t//we set this built-in variable to true to use the emotional process\n\tbool use_emotions_architecture <- true;\n\n    //if the agent perceive that their is something that is not normal (a hazard), it has a probability proba_detect_hazard to suppose (add to its unertainty base) that there is a catastrophe occuring\n\tperceive target:hazard in: hazard_distance when: not escape_mode and flip(proba_detect_hazard){\n\t\tfocus id:\"catastrophe\" is_uncertain: true;\n\t\task myself {\n\t\t\tif(fearful){\n\t\t\t\tdo to_escape_mode;\n\t\t\t}else{\n\t\t\t\tcolor<-#green;\n\t\t\t}\n\t\t}\n\t}\n\n\t//if the agent perceive the catastrophe, it adds a belief about it and pass in escape mode\n\tperceive target:catastrophe in:catastrophe_distance{\n\t\tfocus id:\"catastrophe\";\n\t\task myself{\n\t\t\tif(not escape_mode){\n\t\t\t\tdo to_escape_mode;\n\t\t\t}\n\t\t}\n\t}\n\n\t//if the agent perceives other people agents in their neighborhood that have fear, it can be contaminate by this emotion\n\tperceive target:people in: other_distance when: not escape_mode {\n\t\temotional_contagion emotion_detected:fearConfirmed when: fearful;\n\t\temotional_contagion emotion_detected:new_emotion(\"fear\") charisma: charisma receptivity:receptivity;\n\t\temotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n\t}\n\temotion joy <- nil;\n\t\n\t\n\tperceive target:people in: other_distance{\n\t\temotional_contagion emotion_detected: joy;\n\t\temotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n\t}\n\t\n\t//if the agent has a fear confirmed, it has the desire to go to a shelter\n\trule emotion:fearConfirmed remove_intention: at_target new_desire:in_shelter strength:5.0;\n\t\n\t//if the agent has the belief that there is a a catastrophe,  it has the desire to go to a shelter\n\trule belief:new_predicate(\"catastrophe\") remove_intention:at_target new_desire:in_shelter strength:5.0;\n\t\n\trule emotion:new_emotion(\"fear\" ,new_predicate(\"catastrophe\")) new_desire:in_shelter remove_intention:at_target when: fearful strength:5.0;\n\t\n\t//normal move plan\n\tplan normal_move intention: at_target  {\n\t\tif (target = nil) {\n\t\t\ttarget <- any_location_in(one_of(road));\n\t\t} else {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\ttarget <- nil;\n\t\t\t\tnoTarget<-true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//fast evacuation plan in case where the agent has a fear confirmed\n\tplan evacuationFast intention: in_shelter emotion: fearConfirmed priority:2 {\n\t\tcolor <- #yellow;\n\t\tspeed <- 60 #km/#h;\n\t\tif (target = nil or noTarget) {\n\t\t\ttarget <- (shelter with_min_of (each.location distance_to location)).location;\n\t\t\tnoTarget <- false;\n\t\t}\n\t\telse  {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t}\t\n\t\n\t//normal evacuation plan\n\tplan evacuation intention: in_shelter finished_when: has_emotion(fearConfirmed){\n\t\tcolor <-#darkred;\n\t\tif (target = nil or noTarget) {\n\t\t\ttarget <- (shelter with_min_of (each.location distance_to location)).location;\n\t\t\tnoTarget <- false;\n\t\t}\n\t\telse  {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t}\n\t\n\taction to_escape_mode {\n\t\tescape_mode <- true;\n\t\tcolor <- #darkred;\n\t\ttarget <- nil;\t\n\t\tnoTarget <- true;\n\t\tdo remove_intention(at_target, true);\n\t}\n\t\n\t\n\taspect default {\n\t\tdraw triangle(30) rotate: heading + 90 color: color;\n\t}\n}\n\nspecies road {\n\tfloat capacity <- 1 + shape.perimeter/50;\n\tint nb_people <- 0 update: length(people at_distance 1);\n\tfloat speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\n\t\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies shelter {\n\taspect default {\n\t\tdraw circle(30) color: rgb(#gamablue,0.8) border: #gamablue depth:10;\n\t}\n}\n\nspecies hazard {\n\taspect default {\n\t\tdraw circle(hazard_distance) color: rgb(#gamaorange,0.3) border:#gamaorange depth:5;\n\t}\n}\n\nspecies catastrophe{\n\tinit{\n\t\tlocation <- first(hazard).location;\n\t}\n\taspect default{\n\t\tdraw circle(catastrophe_distance) color: rgb(#gamared,0.4) border:#gamared depth:10;\n\t}\n}\n\nexperiment main type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies shelter refresh: false;\n\t\t\tspecies road refresh: false;\n\t\t\tspecies people;\n\t\t\tspecies catastrophe;\n\t\t\tspecies hazard;\n\t\t}\n\t}\n}"}
{"prompt": "Design a simple BDI (Belief-Desire-Intention) architecture for a helicopter that fights fires, incorporating perception, rules, and plans to patrol, locate, and extinguish fires.", "gaml_code": "/**\n *  Firefighters\n *  Author: Mathieu Bourgais\n *  Description: A simple model to show how the BDI architectures and its tools work (perceive, rule, etc). It's the model of a helicopter that fights fires.\n * the Chopper agent has a general desire to patrol. As it is the only thing he wants at the beginning, it is its initial intention (what it is doing). \n * To patrol, it wanders around (its plan to patrol). When it perceives a fire, it stores this information (it has a new belief about the existence of this fire), \n * and it has a new desire (it wants the fire to be extinct). When it sees a fire, the Patrol intention is put on hold and a new intention is selected (to put out the fire). \n * To achieve this intention, the plan has two steps, i.e. two new (sub)desires: go to the fire and put water on the fire. And so on.\n *  Tags: simple_bdi, perception, rule, plan, predicate\n */\n\nmodel Firefighters\n\nglobal {\n\tint displatTextSize <-4;\n\t\n\t//We define the predicates that will be used later.\n\tpredicate patrol_desire <- new_predicate(\"patrol\");\n\tpredicate water_predicate <- new_predicate(\"has water\",true);\n\tpredicate no_water_predicate <- new_predicate(\"has water\", false) ;\n\tstring fireLocation <- \"fireLocation\";\n\t\n\tinit {\n\t\tcreate fireArea number:20;\n\t\tcreate waterArea number:1;\n\t\tcreate firefighter number: 2;\n\t}\n\t\n\treflex stop when: length(fireArea) = 0 {\n\t\tdo pause;\n\t}\n}\n\n\n//give the simple_bdi architecture to the firefighter agents\nspecies firefighter skills: [moving] control: simple_bdi{\t\n\t\n\t//Here are the variables used by a helicopter. \n\trgb color <- rnd_color(150);\n\tfloat waterValue;\n\tgrille maCellule <- one_of(grille);\n\t//Definition of the variables featured in the BDI architecture.\n\tfloat plan_persistence <- 1.0; \n\tfloat intention_persistence <- 1.0;\n\tbool probabilistic_choice <- false;\n\t\n\t//Initialisation of the agent. At the begining, the agent just has the desire to patrol.\n\tinit {\n\t\twaterValue <-2.0;\n\t\tlocation<-maCellule.location;\n\t\tdo add_desire(patrol_desire );\n\t}\n\t\n\t//This perceive is used to update the beliefs concerning the intern variable of the agent (the amount of water it has).\n\tperceive target:self {\n\t\tif(waterValue>0){\n\t\t\tdo add_belief(water_predicate);\n\t\t\tdo remove_belief(no_water_predicate);\n\t\t}\n\t\tif(waterValue<=0){\n\t\t\tdo add_belief(no_water_predicate);\n\t\t\tdo remove_belief(water_predicate);\n\t\t}\n\t}\n\t\n\t//The helicopter perceive the fires at a certain distance. It just record the location of the fire it obsrves. When it sees a fire, it stops it's intention of patroling.\n\tperceive target:fireArea in: 15{ \n\t\tfocus id:\"fireLocation\" var:location strength:10.0; \n\t\task myself{\n\t\t\tdo remove_intention(patrol_desire, true);\n\t\t} \n\t}\n\t\n\t//The rules are used to create a desire from a belief. We can specify the priority of the desire with a statement priority.\n\trule belief: new_predicate(fireLocation) new_desire: get_belief_with_name(fireLocation).predicate;\n\trule belief: no_water_predicate new_desire: water_predicate strength: 10.0;\n\t\n\t//The plan to do when the intention is to patrol.\n\tplan patrolling intention:patrol_desire{\n\t\tdo wander amplitude: 30.0 speed: 2.0;\n\t}\n\t \n\t//The plan that is executed when the agent got the intention of extinguish a fire.\n\tplan stopFire intention: new_predicate(fireLocation) priority:5{\n\t\tpoint target_fire <- point(get_current_intention().predicate.values[\"location_value\"] );\n\t\tif(waterValue>0){\n\t\t\tif (self distance_to target_fire <= 1) {\n\t\t\t\tfireArea current_fire <- fireArea first_with (each.location = target_fire);\n\t\t\t\tif (current_fire != nil) {\n\t\t\t\t\t waterValue <- waterValue - 1.0;\n\t\t\t\t\t current_fire.size <-  current_fire.size - 1;\n\t\t\t\t\t if ( current_fire.size <= 0) {\n\t\t\t\t\t\task  current_fire {do die;}\n\t\t\t\t\t\tdo remove_belief(get_current_intention().predicate);\n\t\t\t\t\t\tdo remove_intention(get_current_intention().predicate, true);\n\t\t\t\t\t\tdo add_desire(patrol_desire,1.0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdo remove_belief(get_current_intention().predicate);\n\t\t\t\t\tdo remove_intention(get_current_intention().predicate, true);\n\t\t\t\t\tdo add_desire(patrol_desire,1.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo goto(target: target_fire);\n\t\t\t}\n\t\t} else {\n\t\t\tdo add_subintention(get_current_intention(),water_predicate,true);\n\t\t\tdo current_intention_on_hold();\n\t\t}\n\t}  \n\t\n\t//The plan to take water when the agent get the desire of water.\n    plan gotoTakeWater intention: water_predicate priority:2 {\n    \twaterArea wa <- first(waterArea);\n    \tlist<grille> voisins <-  (grille(location) neighbors_at (1)) + grille(location);\n\t\t\tpath cheminSuivi <-  goto(wa);\n    \tif (self distance_to wa <= 1) {\n    \t\twaterValue <- waterValue + 2.0;\n\t\t}\n    }\n\n\taspect base {\n\t\tdraw triangle(2) color:color rotate: 90 + heading;\t\n\t\tdraw circle(15) color: color ;\t\n\t}\n\t\n\taspect bdi {\n\t\tdraw triangle(2) color:color rotate: 90 + heading;\t\n\t\tdraw circle(15) color: color wireframe: true;\n\t\tdraw (\"B:\" + length(belief_base) + \":\" + belief_base) color:#black size:displatTextSize perspective:false; \n\t\tdraw (\"D:\" + length(desire_base) + \":\" + desire_base) color:#black size:displatTextSize at:{location.x,location.y+displatTextSize} perspective:false; \n\t\tdraw (\"I:\" + length(intention_base) + \":\" + intention_base) color:#black size:displatTextSize at:{location.x,location.y+2*displatTextSize} perspective:false;\n\t\tdraw (\"curIntention:\" + get_current_intention()) color:#black size:displatTextSize at:{location.x,location.y+3*displatTextSize} perspective:false; \t\n\t}\n}\n\nspecies fireArea{\n\tfloat size <-1.0;\n\t\n\tinit{\n\t\tgrille place <- one_of(grille);\n\t\tlocation <- place.location;\n\t}\n\t\n\taspect base {\n\t  draw file(\"../includes/Fire.png\") size: 5;\n\t}\n}\n\nspecies waterArea{\n\tinit {\n\t\tgrille place <- one_of(grille);\n\t\tlocation <- place.location;\n\t}\n\taspect base {\n\t  draw square(5) color: #blue border: #black;\t\t\n\t}\n}\n\ngrid grille width: 25 height: 25 neighbors:4 {\n\trgb color <- #green;\n}\n\n\nexperiment fight_fire type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\t\t\t\t\t\n\t\tdisplay view1 { \n\t\t\tgrid grille border: #darkgreen;\n\t\t\tspecies fireArea aspect:base;\n\t\t\tspecies waterArea aspect:base;\n\t\t\tspecies firefighter aspect: bdi;\n\t\t}\n\t}\n\n}"}
{"prompt": "Create a simple BDI (Belief-Desire-Intention) model for a Goldminer tutorial using GAML, including 3D visualization of gold mines and market.", "gaml_code": "/***\n* Name: BDItutorial1\n* Author: Mathieu Bourgais\n* Description: The skeleton model of the Goldminer BDI tutorial.\n* Tags: species\n***/\n\nmodel BDItutorial1\n\nglobal {\n\tint nb_mines <- 10; \n\tmarket the_market;\n\tgeometry shape <- square(20 #km);\n\tfloat step <- 10#mn;\t\n\t\n\tinit {\n\t\tcreate market {\n\t\t\tthe_market <- self;\n\t\t}\n\t\tcreate gold_mine number: nb_mines;\n\t}\n}\n\nspecies gold_mine {\n\tint quantity <- rnd(1,20);\n\taspect default {\n\t\tdraw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;\t\n\t}\n}\n\nspecies market {\n\tint golds;\n\taspect default {\n\t  draw square(1000) color: #black ;\n\t}\n}\n\nexperiment GoldBdi type: gui {\n\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tspecies market ;\n\t\t\tspecies gold_mine ;\n\t\t}\n\t}\n}"}
{"prompt": "Design a multi-agent system where miners interact with gold mines and market, incorporating emotions, personality, and social relationships to optimize gold extraction and trade.", "gaml_code": "/***\n* Name: BDItutorial4\n* Author: Mathieu Bourgais\n* Description: Addition of emotions and personality to miner agents.\n* Tags: emotion, personality\n***/\n\nmodel BDItutorial4\n\nglobal {\n\tint nb_mines <- 10; \n\tint nb_miners <- 5;\n\tmarket the_market;\n\t\n\tstring mine_at_location <- \"mine_at_location\";\n\tstring empty_mine_location <- \"empty_mine_location\";\n\t\n\tfloat step <- 10#mn;\n\t\n\t//possible predicates concerning miners\n\tpredicate mine_location <- new_predicate(mine_at_location) ;\n\tpredicate choose_gold_mine <- new_predicate(\"choose a gold mine\");\n\tpredicate has_gold <- new_predicate(\"extract gold\");\n\tpredicate find_gold <- new_predicate(\"find gold\") ;\n\tpredicate sell_gold <- new_predicate(\"sell gold\") ;\n\tpredicate share_information <- new_predicate(\"share information\") ;\n\t\n\t\n\temotion joy <- new_emotion(\"joy\");\n\t\n\tfloat inequality <- 0.0 update:standard_deviation(miner collect each.gold_sold);\n\t\n\tgeometry shape <- square(20 #km);\n\tinit\n\t{\n\t\tcreate market {\n\t\t\tthe_market <- self;\t\n\t\t}\n\t\tcreate gold_mine number: nb_mines;\n\t\tcreate miner number: nb_miners;\n\t}\n\t\n\treflex display_social_links{\n\t\tloop tempMiner over: miner{\n\t\t\t\tloop tempDestination over: tempMiner.social_link_base{\n\t\t\t\t\tif (tempDestination !=nil){\n\t\t\t\t\t\tbool exists<-false;\n\t\t\t\t\t\tloop tempLink over: socialLinkRepresentation{\n\t\t\t\t\t\t\tif((tempLink.origin=tempMiner) and (tempLink.destination=tempDestination.agent)){\n\t\t\t\t\t\t\t\texists<-true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(not exists){\n\t\t\t\t\t\t\tcreate socialLinkRepresentation number: 1{\n\t\t\t\t\t\t\t\torigin <- tempMiner;\n\t\t\t\t\t\t\t\tdestination <- tempDestination.agent;\n\t\t\t\t\t\t\t\tif(tempDestination.liking>0){\n\t\t\t\t\t\t\t\t\tmy_color <- #green;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmy_color <- #red;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\treflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){\n\t\tdo pause;\n\t\task miner {\n\t\t\twrite name + \" : \" +gold_sold;\n\t\t}\n\t}\n}\n\nspecies gold_mine {\n    int quantity <- rnd(1,20);\n    aspect default {\n        draw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;    \n    }\n}\n\nspecies market {\n\tint golds;\n\taspect default {\n\t\tdraw square(1000) color: #black ;\n\t}\n}\n\nspecies miner skills: [moving] control:simple_bdi {\n\t\n\tfloat view_dist<-1000.0;\n\tfloat speed <- 2#km/#h;\n\trgb my_color<-rnd_color(255);\n\tpoint target;\n\tint gold_sold;\n\t\n    bool use_social_architecture <- true;\n\tbool use_emotions_architecture <- true;\n\tbool use_personality <- true;\n\t\n\tinit {\n\t\tdo add_desire(find_gold);\n\t}\n\t\n\tperceive target:miner in:view_dist {\n\t\tsocialize liking: 1 -  point(my_color.red, my_color.green, my_color.blue) distance_to point(myself.my_color.red, myself.my_color.green, myself.my_color.blue) / ( 255);\n\t}\n\t\t\n\tperceive target: gold_mine where (each.quantity > 0) in: view_dist {\n\t\tfocus id: mine_at_location var: location;\n\t\task myself {\n\t\t\tif (has_emotion(joy)) {\n\t\t\t\twrite self.name + \" is joyous\";\n\t\t\t\tdo add_desire(predicate:share_information, strength: 5.0);\n\t\t\t}\n\t\t\tdo remove_intention(find_gold, false);\n\t\t}\n\t}\n\t\n\trule belief: mine_location new_desire: has_gold strength: 2.0;\n\trule belief: has_gold new_desire: sell_gold strength: 3.0;\n\t\n\tplan lets_wander intention:find_gold finished_when: has_desire(has_gold){\n\t\tdo wander;\n\t}\n\t\n\tplan get_gold intention:has_gold  {\n\t\tif (target = nil) {\n\t\t\tdo add_subintention(get_current_intention(),choose_gold_mine, true);\n\t\t\tdo current_intention_on_hold();\n\t\t} else {\n\t\t\tdo goto target: target ;\n\t\t\tif (target = location)  {\n\t\t\t\tgold_mine current_mine<- gold_mine first_with (target = each.location);\n\t\t\t\tif current_mine.quantity > 0 {\n\t\t\t\t \tdo add_belief(has_gold);\n\t\t\t\t\task current_mine {quantity <- quantity - 1;}\t\n\t\t\t\t} else {\n\t\t\t\t\tdo add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\n\t\t\t\t}\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tplan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true{\n\t\tlist<point> possible_mines <- get_beliefs_with_name(mine_at_location) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tlist<point> empty_mines <- get_beliefs_with_name(empty_mine_location) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tpossible_mines <- possible_mines - empty_mines;\n\t\tif (empty(possible_mines)) {\n\t\t\tdo remove_intention(has_gold, true); \n\t\t} else {\n\t\t\ttarget <- (possible_mines with_min_of (each distance_to self)).location;\n\t\t}\n\t\tdo remove_intention(choose_gold_mine, true); \n\t}\n\t\n\tplan return_to_base intention: sell_gold {\n\t\tdo goto target: the_market ;\n\t\tif (the_market.location = location)  {\n\t\t\tdo remove_belief(has_gold);\n\t\t\tdo remove_intention(sell_gold, true);\n\t\t\tgold_sold <- gold_sold + 1;\n\t\t}\n\t}\n\tplan share_information_to_friends intention: share_information instantaneous: true{\n\t\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\n\t\tloop known_gold_mine over: get_beliefs_with_name(mine_at_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_gold_mine);\n\t\t\t}\n\t\t}\n\t\tloop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_empty_gold_mine);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdo remove_intention(share_information, true); \n\t}\n\n\taspect default {\n\t    draw circle(200) color: my_color border: #black depth: gold_sold;\n\t    draw circle(view_dist) color: my_color border: #black depth: gold_sold wireframe: true;\n\t}\n}\n\nspecies socialLinkRepresentation{\n\tminer origin;\n\tagent destination;\n\trgb my_color;\n\t\n\taspect base{\n\t\tdraw line([origin,destination],50.0) color: my_color;\n\t}\n}\n\n\nexperiment GoldBdi type: gui {\n\toutput {\n\t\tdisplay map type: 3d\n\t\t{\n\t\t\tspecies market ;\n\t\t\tspecies gold_mine ;\n\t\t\tspecies miner;\n\t\t}\n\t\t\n\t\tdisplay socialLinks type: 3d{\n        species socialLinkRepresentation aspect: base;\n    }\n\n\t\tdisplay chart type: 2d {\n\t\t\tchart \"Money\" type: series {\n\t\t\t\tdatalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"}
{"prompt": "Design a 3D simulation of a gold mining economy where miners interact with each other and share information about gold mine locations.", "gaml_code": "/***\n* Name: BDItutorial3\n* Author: Mathieu Bourgais\n* Description: Addition of social relationship and information exchange.\n* Tags: social link, information sharing, socialize\n***/\n\nmodel BDItutorial3\n\nglobal {\n    int nb_mines <- 10; \n    int nb_miners <-5;\n    market the_market;\n    geometry shape <- square(20 #km);\n    float step <- 10#mn;\n\t\n\tstring mine_at_location <- \"mine_at_location\";\n\tstring empty_mine_location <- \"empty_mine_location\";\t\n\t\n\t//possible predicates concerning miners\n\tpredicate mine_location <- new_predicate(mine_at_location) ;\n\tpredicate choose_gold_mine <- new_predicate(\"choose a gold mine\");\n\tpredicate has_gold <- new_predicate(\"extract gold\");\n\tpredicate find_gold <- new_predicate(\"find gold\") ;\n\tpredicate sell_gold <- new_predicate(\"sell gold\") ;\n\tpredicate share_information <- new_predicate(\"share information\") ;\n\t\n\tfloat inequality <- 0.0 update: standard_deviation(miner collect each.gold_sold);\n\t\n\tinit {\n\t\tcreate market {\n\t\t\tthe_market <- self;\t\n\t\t}\n\t\tcreate gold_mine number: nb_mines;\n\t\tcreate miner number: nb_miners;\n\t}\n\t\n\treflex display_social_links{\n\t\tloop tempMiner over: miner{\n\t\t\t\tloop tempDestination over: tempMiner.social_link_base{\n\t\t\t\t\tif (tempDestination !=nil){\n\t\t\t\t\t\tbool exists<-false;\n\t\t\t\t\t\tloop tempLink over: socialLinkRepresentation{\n\t\t\t\t\t\t\tif((tempLink.origin=tempMiner) and (tempLink.destination=tempDestination.agent)){\n\t\t\t\t\t\t\t\texists<-true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(not exists){\n\t\t\t\t\t\t\tcreate socialLinkRepresentation number: 1{\n\t\t\t\t\t\t\t\torigin <- tempMiner;\n\t\t\t\t\t\t\t\tdestination <- tempDestination.agent;\n\t\t\t\t\t\t\t\tif(tempDestination.liking > 0){\n\t\t\t\t\t\t\t\t\tmy_color <- #green;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmy_color <- #red;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\treflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){\n\t\tdo pause;\n\t\task miner {\n\t\t\twrite name + \" : \" +gold_sold;\n\t\t}\n\t}\n}\n\nspecies gold_mine {\n    int quantity <- rnd(1,20);\n    aspect default {\n        draw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;    \n    }\n}\n\nspecies market {\n\tint golds;\n\taspect default {\n\t  draw square(1000) color: #black ;\n\t}\n}\n\nspecies miner skills: [moving] control:simple_bdi {\n\t\n\tfloat view_dist<-1000.0;\n\tfloat speed <- 2#km/#h;\n\trgb my_color<-rnd_color(255);\n\tpoint target;\n\tint gold_sold;\n\n    bool use_social_architecture <- true;\n\t\n\tinit {\n\t\tdo add_desire(find_gold);\n\t}\n\t\n\tperceive target: miner in: view_dist {\n\t\tsocialize liking: 1 -  point(my_color.red, my_color.green, my_color.blue) distance_to point(myself.my_color.red, myself.my_color.green, myself.my_color.blue) / 255;\n\t}\n\t\t\n\tperceive target: gold_mine where (each.quantity > 0) in: view_dist {\n\t\tfocus id: mine_at_location var:location;\n\t\task myself {\n\t\t\tdo add_desire(predicate:share_information, strength: 5.0);\n\t\t\tdo remove_intention(find_gold, false);\n\t\t}\n\t}\n\t\n\trule belief: mine_location new_desire: has_gold strength: 2.0;\n\trule belief: has_gold new_desire: sell_gold strength: 3.0;\n\t\n\t\t\n\tplan lets_wander intention: find_gold finished_when: has_desire(has_gold) {\n\t\tdo wander;\n\t}\n\t\n\tplan get_gold intention:has_gold \n\t{\n\t\tif (target = nil) {\n\t\t\tdo add_subintention(get_current_intention(),choose_gold_mine, true);\n\t\t\tdo current_intention_on_hold();\n\t\t} else {\n\t\t\tdo goto target: target ;\n\t\t\tif (target = location)  {\n\t\t\t\tgold_mine current_mine<- gold_mine first_with (target = each.location);\n\t\t\t\tif current_mine.quantity > 0 {\n\t\t\t\t \tdo add_belief(has_gold);\n\t\t\t\t\task current_mine {quantity <- quantity - 1;}\t\n\t\t\t\t} else {\n\t\t\t\t\tdo add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\n\t\t\t\t}\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tplan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true {\n\t\tlist<point> possible_mines <- get_beliefs_with_name(mine_at_location) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tlist<point> empty_mines <- get_beliefs_with_name(empty_mine_location) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tpossible_mines <- possible_mines - empty_mines;\n\t\tif (empty(possible_mines)) {\n\t\t\tdo remove_intention(has_gold, true); \n\t\t} else {\n\t\t\ttarget <- (possible_mines with_min_of (each distance_to self)).location;\n\t\t}\n\t\tdo remove_intention(choose_gold_mine, true); \n\t}\n\t\n\tplan return_to_base intention: sell_gold {\n\t\tdo goto target: the_market ;\n\t\tif (the_market.location = location)  {\n\t\t\tdo remove_belief(has_gold);\n\t\t\tdo remove_intention(sell_gold, true);\n\t\t\tgold_sold <- gold_sold + 1;\n\t\t}\n\t}\n\t\n\tplan share_information_to_friends intention: share_information instantaneous: true {\n\t\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\n\t\tloop known_gold_mine over: get_beliefs_with_name(mine_at_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_gold_mine);\n\t\t\t}\n\t\t}\n\t\tloop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_empty_gold_mine);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdo remove_intention(share_information, true); \n\t}\n\n\taspect default {\n\t  draw circle(200) color: my_color border: #black depth: gold_sold;\n\t  draw circle(view_dist) color: my_color border: #black depth: gold_sold wireframe: true;\n\t}\n}\n\nspecies socialLinkRepresentation{\n\tminer origin;\n\tagent destination;\n\trgb my_color;\n\t\n\taspect base{\n\t\tdraw line([origin,destination],50.0) color: my_color;\n\t}\n}\n\n\nexperiment GoldBdi type: gui {\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tspecies market ;\n\t\t\tspecies gold_mine ;\n\t\t\tspecies miner;\n\t\t}\n\t\t\n\t\tdisplay socialLinks type: 3d{\n\t\t\tspecies socialLinkRepresentation aspect: base;\n\t\t}\n\t\t\n\t\tdisplay chart type: 2d {\n\t\t\tchart \"Money\" type: series {\n\t\t\t\tdatalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"}
{"prompt": "Design a BDI architecture for gold miners to extract and sell gold in a 3D environment, including market dynamics and visualization of miner performance.", "gaml_code": "/***\n* Name: BDItutorial2\n* Author: Mathieu Bourgais\n* Description: Description of gold miner behaviors using BDI architecture\n* Tags: BDI, plan, intention\n***/\n\nmodel BDItutorial2\n\nglobal {\n    int nb_mines <- 10; \n    int nb_miners <-5;\n    market the_market;\n    geometry shape <- square(20 #km);\n    float step <- 10#mn;\n    \n    string mine_at_location <- \"mine_at_location\";\n    string empty_mine_location <- \"empty_mine_location\";\n        \n    //possible predicates concerning miners\n    predicate mine_location <- new_predicate(mine_at_location) ;\n    predicate choose_gold_mine <- new_predicate(\"choose a gold mine\");\n    predicate has_gold <- new_predicate(\"extract gold\");\n    predicate find_gold <- new_predicate(\"find gold\") ;\n    predicate sell_gold <- new_predicate(\"sell gold\") ;\n    \n    float inequality <- 0.0 update:standard_deviation(miner collect each.gold_sold);\n    \n    init {\n        create market {\n            the_market <- self;    \n        }\n        create gold_mine number:nb_mines;\n        create miner number:nb_miners;\n    }\n    \n    reflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){\n        do pause;\n        ask miner {\n\t\t\twrite name + \" : \" +gold_sold;\n\t\t}\n    }\n}\n\nspecies gold_mine {\n    int quantity <- rnd(1,20);\n    aspect default {\n        draw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;    \n    }\n}\n\nspecies market {\n    int golds;\n    aspect default {\n      draw square(1000) color: #black ;\n    }\n}\n\nspecies miner skills: [moving] control:simple_bdi {\n    \n    float view_dist<-1000.0;\n    float speed <- 2#km/#h;\n    rgb my_color <- rnd_color(255);\n    point target;\n    int gold_sold;\n    \n    init {\n        do add_desire(find_gold);\n    }\n        \n    perceive target: gold_mine where (each.quantity > 0) in: view_dist {\n        focus id:mine_at_location var:location;\n        ask myself {\n            do remove_intention(find_gold, false);\n        }\n    }\n    \n    rule belief: mine_location new_desire: has_gold strength: 2.0;\n    rule belief: has_gold new_desire: sell_gold strength: 3.0;\n    \n        \n    plan lets_wander intention: find_gold  {\n        do wander;\n    }\n    \n    plan get_gold intention: has_gold  {\n        if (target = nil) {\n            do add_subintention(get_current_intention(),choose_gold_mine, true);\n            do current_intention_on_hold();\n        } else {\n            do goto target: target ;\n            if (target = location)  {\n                gold_mine current_mine<- gold_mine first_with (target = each.location);\n                if current_mine.quantity > 0 {\n                     do add_belief(has_gold);\n                    ask current_mine {quantity <- quantity - 1;}    \n                } else {\n                    do add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\n                }\n                target <- nil;\n            }\n        }    \n    }\n    \n    plan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true {\n        list<point> possible_mines <- get_beliefs_with_name(mine_at_location) collect (point((mental_state (each)).predicate.values[\"location_value\"]));\n        list<point> empty_mines <- get_beliefs_with_name(empty_mine_location) collect (point((mental_state (each)).predicate.values[\"location_value\"]));\n        possible_mines <- possible_mines - empty_mines;\n        if (empty(possible_mines)) {\n            do remove_intention(has_gold, true); \n        } else {\n            target <- (possible_mines with_min_of (each distance_to self)).location;\n        }\n        do remove_intention(choose_gold_mine, true); \n    }\n    \n    plan return_to_base intention: sell_gold {\n        do goto target: the_market ;\n        if (the_market.location = location)  {\n            do remove_belief(has_gold);\n            do remove_intention(sell_gold, true);\n            gold_sold <- gold_sold + 1;\n        }\n    }\n\n    aspect default {\n      draw circle(200) color: my_color border: #black depth: gold_sold;\n      draw circle(view_dist) color: my_color border: #black depth: gold_sold wireframe: true;\n    }\n}\n\nexperiment GoldBdi type: gui {\n\n    output {\n        display map type: 3d {\n            species market ;\n            species gold_mine ;\n            species miner;\n        }\n        \n        display chart type: 2d {\n\t\t\tchart \"Money\" type: series {\n\t\t\t\tdatalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;\n\t\t\t}\n\t\t}\n        \n    }\n}"}
{"prompt": "Design a multi-agent system where miners and policemen interact to extract gold from mines while following social norms and obligations.", "gaml_code": "/***\n* Name: BDItutorial5\n* Author: Mathieu Bourgais\n* Description: Addition of norms, obligation, and enforcement\n* Tags: norm, obligation, enforcement\n***/\n\nmodel BDItutorial5\n\nglobal {\n\tint nb_mines <- 10; \n\tint nb_miners <- 5;\n\tint nb_police <- 1;\n\tint fine <- 0;\n\tmarket the_market;\n\t\n\tstring mine_at_location <- \"mine_at_location\";\n\tstring empty_mine_location <- \"empty_mine_location\";\n\t\n\tfloat step <- 10#mn;\n\t\n\t//possible predicates concerning miners\n\tpredicate mine_location <- new_predicate(mine_at_location) ;\n\tpredicate choose_gold_mine <- new_predicate(\"choose a gold mine\");\n\tpredicate has_gold <- new_predicate(\"extract gold\");\n\tpredicate find_gold <- new_predicate(\"find gold\") ;\n\tpredicate sell_gold <- new_predicate(\"sell gold\") ;\n\tpredicate share_information <- new_predicate(\"share information\") ;\n\t\n\t\n\temotion joy <- new_emotion(\"joy\");\n\t\n\tfloat inequality <- 0.0 update:standard_deviation(miner collect each.gold_sold);\n\t\n\tgeometry shape <- square(20 #km);\n\tinit\n\t{\n\t\tcreate market {\n\t\t\tthe_market <- self;\t\n\t\t}\n\t\tcreate gold_mine number:nb_mines;\n\t\tcreate miner number:nb_miners;\n\t\tcreate policeman number:nb_police;\n\t}\n\t\n\treflex display_social_links{\n\t\tloop tempMiner over: miner{\n\t\t\t\tloop tempDestination over: tempMiner.social_link_base{\n\t\t\t\t\tif (tempDestination !=nil){\n\t\t\t\t\t\tbool exists<-false;\n\t\t\t\t\t\tloop tempLink over: socialLinkRepresentation{\n\t\t\t\t\t\t\tif((tempLink.origin=tempMiner) and (tempLink.destination=tempDestination.agent)){\n\t\t\t\t\t\t\t\texists<-true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(not exists){\n\t\t\t\t\t\t\tcreate socialLinkRepresentation number: 1{\n\t\t\t\t\t\t\t\torigin <- tempMiner;\n\t\t\t\t\t\t\t\tdestination <- tempDestination.agent;\n\t\t\t\t\t\t\t\tif(tempDestination.liking>0){\n\t\t\t\t\t\t\t\t\tmy_color <- #green;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmy_color <- #red;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\treflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){\n\t\tdo pause;\n\t\task miner {\n\t\t\twrite name + \" : \" +gold_sold;\n\t\t}\n\t\twrite \"**********************\";\n\t\twrite \"fine : \" + fine;\n\t}\n}\n\nspecies gold_mine {\n    int quantity <- rnd(1,20);\n    aspect default {\n        draw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;    \n    }\n}\n\nspecies market {\n\tint golds;\n\taspect default {\n\t  draw square(1000) color: #black ;\n\t}\n}\n\nspecies policeman skills: [moving] control:simple_bdi {\n\tpredicate patroling <- new_predicate(\"patrolling\");\n\tfloat view_dist <- 1000.0;\n\tminer agent_perceived <- nil;\n\t\n\tinit {\n\t\tdo add_desire(patroling);\n\t}\n\t\n\tperceive target: miner in: view_dist {\n\t\tmyself.agent_perceived <-self;\n\t\tenforcement law:\"working\" sanction:\"sanction_to_law\";\n\t\tenforcement obligation:has_gold /*when:has_belief(has_gold)*/ sanction: \"sanction_to_obligation\" reward:\"reward_to_obligation\";\n\t}\n\t\n\tsanction sanction_to_law{\n\t\task agent_perceived{\n\t\t\tthreshold_law <- 0.0;\n\t\t\tgold_sold <- gold_sold-5;\n\t\t}\n\t\tfine <- fine +5;\n\t}\n\t\n\tsanction sanction_to_obligation {\n\t\task agent_perceived{\n\t\t\tgold_sold <- gold_sold-3;\n\t\t\tdo remove_intention(sell_gold,true);\n\t\t\tthreshold_obligation <- self.threshold_obligation - 0.1;\n\t\t}\n\t\tfine <- fine + 3;\n\t}\n\t\n\tsanction reward_to_obligation{\n\t\task agent_perceived{\n\t\t\tgold_sold <- gold_sold+2;\n\t\t}\n\t\tfine <- fine -2;\n\t}\n\t\n\tplan patrol intention: patroling {\n\t\tdo wander;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(view_dist) color: #blue depth: 0.0;\n\t}\n}\n\nspecies miner skills: [moving] control:simple_bdi {\n\t\n\tfloat view_dist<-1000.0;\n\tfloat speed <- 2#km/#h;\n\trgb my_color<-rnd_color(255);\n\tpoint target;\n\tint gold_sold;\n\tint gold_transported<-0;\n\tagent agent_perceived<-nil;\n\t\n    bool use_social_architecture <- true;\n\tbool use_emotions_architecture <- true;\n\tbool use_personality <- true;\n\t\n\tfloat openness <- gauss(0.5,0.12);\n\tfloat conscientiousness <- gauss(0.5,0.12);\n\tfloat extraversion <- gauss(0.5,0.12);\n\tfloat agreeableness <- gauss(0.5,0.12);\n\tfloat neurotism <- gauss(0.5,0.12);\n\t\n\tfloat plan_persistence <- 1.0;\n\tfloat intention_persistence <- 1.0;\n\t\n\tfloat threshold_law <- 1.0;\n\tfloat threshold_obligation <- 1.0;\n\tfloat threshold_norm <- 0.5;\n\t\n\tinit {\n\t\tdo add_desire(find_gold);\n\t}\n\t\n\tperceive target: self {\n\t\tif(gold_transported>0) {\n\t\t\tdo add_belief(has_gold);\n\t\t} else {\n\t\t\tdo remove_belief(has_gold);\n\t\t}\n\t}\n\t\n\tperceive target: miner in: view_dist {\n\t\tmyself.agent_perceived <- self;\n\t\tsocialize liking: point(my_color.red, my_color.green, my_color.blue) distance_to point(myself.my_color.red, myself.my_color.green, myself.my_color.blue) / ( 255) - 1;\n\t\tenforcement norm:\"share_information\" sanction:\"sanction_to_norm\" reward:\"reward_to_norm\";\n\t}\n\t\t\n\tsanction sanction_to_norm {\n\t\tdo change_liking(agent_perceived,-0.1);\n\t}\t\n\t\n\tsanction reward_to_norm {\n\t\tdo change_liking(agent_perceived,0.1);\n\t}\n\t\t\n\tperceive target: gold_mine where (each.quantity > 0) in: view_dist {\n\t\tfocus id:mine_at_location var:location;\n\t\task myself {\n\t\t\tif (has_emotion(joy)) {\n\t\t\t\twrite self.name + \" is joyous\";\n\t\t\t\tdo add_desire(predicate:share_information, strength: 5.0);\n\t\t\t}\n\t\t\tdo remove_intention(find_gold, false);\n\t\t}\n\t}\n\t\n\trule belief: has_gold new_desire: sell_gold strength: 3.0;\n\t\n\tlaw working belief: mine_location new_obligation: has_gold when:not has_obligation(has_gold) and not has_belief(has_gold) strength: 2.0 threshold:threshold_law;\n\t\n\tplan lets_wander intention:find_gold finished_when: has_desire(has_gold)\n\t{\n\t\tdo wander;\n\t}\n\t\n\tnorm doing_job obligation:has_gold finished_when: has_belief(has_gold) threshold:threshold_obligation{\n\t\tif (target = nil) {\n\t\t\tdo add_subintention(get_current_intention(),choose_gold_mine, true);\n\t\t\tdo current_intention_on_hold();\n\t\t} else {\n\t\t\tdo goto target: target ;\n\t\t\tif (target = location)  {\n\t\t\t\tgold_mine current_mine<- gold_mine first_with (target = each.location);\n\t\t\t\tif current_mine.quantity > 0 {\n\t\t\t\t\tgold_transported <- gold_transported+1;\n\t\t\t\t \tdo add_belief(has_gold);\n\t\t\t\t\task current_mine {quantity <- quantity - 1;}\t\n\t\t\t\t} else {\n\t\t\t\t\tdo add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\n\t\t\t\t\tdo remove_belief(new_predicate(mine_at_location, [\"location_value\"::target]));\n\t\t\t\t}\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tplan get_more_gold intention: has_gold {\n\t\tif (target = nil) {\n\t\t\tdo add_subintention(get_current_intention(),choose_gold_mine, true);\n\t\t\tdo current_intention_on_hold();\n\t\t} else {\n\t\t\tdo goto target: target ;\n\t\t\tif (target = location)  {\n\t\t\t\tgold_mine current_mine<- gold_mine first_with (target = each.location);\n\t\t\t\tif current_mine.quantity > 0 {\n\t\t\t\t\tgold_transported <- 3;\n\t\t\t\t \tdo add_belief(has_gold);\n\t\t\t\t\task current_mine {if(quantity>=3) {\n\t\t\t\t\t\tquantity <- quantity - 3;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tquantity <- 0;\n\t\t\t\t\t} \n\t\t\t\t\t}\t\n\t\t\t\t} else {\n\t\t\t\t\tdo add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\n\t\t\t\t\tdo remove_belief(new_predicate(mine_at_location, [\"location_value\"::target]));\n\t\t\t\t}\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tplan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true{\n\t\tlist<point> possible_mines <- get_beliefs_with_name(mine_at_location) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tlist<point> empty_mines <- get_beliefs_with_name(empty_mine_location) collect (point(mental_state (each).predicate.values[\"location_value\"]));\n\t\tpossible_mines <- possible_mines - empty_mines;\n\t\tif (empty(possible_mines)) {\n\t\t\tdo remove_intention(has_gold, true); \n\t\t} else {\n\t\t\ttarget <- (possible_mines with_min_of (each distance_to self)).location;\n\t\t}\n\t\tdo remove_intention(choose_gold_mine, true); \n\t}\n\t\n\tplan return_to_base intention: sell_gold when: has_belief(has_gold){\n\t\tdo goto target: the_market ;\n\t\tif (the_market.location = location)  {\n\t\t\tdo remove_belief(has_gold);\n\t\t\tdo remove_intention(sell_gold, true);\n\t\t\tgold_sold <- gold_sold + gold_transported;\n\t\t\tgold_transported <- 0;\n\t\t}\n\t}\n\t\n\tnorm share_information intention:share_information threshold:threshold_norm instantaneous: true{\n\t\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\n\t\tloop known_gold_mine over: get_beliefs_with_name(mine_at_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_gold_mine);\n\t\t\t}\n\t\t}\n\t\tloop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_empty_gold_mine);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdo remove_intention(share_information, true); \n\t}\n\t\n\tplan share_information_to_friends intention: share_information instantaneous: true{\n\t\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\n\t\tloop known_gold_mine over: get_beliefs_with_name(empty_mine_location) {\n\t\t\task my_friends {\n\t\t\t\tdo add_directly_belief(known_gold_mine);\n\t\t\t}\n\t\t}\t\t\n\t\tdo remove_intention(share_information, true); \n\t}\n\n\taspect default {\n\t  draw circle(200) color: my_color border: #black depth: gold_sold;\n\t  draw circle(view_dist) color: my_color border: #black depth: gold_sold wireframe: true;\n\t}\n}\n\nspecies socialLinkRepresentation{\n\tminer origin;\n\tagent destination;\n\trgb my_color;\n\t\n\taspect base{\n\t\tdraw line([origin,destination],50.0) color: my_color;\n\t}\n}\n\nexperiment GoldBdi type: gui {\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tspecies market ;\n\t\t\tspecies gold_mine ;\n\t\t\tspecies miner;\n\t\t\tspecies policeman aspect:base;\n\t\t}\t\n\t\t\n        display socialLinks type: 3d{\n        \tspecies socialLinkRepresentation aspect: base;\n    \t}\n\n\t\tdisplay chart type: 2d {\n\t\t\tchart \"Money\" type: series  {\n\t\t\t\tdatalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;\n\t\t\t\tdata \"policeman\" value: fine color: #red;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"}
{"prompt": "Create a 3D physics simulation model using GAML to demonstrate restitution and collision detection between objects, including native and Java Bullet libraries.", "gaml_code": "/**\n* Name: Restitution\n* A model to demonstrate the role of the restitution in the collision of objects and some other techniques (display of contacts between objects, creation of comparisons\n* between native and Java Bullet libraries...).\n* Author: Alexis Drogoul - 2021\n* Tags: 3D, physics\n*/\n\n\nmodel Restitution\n\nglobal parent: physical_world {\n\tstring library_name <- use_native ? \"Native\":\"Java\";\n\tfloat wall_restitution <- 1.0  min: 0.0 max: 1.0 ;\n\tfloat ball_restitution <- 0.8  min: 0.0 max: 1.0 ;\n\tpoint ball_impulse <- {100,100,0} ;\n\tgeometry shape <- box(100,100,0.001);\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.0;\n\t// The definition of the step plays a crucial role in the dynamics. If the physics engine can kick in at a high frequency, then the simulation is more accurate (but also slower). \n\t// The outcome of a model can be completely changed by the step. See the \"Steps.gaml\" model for instance\n\tfloat step <- 1.0/60;\n\tbool accurate_collision_detection <- true;\n\tpoint ball_contact <- nil;\n\tint ball_timer <- 0;\n\tpoint wall_contact <- nil;\n\tint wall_timer <- 0;\n\t\n\tinit {\n\t\tdo register([self]);\n\t\tgeometry box <- box(103,3,10);\n\t\tcreate wall from: [box at_location({50,0}), box rotated_by 90 at_location({0,50}), box at_location({50,100}), box rotated_by 90 at_location({100, 50})];\n\t\tcreate ball from: [sphere(6) at_location {50,50}, sphere(6) at_location {20,20}];\n\t}\n\t\n\treflex r1 when: ball_timer > 0 {\n\t\tball_timer <- ball_timer - 1;\n\t\tif (ball_timer = 0) {\n\t\t\tball_contact <- nil;\n\t\t}\n\t}\n\t\n\treflex r2 when: wall_timer > 0 {\n\t\twall_timer <- wall_timer - 1;\n\t\tif (wall_timer = 0) {\n\t\t\twall_contact <- nil;\n\t\t}\n\t}\n}\n\nspecies wall skills: [static_body] {\n\tfloat restitution <- wall_restitution;\n\tfloat friction <- 0.0; \n}\n\nspecies ball skills: [dynamic_body] {\n\tfloat contact_damping <- 0.0;\n\tfloat damping <- 0.0;\n\tfloat angular_damping <- 0.1;\n\tfloat mass <- 1.0;\n\tfloat restitution <- ball_restitution;\n\tfloat friction <- 0.0;\n\t\n\taction contact_added_with(agent other) {\n\t\tif (other is ball) {\n\t\t\tball_contact <- location;\n\t\t\tball_timer  <- 20;\n\t\t} else if (other is wall) {\n\t\t\twall_contact <- location;\n\t\t\twall_timer <- 20;\n\t\t}\n\t}\n\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\t\n\treflex remove when: cycle = 10 {\n\t\tlocation <- {rnd(100), rnd(100)};\n\t}\n\t\n}\n\n\nexperiment \"Test it !\" type: gui {\n\t\n\t\n\timage_file bang <- image_file(\"../images/bang.png\");\n\timage_file bam <- image_file(\"../images/bam.png\");\n\t\n\t// Ensure that the simulation does not go too fast\n\tfloat minimum_cycle_duration <- 1.0/120;\n\t\n\tfont custom <- font(\"Helvetica\", 12, #bold);\n\t\n\tparameter \"Impulse\" var: ball_impulse;\n\t\n\tuser_command \"  Reset balls\" color: #darkgray {\n\t\t\t\task simulations {\n\t\t\t\t\task ball { \n\t\t\t\t\t\tdo die;\n\t\t\t\t\t}\n\t\t\t\t\tcreate ball from: [sphere(5) at_location {50,50,5}, sphere(5) at_location {20,20,5}];\n\t\t\t\t}\n\t}\n\t\n\taction _init_ {\n\t\tbool prev0 <- gama.pref_experiment_expand_params;\n\t\tbool prev1 <- gama.pref_append_simulation_name;\n \t\tgama.pref_append_simulation_name <- true;\n\t\tgama.pref_experiment_expand_params <- true; \n\t\tbool native <- user_confirm(\"Native\", \"Compare using native library ? \");\n\t\tcreate simulation with: [seed:: 1.0, use_native :: native, step::1/60];\n\t\tcreate simulation with: [seed:: 1.0, use_native :: native, step::1/30];\n\t\tcreate simulation with: [seed:: 1.0, use_native :: native, step::1/15];\n\t\tcreate simulation with: [seed:: 1.0, use_native :: native, step::1/10];\n\t\tgama.pref_experiment_expand_params <- prev0;\n\t\tgama.pref_append_simulation_name <- prev1;\n\t}\n\n\n\n\toutput { \n\t\tlayout #split;\n\t\tdisplay \"Restitution\" type: 3d antialias: true {\n\t\t\tgraphics \"Title\"  refresh: false {\n\t\t\t\tdraw \"Step \" + step + \" (click to move the balls)\" font: custom color: #cadetblue at: {5, 0, 20} depth: 5 precision: 0.001;\n\t\t\t\tdraw shape color: #khaki;\n\t\t\t}\n\t\t\tgraphics \"Bang\" {\n\t\t\t\tif (ball_contact != nil) {\n\t\t\t\t\tdraw  bang at: ball_contact size:{20,20};\n\t\t\t\t}\n\t\t\t\tif (wall_contact != nil) {\n\t\t\t\t\tdraw  bam at: wall_contact size:{20,20};\n\t\t\t\t}\n\t\t\t}\n\t\t\tspecies wall refresh: false {draw shape color: #cadetblue;}\n\t\t\tspecies ball {\n\t\t\t\tdraw shape texture: image_file(\"../images/ball.jpg\") rotate: float(rotation.key) color: #darkseagreen;\n\t\t\t}\n\n\t\t\tevent \"mouse_down\" {\n\t\t\t\tpoint target <- #user_location;\n\t\t\t\t// When the user hits the mouse, we apply an impulse to the while ball, in the direction of the target. 'velocity' could also be used here\n\t\t\t\task simulations {\n\t\t\t\t\task ball {\n\t\t\t\t\t\tpoint direction <- (target - location) / 100;\n\t\t\t\t\t\tdo apply impulse: {ball_impulse.x * direction.x, ball_impulse.y * direction.y};\n\t\t\t\t\t\tangular_velocity <- {rnd(10), rnd(10), rnd(10)};\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D physics simulation demonstrating restitution in collisions between objects, using both native and Java Bullet libraries, with interactive user commands to manipulate balls and display contact points.", "gaml_code": "/**\n* Name: Restitution\n* A model to demonstrate the role of the restitution in the collision of objects and some other techniques (display of contacts between objects, creation of comparisons\n* between native and Java Bullet libraries...).\n* Author: Alexis Drogoul - 2021\n* Tags: 3D, physics\n*/\n\n\nmodel Restitution\n\nglobal parent: physical_world {\n\tstring library_name <- use_native? \"Native\":\"Java\";\n\t// The definition of the step plays a crucial role in the dynamics. If the physics engine can kick in at a high frequency, then the simulation is more accurate (but also slower). \n\t// The outcome of a model can be completely changed by the step. \n\tfloat step <- 1.0/60;\n\tfloat wall_restitution <- 1.0  min: 0.0 max: 1.0 ;\n\tfloat ball_restitution <- 0.8  min: 0.0 max: 1.0 ;\n\tpoint ball_impulse <- {100,100,0} ;\n\tgeometry shape <- box(100,100,0.001);\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.0;\n\n\tpoint ball_contact <- nil;\n\tint ball_timer <- 0;\n\tpoint wall_contact <- nil;\n\tint wall_timer <- 0;\n\t\n\tinit {\n\t\tdo register([self]);\n\t\tgeometry box <- box(103,3,10);\n\t\tcreate wall from: [box at_location({50,0}), box rotated_by 90 at_location({0,50}), box at_location({50,100}), box rotated_by 90 at_location({100, 50})];\n\t\tcreate ball from: [sphere(6) at_location {50,50}, sphere(6) at_location {20,20}];\n\t}\n\t\n\treflex r1 when: ball_timer > 0 {\n\t\tball_timer <- ball_timer - 1;\n\t\tif (ball_timer = 0) {\n\t\t\tball_contact <- nil;\n\t\t}\n\t}\n\t\n\treflex r2 when: wall_timer > 0 {\n\t\twall_timer <- wall_timer - 1;\n\t\tif (wall_timer = 0) {\n\t\t\twall_contact <- nil;\n\t\t}\n\t}\n}\n\nspecies wall skills: [static_body] {\n\tfloat restitution <- wall_restitution;\n\tfloat friction <- 0.0; \n}\n\nspecies ball skills: [dynamic_body] {\n\tfloat contact_damping <- 0.0;\n\tfloat damping <- 0.0;\n\tfloat angular_damping <- 0.1;\n\tfloat mass <- 5.0;\n\tfloat restitution <- ball_restitution;\n\tfloat friction <- 0.0;\n\t\n\taction contact_added_with(agent other) {\n\t\tif (other is ball) {\n\t\t\tball_contact <- location;\n\t\t\tball_timer  <- 20;\n\t\t} else if (other is wall) {\n\t\t\twall_contact <- location;\n\t\t\twall_timer <- 20;\n\t\t}\n\t}\n\t\n\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n}\n\n\nexperiment \"Test Restitution !\" type: gui {\n\t\n\t\n\timage_file bang <- image_file(\"../images/bang.png\");\n\timage_file bam <- image_file(\"../images/bam.png\");\n\t\n\t// Ensure that the simulation does not go too fast\n\tfloat minimum_cycle_duration <- 1.0/60;\n\t\n\tfont custom <- font(\"Helvetica\", 24, #bold);\n\t\n\tparameter \"Impulse\" var: ball_impulse;\n\t\n\tuser_command \"  Move balls\" color: #darkgray {\n\t\t\t\task simulations {\n\t\t\t\t\task ball { \n\t\t\t\t\t\tdo apply impulse: ball_impulse;\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tuser_command \"  Reset balls\" color: #darkgray {\n\t\t\t\task simulations {\n\t\t\t\t\task ball { \n\t\t\t\t\t\tdo die;\n\t\t\t\t\t}\n\t\t\t\t\tcreate ball from: [sphere(5) at_location {50,50,5}, sphere(5) at_location {20,20,5}];\n\t\t\t\t}\n\t}\n\n\t\n\tparameter \"Restitution of the walls\" var: wall_restitution  { \n\t\task simulations {\n\t\t\task wall {\n\t\t\t\trestitution <- wall_restitution;\n\t\t\t}\n\n\t\t}\n\n\t}\n\tparameter \"Restitution of the balls\" var: ball_restitution  {\n\t\task simulations {\n\t\t\task ball {\n\t\t\t\trestitution <- ball_restitution;\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\taction _init_ {\n\t\tbool prev0 <- gama.pref_experiment_expand_params;\n\t\tbool prev1 <- gama.pref_append_simulation_name;\n \t\tgama.pref_append_simulation_name <- true;\n\t\tgama.pref_experiment_expand_params <- true;\n\t\tcreate simulation with: [seed:: 1.0, use_native :: true];\n\t\tcreate simulation with: [seed:: 1.0, use_native :: false];\n\t\tgama.pref_experiment_expand_params <- prev0;\n\t\tgama.pref_append_simulation_name <- prev1;\n\t}\n\n\n\n\toutput { \n\t\tlayout #split;\n\t\tdisplay \"Restitution\" type: 3d antialias: true {\n\t\t\tgraphics \"Title\"  refresh: false {\n\t\t\t\tdraw library_name + \" (click to move the balls)\" font: custom color: #cadetblue at: {5, 0, 20} depth: 5 precision: 0.001;\n\t\t\t\tdraw shape color: #khaki;\n\t\t\t}\n\t\t\tgraphics \"Bang\" {\n\t\t\t\tif (ball_contact != nil) {\n\t\t\t\t\tdraw  bang at: ball_contact size:{20,20};\n\t\t\t\t}\n\t\t\t\tif (wall_contact != nil) {\n\t\t\t\t\tdraw  bam at: wall_contact size:{20,20};\n\t\t\t\t}\n\t\t\t}\n\t\t\tspecies wall refresh: false {draw shape color: #cadetblue;}\n\t\t\tspecies ball {draw shape texture: image_file(\"../images/ball.jpg\") rotate: float(rotation.key) color: #darkseagreen;}\n\t\t\tevent \"mouse_down\" {\n\t\t\t\tpoint target <- #user_location;\n\t\t\t\tfloat divisor <- distance_to(target, ball[0].location);\n\t\t\t\tpoint direction <- (target - ball[0].location) /divisor;\n\t\t\t\t// When the user hits the mouse, we apply an impulse to the while ball, in the direction of the target. 'velocity' could also be used here\n\t\t\t\task simulations {\n\t\t\t\t\task ball {\n\t\t\t\t\tdo apply impulse: {ball_impulse.x * direction.x,ball_impulse.y * direction.y };\n\t\t\t\t\tangular_velocity <- {rnd(10), rnd(10), rnd(10)};\n\t\t\t\t}}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"prompt": "Create a 3D physics simulation of a tank with falling water droplets, allowing users to manipulate camera view and gravity.", "gaml_code": "/**\n* Name: Tricky fountain\n* Author: Arnaud Grignard - Alexis Drogoul 2021\n* Description: This is a model that shows how the physics engine works using a tank, with a floor and 4 walls, and balls of water\n* falling into it. The model is exploiting the viewpoint of the user (thanks to the camera_location and camera_target) to give the illusion\n* of a fake gravity (in a completely unrealistic way, just for the demo !). \n* Tags: physics_engine, skill, 3d, spatial_computation\n*/\nmodel Tank\n\n/**\n * The model is inheriting from 'physical_world' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent\n */\nglobal parent: physical_world {\n\tbool use_native_library <- false;\n\t//Dimensions of the environment\n\tint dim <- 100;\n\t//Step (in #sec) passed to the physics engine. The same step is used for the simulation and the physics engine. The accuracy and synchronization\n\t//between the two can be controlled by max_substeps \n\tfloat step <- 0.1; \n\t//When this variable is true (the default), all the agents that inherit from dynamic_body or static_body are automatically registered as\n\t//physical agents of this world. Otherwise, they have to be registered manually (using the 'register' action)\n\tbool automated_registration <- true;\n\t//The shape of the environment. Since it is not part of the physical world, could be anything\n\tgeometry shape <- rectangle(dim, dim);\n\t\n\t\n\n\tinit {\n\t\t//The floor is a large flat box in the middle of the world.\n\t\tcreate pillarAndFloor {\n\t\t\tshape <- box({dim * 2, dim * 2, 1}) at_location {dim / 2, dim / 2, -5};\n\t\t}\n\t\t//On which we create the bottom of the fountain \n\t\tcreate wall {\n\t\t\tshape <- box({dim, dim, 10}) at_location {dim / 2, dim / 2, -5};\n\t\t}\n\t\tfloat depth <- dim/6;\n\t\t//We then create the walls of the fountain itself as four vertical flat boxes\n\t\tcreate wall from: [\n\t\t\tbox({dim, 2, depth}) at_location {dim / 2, dim, 0}, \n\t\t\tbox({dim, 2, depth}) at_location {dim / 2, 0, 0}, \n\t\t\tbox({2, dim, depth}) at_location {0, dim / 2, 0}, \n\t\t\tbox({2, dim, depth}) at_location {dim, dim / 2, 0}];\n\t\t//And finally, the pillar, a vertical cylinder\n\t\tcreate pillarAndFloor {\n\t\t\tshape <- cylinder(4, dim - 10) at_location {dim / 2, dim / 2, 0};\n\t\t}\n\n\t}\n\n\t//Every 5 steps the world creates 5 water agents at the same place. No need to provide them with a velocity or\n\t//an impulse: the immediate resolution of the physical forces make them spring \n\treflex flow when: every(5 #cycle) {\n\t\tcreate water number: 5 {\n\t\t\t\tlocation <- {dim/2, dim/2, dim};\n\t\t}\n\t}\n\t\n\t\n\t//Here comes the trick of the model. The orientation of the view is estimated (very roughly) by the position and\n\t//target of the camera. Whenever the user changes it (by rotating or tilting the view, for the moment only around the x-axis),  \n\t//the gravity is adjusted in order for it to remain oriented towards the 'bottom' of the screen. The full control (which would involve Euler angles) \n\t//is of course not implemented here, but left as a future exercise ! \n\treflex compute_gravity {\n\t\tpoint p <- #camera_location - #camera_target;\n\t\tp <- {p.x = 0 ? 1 : p.x, p.y = 0 ? -1 : -p.y, p.z = 0 ? 1 : p.z};\n\t\tpoint g <- {0, -1 / (p.y) * signum(p.z), -2 / abs(p.z)};\n\t\tgravity <- g / norm(g) * 9.81;\n\t}\n}\n\n\n/**\n * Species that represent the walls of the tank. They are static physical objects with no behavior\n */\n\nspecies wall skills: [static_body];\n\nspecies pillarAndFloor skills: [static_body];\n\n\n/**\n * Species that represents the balls falling from the fountain, using the skill dynamic_body\n */\nspecies water skills: [dynamic_body] {\n\t//The shape of water drops is a sphere between 1 and 2 of radius\n\tgeometry shape <- sphere(rnd(2.0) + 1.0);\n\t//They are provided with a mass (otherwise they would 'float')\n\tfloat mass <- 3.0;\n\trgb color <- one_of(brewer_colors(\"Blues\")); \n\t//This provides some 'bounciness' when they hit other agents\n\tfloat restitution <- 0.5;\n\t//This provides some stability\n\tfloat angular_damping <- 0.9;\n\tfloat contact_damping <- 0.9;\n\t\n\t//When water drops fall from the ground, they are eliminated (from the simulation and the physical world)\n\treflex when: location.z < -20 {\n\t\tdo die;\n\t}\n} \n\nexperiment \"3D View\" type: gui {\n\toutput { \n\t\t//The initial orientation of the display makes water drops 'fall' slightly towards the user... calling (hopefully) from immediate action!\n\t\tdisplay Flow type: 3d background: #black axes: false  {\n\t\t\tcamera #default location: {50,300,150} target: {dim/2,dim/2,10};\n\t\t\tspecies water {draw shape color: color;}\n\t\t\tspecies wall refresh: false {draw shape texture: image_file(\"../images/marble2.jpg\");}\n\t\t\tspecies pillarAndFloor refresh: false {draw shape texture: image_file(\"../images/marble.jpg\");}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of a gas chamber where particles bounce off walls and each other without friction or gravity, allowing users to experiment with different parameters such as dimensions, gravity, collision detection, and physics resolution step.", "gaml_code": "/**\n* Name: Perfect Gas\n* Author: Arnaud Grignard - Alexis Drogoul 2021\n* Description: This is a model that shows how the physics engine works with and without gravity. Particles, provided with an initial impulse,\n* collide each other and the walls. Without gravity and friction, and with a perfect restitution, this movement can go on forever.\n* The user can apply gravity or not, as well as remove one (or several) of the walls to alter this behavior.\n* Tags: physics_engine, skill, 3d, spatial_computation\n*/\nmodel Gas\n\n/**\n * The model is inheriting from 'physical_world' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent\n */\nglobal parent: physical_world {\n\tbool use_native <- true;\n\tint width init:500 ; \n\tpoint gravity <- {0.0, 0.0, 0.0};\n\tbool withGravity <- false on_change: {gravity <- withGravity ? {0.0, 0.0, -9.81} : {0.0, 0.0, 0.0};};\n\tbool accurate_collision_detection <- false;\n\tbool show_walls <- true;\n\tgeometry shape <- rectangle(width, width);\n\tfloat step <- 0.01;\n \n\tinit {\n\t\t//10000 particles are created, randomly located in a virtual box in the center of the world\n\t\tcreate particles number: 10000 {\n\t\t\tlocation <-  {rnd(width/2) + width/4,rnd(width/2) + width/4,rnd(width/2)  + width/4};\n\t\t}\n\t\t//We create walls, large boxes that prevent the particles from moving outside\n\t\tcreate wall from: [box(width, 3*width, width) at_location {-width/2, width/2, 0},box(width, 3*width, width) at_location {3*width/2, width/2, 0},box(width, width, width) at_location {width/2, -width/2, 0},box(width, width, width) at_location {width/2, 3*width/2,  0}];\n\t\tcreate wall from: [box({3*width,3*width, width}) at_location {width/2,width/2,width}, box({3*width,3*width, width}) at_location {width/2,width/2, -width}];\n\t}\t\n\n} \n\n\n/**\n * The walls are static physical bodies that offer no friction or restitution whatsoever.\n */\nspecies wall skills: [static_body]{\n\tfloat friction <- 0.0;\n\tfloat restitution <- 1.0;\n    aspect default {\n\t\tif (show_walls) {draw shape color: #black wireframe:true;}\n\t}\n}\n \t\n/**\n * Particles are dynamic bodies that wander around. They provide a perfect restitution (i.e. bounciness) and no friction.\n */\nspecies particles skills: [dynamic_body] {  \n\tgeometry shape <- sphere(2);\n\trgb color <- one_of(brewer_colors(\"Greens\"));\n\t// No friction exerted on other particles\n\tfloat friction <- 0.0;\n\t// No damping, which woud slow down their move\n\tfloat damping <- 0.0;\n\tfloat angular_damping <- 0.0;\n\t// Perfect restitution ('bouncing')\n\tfloat restitution <- 1.0;\t\n\t\n\t// An initial velocity is provided to the agents\n\tinit {\n\t\tfloat amp <-100.0;\n\t    velocity <- {rnd(amp) - amp/2, rnd(amp) - amp/2, rnd(amp) - amp/2};\n\t}\n\t\n\t// A (commented out) callback action can be defined, for instance to exchange the colors of the particles when they collide\n//\taction contact_added_with(agent other) {\n//\t\tif (other is particles) {\n//\t\t\tcolor <- particles(other).color;\n//\t\t}\n// \t}\n}\n\n\nexperiment \"Gas Chamber\" type: gui {\n\t\n\tparameter 'Dimensions' var:width; \n\tparameter var:gravity;\n\tparameter \"Enable gravity\" var:withGravity;\n\tparameter \"Finer collision detection\" var:accurate_collision_detection;\n\tparameter \"Show walls\" var:show_walls;\n\t\n\t// Allows to play with the step of the simulation (and physics step)\n\tparameter \"Physics resolution step (in sec)\" var: step min: 0.0001 max: 1.0 ;\n\t// With this command, the user can destroy one of the walls at random\n\tuser_command \"Open one wall\" color: #red {\n\t\task (one_of(wall)) {\n\t\t\tdo die;\n\t\t}\n\t}\n\toutput {\n\t\tdisplay Cube type:3d background:#white axes:false camera: \"1\" {\n\t\t\tcamera \"1\" location: {236.9814,1275.9964,799.6291} target: {250.0,250.0,150.0};\n\t\t\tcamera \"2\" location: {236.9814,-1275.9964,799.6291} target: {250.0,250.0,150.0};\n\t\t\tspecies wall;\n\t    \tspecies particles {draw shape color: color;}\t\t\t\n\t\t}\n\t}\n}"}
{"prompt": "Create a simple physics-based simulation of falling objects in 3D space, including balls that bounce and change color when colliding, and allow user interaction to apply impulses.", "gaml_code": "/**\n* Name: Falling Objects\n* Author: Arnaud Grignard - Alexis Drogoul\n* Description: This is a very simple model that shows how the physics engine works. The model inherits from 'physical_world' and ball agents use the \n* skill 'physics'. The ball agents fall on a floor, giggle a bit, exchange colors, and fall from the floor to the void. The user can click on any of them to give it some impulse\n* Tags: physics_engine, skill, spatial_computation, 3d\n*/\n\nmodel Falling\n\n\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\tfloat restitution <- 0.8; // the \"bounciness\" of the world\n\tfloat friction <- 0.2; // the deceleration it imposes on other objects\n\tint environment_size <- 500; \n\tint max_substeps <-0;\n\tfloat step <- 0.006; \n\tgeometry shape <- box(environment_size,environment_size,10);\n\t\n\tinit {\n\t\t//If the world is to be considered as a physical object in the world, it must register itself\n\t\tdo register([self]);\n\t\tcreate ball number: 100;\n\t}\n} \n\n\nspecies ball skills: [dynamic_body] {\n\tfloat radius <- float(rnd(25) + 1);\n\tgeometry shape <- flip(0.3) ? cube(radius) : (flip(0.5) ? sphere(radius) : cone3D(radius, radius));\n\tpoint location <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\trgb color <- #grey;\n\tfloat restitution <- 0.7;\n\tfloat mass <- 1.0;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.3;\n\tfloat friction <- 0.2;\n\n\t// A callback method when a contact is made with another agent. Here, we simply take its color\n\taction contact_added_with (agent other) {\n\t\tif (other is ball) {\n\t\t\tshape <- shape * 1.01;\t\n\t\t\tcolor <- rnd_color(255);\t\t\n\t\t\tdo update_body;\n\t\t}\n\t}\n\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape color: color rotate: float(rotation.key);\n\t\t// We can also draw the bounding box of the agent in the physical world\n//\tdraw aabb color: #black wireframe: true;\n\t}\n\n}\n\nexperiment Display type: gui {\n\toutput {\t\n\t\tdisplay Falling  type: 3d background:rgb(128,128,128) axes:false{\n\t\t\tcamera 'default' location: {177.8131,883.5764,615.7961} target: {250.0,250.0,0.0};\n\t\t\tgraphics World refresh: false{\n\t\t\t\t draw shape color: #white;\n\t\t\t}\n\t\t\tevent #mouse_down {\n\t\t\t\tball target <- ball with_min_of(each distance_to #user_location);\n\t\t\t\task target {\n\t\t\t\t\tdo apply impulse: {rnd(10)-5,rnd(10)-5,50}; // vertical, with some random side moves\n\t\t\t\t}\n\t\t\t}\n\t\t    species ball;\t\t\t\n\t\t}\n\n\t}\n}"}
{"prompt": "Create a 3D pool simulation using a physics engine, allowing users to play and experiment with different physical properties such as friction, restitution, and damping.", "gaml_code": "/**\n* Name: Pool using Physic Engine\n* Author: Arnaud Grignard (2012) --revised by Alexis Drogoul (2021)\n* Description: This is a model that allows the user to play a (simplistic) game of pool in order to show how the physics engine works. It also\n* demonstrates the effect of different physical properties (friction, restitution, etc.) \n*\n* Tags: physics_engine, skill, 3d, spatial_computation, obstacle\n*/\nmodel pool3D\n\n/**\n * The model is inheriting from 'physical_world' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent but all the other agents (balls and walls) are \n * automatically registered (thanks to the default value of 'true' of the variable 'automated_registration').\n */\nglobal parent: physical_world {\n\t// The dynamics of the agents is a bit different if we use the native (3.0.x) or Java version (2.8.x) of Bullet\n\tbool use_native <- false;\n\tbool draw_aabb <- false;\n\tstring library <- \"bullet\";\n\t//All the physical characteristics of the balls can be accessed here and modified at will by the user\n\tfloat ball_damping <- 0.05 min: 0.0 max: 1.0 on_change: {ask ball {damping<-ball_damping;}};\n\tfloat ball_restitution <- 0.8  min: 0.0 max: 1.0 on_change: {ask ball {restitution<-ball_restitution;}};\n\tfloat ball_friction <- 0.2  min: 0.0 max: 1.0 on_change: {ask ball {friction<-ball_friction;}};\n\tfloat wall_restitution <- 0.7  min: 0.0 max: 1.0 on_change: {ask wall {restitution<-wall_restitution;}};\n\tfloat wall_friction <- 0.2  min: 0.0 max: 1.0 on_change: {ask wall {friction<-wall_friction;}};\n\tfloat ground_friction <- 0.6  min: 0.0 max: 1.0 on_change: {ask ground {friction<-ground_friction;}};\n\tfloat strength <- 120.0  min: 0.0 max: 200.0;\n\tint width <- 200;\n\tint height <- 300;\n\t//Given that very few agents inhabit this world, the step is really small, so as to prevent the physical world to go too fast. \n\t//The simulation itself is aligned with this number (see experiment.minimum_cycle_duration)\n\tfloat step <-1.0/120;\n\t//Gives access (or not) to an improved (but slower) detection collision algorithm\n\tbool better_collision_detection <- false;\n\t// Artificially high gravity to make sure that the balls stay on the ground\n\tpoint gravity <- {0,0,-20};\n\n\n\t//Physical Engine\n\tgeometry shape <- rectangle(width, height);\n\tball white;\n\tpoint target;\n\n\tinit {\n\n\t\tfloat floor <- -4.0;\n\t\tfloat depth <- 4.0;\n\t\tcreate ground from: [\n\t\t\tbox({width - 20, height - 24, depth}) at_location {width / 2, height / 2, floor}, \n\t\t\tbox({width - 20, 20, depth}) at_location {width / 2, 6, floor}, \n\t\t\tbox({width - 20, 20, depth}) at_location {width / 2, height - 6, floor}, \n\t\t\tbox({20, height / 2 - 18, depth}) at_location {6, height / 4 + 3, floor}, \n\t\t\tbox({20, height / 2 - 18, depth}) at_location {6, 3 * height / 4 - 3, floor}, \n\t\t\tbox({20, height / 2 - 18, depth}) at_location {width - 6, height / 4 + 3, floor}, \n\t\t\tbox({20, height / 2 - 18, depth}) at_location {width - 6, 3 * height / 4 - 3, floor}\n\t\t];\n\t\t\t\t\n\t\tfloat section <- 10.0;\n\t\tfloat z <- section + section/4;\n\t\tcreate wall from: [\n\t\t\tline([{0,height + section/2,z}, {width,height + section/2,z}], section/2), //down\n\t\t\tline([{0,-section/2,z}, {width,-section/2,z}], section/2), // up\n\t\t\tline([{-section/2,-section/2,z}, {-section/2,height + section/2, z}], section/2), // left\n\t\t\tline([{width+section/2,-section/2,z}, {width+section/2,height + section/2, z}], section/2) // right\n\n\t\t];\n\t\t\n\t\tcreate wall with: [inside::true] from: [\n\t\t\tbox(width+3*section/2, section/2, section) at_location {width / 2, height + section/2, 0}, // down\n\t\t\tbox(width+3*section/2, section/2, section) at_location {width / 2,  -section/2, 0}, // up\n\t\t\tbox(section/2, height +  section, section) at_location {-section/2, height / 2, 0}, // left\n\t\t\tbox(section/2, height + section, section) at_location {width + section/2, height / 2, 0} // right\n\t\t];\n\n\t\t\n\t\tdo create_white_ball;\n\n\t\tint deltaI <- 0;\n\t\tint initX <- 75;\n\t\tint initY <- int(height / 8);\n\t\tint i <- 0;\n\n\t\t//Create the other balls for the pool\n\t\tcreate ball number: 15 {\n\t\t\tlocation <- {initX + (i - deltaI) * 10, initY, 0};\n\t\t\ti <- i + 1;\n\t\t\tcolor <- (i mod 2) = 0 ? #red :  #yellow;\n\t\t\tif (i in [5, 9, 12, 14]) {\n\t\t\t\tinitX <- initX + 5;\n\t\t\t\tinitY <- initY + 9;\n\t\t\t\tdeltaI <- i;\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\taction create_white_ball {\n\t\tcreate ball {\n\t\t\tlocation <- {width / 2, 4 * height / 5, 0};\n\t\t\twhite <- self;\n\t\t}\n\t}\n\n}\n\n//Species representing the ground agents used for the computation of the forces, using the skill static_body\nspecies ground skills: [static_body] {\n\tfloat friction <- ground_friction;\n}\n\n//Species representing the wall agents of the pool using the skill static_body\nspecies wall skills: [static_body] {\n\tbool inside;\n\tfloat friction <- wall_friction;\n\tfloat restitution <- wall_restitution;\t\n\t\n\taspect default {\n\t\tif (inside) {\n\t\t\tdraw shape color: (#darkgreen);\n\t\t} else {\n\t\t\tdraw shape texture: \"../images/wood.jpg\";\n\t\t}\n\t\t\n\t\tif (draw_aabb) {draw aabb wireframe: true border: #lightblue;}\n\n\t}\n}\n\n//Species representing the ball agents, provided with dynamic_body capabilities (a mass, a velocity, damping ...)\nspecies ball skills: [dynamic_body] {\n\trgb color <- #white;\n\tfloat mass <-2.0;\n\tgeometry shape <- sphere(5);\n\tfloat friction <- ball_friction;\n\tfloat restitution <- ball_restitution;\n\tfloat damping <- ball_damping;\n    float angular_damping <- 0.0;\n\tfloat contact_damping <- 0.0;\n\t\n\t// If any ball falls or goes away, it is destroyed, except the white ball, replaced on the table\n\treflex manage_location when: location.z < -20 {\n\t\tif (self = white) {\n\t\t\task world {\n\t\t\t\tdo create_white_ball;\n\t\t\t}\n\t\t\ttarget <- nil;\n\t\t}\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw  sphere(5) color: color;\n\t\tif (draw_aabb) {draw aabb wireframe: true border: #lightblue;}\n\n\t}\n\n}\n\nexperiment \"Play !\" type: gui autorun: true   {\n\tparameter \"Ball Restitution\" var: ball_restitution category: \"Ball properties\" ;\n\tparameter \"Ball Damping (natural deceleration)\" var: ball_damping category: \"Ball properties\" ;\n\tparameter \"Ball Friction\" var: ball_friction category: \"Ball properties\" ;\n\tparameter \"Wall Restitution\" var: wall_restitution category: \"Wall properties\" ;\n\tparameter \"Wall Friction\" var: wall_friction category: \"Wall properties\" ;\n\tparameter \"Ground Friction\" var: ground_friction category: \"Ground properties\";\n\tparameter \"Strength\" var: strength category: \"Player properties\";\n\tparameter \"Draw bounding boxes\" var: draw_aabb category: \"General\";\n\t\n\t// Ensure that the simulation does not go too fast\n\tfloat minimum_cycle_duration <- 1.0/120;\n\t\n\taction _init_ {\n\t\t// A trick to make sure the parameters are expanded and visible when the simulation is launched.\n\t\tbool previous <- gama.pref_experiment_expand_params;\n\t\tgama.pref_experiment_expand_params <- true;\n\t\tcreate simulation;\n\t\tgama.pref_experiment_expand_params <- previous;\n\t}\n\t\n\toutput {\n\t\tdisplay Pool type: 3d antialias: false axes: false{\n\t\t\tcamera #default location: {100.0,400.0,300.0} target: {width/2,height/2,-20.0};\n\t\t\tlight #ambient intensity: 180;\n\t\t\tlight #default intensity: 180 direction: {0.5, 0.5, -1};\n\t\t\tgraphics user {\n\t\t\t\tif (white != nil) and (target != nil) {\n\t\t\t\t\tdraw line(white, target) color: #white end_arrow: 3;\n\t\t\t\t}\n\t\t\t\tif target = nil {\n\t\t\t\t\tdraw \"Choose a target\" color: #white font: font(\"Helvetica\", 30, #bold) at: location + {0, 0, 10} perspective: false anchor: #center;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tevent #mouse_down  {\n\t\t\t\ttarget <- #user_location;\n\t\t\t\tfloat divisor <- distance_to(target, white.location);\n\t\t\t\tpoint direction <- (target - white.location) /divisor;\n\t\t\t\t// When the user hits the mouse, we apply an impulse to the while ball, in the direction of the target. 'velocity' could also be used here\n\t\t\t\task white {\n\t\t\t\t\tdo apply impulse: {strength * direction.x * 4, strength * direction.y * 4, 0};\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #mouse_move {\n\t\t\t\ttarget <- #user_location;\t\n\t\t\t}\n\t\t\tspecies ground refresh: false {\n\t\t\t\tdraw shape texture: image_file(\"../images/mat.jpg\");\n\t\t\t\tif (draw_aabb) {draw aabb wireframe: true border: #lightblue;}\n\t\t\t}\n\t\t\tspecies wall refresh:false;\n\t\t\tspecies ball;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of an erupting volcano where lava flows down and erodes the terrain, using a physics engine to model the interactions between agents and environment.", "gaml_code": "/**\n* Name: Eroding Vulcano\n* Author: Alexis Drogoul - 2021\n* Description: This is a model that shows how the physics engine works, especially with the definition of uneven terrains, the dynamic\n* change of shapes of agents and the callback actions when contacts occur between agents. \n* A vulcano, situated at the highest point of a DEM, erupts and the lava, falling down on the ground, erodes every patch of terrain it touches. The \n* slope of the terrain evolves as more and more lava is produced (the epicenter of the eruption even changing when higher patches appear).\n* Tags: physics_engine, 3D, grid\n*/\n\n\nmodel Vulcano\n/**\n * The model is inheriting from 'physical_world' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent\n */\nglobal parent: physical_world {\n\tbool use_native <- true;\n\t//Step (in #sec) passed to the physics engine. The same step is used for the simulation and the physics engine. The accuracy and synchronization\n\t//between the two can be controlled by max_substeps. A too large step (e.g. 1#sec) would make the lava 'pass through' the ground (tunnel effect).\n\t//A too small (e.g. 0.01), while more accurate, would, given the velocity of the lava, slow everything down on useless computations.\n\tfloat step <-  0.05;\n\t//A boolean that controls whether or not the lava will erode the ground\n\tbool erosion;\n\tfloat uncertainty -> {rnd(10.0) - 5};\n\t// Support for display parameters\n\tbool show_legend;\n\tbool draw_inside;\n\t//Every step the world creates a lava agent near the top of the highest patch in the terrain. It is provided with an initial high vertical velocity.\n\treflex flow {\n\t\tpatches highest <- patches with_max_of each.grid_value;\n\t\task highest {\n\t\t\tcreate lava number: 1 {\n\t\t\t\tlocation <- {highest.location.x + uncertainty, highest.location.y + uncertainty, highest.grid_value + uncertainty};\n\t\t\t\tvelocity <- velocity + {0,0,rnd(60) - 20};\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The patches come as a grid created after a simple DEM file and each cell is provided with a 'static body' in the physical world. The whole grid represents\n * an approximate terrain (or heightmap). Since the patches are agents, they can individually respond to events or have their own behavior, making the whole \n * a powerful way to describe dynamic environments.\n */\ngrid patches file: grid_file(\"../images/DEM/Volcano DEM.asc\") skills: [static_body] {\n\tfloat friction <- 0.5;\n\tfloat restitution <- 0.2;\n\t\n\t//This action is a 'callback' action, one of the two (with 'contact_removed_with') called by the physics engine when a contact occurs between two agents. \n\t// When redefined, it allows agents to react to contacts. Here, every new contact with a lava agent makes a patch decrease its height (grid_value) \n\t// and that of its neigbors by a small amount, as well as stop the lava agent quite brutally (clearing all the forces applied to it) to imitate \"stickiness\"\n\taction contact_added_with (agent other) {\n\t\tif (erosion) {\n\t\t\tgrid_value <- max(0,grid_value - 0.01);\n\t\t\task neighbors {\n\t\t\t\tgrid_value <- max(0,grid_value - 0.005);\n\t\t\t\tdo update_body;\n\t\t\t}\n\t\t\tdo update_body;\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tif (draw_inside) {draw aabb wireframe: true border: #white;}\n\t}\n}\n\n/**\n * Species that represents the lava erupting from the vulcano. Their physical body will be a sphere, weighting 4#kg, offering no restitution but a lot of friction.\n */\nspecies lava skills: [dynamic_body] {\n\tgeometry shape <- sphere(0.75);\n\tfloat mass <- 1.0;\n\trgb color <- one_of (brewer_colors(\"Reds\"));\n\tfloat restitution <- 0.2;\n\tfloat friction <- 0.3;\n\tfloat damping <- 0.1;\n\tfloat angular_damping<-0.1;\n\n\t//When a lava agent falls from the edges of the world, it is removed from the simulation (and the physical world as well).\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: color; \n\t\tif (draw_inside) {\n\t\t\tdraw aabb color: #lightblue wireframe: true;\n\t\t\tdraw line(location, location+velocity) color: #yellow end_arrow: 1 width: 1;\n\t\t}\n\t}\n\n} \n\n\nexperiment \"3D view\" type: gui {\n\tfont title  <- font(\"Helvetica\", 12, #bold);\n\tparameter \"Show inside structures (velocities and aabbs)\" var: draw_inside <- false;\n\tparameter \"Better collision detection\" var: accurate_collision_detection <- false;\n\tparameter \"Enable erosion\" var: erosion <- false;\n\tparameter \"Show legend\" var: show_legend <- true;\n\toutput {\n\t\t\n\t\tdisplay \"3D\" type: 3d axes: false background: #black camera:#from_up_front antialias: false {\n\t\t\tgraphics title {\n\t\t\t\tif (show_legend) {\n\t\t\t\t\tdraw \"Average height \" + (patches mean_of each.grid_value) with_precision 2 + \" / # of lava agents \" + length(lava) color: #white font: title at: {world.location.x, 100, patches max_of each.grid_value + 10} anchor: #center depth: 2 rotate: -20::{1,0,0};\n\t\t\t\t}\n\t\t\t}\n\t\t\t//The terrain is represented as a field (but could be equally represented as a grid\t\t\n\t\t\tmesh patches  texture: image_file(\"../images/DEM/Volcano Texture.jpg\") triangulation: true ;\n\t\t\t//We add to the representation the individual 'aabb's (axis-aligned bounding boxes) of the patches if 'draw_inside' is true\n\t\t \t//species patches;\n\t\t \t//Finally, each lava agent is represented (with its velocity if 'draw_inside' is true)\n\t\t\tspecies lava;\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a 3D simulation of water flowing through a red river bed terrain, using a physics engine to model the flow and interaction between water particles, with multiple scales and camera views.", "gaml_code": "/**\n* Name: Water flowing in the red river bed\n* Author: drogoul\n* Tags: \n*/\n\n\nmodel Terrain\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\t// We scale the DEM up a little\n\tfloat z_scale <- 0.5;\n\tfloat step <-  1.0/30;\t\n\tbool flowing <- true;\n\tpoint gravity <- {-z_scale/4, z_scale, -9.81};\n\tint number_of_water_units <- 1 min: 0 max: 10;\n\tlist<point> origins_of_flow <- [{17,4}, {55,4}];\n\tfield terrain <- field(grid_file(\"../images/DEM/RedRiver.asc\"));\n\n\tgeometry shape <- box({terrain.columns, terrain.rows, max(terrain)*z_scale});\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.5;\n\n\n\tinit {\n\t\taccurate_collision_detection <- true;\n\t\tmax_substeps <- 100;\n\t\tdo register([self]);\n\t}\n\n\treflex flow {\n\t\t\tloop origin_of_flow over: origins_of_flow {\n\t\t\t\tint x <- int(min(terrain.columns - 1, max(0, origin_of_flow.x + 10)));\n\t\t\t\tint y <- int(min(terrain.rows - 1, max(0, origin_of_flow.y + 10)));\n\t\t\t\tpoint p <- origin_of_flow + {rnd(10) - 5, rnd(10 - 5), terrain[x, y] + 10};\n\t\t\t\tcreate water number: number_of_water_units with: [location::p];\n\t\t\t}\n\t}\n}\n\nspecies water skills: [dynamic_body] {\n\tgeometry shape <- sphere(1.0);\n\tfloat friction <- 0.0;\n\tfloat damping <- 0.0;\n\tfloat mass <- 0.5;\n\trgb color <- one_of(brewer_colors(\"Blues\"));\n\t\n\n\taspect default {\n\t\tif (location.y > 10){\n\t\tdraw shape color: color;}\n\t}\n\t\n\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n} \n\nexperiment \"Four different scales\" type: gui {\n\t\n\tstring camera_loc <- #from_up_front;\n\tint distance <- 200;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [z_scale::0.3];\n\t\tcreate simulation with: [z_scale::1.0];\n\t\tcreate simulation with: [z_scale::2.0];\n\t\tcreate simulation with: [z_scale::3.0];\n\t} \n\tparameter \"Location of the camera\" var: camera_loc among: [#from_up_front, #from_above, #from_up_left, #from_up_right];\n\tparameter \"Distance of the camera\" var: distance min: 1 max: 1000 slider: true;\n \tparameter \"Number of water agents per cycle\" var: number_of_water_units;\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Flow\" type: 3d background: #white   antialias: false {\n\t\t\tcamera #default location: camera_loc distance: distance dynamic: true;\n\t\t\tgraphics world {\n\t\t\t\tdraw \"Scale: \" + z_scale color: #cadetblue font: font(\"Helvetica\", 18, #bold) at: {world.location.x, -10, 25} anchor: #center depth: 2 rotate: -90::{1,0,0};\n\t\t\t\tdraw aabb wireframe: true color: #lightblue;\n\t\t\t}\n\t\t\tmesh terrain grayscale: true triangulation: true refresh: false scale: z_scale smooth: 2;\n\t\t\tspecies water;\n\t\t\tevent #mouse_down {\n\t\t\t\tpoint p <- #user_location;\n\t\t\t\torigins_of_flow << {p.x, p.y};\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t\n\t\n\t}\n\t\nexperiment \"Largest scale\" type: gui {\n\t\n\tstring camera_loc <- #from_up_front;\n\tint distance <- 200;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [z_scale::3.0];\n\t} \n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Flow\" type: 3d background: #white   antialias: false camera: #from_up_front{\n\t\t\tmesh terrain grayscale: true triangulation: true refresh: false scale: z_scale;\n\t\t\tspecies water;\n\t\t}\n\n\t}}"}
{"prompt": "Create a 3D simulation of a staircase with physics engine, including balls bouncing on each step, using GAML language.", "gaml_code": "/**\n* Name: Stairs\n* This model demonstrates the use of the physics engine to build a simple model where particles are \n* Author: Alexis Drogoul - 2021\n* Tags: physics\n*/\nmodel Stairs\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\tlist<string> textures <- [\"tennis\", \"foot\", \"basket\", \"ball\"];\n\tlist<float> sizes <- [0.07, 0.22, 0.25, 0.5];\n\tlist<float> masses <- [0.1, 0.45, 0.62, 0.01];\n\tlist<float> restitutions <- [0.7, 0.7, 0.8, 1.0];\n\tlist<float> frictions <- [0.1, 0.5, 0.5, 0.0];\n\tint tennis <- 0;\n\tint basket <- 1;\n\tint foot <- 2;\n\tfloat step <- 0.001;\n\tint max_substeps <- 0;\n\tint number_of_steps <- 8;\n\tfloat max_height <- 20.0;\n\tfloat dimension <- 40.0;\n\tgeometry shape <- box(dimension * 3, dimension * 3, 1);\n\tfloat friction <- 0.7;\n\tfloat restitution <- 0.5;\n\n\tinit {\n\t\tdo register([self]);\n\t\tfloat step_width <- dimension / (number_of_steps + 2);\n\t\tfloat step_diff <- max_height / (number_of_steps + 1);\n\t\tfloat current_y <- dimension / 2;\n\t\tfloat current_height <- max_height;\n\t\tloop i from: 0 to: number_of_steps {\n\t\t\tcreate steps from: [box(dimension / 2, step_width, current_height) at_location {dimension * 3 / 2, current_y}];\n\t\t\tcurrent_y <- current_y + step_width;\n\t\t\tcurrent_height <- current_height - step_diff;\n\t\t}\n\n\t}\n\n\treflex when: every(500 #cycle) {\n\t\tcreate ball with: [type::one_of(0, 1, 2, 3)] {\n\t\t\tlocation <- {dimension * 3 / 2 + rnd(4) - 2, dimension + rnd(4) - 2, max_height + dimension + rnd(4) - 2};\n\t\t}\n\n\t}\n\n}\n\nspecies steps skills: [static_body] {\n\tfloat restitution <- 1.0;\n\tfloat friction <- 0.05;\n\n\taspect default {\n\t\tdraw shape color: rgb(132, 172, 136, 255);\n\t}\n\n}\n\nspecies ball skills: [dynamic_body] {\n\tint type;\n\tfloat radius <- sizes[type] * 10;\n\tfloat mass <- masses[type];\n\tgeometry shape <- sphere(radius);\n\tfloat restitution <- restitutions[type];\n\tfloat friction <- frictions[type];\n\tfloat damping <- 0.1;\n\n\tinit {\n\t\tangular_velocity <- {rnd(2) - 1, rnd(2) - 1, rnd(2) - 1};\n\t}\n\n\t//When a ball agent falls from the edges of the world, it is removed from the simulation (and the physical world as well).\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape rotate: float(rotation.key) texture: \"../images/\" + textures[type] + \".jpg\";\n\t\t//draw aabb wireframe: true color: #blue;\n\t}\n\n}\n\nexperiment Stairs type: gui {\n\toutput {\n\t\tdisplay \"Climb\" type: 3d axes: false {\n\t\n\t\t\tcamera 'default' location: {-47.816,165.8396,88.7059} target: {60.0,60.0,0.0};\n\t\t\tgraphics ground refresh:false{\n\t\t\t\tdraw shape color: rgb(132, 172, 136, 255);\n\t\t\t\t//draw aabb wireframe: true color: #blue;\n\t\t\t}\n\n\t\t\tspecies steps refresh: false;\n\t\t\tspecies ball;\n\t\t\tevent #mouse_down {\n\t\t\t\task ball {\n\t\t\t\t\tdo apply impulse: {rnd(2)-1, rnd(2)-1, 10};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Create a Box2D simulation to demonstrate the role of restitution in collisions between objects, including balls and walls, with adjustable parameters for step size, wall and ball restitution, and collision detection accuracy.", "gaml_code": "/**\n* Name: Restitution\n* A model to demonstrate the role of the restitution in the collision of objects in the box2D library, which simulates physical interactions in 2 dimensions\n* Author: Alexis Drogoul - 2023\n* Tags: 2D, physics\n*/\nmodel Box2D\n\nglobal parent: physical_world {\n\t\n\tint size <- 250;\n\t\n\tfloat seed <- gama.machine_time;\n\tstring library <- \"box2D\";\n\t// The definition of the step plays a crucial role in the dynamics. If the physics engine can kick in at a high frequency, then the simulation is more accurate (but also slower). \n\t// The outcome of a model can be completely changed by the step. \n\tfloat step <- 1.0 / 100;\n\tfloat wall_restitution <- 1.0 min: 0.0 max: 2.0;\n\tfloat ball_restitution <- 0.9 min: 0.0 max: 1.0;\n\tgeometry shape <- box(size, size, 0.001);\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.0;\n\tbool accurate_collision_detection <- true; // expensive but much better\n\tint max_substeps <- 1;\n\tpoint ball_contact <- nil;\n\tint ball_timer <- 0;\n\tpoint wall_contact <- nil;\n\tint wall_timer <- 0;\n\tbool disturb <- true;\n\tlist<ball> movers;\n\n\tinit {\n\t\tdo register([self]);\n\n\t\tgeometry box <- box(size+3, 3, 10);\n\t\tcreate wall from: [box at_location ({size/2, 0}), box rotated_by 90 at_location ({0, size/2}), box at_location ({size/2, size}), box rotated_by 90 at_location ({size, size/2})];\n\t\tlist<point> starting_places <- [{5,5}, {5,size-5},{size-5,5}, {size-5,size-5}];\n\t\tcreate ball from: starting_places collect (circle(4) at_location each) with: [mass::10, color::#cadetblue, speed::30] returns: balls;\n\t\tmovers <-balls;\n\t\tloop x from: 5 to: size-5 step: 10 {\n\t\t\tloop y from: 5 to: size-5 step: 10 {\n\t\t\t\tif (x = 5) or (x = size-5) {\n\t\t\t\t\tif (y = 5) or (y = size-5) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tfloat n <- rnd(1.0, 4.5);\n\t\t\t\tcreate ball with: [shape::circle(n) at_location {x,y},mass::n, color::brewer_colors(\"Set3\")[int(n)], speed::n*2] {\n\t\t\t\t\tinitial_location <- location;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\n\t}\n\t\n\treflex when: every(1000#cycle){\n\t\task movers{\n\t\t\tfloat s <- speed * 2;\n\t\t\tvelocity <- velocity + {(rnd(s) * rnd(-1.0,1.0)), (rnd(s) * rnd(-1.0,1.0))};\n\t\t}\n\t}\n\n}\n\nspecies wall skills: [static_body] {\n\tfloat restitution <- wall_restitution;\n\tfloat friction <- 0.1;\n}\n\nspecies ball skills: [dynamic_body, moving] {\n\tpoint initial_location;\n\tfloat contact_damping <- 0.1;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.0;\n\tfloat restitution <- ball_restitution;\n\tfloat friction <- 0.1;\n\trgb color ;//<- one_of(brewer_colors(\"Set3\"));\n\n\n\treflex go_back when: every(10#cycle) and (abs(velocity.x) between(0.0,1.0)) and (abs(velocity.y) between(0.0,1.0)) {\n\t\tdo goto target: initial_location;\n\t}\n\n}\n\nexperiment \"Disturbance\" type: gui {\n\t\n\n\n\timage_file bang <- image_file(\"../images/bang.png\");\n\timage_file bam <- image_file(\"../images/bam.png\");\n\ttext \"This experiment uses the Box2D library to display particles that are disturbed randomly and try to get back to their original location when this happens. Try stopping the disturbance or increasing or decreasing the restitution to see what happens. Agents are provided also with the moving skill, and it is a good example of mixing a physics-based with a behavior-based dynamics\";\n\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Restitution\" type: 3d antialias: true axes: false {\n\n\t\t\tspecies ball {\n\t\t\t\tdraw shape color: color;\n\t\t\t\tdraw line(location, location + velocity) color: #black end_arrow: 1 width: 1;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"}
{"prompt": "Design a predator-prey simulation model where prey and predators interact through energy transfer, reproduction, and death, and optimize the parameters to maximize the total population size over time.", "gaml_code": "/**\n* Name: Breeding of prey and predator agents\n* Author:\n* Description: 6th part of the tutorial : Predator Prey\n* Tags: reproduce, myself, self\n*/\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5;\n\tfloat prey_energy_reproduce <- 0.5;\n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tint nb_preys -> {length(prey)};\n\tint nb_predators -> {length(predator)};\n\tbool is_batch <- false;\n\n\tinit {\n\t\tcreate prey number: nb_preys_init;\n\t\tcreate predator number: nb_predators_init;\n\t\twrite(self);\n\t}\t\n\t\n\treflex stop_simulation when: ((nb_preys = 0) or (nb_predators = 0)) and !is_batch {\n\t\tdo pause;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tfloat proba_reproduce;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\tvegetation_cell my_cell <- one_of(vegetation_cell);\n\tfloat energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n\tinit {\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex basic_move {\n\t\tmy_cell <- one_of(my_cell.neighbors2);\n\t\tlocation <- my_cell.location;\n\t}\n\n\treflex eat {\n\t\tenergy <- energy + energy_from_eat();\n\t}\n\n\treflex die when: energy <= 0 {\n\t\tdo die;\n\t}\n\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- rnd(1, nb_max_offsprings);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmy_cell <- myself.my_cell;\n\t\t\tlocation <- my_cell.location;\n\t\t\tenergy <- myself.energy / nb_offsprings;\n\t\t}\n\n\t\tenergy <- energy / nb_offsprings;\n\t}\n\n\tfloat energy_from_eat {\n\t\treturn 0.0;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy;\n\tfloat max_transfer <- prey_max_transfer;\n\tfloat energy_consum <- prey_energy_consum;\n\tfloat proba_reproduce <- prey_proba_reproduce;\n\tint nb_max_offsprings <- prey_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_energy_reproduce;\n\n\tfloat energy_from_eat {\n\t\tfloat energy_transfer <- 0.0;\n\t\tif(my_cell.food > 0) {\n\t\t\tenergy_transfer <- min([max_transfer, my_cell.food]);\n\t\t\tmy_cell.food <- my_cell.food - energy_transfer;\n\t\t} \t\t\t\n\t\treturn energy_transfer;\n\t}\n}\n\nspecies predator parent: generic_species {\n\trgb color <- #red;\n\tfloat max_energy <- predator_max_energy;\n\tfloat energy_transfer <- predator_energy_transfer;\n\tfloat energy_consum <- predator_energy_consum;\n\tfloat proba_reproduce <- predator_proba_reproduce;\n\tint nb_max_offsprings <- predator_nb_max_offsprings;\n\tfloat energy_reproduce <- predator_energy_reproduce;\n\n\tfloat energy_from_eat {\n\t\tlist<prey> reachable_preys <- prey inside (my_cell);\n\t\tif(! empty(reachable_preys)) {\n\t\t\task one_of (reachable_preys) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t\treturn energy_transfer;\n\t\t}\n\t\treturn 0.0;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2 <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 0 max: 1000 category: \"Prey\";\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n\tparameter \"Prey max transfer: \" var: prey_max_transfer category: \"Prey\";\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum category: \"Prey\";\n\tparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\";\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\";\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer category: \"Predator\";\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum category: \"Predator\";\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey';\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey';\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey';\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator';\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator';\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator';\n\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell border: #black;\n\t\t\tspecies prey aspect: base;\n\t\t\tspecies predator aspect: base;\n\t\t}\n\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n\nexperiment Optimization type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {\n\tparameter \"Predator energy reproduce:\" var: predator_energy_reproduce min: 0.25 max: 1.0 step: 0.25;\n\tparameter \"Batch mode:\" var: is_batch <- true;\n\t\n\tmethod tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3;\n\t\n\t\n\treflex save_results_explo {\n\t\task simulations {\n\t\t\tsave [int(self),prey_max_transfer,prey_energy_reproduce,predator_energy_transfer,predator_energy_reproduce,self.nb_predators,self.nb_preys] \n\t\t   \t\tto: \"results.csv\" format:\"csv\" rewrite: (int(self) = 0) ? true : false header: true;\n\t\t}\t\t\n\t}\n}"}
{"prompt": "Create a NetLogo model that simulates traffic flow and road damage in a city, including pedestrians moving between residential and industrial areas, with adjustable parameters for population size, working hours, speed limits, and road repair frequency.", "gaml_code": "/**\n* Name: Automatic repair of roads\n* Author:\n* Description: 7th part of the tutorial: Road Traffic\n* Tags: transport\n*/\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tint repair_time <- 2 ;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n\treflex repair_road when: every(repair_time #hour ) {\n\t\troad the_road_to_repair <- road with_max_of (each.destruction_coeff) ;\n\t\task the_road_to_repair {\n\t\t\tdestruction_coeff <- 1.0 ;\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- goto(target:the_target, on:the_graph, return_path: true);\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color border: #black;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\tparameter \"Number of hours between two road repairs\" var: repair_time category: \"Road\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}"}
